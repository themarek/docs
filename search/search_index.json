{"config":{"indexing":"full","lang":["de","en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open source firmware for ESP devices ~ Total local control with quick setup and updates. Control using MQTT, Web UI, HTTP or serial. Automate using timers, rules or scripts. Integration with home automation solutions. Incredibly expandable and flexible. Current Release Tasmota 12.1.1 Patricia Breaking Changes ~ This version removes support for direct migration from versions before v8.1.0 (Doris) Restructured tasmota source directories taking benefit from PlatformIO Core v6.0.2 Removed dedicated MQTT Home Assistant discovery in favour of Tasmota Discovery and hatasmota ESP32 Tasmota Safeboot with changed partition scheme allowing larger binaries ESP32 increase Serial Bridge input buffer from 130 to 520 characters Removed Arduino IDE support New Features ~ Added support for: 5-channel light dimmer driver SM2335 used in SwitchBot color bulbs Sonoff POWR3xxD and THR3xxD with their bistable (latching) relays mixed with monostable relays Modbus bridge multiple IRSend GPIOs Catalan language ESP32 Support for Ultra Low Power (ULP) coprocessor via Berry New commands: SetOption45 , SetOption144 , GlobalTemp2 , GlobalHum2 , GlobalPress2 , Sleep2 , WiFiScan , WiFiTest 12.1.1 Hotfixes ~ Button response delay regression from v12.0.2.4 Lost module name in GUI regression from v12.0.2.4 RTC not detected when lights are present #16242 DNS lookup for .local domains See release notes for a complete list of new features, changes and bug fixes. Join Our Community ~ For feedback, questions, live troubleshooting or just general chat Telegram Reddit Google Groups Report bugs and suggest features ~ Open a new topic on Tasmota discussions . Report a bug in Tasmota issues .","title":"News"},{"location":"#open-source-firmware-for-esp-devices","text":"Total local control with quick setup and updates. Control using MQTT, Web UI, HTTP or serial. Automate using timers, rules or scripts. Integration with home automation solutions. Incredibly expandable and flexible. Current Release Tasmota 12.1.1 Patricia","title":"Open source firmware for ESP devices"},{"location":"#breaking-changes","text":"This version removes support for direct migration from versions before v8.1.0 (Doris) Restructured tasmota source directories taking benefit from PlatformIO Core v6.0.2 Removed dedicated MQTT Home Assistant discovery in favour of Tasmota Discovery and hatasmota ESP32 Tasmota Safeboot with changed partition scheme allowing larger binaries ESP32 increase Serial Bridge input buffer from 130 to 520 characters Removed Arduino IDE support","title":"Breaking Changes"},{"location":"#new-features","text":"Added support for: 5-channel light dimmer driver SM2335 used in SwitchBot color bulbs Sonoff POWR3xxD and THR3xxD with their bistable (latching) relays mixed with monostable relays Modbus bridge multiple IRSend GPIOs Catalan language ESP32 Support for Ultra Low Power (ULP) coprocessor via Berry New commands: SetOption45 , SetOption144 , GlobalTemp2 , GlobalHum2 , GlobalPress2 , Sleep2 , WiFiScan , WiFiTest","title":"New Features"},{"location":"#1211-hotfixes","text":"Button response delay regression from v12.0.2.4 Lost module name in GUI regression from v12.0.2.4 RTC not detected when lights are present #16242 DNS lookup for .local domains See release notes for a complete list of new features, changes and bug fixes.","title":"12.1.1 Hotfixes"},{"location":"#join-our-community","text":"For feedback, questions, live troubleshooting or just general chat Telegram Reddit Google Groups","title":"Join Our Community"},{"location":"#report-bugs-and-suggest-features","text":"Open a new topic on Tasmota discussions . Report a bug in Tasmota issues .","title":"Report bugs and suggest features"},{"location":"A4988-Stepper-Motor-Controller/","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_A4988_STEPPER #define USE_A4988_STEPPER // A4988/DRV8825 stepper motor (+10k5 code) #endif This driver is used to control stepper-motors such as NEMA 17 . Configuration ~ Wiring ~ The driverboard has several connectors: powering the controller (3.3-5.0 V), input (+/-) & output (1a/1b/2a/2b), the motor (up to 35V/2A), and to control the circuit (in order at the control side of the board): Connector Description DIR Direction of rotation STEP Initiate stepping MS1 Microstep increment select MS2 Microstep increment select MS3 Microstep increment select EN Enable the power supply for the motor SLP Sleep (bridge to RST) RST Reset (bridge to SLP) Tasmota Settings ~ There are six GPIO components that should be configured to free GPIOs: A4988 DIR (170) A4988 STP (171) A4988 ENA (172) A4988 MS1 (173) A4988 MS2 (174) A4988 MS3 (175) The minimal configuration are the DIR and STEP signals. In such a configuration the motor will be permanently powered and microstepping will be set to 1/1 (full steps). A4988 Controller ~ Detailed information about the A4988 controller can be found in the datasheet . Microstepping Configuration ~ DRV8825 Controller ~ The DRV8825 is directly pin compatible with the A4988. The microstepping increment settings are different. Also, there is one additional option on the DRV8825. Microstepping Configuration ~ Operation ~ Refer to the Stepper Motor Commands MotorRPM is an imprecise setting due to the implementation method. Also, if the value is too high for the combination of chosen micro stepping increment ( MotorMIS ) and the number of steps the given motor needs for one revolution ( MotorSPR ), the motor will not turn but make a whining noise. You will have to experiment some to find the optimal combination for your use case. Example Project ~ The cheap auto-feeder for my cats broke. It was a fancy plastic-thingy with voice-recording-function & programmable to feed several times a day after playing back your voice (cats don't give a sh$7 about your voice - they come when they hear the food falling into the bowl). It was never precise - a concern for the amount of nutrition it gave the cats. And it was not reliable, as the torque of the internal moving mechanism was insufficient to spin the separator/proportioning wheel through the food reliably. In addition, the batteries were always drained in a day meaning very grumpy cats when we returned! Thus the wish to install a high-torque stepper-motor (with shifting gear) was born. I could power it with mains instead of relying on a battery, control it over WiFi from my home automation hub. Tasmota now offers a way to do this! The \"TasmotaSmartCatFeeder\" circuit consists of a WeMos D1 mini, a A4988 controller, and two power supplies (5V&12V). This all fits into the housing of the feeder and costs less than 50\u20ac! Virtually everything which has to be moved or rotated can be done now using these cheap components. It can be a window, door, shutter, cat or dog flap, a solar panel which follows the sun, a moving spotlight, PTZ-camera, or whatever. Wiring Diagrams ~ Convert 28BYJ-48 to bipolar so that it works with this driver Breakout Boards ~ Buy Links ~ Banggood AliExpress #1 AliExpress #1","title":"A4988 Stepper Motor Controller"},{"location":"A4988-Stepper-Motor-Controller/#configuration","text":"","title":"Configuration"},{"location":"A4988-Stepper-Motor-Controller/#wiring","text":"The driverboard has several connectors: powering the controller (3.3-5.0 V), input (+/-) & output (1a/1b/2a/2b), the motor (up to 35V/2A), and to control the circuit (in order at the control side of the board): Connector Description DIR Direction of rotation STEP Initiate stepping MS1 Microstep increment select MS2 Microstep increment select MS3 Microstep increment select EN Enable the power supply for the motor SLP Sleep (bridge to RST) RST Reset (bridge to SLP)","title":"Wiring"},{"location":"A4988-Stepper-Motor-Controller/#tasmota-settings","text":"There are six GPIO components that should be configured to free GPIOs: A4988 DIR (170) A4988 STP (171) A4988 ENA (172) A4988 MS1 (173) A4988 MS2 (174) A4988 MS3 (175) The minimal configuration are the DIR and STEP signals. In such a configuration the motor will be permanently powered and microstepping will be set to 1/1 (full steps).","title":"Tasmota Settings"},{"location":"A4988-Stepper-Motor-Controller/#a4988-controller","text":"Detailed information about the A4988 controller can be found in the datasheet .","title":"A4988 Controller"},{"location":"A4988-Stepper-Motor-Controller/#drv8825-controller","text":"The DRV8825 is directly pin compatible with the A4988. The microstepping increment settings are different. Also, there is one additional option on the DRV8825.","title":"DRV8825 Controller"},{"location":"A4988-Stepper-Motor-Controller/#operation","text":"Refer to the Stepper Motor Commands MotorRPM is an imprecise setting due to the implementation method. Also, if the value is too high for the combination of chosen micro stepping increment ( MotorMIS ) and the number of steps the given motor needs for one revolution ( MotorSPR ), the motor will not turn but make a whining noise. You will have to experiment some to find the optimal combination for your use case.","title":"Operation"},{"location":"A4988-Stepper-Motor-Controller/#example-project","text":"The cheap auto-feeder for my cats broke. It was a fancy plastic-thingy with voice-recording-function & programmable to feed several times a day after playing back your voice (cats don't give a sh$7 about your voice - they come when they hear the food falling into the bowl). It was never precise - a concern for the amount of nutrition it gave the cats. And it was not reliable, as the torque of the internal moving mechanism was insufficient to spin the separator/proportioning wheel through the food reliably. In addition, the batteries were always drained in a day meaning very grumpy cats when we returned! Thus the wish to install a high-torque stepper-motor (with shifting gear) was born. I could power it with mains instead of relying on a battery, control it over WiFi from my home automation hub. Tasmota now offers a way to do this! The \"TasmotaSmartCatFeeder\" circuit consists of a WeMos D1 mini, a A4988 controller, and two power supplies (5V&12V). This all fits into the housing of the feeder and costs less than 50\u20ac! Virtually everything which has to be moved or rotated can be done now using these cheap components. It can be a window, door, shutter, cat or dog flap, a solar panel which follows the sun, a moving spotlight, PTZ-camera, or whatever.","title":"Example Project"},{"location":"A4988-Stepper-Motor-Controller/#wiring-diagrams","text":"Convert 28BYJ-48 to bipolar so that it works with this driver","title":"Wiring Diagrams"},{"location":"A4988-Stepper-Motor-Controller/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"ADC/","text":"ESP8266 has a single ADC pin available. It may be used to read voltage at ADC pin or to read module supply voltage (VCC). Note When referring to the ADC pin these terms are used interchangeably: ADC (Analog-to-digital Converter), TOUT, Pin6, A0 or Analog0. Warning Check your Wi-Fi module! The ESP8266 A0 pin supports a maximum voltage of 1.0V. Many newer Wi-Fi modules have an on-board voltage divider to support a higher A0 input voltage range (typically in the range between 0 and 3.3 volts). You may need to use an external voltage divider to ensure your input voltage is in the right range. By default Tasmota uses the ADC pin to read voltage. The signal comes from an analog peripheral , or sometimes from the device itself (see Shelly 2.5 ). After wiring a peripheral to GPIO17 (A0) pin you have to configure it in Configure Module : ESP32 has more ADC pin available, of this something specified for analog input (gpio34, gpio35, gpio36, gpio39). It may be used to read voltage at ADC pin or to read module supply voltage (VCC). All analog input pins support 3.3V of max supply. After wiring a peripheral to specified Analog Input GPIO pin you have to configure it in Configure Module : # Option WebUI display MQTT mesage 0 None none none 1 Analog Analog0 %value% {\"A0\":%value%} 2 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 Button none none 5 Buttoni none none 6 Range Range %value% {\"Range\":%value%} 7 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\":%value,\"Power\":%value,\"Voltage\":230,\"Current\":%value} 9 pH ph %value {\"pH\":%value} 10 MQ-X MQ-X %value ppm {\"MQX\":%value} The reading will show in web UI's sensor section as \" %option% %value% \" depending on the selected option. Tasmota calculates the values for temperature and light, analog values can be 1 to 1024 . Note When using Temperature (2) or light (3) a calibration could be needed. In case of shifted values AdcParam can be used to calibrate the output. Example: ADC as Analog (1) A message will be published in tele/%topic%/SENSOR JSON response as \"ANALOG\": depending on the selected option. Example: ADC as Light (3) 18 : 55 : 09 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T18:55:09\" , \"ANALOG\" :{ \"Illuminance\" : 8 }} Warning Careful when setting ADC as Button, if there is constant voltage on the pin it might register as a long press and reset the device to firmware defaults Commands ~ Command Parameters AdcParam<x> ADC analog input tuning parameters. On ESP32 x is channel 1..8 <sensor>, <param1>, <param2>, <param3>, <param4> <sensor> values: \u2003 2 = Temperature Steinhart-Hart thermistor equation parameters: <param1> = NTC Voltage bridge resistor in Ohms (default = 32000 ) <param2> = NTC Resistance in Ohms (default = 10000 ) <param3> = NTC Beta Coefficient (default = 3350 ) \u2003 3 = Light Lux equation parameters: <param1> = LDR Voltage bridge resistor in Ohms (default = 10000 ) <param2> = LDR Lux Scalar (default = 12518931 ) <param3> = LDR Lux Exponent (default = -1.4050 ) \u2003 6 = ADC linear range remapping parameters: <param1> = input range low value adcLow (default = 0 ) <param2> = input range high value adcHigh (default = 1023 ) <param3> = output range low value rangeLow (default = 0 ) <param4> = output range high value rangeHigh (default = 100 ) The range remapping perform the following calculation on the ADC value [0..1023] : Range = ((adcHigh - ADC) / (adcHigh - adcLow)) * (rangeLow - rangeHigh) + rangeHigh The calculation is performed in double resolution floating point, but the output is a signed integer. All 4 input parameters are unsigned 16 bit integers. Example to convert the ADC value on a D1-mini into millivolts (using the default resistor bridge of 220k/100k): AdcParam 6, 0, 1023, 0, 3200 \u2003 7 = CT POWER parameter adjustments: <param1> = ANALOG_CT_FLAGS (default 0 for a non-invasive current sensor). When value is >0 its sets the adcLow value as base for the measurement via OpAmp differential amplifier. <param2> = ANALOG_CT_MULTIPLIER ( 2146 = Default settings for a (AC) 20A/1V Current Transformer.) multiplier*100000 to convert raw ADC peak to peak range 0..1023 to RMS current in Amps. Value of 100000 corresponds to 1 <param3> = ANALOG_CT_VOLTAGE (default 2300) to convert current in Amps to apparent power in Watts using voltage in Volts*10. Value of 2200 corresponds to AC220V. For DC its Volt/1000. Eg. 12VDC = 0.012. AdcParam 7,406,3282,0.012 \u2003 9 = ANALOG_PH parameter adjustments: <param1> = ANALOG_PH_CALSOLUTION_LOW_PH (default 4.0). <param2> = ANALOG_PH_CALSOLUTION_LOW_ANALOG_VALUE ( default 282 ) <param3> = ANALOG_PH_CALSOLUTION_HIGH_PH (default 9.18). <param4> = ANALOG_PH_CALSOLUTION_HIGH_ANALOG_VALUE (default 435). To calibrate the probe, two reference solutions with known pH are required. Calibration procedure: Put probe in solution with lower pH value. pH value of the solution is ANALOG_PH_CALSOLUTION_LOW_PH. Wait until analog value / RAW value stabilizes (~3 minutes) The analog reading is ANALOG_PH_CALSOLUTION_LOW_ANALOG_VALUE Clean probe and put in solution with higher pH value. pH value of the solution is ANALOG_PH_CALSOLUTION_HIGH_PH. Wait until analog value / RAW value stabilizes (~3 minutes) The analog reading is ANALOG_PH_CALSOLUTION_HIGH_ANALOG_VALUE Analog readings can be read by either changing the analog port configuration to \"Analog Input\" while calibrating, or by enabling debug logs in the console and having a look at the RAW Value reading instead. \u2003 10 = MQ-X sensors parameter adjustments: <param1> = ANALOG_MQ_TYPE (default 2) It used to specify sensor type. At the moment exists: 2, 3, 4, 5, 6, 7, 8, 9, 131, 135 (means MQ-02, MQ-03, MQ-04 ecc.). <param2> = ANALOG_MQ_A (default 574.25 a params for MQ-02) It is exponential regression a params <param3> = ANALOG_MQ_B (default -2.222 b params for MQ-02) It is exponential regression b params, generally negative <param4> = ANALOG_MQ_RatioMQCleanAir (default 15.0 RatioMQCleanAir params for MQ-02) NOT USED YET. It is threashold for good air in ppm for future alams arming Usage example for MQ-02, MQ-04, MQ-07 and MQ-131 AdcParam 10, 2.00, 574.25, -2.22, 9.83 AdcParam 10, 4.00, 1012.70, -2.79, 4.40 AdcParam 10, 7.00, 99.04, -1.52, 27.50 AdcParam 10, 131.00, 23.94, -1.11, 15.00 Rule triggers ~ Use these triggers in rules: on ANALOG#A0div10 do ... - when the ADC input changes by more than 1% it provides a value between 0 and 100 on Tele-ANALOG#A0 do ... - triggers on tele messages with Analog object MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-14T19:36:51\",\"ANALOG\":{\"A0\":1024}} Rule example: using a potentiometer on analog pin . ADC_VCC ~ Instead of an input, ADC pin can be used to measure supply voltage of the ESP module ( this reading in not 100% accurate ). To enable ADC_VCC feature you need to compile your own build : If you enable ADC_VCC you cannot use the pin as analog input anymore. user_config_override.h flag: // -- Internal Analog input ----------------------- #define USE_ADC_VCC // Display Vcc in Power status Supply voltage is published in tele/%topic%/STATE under \"Vcc\": in mV: 11:14:59 MQT: tele/tasmota/STATE = {\"Time\":\"2019-10-31T11:14:59\",\"Uptime\":\"0T18:36:12\",\"UptimeSec\":66972,\"Vcc\":3.423,\"Heap\":28,\"SleepMode\":\"Dynamic\",\"Sleep\":50,\"LoadAvg\":19,\"MqttCount\":6,\"POWER\":\"OFF\",\"Wifi\":{\"AP\":1,\"SSId\":\"Tasmota\",\"BSSId\":\"00:00:00:00:00:00\",\"Channel\":13,\"RSSI\":100,\"LinkCount\":1,\"Downtime\":\"0T00:00:06\"}}","title":"Analog Pin"},{"location":"ADC/#commands","text":"Command Parameters AdcParam<x> ADC analog input tuning parameters. On ESP32 x is channel 1..8 <sensor>, <param1>, <param2>, <param3>, <param4> <sensor> values: \u2003 2 = Temperature Steinhart-Hart thermistor equation parameters: <param1> = NTC Voltage bridge resistor in Ohms (default = 32000 ) <param2> = NTC Resistance in Ohms (default = 10000 ) <param3> = NTC Beta Coefficient (default = 3350 ) \u2003 3 = Light Lux equation parameters: <param1> = LDR Voltage bridge resistor in Ohms (default = 10000 ) <param2> = LDR Lux Scalar (default = 12518931 ) <param3> = LDR Lux Exponent (default = -1.4050 ) \u2003 6 = ADC linear range remapping parameters: <param1> = input range low value adcLow (default = 0 ) <param2> = input range high value adcHigh (default = 1023 ) <param3> = output range low value rangeLow (default = 0 ) <param4> = output range high value rangeHigh (default = 100 ) The range remapping perform the following calculation on the ADC value [0..1023] : Range = ((adcHigh - ADC) / (adcHigh - adcLow)) * (rangeLow - rangeHigh) + rangeHigh The calculation is performed in double resolution floating point, but the output is a signed integer. All 4 input parameters are unsigned 16 bit integers. Example to convert the ADC value on a D1-mini into millivolts (using the default resistor bridge of 220k/100k): AdcParam 6, 0, 1023, 0, 3200 \u2003 7 = CT POWER parameter adjustments: <param1> = ANALOG_CT_FLAGS (default 0 for a non-invasive current sensor). When value is >0 its sets the adcLow value as base for the measurement via OpAmp differential amplifier. <param2> = ANALOG_CT_MULTIPLIER ( 2146 = Default settings for a (AC) 20A/1V Current Transformer.) multiplier*100000 to convert raw ADC peak to peak range 0..1023 to RMS current in Amps. Value of 100000 corresponds to 1 <param3> = ANALOG_CT_VOLTAGE (default 2300) to convert current in Amps to apparent power in Watts using voltage in Volts*10. Value of 2200 corresponds to AC220V. For DC its Volt/1000. Eg. 12VDC = 0.012. AdcParam 7,406,3282,0.012 \u2003 9 = ANALOG_PH parameter adjustments: <param1> = ANALOG_PH_CALSOLUTION_LOW_PH (default 4.0). <param2> = ANALOG_PH_CALSOLUTION_LOW_ANALOG_VALUE ( default 282 ) <param3> = ANALOG_PH_CALSOLUTION_HIGH_PH (default 9.18). <param4> = ANALOG_PH_CALSOLUTION_HIGH_ANALOG_VALUE (default 435). To calibrate the probe, two reference solutions with known pH are required. Calibration procedure: Put probe in solution with lower pH value. pH value of the solution is ANALOG_PH_CALSOLUTION_LOW_PH. Wait until analog value / RAW value stabilizes (~3 minutes) The analog reading is ANALOG_PH_CALSOLUTION_LOW_ANALOG_VALUE Clean probe and put in solution with higher pH value. pH value of the solution is ANALOG_PH_CALSOLUTION_HIGH_PH. Wait until analog value / RAW value stabilizes (~3 minutes) The analog reading is ANALOG_PH_CALSOLUTION_HIGH_ANALOG_VALUE Analog readings can be read by either changing the analog port configuration to \"Analog Input\" while calibrating, or by enabling debug logs in the console and having a look at the RAW Value reading instead. \u2003 10 = MQ-X sensors parameter adjustments: <param1> = ANALOG_MQ_TYPE (default 2) It used to specify sensor type. At the moment exists: 2, 3, 4, 5, 6, 7, 8, 9, 131, 135 (means MQ-02, MQ-03, MQ-04 ecc.). <param2> = ANALOG_MQ_A (default 574.25 a params for MQ-02) It is exponential regression a params <param3> = ANALOG_MQ_B (default -2.222 b params for MQ-02) It is exponential regression b params, generally negative <param4> = ANALOG_MQ_RatioMQCleanAir (default 15.0 RatioMQCleanAir params for MQ-02) NOT USED YET. It is threashold for good air in ppm for future alams arming Usage example for MQ-02, MQ-04, MQ-07 and MQ-131 AdcParam 10, 2.00, 574.25, -2.22, 9.83 AdcParam 10, 4.00, 1012.70, -2.79, 4.40 AdcParam 10, 7.00, 99.04, -1.52, 27.50 AdcParam 10, 131.00, 23.94, -1.11, 15.00","title":"Commands"},{"location":"ADC/#rule-triggers","text":"Use these triggers in rules: on ANALOG#A0div10 do ... - when the ADC input changes by more than 1% it provides a value between 0 and 100 on Tele-ANALOG#A0 do ... - triggers on tele messages with Analog object MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-14T19:36:51\",\"ANALOG\":{\"A0\":1024}} Rule example: using a potentiometer on analog pin .","title":"Rule triggers"},{"location":"ADC/#adc_vcc","text":"Instead of an input, ADC pin can be used to measure supply voltage of the ESP module ( this reading in not 100% accurate ). To enable ADC_VCC feature you need to compile your own build : If you enable ADC_VCC you cannot use the pin as analog input anymore. user_config_override.h flag: // -- Internal Analog input ----------------------- #define USE_ADC_VCC // Display Vcc in Power status Supply voltage is published in tele/%topic%/STATE under \"Vcc\": in mV: 11:14:59 MQT: tele/tasmota/STATE = {\"Time\":\"2019-10-31T11:14:59\",\"Uptime\":\"0T18:36:12\",\"UptimeSec\":66972,\"Vcc\":3.423,\"Heap\":28,\"SleepMode\":\"Dynamic\",\"Sleep\":50,\"LoadAvg\":19,\"MqttCount\":6,\"POWER\":\"OFF\",\"Wifi\":{\"AP\":1,\"SSId\":\"Tasmota\",\"BSSId\":\"00:00:00:00:00:00\",\"Channel\":13,\"RSSI\":100,\"LinkCount\":1,\"Downtime\":\"0T00:00:06\"}}","title":"ADC_VCC"},{"location":"AHT1x/","text":"AHT10/AHT15 temperature and humidity sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_AHT1x #define USE_AHT1x // [I2cDriver43] Enable AHT10/15 humidity and temperature sensor (I2C address 0x38, 0x39) (+0k8 code) #endif AHT1x are an I 2 C temperature and humidity sensor. AHT2x or AM2301B are upgraded versions. Configuration ~ This sensor is incompatible with other I 2 C devices on I 2 C bus Sensor datasheet implicitly says: Only a single AHT10 can be connected to the I 2 C bus and no other I 2 C devices can be connected. The AHT2x/AM2301B does not suffer from this problem. Wiring ~ AHT ESP VCC 3.3V GND GND SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect AHT1x automatically and display sensor readings. and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"AHT1X-0x38\":{\"Temperature\":24.7,\"Humidity\":61.9,\"DewPoint\":16.8},\"TempUnit\":\"C\"} Troubleshooting ~ On some I2C sensors, like the AHT25, Tasmota might mistake the sensor for another one using the same address. This can be resolved by disabling the unneeded drivers. For our example AHT25, the address might get confused with the VEML6070 UV sensor. You can tell Tasmota to use the other driver by issuing the following commands in the console: I2CDriver12 0 to disable the VEML driver I2CDriver43 1 to enable the AHT driver An overview of all I2C drivers is available in the docs. Breakout Boards ~ Note : The pins on the smaller breakout board with the AHT15 are in a different order: VDD - SDA - GND - SCL See also the datasheet. AHT10 Datasheet AHT15 Datasheet","title":"AHT10/AHT15 temperature and humidity sensor"},{"location":"AHT1x/#aht10aht15-temperature-and-humidity-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_AHT1x #define USE_AHT1x // [I2cDriver43] Enable AHT10/15 humidity and temperature sensor (I2C address 0x38, 0x39) (+0k8 code) #endif AHT1x are an I 2 C temperature and humidity sensor. AHT2x or AM2301B are upgraded versions.","title":"AHT10/AHT15 temperature and humidity sensor"},{"location":"AHT1x/#configuration","text":"This sensor is incompatible with other I 2 C devices on I 2 C bus Sensor datasheet implicitly says: Only a single AHT10 can be connected to the I 2 C bus and no other I 2 C devices can be connected. The AHT2x/AM2301B does not suffer from this problem.","title":"Configuration"},{"location":"AHT1x/#wiring","text":"AHT ESP VCC 3.3V GND GND SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"AHT1x/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect AHT1x automatically and display sensor readings. and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"AHT1X-0x38\":{\"Temperature\":24.7,\"Humidity\":61.9,\"DewPoint\":16.8},\"TempUnit\":\"C\"}","title":"Tasmota Settings"},{"location":"AHT1x/#troubleshooting","text":"On some I2C sensors, like the AHT25, Tasmota might mistake the sensor for another one using the same address. This can be resolved by disabling the unneeded drivers. For our example AHT25, the address might get confused with the VEML6070 UV sensor. You can tell Tasmota to use the other driver by issuing the following commands in the console: I2CDriver12 0 to disable the VEML driver I2CDriver43 1 to enable the AHT driver An overview of all I2C drivers is available in the docs.","title":"Troubleshooting"},{"location":"AHT1x/#breakout-boards","text":"Note : The pins on the smaller breakout board with the AHT15 are in a different order: VDD - SDA - GND - SCL See also the datasheet. AHT10 Datasheet AHT15 Datasheet","title":"Breakout Boards"},{"location":"AHT2x/","text":"AHT2x/AM2301B temperature and humidity sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_AHT2x #define USE_AHT2x // [I2cDriver43] Enable AHT20/AM2301B instead of AHT1x humidity and temperature sensor (I2C address 0x38) (+0k8 code) #endif Configuration ~ Wiring ~ AHT ESP VCC 3.3V GND GND SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver should detect the sensor and display sensor readings. Troubleshooting ~ On some I2C sensors, like the AHT25, Tasmota might mistake the sensor for another one using the same address. This can be resolved by disabling the unneeded drivers. For our example AHT25, the address might get confused with the VEML6070 UV sensor. You can tell Tasmota to use the other driver by issuing the following commands in the console: I2CDriver12 0 to disable the VEML driver I2CDriver43 1 to enable the AHT driver An overview of all I2C drivers is available in the docs. Breakout Boards ~ AHT20 Datasheet AHT21 Datasheet AHT25 Datasheet","title":"AHT2x/AM2301B temperature and humidity sensor"},{"location":"AHT2x/#aht2xam2301b-temperature-and-humidity-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_AHT2x #define USE_AHT2x // [I2cDriver43] Enable AHT20/AM2301B instead of AHT1x humidity and temperature sensor (I2C address 0x38) (+0k8 code) #endif","title":"AHT2x/AM2301B temperature and humidity sensor"},{"location":"AHT2x/#configuration","text":"","title":"Configuration"},{"location":"AHT2x/#wiring","text":"AHT ESP VCC 3.3V GND GND SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"AHT2x/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver should detect the sensor and display sensor readings.","title":"Tasmota Settings"},{"location":"AHT2x/#troubleshooting","text":"On some I2C sensors, like the AHT25, Tasmota might mistake the sensor for another one using the same address. This can be resolved by disabling the unneeded drivers. For our example AHT25, the address might get confused with the VEML6070 UV sensor. You can tell Tasmota to use the other driver by issuing the following commands in the console: I2CDriver12 0 to disable the VEML driver I2CDriver43 1 to enable the AHT driver An overview of all I2C drivers is available in the docs.","title":"Troubleshooting"},{"location":"AHT2x/#breakout-boards","text":"AHT20 Datasheet AHT21 Datasheet AHT25 Datasheet","title":"Breakout Boards"},{"location":"AM2301/","text":"AM2301/AM2302 (DHT21/DHT22) temperature and humidity sensor ~ This feature is included in tasmota , tasmota32 , tasmota-knx and tasmota-display binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DHT #define USE_DHT // Add support for DHT11, AM2301 (DHT21, DHT22, AM2302, AM2321) and SI7021 Temperature and Humidity sensor (1k6 code) #endif AM2301 driver supports AM2301 (DHT21) , AM2302 (DHT22) and AM2321 temperature and humidity sensors. Introduced in Tasmota through Sonoff AM2301 accessory for Sonoff TH . This driver is ONLY for single wire implementations of the sensor. For AM2301B I 2 C model, refer to AHT2x driver. Configuration ~ Wiring ~ AM2301 ESP - GND OUT GPIOx + 3.3V - 5.2V (5V is recommended) Tasmota Settings ~ In the Configuration -> Configure Module page assign: - GPIOx to AM2301 After a reboot webUI will display temperature and humidity measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"AM2301\" : { \"Temperature\" : 24.6 , \"Humidity\" : 58.2 }, \"TempUnit\" : \"C\" } Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Wemos DHT Shield ~ Like the Wemos DHT11 shield specs the DATA OUT pin of Wemos DHT22 is connected to D4 of the Wemos. Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIO2 to AM2301 (2) Sensors ~ Read more about differences between sensors .","title":"AM2301/AM2302 (DHT21/DHT22) temperature and humidity sensor"},{"location":"AM2301/#am2301am2302-dht21dht22-temperature-and-humidity-sensor","text":"This feature is included in tasmota , tasmota32 , tasmota-knx and tasmota-display binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DHT #define USE_DHT // Add support for DHT11, AM2301 (DHT21, DHT22, AM2302, AM2321) and SI7021 Temperature and Humidity sensor (1k6 code) #endif AM2301 driver supports AM2301 (DHT21) , AM2302 (DHT22) and AM2321 temperature and humidity sensors. Introduced in Tasmota through Sonoff AM2301 accessory for Sonoff TH . This driver is ONLY for single wire implementations of the sensor. For AM2301B I 2 C model, refer to AHT2x driver.","title":"AM2301/AM2302 (DHT21/DHT22) temperature and humidity sensor"},{"location":"AM2301/#configuration","text":"","title":"Configuration"},{"location":"AM2301/#wiring","text":"AM2301 ESP - GND OUT GPIOx + 3.3V - 5.2V (5V is recommended)","title":"Wiring"},{"location":"AM2301/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: - GPIOx to AM2301 After a reboot webUI will display temperature and humidity measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"AM2301\" : { \"Temperature\" : 24.6 , \"Humidity\" : 58.2 }, \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"AM2301/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"AM2301/#wemos-dht-shield","text":"Like the Wemos DHT11 shield specs the DATA OUT pin of Wemos DHT22 is connected to D4 of the Wemos.","title":"Wemos DHT Shield"},{"location":"AM2301/#tasmota-settings_1","text":"In the Configuration -> Configure Module page assign: GPIO2 to AM2301 (2)","title":"Tasmota Settings"},{"location":"AM2301/#sensors","text":"Read more about differences between sensors .","title":"Sensors"},{"location":"APDS-9960/","text":"APDS-9960 light and gesture sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_APDS9960 #define USE_APDS9960 // [I2cDriver21] Enable APDS9960 Proximity Sensor (I2C address 0x39). Disables SHT and VEML6070 (+4k7 code) #define USE_APDS9960_GESTURE // Enable APDS9960 Gesture feature (+2k code) #define USE_APDS9960_PROXIMITY // Enable APDS9960 Proximity feature (>50 code) #define USE_APDS9960_COLOR // Enable APDS9960 Color feature (+0.8k code) #define USE_APDS9960_STARTMODE 0 // Default to enable Gesture mode #endif Broadcom APDS-9960 is a digital RGB, ambient light, proximity and gesture sensor device in a single 8-pin package. The device has an I2C compatible interface providing red, green, blue, clear (RGBC), proximity and gesture sensing with IR LED. The RGB and ambient light sensing feature detects light intensity under various lighting conditions and through various attentuation materials including darkened glass. In addition, the integrated UV-IR blocking filter enables accurate ambient light and correlated color temperature sensing. Configuration ~ Wiring ~ Breakout ESP VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT/IRQ not used Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After configuring the GPIO's the driver will detect the APDS-9960 automatically. On first boot sensor will start in gesture mode. It will not appear in the webUI but it can be observed via MQTT messages in console: 21 : 34 : 21 MQT : tele / tas mo ta /RESULT = { \"Gesture\" : \"Off\" } 21 : 34 : 23 MQT : tele / tas mo ta /RESULT = { \"Gesture\" : \"On\" } 21 : 34 : 25 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:25\" , \"APDS9960\" :{ \"None\" : 1 }} 21 : 34 : 26 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:26\" , \"APDS9960\" :{ \"Right\" : 1 }} 21 : 34 : 29 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:29\" , \"APDS9960\" :{ \"Down\" : 1 }} 21 : 34 : 29 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:29\" , \"APDS9960\" :{ \"Right\" : 1 }} 21 : 34 : 31 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:31\" , \"APDS9960\" :{ \"Left\" : 1 }} 21 : 34 : 33 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:33\" , \"APDS9960\" :{ \"Up\" : 1 }} 21 : 34 : 35 MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2019-10-31T21:34:35\" , \"APDS9960\" :{ \"Down\" : 1 }} When you enable RGBC mode with Sensor27 0 sensor will show up in web UI: and in MQTT topic (according to TelePeriod): MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-10-31T21:48:51\",\"APDS9960\":{\"Red\":282,\"Green\":252,\"Blue\":196,\"Ambient\":169,\"CCT\":4217,\"Proximity\":9}} Commands ~ Command Value Description Sensor27 Show APDS9960 gesture/RGBC mode Sensor27 0 / off Disable APDS9960 gesture mode/Enable RGBC mode Sensor27 1 / on Enable APDS9960 gesture mode/Disable RGBC mode Sensor27 2 / on Enable APDS9960 gesture mode/Disable RGBC mode with half gain Sensor27 3 ...255 Set ATIME register for different integration times Example Rules ~ Device will be in RGBC mode until something is close to it, then it switches into gesture mode for 60 seconds. Rule on APDS9960#Proximity=250 do backlog Sensor27 1; RuleTimer1 60 endon on Rules#Timer=1 do Sensor27 0 endon Relay ON when ambient light is below 100 lux. Rule on APDS9960#Ambient<100 do POWER ON endon Control ON/OFF, brightness and color temperature with gestures Rule on APDS9960#Long=1 do power toggle endon on APDS9960#Up=1 do dimmer + endon on APDS9960#Down=1 do dimmer - endon on APDS9960#Left=1 do ct + endon on APDS9960#Right=1 do ct - endon Known Issues ~ The different PCB\u2019s on the market seem to differ quite substantially regarding to their electrical characteristics. We have at least one case report, where this led to a malfunction on an ESP8266-board within Tasmota but in another library too. The exact technical reason can only be suspected, but it is probably related to electrical noise and/or power consumption. In the case from above the sensor measured an incorrect high proximity value, which resulted in repeated triggering of a \"LONG\" gesture. The solution was to decrease the gain factor for proximity and gesture. Therefore the argument 2 ( sensor27 2 ) was introduced to change this at runtime. If you experience gesture sensing problems you could try this out, but if you measure proximity values <25 with nothing in front of the sensor (e.g. web interface after sensor27 0 ), then there is very likely another problem. It can be assumed, that the gesture sensitivity will suffer with reduced gain, so first try option 1 (=default). Beside that better wiring and maybe an additional capacitor over VCC and GROUND might be helpful. The measurement of the light level is briefly described in the datasheet and the open-source-libraries use the ambient-light-value directly from the sensor or calculate a LUX-value from RGB. Both variants are usable and differentiate between low and strong light, but the absolute values are questionable and at the moment we have an uncalibrated sensor. All known solutions use a fixed integration time, which is more or less the same as a fixed exposure time in photography. In contrast the TSL2561-library uses various integration times and maybe this is possible on the APDS9960 too. To eventually achieve this in the future, the option to set this integration time at runtime was added. Every argument between 3 and 255 sets the ATIME-register. The formula is: integration time = (256-ATIME) 2,78 ms, so with the default value of 219 we get (256-219) 2,78 = 102,86 ms. That means a smaller ATIME makes the integration time longer and more photons are captured, which might be usable for (very) low light conditions, because otherwise the sensor will saturate too early. The opposite is valid for a bigger ATIME value. The change of this value only makes sense for: users who need to change the sensitivity, if the sensor resides behind dark glass or want to contribute to the development of a new LUX-calculation in the driver. If we get enough feedback, this could lead to an improvement on the software side. Feel free to open (or search for) an issue, if you have measured the APDS9960 against other devices with different ATIME-values at different light levels. This is not a trivial task though. Breakout Boards ~ Where to get ~ ~ 2\u20ac at AliExpress ~ $8 at Adafruit APDS-9960 Datasheet","title":"APDS-9960 light and gesture sensor"},{"location":"APDS-9960/#apds-9960-light-and-gesture-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_APDS9960 #define USE_APDS9960 // [I2cDriver21] Enable APDS9960 Proximity Sensor (I2C address 0x39). Disables SHT and VEML6070 (+4k7 code) #define USE_APDS9960_GESTURE // Enable APDS9960 Gesture feature (+2k code) #define USE_APDS9960_PROXIMITY // Enable APDS9960 Proximity feature (>50 code) #define USE_APDS9960_COLOR // Enable APDS9960 Color feature (+0.8k code) #define USE_APDS9960_STARTMODE 0 // Default to enable Gesture mode #endif Broadcom APDS-9960 is a digital RGB, ambient light, proximity and gesture sensor device in a single 8-pin package. The device has an I2C compatible interface providing red, green, blue, clear (RGBC), proximity and gesture sensing with IR LED. The RGB and ambient light sensing feature detects light intensity under various lighting conditions and through various attentuation materials including darkened glass. In addition, the integrated UV-IR blocking filter enables accurate ambient light and correlated color temperature sensing.","title":"APDS-9960 light and gesture sensor"},{"location":"APDS-9960/#configuration","text":"","title":"Configuration"},{"location":"APDS-9960/#commands","text":"Command Value Description Sensor27 Show APDS9960 gesture/RGBC mode Sensor27 0 / off Disable APDS9960 gesture mode/Enable RGBC mode Sensor27 1 / on Enable APDS9960 gesture mode/Disable RGBC mode Sensor27 2 / on Enable APDS9960 gesture mode/Disable RGBC mode with half gain Sensor27 3 ...255 Set ATIME register for different integration times","title":"Commands"},{"location":"APDS-9960/#example-rules","text":"Device will be in RGBC mode until something is close to it, then it switches into gesture mode for 60 seconds. Rule on APDS9960#Proximity=250 do backlog Sensor27 1; RuleTimer1 60 endon on Rules#Timer=1 do Sensor27 0 endon Relay ON when ambient light is below 100 lux. Rule on APDS9960#Ambient<100 do POWER ON endon Control ON/OFF, brightness and color temperature with gestures Rule on APDS9960#Long=1 do power toggle endon on APDS9960#Up=1 do dimmer + endon on APDS9960#Down=1 do dimmer - endon on APDS9960#Left=1 do ct + endon on APDS9960#Right=1 do ct - endon","title":"Example Rules"},{"location":"APDS-9960/#known-issues","text":"The different PCB\u2019s on the market seem to differ quite substantially regarding to their electrical characteristics. We have at least one case report, where this led to a malfunction on an ESP8266-board within Tasmota but in another library too. The exact technical reason can only be suspected, but it is probably related to electrical noise and/or power consumption. In the case from above the sensor measured an incorrect high proximity value, which resulted in repeated triggering of a \"LONG\" gesture. The solution was to decrease the gain factor for proximity and gesture. Therefore the argument 2 ( sensor27 2 ) was introduced to change this at runtime. If you experience gesture sensing problems you could try this out, but if you measure proximity values <25 with nothing in front of the sensor (e.g. web interface after sensor27 0 ), then there is very likely another problem. It can be assumed, that the gesture sensitivity will suffer with reduced gain, so first try option 1 (=default). Beside that better wiring and maybe an additional capacitor over VCC and GROUND might be helpful. The measurement of the light level is briefly described in the datasheet and the open-source-libraries use the ambient-light-value directly from the sensor or calculate a LUX-value from RGB. Both variants are usable and differentiate between low and strong light, but the absolute values are questionable and at the moment we have an uncalibrated sensor. All known solutions use a fixed integration time, which is more or less the same as a fixed exposure time in photography. In contrast the TSL2561-library uses various integration times and maybe this is possible on the APDS9960 too. To eventually achieve this in the future, the option to set this integration time at runtime was added. Every argument between 3 and 255 sets the ATIME-register. The formula is: integration time = (256-ATIME) 2,78 ms, so with the default value of 219 we get (256-219) 2,78 = 102,86 ms. That means a smaller ATIME makes the integration time longer and more photons are captured, which might be usable for (very) low light conditions, because otherwise the sensor will saturate too early. The opposite is valid for a bigger ATIME value. The change of this value only makes sense for: users who need to change the sensitivity, if the sensor resides behind dark glass or want to contribute to the development of a new LUX-calculation in the driver. If we get enough feedback, this could lead to an improvement on the software side. Feel free to open (or search for) an issue, if you have measured the APDS9960 against other devices with different ATIME-values at different light levels. This is not a trivial task though.","title":"Known Issues"},{"location":"APDS-9960/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"API/","text":"Basic API information ~ Tasmota can easily be extended by developers using provided function pointers as callback Ids. This document lists the available callback function Ids. Read Sensor API for more information. \u00bd Callback availability can be checked by searching for either XdrvCall, XsnsCall, XdspCall, XnrgCall and XlgtCall. Driver, Sensor, Energy and Light Callback Ids ~ The following table lists Callback Ids and their availability for a Driver, Sensor or Energy service. Callback Id Bool xdrv xsns xnrg xlgt Description FUNC_SETTINGS_OVERRIDE x Override start-up settings FUNC_PIN_STATE x 1 2 At GPIO configuration FUNC_MODULE_INIT x 1 2 Init module specific parameters FUNC_PRE_INIT 1 2 Once GPIO have been established FUNC_INIT 1 3 2 At end of initialisation FUNC_LOOP 1 2 In main loop FUNC_EVERY_50_MSECOND 1 2 FUNC_EVERY_100_MSECOND 1 2 FUNC_EVERY_200_MSECOND x FUNC_EVERY_250_MSECOND 1 3 2 FUNC_EVERY_SECOND 1 2 FUNC_SAVE_AT_MIDNIGHT x At midnight FUNC_SAVE_BEFORE_RESTART 2 1 Just before a planned restart FUNC_AFTER_TELEPERIOD 2 1 At end of teleperiod FUNC_JSON_APPEND 2 1 3 Extend teleperiod JSON text FUNC_WEB_SENSOR 2 1 3 Add sensor data to web GUI FUNC_COMMAND x 1 2 3 4 When a command is not recognized FUNC_COMMAND_DRIVER x x When command Driver<id> is executed FUNC_COMMAND_SENSOR x x When command Sensor<id> is executed FUNC_MQTT_SUBSCRIBE x At end of MQTT subscriptions FUNC_MQTT_INIT x Once at end of MQTT connection FUNC_MQTT_DATA x x Before decoding command FUNC_SET_POWER x Before setting relays FUNC_SET_DEVICE_POWER x x Set relay FUNC_SHOW_SENSOR x When FUNC_JSON_APPEND completes FUNC_ANY_KEY x FUNC_ENERGY_EVERY_SECOND x FUNC_ENERGY_RESET x FUNC_RULES_PROCESS x x Process specific rule FUNC_SERIAL x 1 2 3 Process serial data FUNC_FREE_MEM x Show free memory for debugging FUNC_BUTTON_PRESSED x x When a button is pressed FUNC_WEB_ADD_BUTTON 1 2 Add a Configuration Button to GUI FUNC_WEB_ADD_MAIN_BUTTON 1 2 Add a main button to GUI FUNC_WEB_ADD_HANDLER 1 2 Add a webserver handler FUNC_SET_CHANNELS 2 1 FUNC_SET_SCHEME x The numbers represent the sequence of execution Display Call back Ids ~ The following table lists all Callback Ids for a Display service. Callback Id Bool Description FUNC_DISPLAY_INIT_DRIVER FUNC_DISPLAY_INIT FUNC_DISPLAY_EVERY_50_MSECOND FUNC_DISPLAY_EVERY_SECOND FUNC_DISPLAY_MODEL x FUNC_DISPLAY_MODE FUNC_DISPLAY_POWER FUNC_DISPLAY_CLEAR FUNC_DISPLAY_DRAW_FRAME FUNC_DISPLAY_DRAW_HLINE FUNC_DISPLAY_DRAW_VLINE FUNC_DISPLAY_DRAW_LINE FUNC_DISPLAY_DRAW_CIRCLE FUNC_DISPLAY_FILL_CIRCLE FUNC_DISPLAY_DRAW_RECTANGLE FUNC_DISPLAY_FILL_RECTANGLE FUNC_DISPLAY_TEXT_SIZE FUNC_DISPLAY_FONT_SIZE FUNC_DISPLAY_ROTATION FUNC_DISPLAY_DRAW_STRING FUNC_DISPLAY_ONOFF FUNC_DISPLAY_NUMBER * FUNC_DISPLAY_FLOAT * FUNC_DISPLAY_NUMBERNC * FUNC_DISPLAY_FLOATNC * FUNC_DISPLAY_BRIGHTNESS * FUNC_DISPLAY_RAW * FUNC_DISPLAY_LEVEL * FUNC_DISPLAY_SEVENSEG_TEXT * FUNC_DISPLAY_SEVENSEG_TEXTNC * FUNC_DISPLAY_SCROLLDELAY * FUNC_DISPLAY_CLOCK * FUNC_DISPLAY_SCROLLTEXT * * TM1637 driver Only Init sequence ~ The following list shows a typical callback init sequence CFG: Loaded from flash at FB, Count 1581 xdrv - FUNC_SETTINGS_OVERRIDE xdrv - FUNC_PIN_STATE xsns - FUNC_PIN_STATE xdrv - FUNC_MODULE_INIT xlgt - FUNC_MODULE_INIT xdrv - FUNC_PRE_INIT xnrg - FUNC_PRE_INIT SRC: Restart xdrv - FUNC_SET_POWER xlgt - FUNC_SET_CHANNELS xdrv - FUNC_SET_DEVICE_POWER Project tasmota Wemos 2 Version 7.0.0.3(tasmota)-STAGE xdrv - FUNC_INIT xsns - FUNC_INIT I2C: ADS1115 found at 0x48 xdrv - FUNC_LOOP xsns - FUNC_LOOP xdrv - FUNC_EVERY_50_MSECOND xlgt - FUNC_SET_CHANNELS xsns - FUNC_EVERY_50_MSECOND xdrv - FUNC_EVERY_100_MSECOND xsns - FUNC_EVERY_100_MSECOND xdrv - FUNC_EVERY_250_MSECOND xsns - FUNC_EVERY_250_MSECOND xdrv - FUNC_EVERY_SECOND xsns - FUNC_EVERY_SECOND WIF: Attempting connection... WIF: Network (re)scan started... WIF: Attempting connection... WIF: Attempting connection... WIF: Attempting connection... WIF: Network 0, AP1, SSId indebuurt1, Channel 1, BSSId 24:D3:F2:97:C0:A1, RSSI -86, Encryption 1 WIF: Network 1, AP2, SSId indebuurt2, Channel 5, BSSId A0:AB:1B:7D:42:AC, RSSI -42, Encryption 1 WIF: Network 2, AP-, SSId indebuurt3, Channel 12, BSSId 60:E3:27:58:77:E6, RSSI -84, Encryption 1 WIF: Connecting to AP2 indebuurt2 in mode 11N as wemos2... WIF: Attempting connection... WIF: Attempting connection... WIF: Attempting connection... WIF: Connected xdrv - FUNC_WEB_ADD_HANDLER xsns - FUNC_WEB_ADD_HANDLER HTP: Web server active on wemos2 with IP address 192.168.2.191 NTP: Drift 0, (UTC) Wed Nov 06 13:57:08 2019, (DST) Sun Mar 31 02:00:00 2019, (STD) Sun Oct 27 03:00:00 2019 APP: Boot Count 500 MQT: Attempting connection... MQT: Connected MQT: tele/wemos2/LWT = Online (retained) MQT: cmnd/wemos2/POWER = MQT: Subscribe to cmnd/wemos2/# MQT: Subscribe to cmnd/sonoffs/# MQT: Subscribe to cmnd/DVES_15568C_fb/# xdrv - FUNC_MQTT_SUBSCRIBE MQT: tele/wemos2/INFO1 = {\"Module\":\"Generic\",\"Version\":\"7.0.0.3(tasmota)\",\"FallbackTopic\":\"cmnd/DVES_15568C_fb/\",\"GroupTopic\":\"cmnd/sonoffs/\"} MQT: tele/wemos2/INFO2 = {\"WebServerMode\":\"Admin\",\"Hostname\":\"wemos2\",\"IPAddress\":\"192.168.2.191\"} MQT: tele/wemos2/INFO3 = {\"RestartReason\":\"Software/System restart\"} MQT: stat/wemos2/RESULT = {\"POWER1\":\"OFF\"} MQT: stat/wemos2/POWER1 = OFF MQT: stat/wemos2/RESULT = {\"POWER2\":\"ON\"} MQT: stat/wemos2/POWER2 = ON xdrv - FUNC_MQTT_INIT CFG: Saved to flash at FA, Count 1582, Bytes 4096","title":"Basic API information"},{"location":"API/#basic-api-information","text":"Tasmota can easily be extended by developers using provided function pointers as callback Ids. This document lists the available callback function Ids. Read Sensor API for more information. \u00bd Callback availability can be checked by searching for either XdrvCall, XsnsCall, XdspCall, XnrgCall and XlgtCall.","title":"Basic API information"},{"location":"API/#driver-sensor-energy-and-light-callback-ids","text":"The following table lists Callback Ids and their availability for a Driver, Sensor or Energy service. Callback Id Bool xdrv xsns xnrg xlgt Description FUNC_SETTINGS_OVERRIDE x Override start-up settings FUNC_PIN_STATE x 1 2 At GPIO configuration FUNC_MODULE_INIT x 1 2 Init module specific parameters FUNC_PRE_INIT 1 2 Once GPIO have been established FUNC_INIT 1 3 2 At end of initialisation FUNC_LOOP 1 2 In main loop FUNC_EVERY_50_MSECOND 1 2 FUNC_EVERY_100_MSECOND 1 2 FUNC_EVERY_200_MSECOND x FUNC_EVERY_250_MSECOND 1 3 2 FUNC_EVERY_SECOND 1 2 FUNC_SAVE_AT_MIDNIGHT x At midnight FUNC_SAVE_BEFORE_RESTART 2 1 Just before a planned restart FUNC_AFTER_TELEPERIOD 2 1 At end of teleperiod FUNC_JSON_APPEND 2 1 3 Extend teleperiod JSON text FUNC_WEB_SENSOR 2 1 3 Add sensor data to web GUI FUNC_COMMAND x 1 2 3 4 When a command is not recognized FUNC_COMMAND_DRIVER x x When command Driver<id> is executed FUNC_COMMAND_SENSOR x x When command Sensor<id> is executed FUNC_MQTT_SUBSCRIBE x At end of MQTT subscriptions FUNC_MQTT_INIT x Once at end of MQTT connection FUNC_MQTT_DATA x x Before decoding command FUNC_SET_POWER x Before setting relays FUNC_SET_DEVICE_POWER x x Set relay FUNC_SHOW_SENSOR x When FUNC_JSON_APPEND completes FUNC_ANY_KEY x FUNC_ENERGY_EVERY_SECOND x FUNC_ENERGY_RESET x FUNC_RULES_PROCESS x x Process specific rule FUNC_SERIAL x 1 2 3 Process serial data FUNC_FREE_MEM x Show free memory for debugging FUNC_BUTTON_PRESSED x x When a button is pressed FUNC_WEB_ADD_BUTTON 1 2 Add a Configuration Button to GUI FUNC_WEB_ADD_MAIN_BUTTON 1 2 Add a main button to GUI FUNC_WEB_ADD_HANDLER 1 2 Add a webserver handler FUNC_SET_CHANNELS 2 1 FUNC_SET_SCHEME x The numbers represent the sequence of execution","title":"Driver, Sensor, Energy and Light Callback Ids"},{"location":"API/#display-call-back-ids","text":"The following table lists all Callback Ids for a Display service. Callback Id Bool Description FUNC_DISPLAY_INIT_DRIVER FUNC_DISPLAY_INIT FUNC_DISPLAY_EVERY_50_MSECOND FUNC_DISPLAY_EVERY_SECOND FUNC_DISPLAY_MODEL x FUNC_DISPLAY_MODE FUNC_DISPLAY_POWER FUNC_DISPLAY_CLEAR FUNC_DISPLAY_DRAW_FRAME FUNC_DISPLAY_DRAW_HLINE FUNC_DISPLAY_DRAW_VLINE FUNC_DISPLAY_DRAW_LINE FUNC_DISPLAY_DRAW_CIRCLE FUNC_DISPLAY_FILL_CIRCLE FUNC_DISPLAY_DRAW_RECTANGLE FUNC_DISPLAY_FILL_RECTANGLE FUNC_DISPLAY_TEXT_SIZE FUNC_DISPLAY_FONT_SIZE FUNC_DISPLAY_ROTATION FUNC_DISPLAY_DRAW_STRING FUNC_DISPLAY_ONOFF FUNC_DISPLAY_NUMBER * FUNC_DISPLAY_FLOAT * FUNC_DISPLAY_NUMBERNC * FUNC_DISPLAY_FLOATNC * FUNC_DISPLAY_BRIGHTNESS * FUNC_DISPLAY_RAW * FUNC_DISPLAY_LEVEL * FUNC_DISPLAY_SEVENSEG_TEXT * FUNC_DISPLAY_SEVENSEG_TEXTNC * FUNC_DISPLAY_SCROLLDELAY * FUNC_DISPLAY_CLOCK * FUNC_DISPLAY_SCROLLTEXT * * TM1637 driver Only","title":"Display Call back Ids"},{"location":"API/#init-sequence","text":"The following list shows a typical callback init sequence CFG: Loaded from flash at FB, Count 1581 xdrv - FUNC_SETTINGS_OVERRIDE xdrv - FUNC_PIN_STATE xsns - FUNC_PIN_STATE xdrv - FUNC_MODULE_INIT xlgt - FUNC_MODULE_INIT xdrv - FUNC_PRE_INIT xnrg - FUNC_PRE_INIT SRC: Restart xdrv - FUNC_SET_POWER xlgt - FUNC_SET_CHANNELS xdrv - FUNC_SET_DEVICE_POWER Project tasmota Wemos 2 Version 7.0.0.3(tasmota)-STAGE xdrv - FUNC_INIT xsns - FUNC_INIT I2C: ADS1115 found at 0x48 xdrv - FUNC_LOOP xsns - FUNC_LOOP xdrv - FUNC_EVERY_50_MSECOND xlgt - FUNC_SET_CHANNELS xsns - FUNC_EVERY_50_MSECOND xdrv - FUNC_EVERY_100_MSECOND xsns - FUNC_EVERY_100_MSECOND xdrv - FUNC_EVERY_250_MSECOND xsns - FUNC_EVERY_250_MSECOND xdrv - FUNC_EVERY_SECOND xsns - FUNC_EVERY_SECOND WIF: Attempting connection... WIF: Network (re)scan started... WIF: Attempting connection... WIF: Attempting connection... WIF: Attempting connection... WIF: Network 0, AP1, SSId indebuurt1, Channel 1, BSSId 24:D3:F2:97:C0:A1, RSSI -86, Encryption 1 WIF: Network 1, AP2, SSId indebuurt2, Channel 5, BSSId A0:AB:1B:7D:42:AC, RSSI -42, Encryption 1 WIF: Network 2, AP-, SSId indebuurt3, Channel 12, BSSId 60:E3:27:58:77:E6, RSSI -84, Encryption 1 WIF: Connecting to AP2 indebuurt2 in mode 11N as wemos2... WIF: Attempting connection... WIF: Attempting connection... WIF: Attempting connection... WIF: Connected xdrv - FUNC_WEB_ADD_HANDLER xsns - FUNC_WEB_ADD_HANDLER HTP: Web server active on wemos2 with IP address 192.168.2.191 NTP: Drift 0, (UTC) Wed Nov 06 13:57:08 2019, (DST) Sun Mar 31 02:00:00 2019, (STD) Sun Oct 27 03:00:00 2019 APP: Boot Count 500 MQT: Attempting connection... MQT: Connected MQT: tele/wemos2/LWT = Online (retained) MQT: cmnd/wemos2/POWER = MQT: Subscribe to cmnd/wemos2/# MQT: Subscribe to cmnd/sonoffs/# MQT: Subscribe to cmnd/DVES_15568C_fb/# xdrv - FUNC_MQTT_SUBSCRIBE MQT: tele/wemos2/INFO1 = {\"Module\":\"Generic\",\"Version\":\"7.0.0.3(tasmota)\",\"FallbackTopic\":\"cmnd/DVES_15568C_fb/\",\"GroupTopic\":\"cmnd/sonoffs/\"} MQT: tele/wemos2/INFO2 = {\"WebServerMode\":\"Admin\",\"Hostname\":\"wemos2\",\"IPAddress\":\"192.168.2.191\"} MQT: tele/wemos2/INFO3 = {\"RestartReason\":\"Software/System restart\"} MQT: stat/wemos2/RESULT = {\"POWER1\":\"OFF\"} MQT: stat/wemos2/POWER1 = OFF MQT: stat/wemos2/RESULT = {\"POWER2\":\"ON\"} MQT: stat/wemos2/POWER2 = ON xdrv - FUNC_MQTT_INIT CFG: Saved to flash at FA, Count 1582, Bytes 4096","title":"Init sequence"},{"location":"AS3935/","text":"AS3935 Franklin Lightning sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_AS3935 #define USE_AS3935 // [I2cDriver48] Enable AS3935 Franklin Lightning Sensor (I2C address 0x03) (+5k4 code) #endif The AS3935 is a programmable fully integrated Lightning Sensor IC that detects the presence and approach of potentially hazardous lightning activity in the vicinity and provides an estimation on the distance to the head of the storm. The embedded lightning algorithm checks the incoming signal pattern to reject the potential man-made disturbers. Tasmota driver includes: support for all AS3935 Parameters support of all related commands for configuration support of NF-Auto Function to auto Threshold the Noise Reduction support of Auto Disturber support of calibrating the internal OSC with switchable Caps Configuration ~ Wiring ~ AS3935 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy IRQ GPIOz Warning \"Sensor uses a software interrupt. Make sure that the connection with the IRQ pin is stable to prevent flicker.\" Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL GPIOz to AS3935 Note for I 2 C Use You will need to wire up all of the associated pins for the different boards. - Always connect CS and MISO to GND. - If \"SI\" is present, you need to connect to VCC. See some wiring on the Board pictures below. I 2 C wiring After a reboot the driver will detect AS3935 automatically. and in MQTT topic when an Event occurs: {\"Time\":\"2020-01-01T17:07:07\",\"AS3935\":{\"Event\":4,\"Distance\":12,\"Energy\":58622,\"Stage\":1}} Commands and Use ~ Console Commands Description values Bitlength AS3935power Power On/Off the Device 0/1 (On/Off) (1 Bit) AS3935setnf Noise Floor Level value from 0-7 (3 Bit) AS3935setml Minimum number of lightning 1, 5, 9, 16 (2 bit) AS3935default load default for Sensor and Settings no argument AS3935setgain Set Indoor/Outdoor Indoors/Outdoors (Ascii) AS3935settunecaps Internal Tuning Cap. value from 0-15 (4 Bits) AS3935setrej Spike rejection value from 0-15 (4 Bits) AS3935setwdth Watchdog threshold value from 0-15 (4 Bits) AS3935setminstage min stage that could be come with NFautotune value from 0-15: 0-7 Indoors, 8-15 Outdoors (4 Bits) AS3935disturber Set Disturber 0/1 (On/Off) (1 Bit) AS3935autonf Set Auto Tune for Noise Level 0/1 (On/Off) (1 Bit) AS3935autodisturber Set Auto-Disturber 0/1 (On/Off) (1 Bit) AS3935autonfmax Auto Tune with INDOOR and OUTDOOR 0/1 (On/Off) (1 Bit) AS3935lightevent mqtt messages only for lightning events 0/1 (On/Off) (1 Bit) AS3935noirqevent suppress mqtt \"IRQ with no Event\" Messages 0/1 (On/Off) (1 Bit) AS3935settings show all settings no argument AS3935calibrate auto calibrate the internal Capacitors no argument AS3935disttime time for reset Disturber in auto-mode 0-15 min. (4 Bit) AS3935nftime time for auto-Nf treshhold 0-15 min (4 Bit) Note for AS3935Calibrate Normally you don't need the calibrate function. If you buy the AS3935, the module has a sticker on it with the calibrated cap. Use AS3935Settunecaps for setting up this value. if the calibration fails, it is possible that you have a board with the wrong caps on it! (some CJMCU-Boards) Mqtt Events: ~ No. Description Suppress with Command AS3935lightevent Suppress with Command AS3935noirqevent 0 no event 1 Lightning with Distance detected 2 Lightning out of Distance 3 Distance cannot be determined 4 Storm is Overhead 5 Noise level too high * 6 Disturber detected * 7 Irq with no Event detected * 8 Irq Pin flicker detected 9 Device is Powerd Off NF setting table: ~ Setting table of the NF-noise sensitivity and stages: Stages NF-LEV AFE-GB uVrms Sensitivity Stage 0 000 Indoors 28 highly sensitive Stage 1 001 Indoors 45 Stage 2 010 Indoors 62 Stage 3 011 Indoors 78 Stage 4 100 Indoors 95 Stage 5 101 Indoors 112 Stage 6 110 Indoors 130 Stage 7 111 Indoors 146 Stage 8 000 Outdoors 390 Stage 9 001 Outdoors 630 Stage 10 010 Outdoors 860 Stage 11 011 Outdoors 1100 Stage 12 100 Outdoors 1330 Stage 13 101 Outdoors 1570 Stage 14 110 Outdoors 1800 Stage 15 111 Outdoors 2000 less sensitive Hint and Tips take a stabilized power supply. keep a distance of at least 200 mm from the ESP and the AS3395 be careful with \"ready to Use\" devices like Sonoff, etc. they don't have a good power supply inside. use a Ferrit clamp filter on the sensor cable. wire all related Pins for I 2 C use. You can find some troubleshooting tips in the Tasmota GitHub discussion . Breakout Boards and Wiring for I 2 C use: ~ PlayingwithFusion Board: ~ Sparkfun Board V2.0: ~ Embedded Adventures Board: ~ CJMCU Board: ~ GY-AS3935 Board: ~ Breakout Boards Issues: ~ Warning \"Some type of this sensor have wrong capacitors (100pF and 1000pF) installed and the calibration fails. The correct caps are 680pF and 270pF.\" Datasheet: ~ Datasheet from Mouser Web Site","title":"AS3935 Franklin Lightning sensor"},{"location":"AS3935/#as3935-franklin-lightning-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_AS3935 #define USE_AS3935 // [I2cDriver48] Enable AS3935 Franklin Lightning Sensor (I2C address 0x03) (+5k4 code) #endif The AS3935 is a programmable fully integrated Lightning Sensor IC that detects the presence and approach of potentially hazardous lightning activity in the vicinity and provides an estimation on the distance to the head of the storm. The embedded lightning algorithm checks the incoming signal pattern to reject the potential man-made disturbers. Tasmota driver includes: support for all AS3935 Parameters support of all related commands for configuration support of NF-Auto Function to auto Threshold the Noise Reduction support of Auto Disturber support of calibrating the internal OSC with switchable Caps","title":"AS3935 Franklin Lightning sensor"},{"location":"AS3935/#configuration","text":"","title":"Configuration"},{"location":"AS3935/#wiring","text":"AS3935 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy IRQ GPIOz Warning \"Sensor uses a software interrupt. Make sure that the connection with the IRQ pin is stable to prevent flicker.\"","title":"Wiring"},{"location":"AS3935/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL GPIOz to AS3935 Note for I 2 C Use You will need to wire up all of the associated pins for the different boards. - Always connect CS and MISO to GND. - If \"SI\" is present, you need to connect to VCC. See some wiring on the Board pictures below. I 2 C wiring After a reboot the driver will detect AS3935 automatically. and in MQTT topic when an Event occurs: {\"Time\":\"2020-01-01T17:07:07\",\"AS3935\":{\"Event\":4,\"Distance\":12,\"Energy\":58622,\"Stage\":1}}","title":"Tasmota Settings"},{"location":"AS3935/#commands-and-use","text":"Console Commands Description values Bitlength AS3935power Power On/Off the Device 0/1 (On/Off) (1 Bit) AS3935setnf Noise Floor Level value from 0-7 (3 Bit) AS3935setml Minimum number of lightning 1, 5, 9, 16 (2 bit) AS3935default load default for Sensor and Settings no argument AS3935setgain Set Indoor/Outdoor Indoors/Outdoors (Ascii) AS3935settunecaps Internal Tuning Cap. value from 0-15 (4 Bits) AS3935setrej Spike rejection value from 0-15 (4 Bits) AS3935setwdth Watchdog threshold value from 0-15 (4 Bits) AS3935setminstage min stage that could be come with NFautotune value from 0-15: 0-7 Indoors, 8-15 Outdoors (4 Bits) AS3935disturber Set Disturber 0/1 (On/Off) (1 Bit) AS3935autonf Set Auto Tune for Noise Level 0/1 (On/Off) (1 Bit) AS3935autodisturber Set Auto-Disturber 0/1 (On/Off) (1 Bit) AS3935autonfmax Auto Tune with INDOOR and OUTDOOR 0/1 (On/Off) (1 Bit) AS3935lightevent mqtt messages only for lightning events 0/1 (On/Off) (1 Bit) AS3935noirqevent suppress mqtt \"IRQ with no Event\" Messages 0/1 (On/Off) (1 Bit) AS3935settings show all settings no argument AS3935calibrate auto calibrate the internal Capacitors no argument AS3935disttime time for reset Disturber in auto-mode 0-15 min. (4 Bit) AS3935nftime time for auto-Nf treshhold 0-15 min (4 Bit) Note for AS3935Calibrate Normally you don't need the calibrate function. If you buy the AS3935, the module has a sticker on it with the calibrated cap. Use AS3935Settunecaps for setting up this value. if the calibration fails, it is possible that you have a board with the wrong caps on it! (some CJMCU-Boards)","title":"Commands and Use"},{"location":"AS3935/#mqtt-events","text":"No. Description Suppress with Command AS3935lightevent Suppress with Command AS3935noirqevent 0 no event 1 Lightning with Distance detected 2 Lightning out of Distance 3 Distance cannot be determined 4 Storm is Overhead 5 Noise level too high * 6 Disturber detected * 7 Irq with no Event detected * 8 Irq Pin flicker detected 9 Device is Powerd Off","title":"Mqtt Events:"},{"location":"AS3935/#nf-setting-table","text":"Setting table of the NF-noise sensitivity and stages: Stages NF-LEV AFE-GB uVrms Sensitivity Stage 0 000 Indoors 28 highly sensitive Stage 1 001 Indoors 45 Stage 2 010 Indoors 62 Stage 3 011 Indoors 78 Stage 4 100 Indoors 95 Stage 5 101 Indoors 112 Stage 6 110 Indoors 130 Stage 7 111 Indoors 146 Stage 8 000 Outdoors 390 Stage 9 001 Outdoors 630 Stage 10 010 Outdoors 860 Stage 11 011 Outdoors 1100 Stage 12 100 Outdoors 1330 Stage 13 101 Outdoors 1570 Stage 14 110 Outdoors 1800 Stage 15 111 Outdoors 2000 less sensitive Hint and Tips take a stabilized power supply. keep a distance of at least 200 mm from the ESP and the AS3395 be careful with \"ready to Use\" devices like Sonoff, etc. they don't have a good power supply inside. use a Ferrit clamp filter on the sensor cable. wire all related Pins for I 2 C use. You can find some troubleshooting tips in the Tasmota GitHub discussion .","title":"NF setting table:"},{"location":"AS3935/#breakout-boards-and-wiring-for-i2c-use","text":"","title":"Breakout Boards and Wiring for I2C use:"},{"location":"AS3935/#breakout-boards-issues","text":"Warning \"Some type of this sensor have wrong capacitors (100pF and 1000pF) installed and the calibration fails. The correct caps are 680pF and 270pF.\"","title":"Breakout Boards Issues:"},{"location":"AS3935/#datasheet","text":"Datasheet from Mouser Web Site","title":"Datasheet:"},{"location":"AWS-IoT-cert/","text":"This page contains deprecated information. We advise to use the AWS IoT password based authentication . New simplified and automated configuration We now provide easy to use AWS CloudFormation templates to generate the private key and sign the certificate. The manual method is now in Appendix This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #define USE_MQTT_TLS_CA_CERT // Optional but highly recommended #endif #ifndef USE_MQTT_AWS_IOT #define USE_MQTT_AWS_IOT #endif #ifdef USE_DISCOVERY #undef USE_DISCOVERY #endif As of Tasmota version 6.6.0.3, the device-specific credentials are no longer restricted to being set at compile time only. You can now use the same firmware for all your devices. AWS IoT credentials can be set through the Console at runtime and are stored in flash memory. Credentials will survive firmware updates and OTA. Credentials will not survive a full Flash reset Reset 5 or Reset 6 nor will it survive a System Parameter Flash reset Reset 3 Benefits ~ AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS. 1. More Alexa controls ~ It's actually easy to develop smarthome Alexa skills, so that you can control your whole house. Currently you can only use the local Philips Hue/Wemo emulation - limited to lights and switches. You can imagine for instance controlling your Sonoff RF Bridge and send IR codes to your TV. Alexa skills need to communicate back to your devices, which is easy using MQTT and AWS IoT 2. No need for a local gateway ~ Of course you can do it with a local gateway like Raspberry PI using many of the open-source solutions (Domoticz...). You can also do it entirely from the cloud without the hassle of managing and updating a local gateway. On top of it, AWS IoT provides tools to collect and archive your data, automate (AWS IoT things). Maximum security ~ Keep in mind that AWS IoT is based with 'security first' in mind. All the data in AWS IoT is your data and is not shared with anyone else. Communication is done over TLS 1.2 tunnels, using client certificates to authenticate each device. Up to now it was challenging to enable TLS on ESP8266 because of the high memory requirements of TLS. Thanks to the switch of Arduino to BearSSL and aggressive optimization, the amount of memory needed is as low as 6.0k during normal operation, and an additional 6.6k during connection (TLS handshake). This makes it totally doable with standard 'Tasmota' firmware with Web and Hue emulation activated. You should see more than 20k of memory still available. Caveats ~ AWS IoT requires each Tasmota device to have its own distinct Private Key and Certificate (~800 bytes). Although you could imagine to use the same Private Key in all your devices, this is considered as a very bad practice. You are warned! During TLS handshake, a secondary stack of 5.3k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes. Cost ~ AWS provides a Free Tier that allows you to use some services for free up to a specific level. For example, it allows you to have 50 devices connecting 24 hours a day exchanging 300 messages per day. For a typical house, there is a good chance the service costs you nothing (the first year). How to configure? ~ AWS IoT requires a distinct Private Key and Certificate per Tasmota device. Currently you need to custom compile your Tasmota firmware and burn the Key and Certificate in your firmware. We will later explore how to configure them separately. Here is a simple guide. 0. Open an AWS Account ~ If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/ 1. Prerequisites ~ You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl 2. Enable AWS IoT in Tasmota ~ Using your favorite IDE, create user_config_override.h and add the required compilation directives as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate. 3. Flash your device ~ Flash your device the normal way; either through serial or OTA. If you use OTA, first flash a sonoff-minimal firmware, then your target firmware. 4. Configure AWS IoT Policy (to be done once) ~ Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template Tasmota-MqttPolicy and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . At the Configure stack options screen, keep all default parameters and click Next . At the Review TasmotaMqttPolicy screen, scroll down and click Create Stack . The stack usually takes less than 2 minutes to complete. Wait for it to reach CREATE_COMPLETE state. If you have left the parameter RetentionPolicy to Retain , then you can delete this CloudFormation stack (it will not delete the Policy). Click on the Delete button. After less than 2 minutes, the stack should have reached the state DELETE_COMPLETE 5. Create an AWS IoT Thing with Private Key and Certificate (once per Tasmota device) ~ The provided AWS CloudFormation template will create the required resources to create: One AWS IoT Thing One Private key One Certificate signed by AWS IoT Temporary resources (AWS Lambda functions, AWS IAM resources) that you can delete once the Tasmota thing is created. Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template Tasmota-Thing and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . Note: you can change the name of the Thing in AWS IoT by specifying the parameter ThingParamName. At the Configure stack options screen, keep all default parameters and click Next . At the Review Tasmota-91 screen, scroll down, check the box I acknowledge that AWS CloudFormation might create IAM resources. and click Create Stack . The stack usually takes less than 4 minutes to complete. Wait for it to reach CREATE_COMPLETE state. You need to copy & paste the contents of the Outputs tab of the CloudFormation stack: MqttHost , TlsKey1 , TlsKey2 Keep a copy of those parameters in a file, you might need them again. Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain . 6. Configure Tasmota device ~ This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. We will only cut and paste parameters from the Outputs tab of the CloudFormation console. Configure the AWS EndPoint ~ Copy and paste in the web console the content of MqttHost Example: Backlog MqttHost <your_endpoint>-ats.iot.eu-central-1.amazonaws.com; MqttPort 8883 This will trigger a reboot of the device. Optional, change the topic to distinguish the devices from each others: Topic sonoff/Tasmota-01 Check that the key store is empty ~ Type the following command: TLSKey hh:mm:ss CMD: TLSKey hh:mm:ss MQT: stat/<topic>/RESULT = {\"TLSKey1\":-1,\"TLSKey2\":-1} If both values are -1 , it means it does not contain any key. If you need to reset the key store, use the command TLSKey 0 . Configure the Private Key and Certificate ~ AWS IoT credentials are composed of two distinct parts, first a Private Key - this is the secret that will allow your device to prove it is who it pretends to be. Consider this as sensitive as a password. The Private Key is exactly 32 bytes (256 bits). The second part is the Certificate delivered by AWS IoT. Tasmota will also need it to authenticate to the AWS IoT endpoint. Both credentials must be stored in Tasmota Flash memory, in that order, using the new TLSKey command. TlsKey1 stores the Private Key. TlsKey2 stores the Certificate. There is no command to retrieve the private key from a Tasmota device, but keep in mind this secret information can easily be dumped via Serial if somebody gets physical access to the device (ESP8266 does not contain any secure storage area). Simply Copy and Paste the two commands from TlsKey1 and TlsKey2 . TLSKey1 <secret_key_secret_key_secret_key>= TLSKey2 MIIC<certificate_very_long_string>= TLSKey1 and TLSKey2 must be entered in that order. If successful, you should see a message similar to: hh:mm:ss MQT: stat/<topic>/RESULT = {\"TLSKey1\":32,\"TLSKey2\":641} You need to check that both values are not \"-1\". The value for \"TLSKey1\" should always be 32. The value for \"TLSKey2\" varies depending on several parameters, and should be within the 640-700 bytes range. Connect to AWS IoT ~ Once the TLSKey1 and TLSKey2 are entered, Tasmota will try to connect to AWS IoT. Keep in mind that AWS IoT does not support 'retained' messages. Whatever the 'retained' configuration in Tasmota, messages are always published as 'retained=false'. Here is an example of output you should see: 00:00:04 HTP: Web server active on sonoff-4585 with IP address 192.168.1.59 00:00:04 UPP: Multicast (re)joined 21:28:25 MQT: Attempting connection... 21:28:25 MQT: AWS IoT endpoint: xxxxxxxxxxxxx-ats.iot.eu-central-1.amazonaws.com 21:28:26 MQT: AWS IoT connected in 1279 ms 21:28:26 MQT: Connected 21:28:26 MQT: tele/tasmota/LWT = Online 21:28:26 MQT: cmnd/tasmota/POWER = 21:28:26 MQT: tele/tasmota/INFO1 = {\"Module\":\"Sonoff Basic\",\"Version\":\"6.5.0.14(sonoff)\",\"FallbackTopic\": \"cmnd/DVES_67B1E9_fb/\",\"GroupTopic\":\"sonoffs\"} 7. Check end-to-end communication ~ In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy! 8. Cleaning ~ Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain . 9. Troubleshooting ~ TLSError shows any error at the TLS level. See here for most common error codes. For implementation details, see here ~ Appendix: Manual configuration ~ 1. Prerequisites ~ You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl 2. Configure AWS IoT (to be done once) ~ Open the AWS Console. Click on \" Services \" and select \" IoT Core \". Select the AWS Region where you want to locate your data, for ex: \" (EU) Frankfurt \". Now we need to create a security policy to allow your Tasmota devices to connect to AWS IoT, publish and subscribe to topics. On the left panel, click on \" Secure \" > \" Policies \". Click on the \" Create \" button in the upper right corner. Enter in the \" Name \" field, enter the name of your policy, for ex: \" TasmotaMqttPolicy \". Then click on \" Advanced mode \" Cut and paste the policy below. Click on \" Create \" in the lower right corner. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Connect\", \"iot:Publish\", \"iot:Subscribe\", \"iot:Receive\" ], \"Resource\": \"*\" } ] } 3. Create a Private Key and Certificate (once per Tasmota device) ~ Do not use the default AWS IoT feature to generate your private key online. It creates a 2048 bits RSA key. Instead we are using elliptic curves keys - they are much smaller in memory than RSA keys (this saves ~1k of memory) and the handshake is significantly faster. First create an ECC private key for your device (as described in this Blog ). Keep you private key in a safe place. $ openssl ecparam -name prime256v1 -genkey -out tasmota-01.key Next, using this private key, create a certificate signing request (CSR). When asked enter the certificate details. This is not really used later, you can just enter a 2 letters country code like \" EU \" and leave all other fields blank (type 8 times enter). $ openssl req -new -sha256 -key tasmota-01.key -nodes -out tasmota-01.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) []:EU <enter> State or Province Name (full name) []: <enter> Locality Name (eg, city) []: <enter> Organization Name (eg, company) []: <enter> Organizational Unit Name (eg, section) []: <enter> Common Name (eg, fully qualified host name) []: <enter> Email Address []: <enter> Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: <enter> Next ask AWS IoT to sign your key with its certificate. On the left panel, click on \" Secure \" > \" Certificates \". Click on \" Create a certificate \". Then choose the \" Create with CSR \" button, locate your CSR file from above. Click on \" Upload file \". Download the certificate file, click on \" Download \", save the file as \" tasmota-01.cert.pem \". Important : don't forget to click on the \" Activate \" to activate the certificate. Your Private Key and Certificates are ready to use. Now we need to register the Tasmota Device. 4. Write down your AWS IoT endpoint (same for all devices) ~ Click on \" Settings \" in the left panel. You should see a field called \" Custom endpoint \". Write down the endpoint domain name. It should look like this (if you have chosen the Frankfurt region: <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com This is your MQTT endpoint, the port is 8883 - MQTT over TLS. 5. Register the device in AWS IoT (once per Tasmota device) ~ Now on the left pane, click on \" Manage \" > \" Things \". Click on \" Register a thing \", then \" Create a single thing \". Give your device a name like \" Tasmota-01 \". Scroll down and click \" Next \" at the botton right. Then click on \" Create thing without a certificate \". Now we need to associate the certificate created earlier to your device. In the left panel, click back on \" Secure \" > \" Certificates \". Select the certificate created earlier. In the next pane, click on \" Actions \" in the upper right part. First select \" Attach policy \", check \" TasmotaMqttPolicy \" and \" Attach \". Click again on \" Actions \" and select \" Attach thing \", check \" Tasmota-01 \" and \" Attach \". Your setup is done in AWS IoT. Let's proceed to the custom firmware. 8. Prepare your AWS IoT credentials ~ You will now need to convert your AWS IoT credentials to Tasmota commands. Credentials are composed of two distinct parts, first a Private Key - this is the secret that will allow your device to prove it is who it pretends to be. Consider this as sensitive as a password. The Private Key is exactly 32 bytes (256 bits). The second part is the Certificate delivered by AWS IoT. Tasmota will also need it to authenticate to the AWS IoT endpoint. Both credentials must be stored in Tasmota Flash memory, in that order, using the new TLSKey command. a. First check that the key store is empty ~ Type the following command: TLSKey hh:mm:ss CMD: TLSKey hh:mm:ss MQT: stat/tasmota/RESULT = {\"TLSKey1\":-1,\"TLSKey2\":-1} If both values are -1 , it means it does not contain any key. If you need to reset the key store, use the command TLSKey 0 . b. Convert the Private Key ~ We will extract the 32 bytes Private key from tasmota-01.key generated above. 1-line method, use the following command: (fake key below) openssl ec -in tasmota-01.key -inform PEM -outform DER | openssl asn1parse -inform DER | head -3 | tail -1 | awk -F':' '{ print $4 }' | xxd -r -p | base64 | echo \"TLSKey1 $(</dev/stdin)\" Example: openssl ec -in tasmota-01.key -inform PEM -outform DER | openssl asn1parse -inform DER | head -3 | tail -1 | awk -F':' '{ print $4 }' | xxd -r -p | base64 | echo \"TLSKey1 $(</dev/stdin)\" read EC key writing EC key TLSKey1 UvBgyCuPr/lKSgwumf/8o/mIsKQPBHn3ZZAGZl4ui9E= Cut and paste the command starting with TLSKey1 ... into the Tasmota Web Console or through MQTT. hh:mm:ss CMD: TLSKey1 UvBgyCuPr/lKSgwumf/8o/mIsKQPBHn3ZZAGZl4ui9E= hh:mm:ss MQT: stat/tasmota/RESULT = {\"TLSKey1\":32,\"TLSKey2\":-1} Alternative method: Convert the Private Key file from PEM to DER (binary format): openssl ec -in tasmota-01.key -inform PEM -outform DER -out tasmota-01.key.der Dump the ASN.1 format from the DER file: openssl asn1parse -inform DER -in tasmota-01.key.der 0:d=0 hl=2 l= 119 cons: SEQUENCE 2:d=1 hl=2 l= 1 prim: INTEGER :01 5:d=1 hl=2 l= 32 prim: OCTET STRING [HEX DUMP]:52F060C82B8FAFF94A4A0C2E99FFFCA3F988B0A40F0479F7659006665E2E8BD1 39:d=1 hl=2 l= 10 cons: cont [ 0 ] 41:d=2 hl=2 l= 8 prim: OBJECT :prime256v1 51:d=1 hl=2 l= 68 cons: cont [ 1 ] 53:d=2 hl=2 l= 66 prim: BIT STRING Then convert the byte stream after [HEX DUMP] to base64 and use it with the TLSKey1 command. c. Convert the Certificate ~ Similarly you will need to convert the file \" tasmota-01.cert.pem \" generated above to a Tasmota command. 1-line version, use the following command: openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER | base64 | echo \"TLSKey2 $(</dev/stdin)\" Example: (fake certificate) openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER | base64 | echo \"TLSKey2 $(</dev/stdin)\" TLSKey2 MIICfTCCAWWgAwIBAgIUMPd6KefJYqwIHxzgCk1kEXIjHhkwDQYJKoZIhvcNAQELBQAwTTFLMEkGA1UECwxCQW1hem9uIFdlYiBTZXJ2aWNlcyBPPUFtYXpvbi5jb20gSW5jLiBMPVNlYXR0bGUgU1Q9V2FzaGluZ3RvbiBDPVVTMB4XDTE5MDgwNDE5MjI1NVoXDTQ5MTIzMTIzNTk1OVowDTELMAkGA1UEBhMCRVUwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASCzFZFhPXBbr6G6gbhT/rGXROhN5AHdwhxfpY55xi3c1W3TBuvUdZYdU2Urc9t4ces9Nz3UcF1xfMBvIpVqMVco2AwXjAfBgNVHSMEGDAWgBT3n7seZ1eHUIcZCcuwn0fkEad77TAdBgNVHQ4EFgQUUruspk3ohBJB8buA8qq9kQIZUs0wDAYDVR0TAQH/BAIwADAOBgNVHQ8BAf8EBAMCB4AwDQYJKoZIhvcNAQELBQADggEBAFPKpVjaowYY3taAcKsSxfwkwzglI2eUlnmSdnu6WZkNEdiYpx8QVYb+miJnIyTVaE3bzkTr4PvObwf4Vs92uMtIQ5BuU1lj8EdfsZAs6uA1rqfQIl0n7ty3bErtVb3d+uUBm4C1b9mtbQS45itfrTvzWEoLuWflUxAFqyYVmNPNHTfPFLjAP9dcpWk+388pRl3jkGo1qiFrEp+ucQMtkqwn3lfVXlRFuGY6GxKg2lBWvqW5CuHaBhFjeT63pqUmjj76VrBk/Vp9BMjIJ3a1omuW3ZUGCPdXUVqj4/m2pXoYIGW7l/fZpfV4piKOW1tcxeX/iBdgPUL1XUMbCtBybbc= Copy and paste the last line starting with TLSKey2 ... into the Web Tasmota Console or through MQTT. Note: you cannot use this command through Serial, it is bigger than the max serial buffer (520 bytes). hh:mm:ss CMD: TLSKey2 MIICfTCCAWWgAwIBAgIUMPd6KefJYqwIHxzgCk1kEXIjHhkwDQYJKoZIhvcNAQELBQAwTTFLMEkGA1UECwxCQW1hem9uIFdlYiBTZXJ2aWNlcyBPPUFtYXpvbi5jb20gSW5jLiBMPVNlYXR0bGUgU1Q9V2FzaGluZ3RvbiBDPVVTMB4XDTE5MDgwNDE5MjI1NVoXDTQ5MTIzMTIzNTk1OVowDTELMAkGA1UEBhMCRVUwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASCzFZFhPXBbr6G6gbhT/rGXROhN5AHdwhxfpY55xi3c1W3TBuvUdZYdU2Urc9t4ces9Nz3UcF1xfMBvIpVqMVco2AwXjAfBgNVHSMEGDAWgBT3n7seZ1eHUIcZCcuwn0fkEad77TAdBgNVHQ4EFgQUUruspk3ohBJB8buA8qq9kQIZUs0wDAYDVR0TAQH/BAIwADAOBgNVHQ8BAf8EBAMCB4AwDQYJKoZIhvcNAQELBQ hh:mm:ss MQT: stat/tasmota/IR2/RESULT = {\"TLSKey1\":32,\"TLSKey2\":641} You need to check that both values are not \"-1\". The value for \"TLSKey1\" should always be 32. The value for \"TLSKey2\" varies depending on several parameters, and should be within the 640-700 bytes range. Alternative version: Convert your certificate from PEM to DER (binary) format: openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER -out tasmota-01.cert.der Then convert the Certificate to plain base64 in a single line (use -A flag): openssl base64 -e -in tasmota-01.cert.der -A -out tasmota-01.cert.b64 Then use the command TSLKey2 <base64> and replace <base64> with the content of tasmota-01.cert.b64 .","title":"AWS IoT cert"},{"location":"AWS-IoT-cert/#benefits","text":"AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS.","title":"Benefits"},{"location":"AWS-IoT-cert/#caveats","text":"AWS IoT requires each Tasmota device to have its own distinct Private Key and Certificate (~800 bytes). Although you could imagine to use the same Private Key in all your devices, this is considered as a very bad practice. You are warned! During TLS handshake, a secondary stack of 5.3k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes.","title":"Caveats"},{"location":"AWS-IoT-cert/#how-to-configure","text":"AWS IoT requires a distinct Private Key and Certificate per Tasmota device. Currently you need to custom compile your Tasmota firmware and burn the Key and Certificate in your firmware. We will later explore how to configure them separately. Here is a simple guide.","title":"How to configure?"},{"location":"AWS-IoT-cert/#0-open-an-aws-account","text":"If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/","title":"0. Open an AWS Account"},{"location":"AWS-IoT-cert/#1-prerequisites","text":"You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl","title":"1. Prerequisites"},{"location":"AWS-IoT-cert/#2-enable-aws-iot-in-tasmota","text":"Using your favorite IDE, create user_config_override.h and add the required compilation directives as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate.","title":"2. Enable AWS IoT in Tasmota"},{"location":"AWS-IoT-cert/#3-flash-your-device","text":"Flash your device the normal way; either through serial or OTA. If you use OTA, first flash a sonoff-minimal firmware, then your target firmware.","title":"3. Flash your device"},{"location":"AWS-IoT-cert/#4-configure-aws-iot-policy-to-be-done-once","text":"Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template Tasmota-MqttPolicy and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . At the Configure stack options screen, keep all default parameters and click Next . At the Review TasmotaMqttPolicy screen, scroll down and click Create Stack . The stack usually takes less than 2 minutes to complete. Wait for it to reach CREATE_COMPLETE state. If you have left the parameter RetentionPolicy to Retain , then you can delete this CloudFormation stack (it will not delete the Policy). Click on the Delete button. After less than 2 minutes, the stack should have reached the state DELETE_COMPLETE","title":"4. Configure AWS IoT Policy (to be done once)"},{"location":"AWS-IoT-cert/#5-create-an-aws-iot-thing-with-private-key-and-certificate-once-per-tasmota-device","text":"The provided AWS CloudFormation template will create the required resources to create: One AWS IoT Thing One Private key One Certificate signed by AWS IoT Temporary resources (AWS Lambda functions, AWS IAM resources) that you can delete once the Tasmota thing is created. Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template Tasmota-Thing and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . Note: you can change the name of the Thing in AWS IoT by specifying the parameter ThingParamName. At the Configure stack options screen, keep all default parameters and click Next . At the Review Tasmota-91 screen, scroll down, check the box I acknowledge that AWS CloudFormation might create IAM resources. and click Create Stack . The stack usually takes less than 4 minutes to complete. Wait for it to reach CREATE_COMPLETE state. You need to copy & paste the contents of the Outputs tab of the CloudFormation stack: MqttHost , TlsKey1 , TlsKey2 Keep a copy of those parameters in a file, you might need them again. Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain .","title":"5. Create an AWS IoT Thing with Private Key and Certificate (once per Tasmota device)"},{"location":"AWS-IoT-cert/#6-configure-tasmota-device","text":"This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. We will only cut and paste parameters from the Outputs tab of the CloudFormation console.","title":"6. Configure Tasmota device"},{"location":"AWS-IoT-cert/#7-check-end-to-end-communication","text":"In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy!","title":"7. Check end-to-end communication"},{"location":"AWS-IoT-cert/#8-cleaning","text":"Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain .","title":"8. Cleaning"},{"location":"AWS-IoT-cert/#9-troubleshooting","text":"TLSError shows any error at the TLS level. See here for most common error codes.","title":"9. Troubleshooting"},{"location":"AWS-IoT-cert/#for-implementation-details-see-here","text":"","title":"For implementation details, see here"},{"location":"AWS-IoT-cert/#appendix-manual-configuration","text":"","title":"Appendix: Manual configuration"},{"location":"AWS-IoT-cert/#1-prerequisites_1","text":"You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl","title":"1. Prerequisites"},{"location":"AWS-IoT-cert/#2-configure-aws-iot-to-be-done-once","text":"Open the AWS Console. Click on \" Services \" and select \" IoT Core \". Select the AWS Region where you want to locate your data, for ex: \" (EU) Frankfurt \". Now we need to create a security policy to allow your Tasmota devices to connect to AWS IoT, publish and subscribe to topics. On the left panel, click on \" Secure \" > \" Policies \". Click on the \" Create \" button in the upper right corner. Enter in the \" Name \" field, enter the name of your policy, for ex: \" TasmotaMqttPolicy \". Then click on \" Advanced mode \" Cut and paste the policy below. Click on \" Create \" in the lower right corner. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Connect\", \"iot:Publish\", \"iot:Subscribe\", \"iot:Receive\" ], \"Resource\": \"*\" } ] }","title":"2. Configure AWS IoT (to be done once)"},{"location":"AWS-IoT-cert/#3-create-a-private-key-and-certificate-once-per-tasmota-device","text":"Do not use the default AWS IoT feature to generate your private key online. It creates a 2048 bits RSA key. Instead we are using elliptic curves keys - they are much smaller in memory than RSA keys (this saves ~1k of memory) and the handshake is significantly faster. First create an ECC private key for your device (as described in this Blog ). Keep you private key in a safe place. $ openssl ecparam -name prime256v1 -genkey -out tasmota-01.key Next, using this private key, create a certificate signing request (CSR). When asked enter the certificate details. This is not really used later, you can just enter a 2 letters country code like \" EU \" and leave all other fields blank (type 8 times enter). $ openssl req -new -sha256 -key tasmota-01.key -nodes -out tasmota-01.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) []:EU <enter> State or Province Name (full name) []: <enter> Locality Name (eg, city) []: <enter> Organization Name (eg, company) []: <enter> Organizational Unit Name (eg, section) []: <enter> Common Name (eg, fully qualified host name) []: <enter> Email Address []: <enter> Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: <enter> Next ask AWS IoT to sign your key with its certificate. On the left panel, click on \" Secure \" > \" Certificates \". Click on \" Create a certificate \". Then choose the \" Create with CSR \" button, locate your CSR file from above. Click on \" Upload file \". Download the certificate file, click on \" Download \", save the file as \" tasmota-01.cert.pem \". Important : don't forget to click on the \" Activate \" to activate the certificate. Your Private Key and Certificates are ready to use. Now we need to register the Tasmota Device.","title":"3. Create a Private Key and Certificate (once per Tasmota device)"},{"location":"AWS-IoT-cert/#4-write-down-your-aws-iot-endpoint-same-for-all-devices","text":"Click on \" Settings \" in the left panel. You should see a field called \" Custom endpoint \". Write down the endpoint domain name. It should look like this (if you have chosen the Frankfurt region: <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com This is your MQTT endpoint, the port is 8883 - MQTT over TLS.","title":"4. Write down your AWS IoT endpoint (same for all devices)"},{"location":"AWS-IoT-cert/#5-register-the-device-in-aws-iot-once-per-tasmota-device","text":"Now on the left pane, click on \" Manage \" > \" Things \". Click on \" Register a thing \", then \" Create a single thing \". Give your device a name like \" Tasmota-01 \". Scroll down and click \" Next \" at the botton right. Then click on \" Create thing without a certificate \". Now we need to associate the certificate created earlier to your device. In the left panel, click back on \" Secure \" > \" Certificates \". Select the certificate created earlier. In the next pane, click on \" Actions \" in the upper right part. First select \" Attach policy \", check \" TasmotaMqttPolicy \" and \" Attach \". Click again on \" Actions \" and select \" Attach thing \", check \" Tasmota-01 \" and \" Attach \". Your setup is done in AWS IoT. Let's proceed to the custom firmware.","title":"5. Register the device in AWS IoT (once per Tasmota device)"},{"location":"AWS-IoT-cert/#8-prepare-your-aws-iot-credentials","text":"You will now need to convert your AWS IoT credentials to Tasmota commands. Credentials are composed of two distinct parts, first a Private Key - this is the secret that will allow your device to prove it is who it pretends to be. Consider this as sensitive as a password. The Private Key is exactly 32 bytes (256 bits). The second part is the Certificate delivered by AWS IoT. Tasmota will also need it to authenticate to the AWS IoT endpoint. Both credentials must be stored in Tasmota Flash memory, in that order, using the new TLSKey command.","title":"8. Prepare your AWS IoT credentials"},{"location":"AWS-IoT/","text":"Tip New simplified configuration, since AWS IoT doesn't require private certificates anymore and can use password authentication. Requires v8.5.0.1 or higher. The certificate based authentication is kept for reference. New simplified and automated configuration We now provide easy to use AWS CloudFormation templates to generate the private key and sign the certificate. The manual method is now in Appendix This feature is not included in precompiled binaries, except tasmota-zbbridge To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #define USE_MQTT_TLS_CA_CERT // Optional but highly recommended #endif #ifndef USE_MQTT_AWS_IOT_LIGHT #define USE_MQTT_AWS_IOT_LIGHT #endif #ifdef USE_DISCOVERY #undef USE_DISCOVERY #endif As of Tasmota version 8.5.0.1, device-specific private key and certificate are no more required. We introduces AWS_IOT_LIGHT to use password based authentication. Legacy private certificate authentication can be found here . Benefits ~ AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS. 1. More Alexa controls ~ It's actually easy to develop smarthome Alexa skills, so that you can control your whole house. Currently you can only use the local Philips Hue/Wemo emulation - limited to lights and switches. You can imagine for instance controlling your Sonoff RF Bridge and send IR codes to your TV. Alexa skills need to communicate back to your devices, which is easy using MQTT and AWS IoT 2. No need for a local gateway ~ Of course you can do it with a local gateway like Raspberry PI using many of the open-source solutions (Domoticz...). You can also do it entirely from the cloud without the hassle of managing and updating a local gateway. On top of it, AWS IoT provides tools to collect and archive your data, automate (AWS IoT things). Maximum security ~ Keep in mind that AWS IoT is based with 'security first' in mind. All the data in AWS IoT is your data and is not shared with anyone else. Communication is done over TLS 1.2 tunnels. Thanks to the switch of Arduino to BearSSL and aggressive optimization, the amount of memory needed is as low as 6.0k during normal operation, and an additional 6.6k during connection (TLS handshake). This makes it totally doable with standard 'Tasmota' firmware with Web and Hue emulation activated. You should see more than 20k of memory still available. Caveats ~ During TLS handshake, a secondary stack of 4.8k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes. Cost ~ AWS provides a Free Tier that allows you to use some services for free up to a specific level. For example, it allows you to have 50 devices connecting 24 hours a day exchanging 300 messages per day. For a typical house, there is a good chance the service costs you nothing (the first year). How to configure? ~ AWS IoT now works with Password authentication. Although it is not a good practice to use the same password for all your devices, it is technically working and the easiest way to start with Tasmota and AWS IoT. Here is a simple guide. 0. Open an AWS Account ~ If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/ 1. Prerequisites ~ You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) 2. Enable AWS IoT in Tasmota ~ Add the required compilation directives to user_config_override.h as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate. 3. Flash your device ~ Flash your device the normal way; either through serial or OTA. 4. Configure AWS IoT Policy (to be done once) ~ Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template TasmotaAuth and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . At the Configure stack options screen, keep all default parameters and click Next . At the Review TasmotaMqttPolicy screen, scroll down and click Create Stack . The stack usually takes less than 1 minute to complete. Wait for it to reach CREATE_COMPLETE state. Copy the commands under BackLogCommand , you will need it to configure Tasmota devices. If you have left the parameter RetentionPolicy to Retain , then you can delete this CloudFormation stack (it will not delete the Policy). Click on the Delete button. After less than 2 minutes, the stack should have reached the state DELETE_COMPLETE 6. Configure Tasmota device ~ This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. We will only cut and paste parameters from the Outputs tab of the CloudFormation console. Example: BackLog SetOption3 1; SetOption103 1; MqttHost a............u-ats.iot.eu-central-1.amazonaws.com; MqttPort 443; MqttUser tasmota?x-amz-customauthorizer-name=TasmotaAuth; MqttPassword YknLuSd2tBY2HodwI/7RqA== 11:28:44 CMD: BackLog SetOption3 1; SetOption103 1; MqttHost a............u-ats.iot.eu-central-1.amazonaws.com; MqttPort 443; MqttUser tasmota?x-amz-customauthorizer-name=TasmotaAuth; MqttPassword YknLuSd2tBY2HodwI/7RqA== 11:28:44 MQT: stat/tasmota_4B3316/RESULT = {\"SetOption3\":\"ON\"} 11:28:44 MQT: stat/tasmota_4B3316/RESULT = {\"SetOption103\":\"ON\"} 11:28:45 MQT: stat/tasmota_4B3316/RESULT = {\"MqttHost\":\"a...........u-ats.iot.eu-central-1.amazonaws.com\"} 11:28:45 MQT: stat/tasmota_4B3316/RESULT = {\"MqttPort\":443} 11:28:45 MQT: stat/tasmota_4B3316/RESULT = {\"MqttUser\":\"tasmota?x-amz-customauthorizer-name=TasmotaAuth\"} 11:28:45 MQT: stat/tasmota_4B3316/RESULT = {\"MqttPassword\":\"YknLuSd2tBY2HodwI/7RqA==\"} 11:28:47 APP: Restarting Connect to AWS IoT ~ Once the MQTTHost and MQTTPort are configured, Tasmota will try to connect to AWS IoT. Keep in mind that AWS IoT does not support 'retained' messages. Whatever the 'retained' configuration in Tasmota, messages are always published as 'retained=false'. Here is an example of output you should see: 00:00:04 HTP: Web server active on sonoff-4585 with IP address 192.168.1.59 00:00:04 UPP: Multicast (re)joined 21:28:25 MQT: Attempting connection... 21:28:25 MQT: AWS IoT endpoint: xxxxxxxxxxxxx-ats.iot.eu-central-1.amazonaws.com 21:28:26 MQT: AWS IoT connected in 1279 ms 21:28:26 MQT: Connected 21:28:26 MQT: tele/tasmota/LWT = Online 21:28:26 MQT: cmnd/tasmota/POWER = 21:28:26 MQT: tele/tasmota/INFO1 = {\"Module\":\"Sonoff Basic\",\"Version\":\"9.0.0.2(sonoff)\",\"FallbackTopic\": \"cmnd/DVES_67B1E9_fb/\",\"GroupTopic\":\"sonoffs\"} 7. Check end-to-end communication ~ In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy! 8. Cleaning ~ Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain . 9. Troubleshooting ~ TLSError shows any error at the TLS level. See here for most common error codes. For implementation details, see here ~","title":"AWS IoT"},{"location":"AWS-IoT/#benefits","text":"AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS.","title":"Benefits"},{"location":"AWS-IoT/#caveats","text":"During TLS handshake, a secondary stack of 4.8k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes.","title":"Caveats"},{"location":"AWS-IoT/#how-to-configure","text":"AWS IoT now works with Password authentication. Although it is not a good practice to use the same password for all your devices, it is technically working and the easiest way to start with Tasmota and AWS IoT. Here is a simple guide.","title":"How to configure?"},{"location":"AWS-IoT/#0-open-an-aws-account","text":"If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/","title":"0. Open an AWS Account"},{"location":"AWS-IoT/#1-prerequisites","text":"You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO)","title":"1. Prerequisites"},{"location":"AWS-IoT/#2-enable-aws-iot-in-tasmota","text":"Add the required compilation directives to user_config_override.h as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate.","title":"2. Enable AWS IoT in Tasmota"},{"location":"AWS-IoT/#3-flash-your-device","text":"Flash your device the normal way; either through serial or OTA.","title":"3. Flash your device"},{"location":"AWS-IoT/#4-configure-aws-iot-policy-to-be-done-once","text":"Open the AWS Console and select the target region. In the example below we will use (EU) Frankfurt (eu-central-1). Download the CloudFormation template TasmotaAuth and use it in AWS CloudFormation. Or click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Frankfurt) eu-central-1 EU (Paris) eu-west-3 At the Create Stack screen, click Next . At the Specify stack details screen, keep all default parameters and click Next . At the Configure stack options screen, keep all default parameters and click Next . At the Review TasmotaMqttPolicy screen, scroll down and click Create Stack . The stack usually takes less than 1 minute to complete. Wait for it to reach CREATE_COMPLETE state. Copy the commands under BackLogCommand , you will need it to configure Tasmota devices. If you have left the parameter RetentionPolicy to Retain , then you can delete this CloudFormation stack (it will not delete the Policy). Click on the Delete button. After less than 2 minutes, the stack should have reached the state DELETE_COMPLETE","title":"4. Configure AWS IoT Policy (to be done once)"},{"location":"AWS-IoT/#6-configure-tasmota-device","text":"This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. We will only cut and paste parameters from the Outputs tab of the CloudFormation console. Example: BackLog SetOption3 1; SetOption103 1; MqttHost a............u-ats.iot.eu-central-1.amazonaws.com; MqttPort 443; MqttUser tasmota?x-amz-customauthorizer-name=TasmotaAuth; MqttPassword YknLuSd2tBY2HodwI/7RqA== 11:28:44 CMD: BackLog SetOption3 1; SetOption103 1; MqttHost a............u-ats.iot.eu-central-1.amazonaws.com; MqttPort 443; MqttUser tasmota?x-amz-customauthorizer-name=TasmotaAuth; MqttPassword YknLuSd2tBY2HodwI/7RqA== 11:28:44 MQT: stat/tasmota_4B3316/RESULT = {\"SetOption3\":\"ON\"} 11:28:44 MQT: stat/tasmota_4B3316/RESULT = {\"SetOption103\":\"ON\"} 11:28:45 MQT: stat/tasmota_4B3316/RESULT = {\"MqttHost\":\"a...........u-ats.iot.eu-central-1.amazonaws.com\"} 11:28:45 MQT: stat/tasmota_4B3316/RESULT = {\"MqttPort\":443} 11:28:45 MQT: stat/tasmota_4B3316/RESULT = {\"MqttUser\":\"tasmota?x-amz-customauthorizer-name=TasmotaAuth\"} 11:28:45 MQT: stat/tasmota_4B3316/RESULT = {\"MqttPassword\":\"YknLuSd2tBY2HodwI/7RqA==\"} 11:28:47 APP: Restarting","title":"6. Configure Tasmota device"},{"location":"AWS-IoT/#7-check-end-to-end-communication","text":"In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy!","title":"7. Check end-to-end communication"},{"location":"AWS-IoT/#8-cleaning","text":"Cleaning : to avoid having CloudFormation templates piling up in your console, you can delete them. The created resources will remain, if you have left the parameter RetentionPolicy to Retain .","title":"8. Cleaning"},{"location":"AWS-IoT/#9-troubleshooting","text":"TLSError shows any error at the TLS level. See here for most common error codes.","title":"9. Troubleshooting"},{"location":"AWS-IoT/#for-implementation-details-see-here","text":"","title":"For implementation details, see here"},{"location":"AZ-7798/","text":"AZ7798 CO 2 meter ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_AZ7798 #define USE_AZ7798 // Add support for AZ-Instrument 7798 CO2 datalogger (+1k6 code) #endif The AZ7798 CO 2 Meter/Datalogger appears to be made by AZ Instrument , but other branded versions exist. The CO 2 meter is already provided with a PC interface in the form of a logic-level (3V3) serial port, accessible through a 2.5mm stereo jack on the back. The Wemos D1 Mini is connected to this serial port instead, and the PC interface is no longer available. Configuration ~ Connecting the AZ7798 to a Wemos D1 Mini ~ The Wemos D1 Mini is fitted inside the meter enclosure. This requires the enclosure to be opened. There are four screws. Two of the screws are hidden behind the type label. Use the tip of a small knife to cut holes in the label. There are also two clips at the top of the enclosure. To release those, gently pry apart the bottom of the enclosure a small amount. The grey band between the two halves can now be lifted up and pushed aside a little and expose the clips near the top. A push with a flat-blade screwdriver will then release the clips. Once the enclosure is opened, disconnect the two serial port wires from the socket on the back panel. The black wire (0V) can remain connected. Now connect these two wires to TX and RX of the Wemos D1 Mini. Wemos D1 Mini AZ7798 TX wire with stripe RX wire without stripe The power supply for the Wemos D1 Mini is taken directly from the power supply for the meter, which is a 5V external power supply. Solder two wires to the incoming power supply and connect the other ends to the 5V and G terminals on the Wemos D1 Mini. Make a small right-angle bracket for mounting the Wemos D1 Mini to the meter board. Use double-sided tape to hold everything together. Tasmota Settings ~ In the Configuration -> Configure Module page assign: D1 TX to AZ Tx D3 RX to AZ Rx After reboot of the device the AZ7798 measurements are shown.","title":"AZ7798 CO~2~ meter"},{"location":"AZ-7798/#az7798-co2-meter","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_AZ7798 #define USE_AZ7798 // Add support for AZ-Instrument 7798 CO2 datalogger (+1k6 code) #endif The AZ7798 CO 2 Meter/Datalogger appears to be made by AZ Instrument , but other branded versions exist. The CO 2 meter is already provided with a PC interface in the form of a logic-level (3V3) serial port, accessible through a 2.5mm stereo jack on the back. The Wemos D1 Mini is connected to this serial port instead, and the PC interface is no longer available.","title":"AZ7798 CO2 meter"},{"location":"AZ-7798/#configuration","text":"","title":"Configuration"},{"location":"AZ-7798/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: D1 TX to AZ Tx D3 RX to AZ Rx After reboot of the device the AZ7798 measurements are shown.","title":"Tasmota Settings"},{"location":"About/","text":"If you don't have the willingness to tinker and learn... TURN BACK!. Tasmota is not a commercial product and support is limited. You have to be willing to research and solve potential problems yourself. Tasmota is an open source firmware for Espressif ESP8266, ESP32, ESP32-S or ESP32-C3 chipset based devices created and maintained by Theo Arends . Everything began as Sonoff-MQTT-OTA with a commit on 25th January 2016. by Theo Arendst. Its goal was to provide ESP8266 based ITEAD Sonoff devices with MQTT and 'Over the Air' or OTA firmware. What started as a simple way to hack a cloud bound Sonoff Basic (one of the first cheap and accessible smart home devices in the market) into a locally controlled device has grown into a fully fledged ecosystem for virtually any ESP8266 based device. Contribute ~ Any contribution helps our team and makes Tasmota better for the entire community! Everybody is welcome and invited to contribute to Tasmota Project by: providing Pull Requests (Features, Proof of Concepts, Language files or Fixes) testing new released features and report issues donating to acquire hardware for testing and implementing or out of gratitude contributing missing documentation for features and devices Credits ~ People helping to keep the show on the road: David Lang providing initial issue resolution and code optimizations Heiko Krupp for his IRSend, HTU21, SI70xx and Wemo/Hue emulation drivers Wiktor Schmidt for Travis CI implementation Thom Dietrich for PlatformIO optimizations Marinus van den Broek for his EspEasy groundwork Pete Ba for more user friendly energy monitor calibration Lobradov providing compile optimization tips Flexiti for his initial timer implementation reloxx13 for his TasmoAdmin management tool Joachim Banzhaf for his TSL2561 library and driver Gijs Noorlander for his MHZ19, SenseAir and updated PubSubClient drivers Erik Montnemery for his HomeAssistant Discovery concept and many code tuning tips Federico Leoni for continued HomeAssistant Discovery support Aidan Mountford for his HSB support Daniel Ztolnai for his Serial Bridge implementation Gerhard Mutz for multiple sensor & display drivers, Sunrise/Sunset, and scripting Nuno Ferreira for his HC-SR04 driver Adrian Scillato for his (security) fixes and implementing and maintaining KNX Gennaro Tortone for implementing and maintaining Eastron drivers Raymond Mouthaan for managing Wemos Wiki information Norbert Richter for his decode-config.py tool Andre Thomas for providing thehackbox OTA support and daily development builds Joel Stein, digiblur and Shantur Rathore for their Tuya research and driver Frogmore42 for providing many issue answers Jason2866 for platformio support and providing many issue answers Blakadder for managing the new document site and providing template management Stephan Hadinger for refactoring light driver, enhancing HueEmulation and Zigbee support tmo for designing the official Tasmota logo Stefan Bode for his Shutter and Deep sleep drivers Jacek Zi\u00f3\u0142kowski for his TDM management tool and Tasmotizer flashing tool Christian Staars for NRF24L01 and HM-10 Bluetooth sensor support Paul Diem for UDP Group communication support J\u00f6rg Sch\u00fcler-Maroldt for his initial ESP32 port Many more providing Tips, Wips, Pocs, PRs and Donations License ~ This program is licensed under GPL-3.0","title":"About"},{"location":"About/#contribute","text":"Any contribution helps our team and makes Tasmota better for the entire community! Everybody is welcome and invited to contribute to Tasmota Project by: providing Pull Requests (Features, Proof of Concepts, Language files or Fixes) testing new released features and report issues donating to acquire hardware for testing and implementing or out of gratitude contributing missing documentation for features and devices","title":"Contribute"},{"location":"About/#credits","text":"People helping to keep the show on the road: David Lang providing initial issue resolution and code optimizations Heiko Krupp for his IRSend, HTU21, SI70xx and Wemo/Hue emulation drivers Wiktor Schmidt for Travis CI implementation Thom Dietrich for PlatformIO optimizations Marinus van den Broek for his EspEasy groundwork Pete Ba for more user friendly energy monitor calibration Lobradov providing compile optimization tips Flexiti for his initial timer implementation reloxx13 for his TasmoAdmin management tool Joachim Banzhaf for his TSL2561 library and driver Gijs Noorlander for his MHZ19, SenseAir and updated PubSubClient drivers Erik Montnemery for his HomeAssistant Discovery concept and many code tuning tips Federico Leoni for continued HomeAssistant Discovery support Aidan Mountford for his HSB support Daniel Ztolnai for his Serial Bridge implementation Gerhard Mutz for multiple sensor & display drivers, Sunrise/Sunset, and scripting Nuno Ferreira for his HC-SR04 driver Adrian Scillato for his (security) fixes and implementing and maintaining KNX Gennaro Tortone for implementing and maintaining Eastron drivers Raymond Mouthaan for managing Wemos Wiki information Norbert Richter for his decode-config.py tool Andre Thomas for providing thehackbox OTA support and daily development builds Joel Stein, digiblur and Shantur Rathore for their Tuya research and driver Frogmore42 for providing many issue answers Jason2866 for platformio support and providing many issue answers Blakadder for managing the new document site and providing template management Stephan Hadinger for refactoring light driver, enhancing HueEmulation and Zigbee support tmo for designing the official Tasmota logo Stefan Bode for his Shutter and Deep sleep drivers Jacek Zi\u00f3\u0142kowski for his TDM management tool and Tasmotizer flashing tool Christian Staars for NRF24L01 and HM-10 Bluetooth sensor support Paul Diem for UDP Group communication support J\u00f6rg Sch\u00fcler-Maroldt for his initial ESP32 port Many more providing Tips, Wips, Pocs, PRs and Donations","title":"Credits"},{"location":"About/#license","text":"This program is licensed under GPL-3.0","title":"License"},{"location":"Alexa/","text":"This feature is included only in tasmota , tasmota32 , tasmota-lite and tasmota-sensors binaries When compiling your build add the following to user_config_override.h : c++ #define USE_EMULATION // Enable Wemo or Hue emulation #define USE_EMULATION_HUE // Enable Hue Bridge emulation for Alexa (+14k code, +2k mem common) #define USE_EMULATION_WEMO // Enable Belkin WeMo emulation for Alexa (+6k code, +2k mem common) Connecting to Alexa ~ You can interact with Tasmota using Amazon Alexa through its Echo devices . In Configuration - Configure Other page in the webUI select emulation type. Warning Alexa Hue integration requires a physical Alexa device. The app alone is not enough. Check your router settings. You have to enable IGMP Belkin WeMo Emulation ~ Use Belkin WeMo for devices with a single relay or Hue Bridge for devices with one or more relays or for lights. Tasmota devices will be discovered by the Alexa app. You do not need to install the Wemo app or enable the Wemo skill in Alexa. Just tell Alexa to discover devices of the appropriate type (plug, switch, etc.) and when it asks what brand device, scroll to the end and choose \"Other\". Hue Bridge Emulation ~ For control of lights, color control (introduced in version 6.5.0.9), on/off, and dimming is supported. Enable Hue Bridge emulation and perform a device discovery in the Alexa app. No skill needs to be added to Alexa. Select Hue Bridge V1 as the device type. Relays and lights with friendly names beginning with a dollar sign ( $ ) will cause Tasmota to not \"announce\" them (i.e., be hidden) to Alexa. If they were previously discovered, they will still continue to work. As there are only four friendly names provided in Tasmota, if FriendlyName4 begins with $ , component 4 and all higher numbered discoverable components will not be discovered by Alexa. Hue Bridge emulation does not support sensors.","title":"Alexa"},{"location":"Alexa/#connecting-to-alexa","text":"You can interact with Tasmota using Amazon Alexa through its Echo devices . In Configuration - Configure Other page in the webUI select emulation type. Warning Alexa Hue integration requires a physical Alexa device. The app alone is not enough. Check your router settings. You have to enable IGMP","title":"Connecting to Alexa"},{"location":"Azure-IoT-Central/","text":"!!! failure \"This feature is not included in precompiled binaries, To use it you must compile your build. Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT #define USE_MQTT_AZURE_DPS_SCOPEID \"YOURSCOPEIDHERE\" #define USE_MQTT_AZURE_DPS_PRESHAREDKEY \"YOURPRESHAREDKEYHERE==\" As of Tasmota version 9.2.4, Tasmota now supports TLS 1.2 connections to Azure IoT Hub and IoT Central using time bound token authentication based on a unique key. IoT Central includes Azure Device Provisioning Service which is used for simplified deployment at scale. Benefits ~ Azure IoT Central supports supports bi-directional communication between the could and both IoT Devices and/or Intelligent Edge devices base on Azure IoT Edge and is delivered as a Software as a Service (SaaS). In addition to telemtary and communication, IoT Central if a full solution for quickly managing and deploying IoT solutions at scale. Authentication ~ This version of Tasmota leverages the Preshared Key authentication, which will create a time bound (one hour by default) SHA256 signature based on a unique key. Only this signed text is sent across the network over a TLS 1.2 channel ensuring mutual authentication. Because of this time bound nature, Tasmota must (by default) be configured to synchronize time with public Network Time Protocol Servers. Developer level information provided here discussed here . Cost ~ Azure IoT Central provides a free tier that allows for 2 devices at no charge. Get Started ~ 0. Create an IoT Central Application ~ Follow the steps here to create an IoT Central Application: https://docs.microsoft.com/en-us/azure/iot-central/core/quick-deploy-iot-central 1. Get the ID Scope ~ Select Administration --> Device Connection to note the ID Scope as shown below: 2. Create a Enrollment Group ~ Click Create enrollment group , name the group, and select the Attestation type as Shared access signature (SAS) . Click Save to and copy the Primary Key, as shown below: 3. Compile your binary including support for Azure IoT Device Provisioning Service (and IoT Central) ~ Following the directions here: https://tasmota.github.io/docs/Compile-your-build/ compile your binary adding the following settings to your my_user_config.h adding your Scope Id and your Primary Key. Tip Don't foget your WiFi for complete automation. #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT #define USE_MQTT_AZURE_DPS_SCOPEID \"0ne002AEBBA\" #define USE_MQTT_AZURE_DPS_PRESHAREDKEY \"iQ9Qtjfux9wWW0guHi/ChRGQX//LLkZEnyUNIaLD8+imAsKvpZwYYT8M0kFPVxt3KjtRF00KpNi5/ejBt+1YLA==\" 4. Flash your device and configure for WiFi ~ Tip If you configured the WiFi in the config file, no WiFi configuration needed. Flash your device as discussed here and then configure the WiFi as discussed here . 5. Verify your automatic (DPS) configuration ~ In the Console of Tasmota, you will see it was registered with Device Provisioning Service (which created the IoT Hub device) and authenticated with a token, connected and it will start sending state: If you look at the properties, you will see it automatically definded the Host name, port, TLS and MQTT Client (device Id) -- which defaulted to the MAC address: In the IoT Central Application, you can see the telemtry data:","title":"Azure IoT Central"},{"location":"Azure-IoT-Central/#benefits","text":"Azure IoT Central supports supports bi-directional communication between the could and both IoT Devices and/or Intelligent Edge devices base on Azure IoT Edge and is delivered as a Software as a Service (SaaS). In addition to telemtary and communication, IoT Central if a full solution for quickly managing and deploying IoT solutions at scale.","title":"Benefits"},{"location":"Azure-IoT-Central/#authentication","text":"This version of Tasmota leverages the Preshared Key authentication, which will create a time bound (one hour by default) SHA256 signature based on a unique key. Only this signed text is sent across the network over a TLS 1.2 channel ensuring mutual authentication. Because of this time bound nature, Tasmota must (by default) be configured to synchronize time with public Network Time Protocol Servers. Developer level information provided here discussed here .","title":"Authentication"},{"location":"Azure-IoT-Central/#cost","text":"Azure IoT Central provides a free tier that allows for 2 devices at no charge.","title":"Cost"},{"location":"Azure-IoT-Central/#get-started","text":"","title":"Get Started"},{"location":"Azure-IoT-Central/#0-create-an-iot-central-application","text":"Follow the steps here to create an IoT Central Application: https://docs.microsoft.com/en-us/azure/iot-central/core/quick-deploy-iot-central","title":"0. Create an IoT Central Application"},{"location":"Azure-IoT-Central/#1-get-the-id-scope","text":"Select Administration --> Device Connection to note the ID Scope as shown below:","title":"1. Get the ID Scope"},{"location":"Azure-IoT-Central/#2-create-a-enrollment-group","text":"Click Create enrollment group , name the group, and select the Attestation type as Shared access signature (SAS) . Click Save to and copy the Primary Key, as shown below:","title":"2. Create a Enrollment Group"},{"location":"Azure-IoT-Central/#3-compile-your-binary-including-support-for-azure-iot-device-provisioning-service-and-iot-central","text":"Following the directions here: https://tasmota.github.io/docs/Compile-your-build/ compile your binary adding the following settings to your my_user_config.h adding your Scope Id and your Primary Key. Tip Don't foget your WiFi for complete automation. #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT #define USE_MQTT_AZURE_DPS_SCOPEID \"0ne002AEBBA\" #define USE_MQTT_AZURE_DPS_PRESHAREDKEY \"iQ9Qtjfux9wWW0guHi/ChRGQX//LLkZEnyUNIaLD8+imAsKvpZwYYT8M0kFPVxt3KjtRF00KpNi5/ejBt+1YLA==\"","title":"3. Compile your binary including support for Azure IoT Device Provisioning Service (and IoT Central)"},{"location":"Azure-IoT-Central/#4-flash-your-device-and-configure-for-wifi","text":"Tip If you configured the WiFi in the config file, no WiFi configuration needed. Flash your device as discussed here and then configure the WiFi as discussed here .","title":"4. Flash your device and configure for WiFi"},{"location":"Azure-IoT-Central/#5-verify-your-automatic-dps-configuration","text":"In the Console of Tasmota, you will see it was registered with Device Provisioning Service (which created the IoT Hub device) and authenticated with a token, connected and it will start sending state: If you look at the properties, you will see it automatically definded the Host name, port, TLS and MQTT Client (device Id) -- which defaulted to the MAC address: In the IoT Central Application, you can see the telemtry data:","title":"5. Verify your automatic (DPS) configuration"},{"location":"Azure-IoT-Hub/","text":"!!! failure \"This feature is not included in precompiled binaries, To use it you must compile your build. Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT As of Tasmota version 9.2.4, Tasmota now supports TLS 1.2 connections to Azure IoT Hub using time bound token authentication based on a unique key. Tasmota can be used with or without Azure Device Provisioning Service which is used for simplified deployment at scale. Benefits ~ Azure IoT Hub supports bi-directional communication between the could and both IoT Devices and/or Intelligent Edge devices base on Azure IoT Edge . Azure IoT Hub supports REST, AMQP and the MQTT 3.1.1 protocol as discussed here . IoT Hub supports Trusted Platform Module (when used with Device Provisioning Service), x509 Certificates and Preshared Keys authentication discussed here . Authentication ~ This version of Tasmota leverages the Preshared Key authentication, which will create a time bound (one hour by default) SHA256 signature based on a unique key. Only this signed text is sent across the network over a TLS 1.2 channel ensuring mutual authentication. Because of this time bound nature, Tasmota must (by default) be configured to synchronize time with public Network Time Protocol Servers. Developer level information provided here discussed here . Cost ~ Azure IoT Hub provides a free tier that allows for up to 8,000 message a day. IoT Central ~ In additon to Azure IoT Hub which is a Platform as a Service (PaaS), Tasmota also works with IoT Central which is a more complete Software as a Service (SaaS). How to configure (without Device Provisioning Service) ~ 0. Open an Azure Subscription ~ If you don't already have an Azure Subscription (one is included with most MSDN subscriptions), you can get started here: https://azure.microsoft.com/account/free 1. Create an Azure IoT Hub and a Device ~ The following steps will walk you through creating an IoT Hub and your first device using a web browser: https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-create-through-portal You will need 3 pieces of information from this step: Information Your Setting Example Value IoT Hub Full Name myiothub.azure-devices.net Device Id myfirstTasmotaDevice Primary Key i2B6TVRnpWGS5i5aZaRddaGTc+tIte1gg4PUkh0t+30= 2. Compile your binary including support for Azure IoT ~ Following the directions here: https://tasmota.github.io/docs/Compile-your-build/ compile your binary adding the following settings to your my_user_config.h . #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT 3. Flash your device and configure for WiFi ~ Flash your device as discussed here and then configure the WiFi as discussed here . 4. Configure your device for you Azure IoT Hub ~ In the web portal, click the configuration button and then the configure MQTT button. Following the diagram below, set the: Host (IoT Hub Full Name), Port of 8883, select MQTT TLS , type in the Client and User (your Device Id) and the Password (your Primary Key) and click Save . Your device will reboot and connect. 5. Verify the connection ~ In the Console of Tasmota, you will see it was authenticated with a token, connected and it will start sending state: Using a tool like the Azure IoT Explorer , you can see message received in IoT Hub. Note the topic property. 6. Send a message to your Tasmota ~ Using a tool like the Azure IoT Explorer , select Cloud-to-device message set a property of Topic to /power , add toggle to the message body and click Send message to device button. All of the Tasmota Commands are discussed here https://tasmota.github.io/docs/Commands/ . How to configure (with Device Provisioning Service) ~ Azure Device Provisioning Services (DPS) allows for automatic deployment at scale. Simular to Tasmota authenticating to IoT Hub without DPS, authenticating to DPS uses a time bound SHA256 signature to authenticate over TLS 1.2. For this setup, we configure the following settings when building our binary. For full automation, you will want to add STA_SSID1 and STA_PASS1 to your user_config_override.h . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT #define USE_MQTT_AZURE_DPS_SCOPEID \"YOURSCOPEIDHERE\" #define USE_MQTT_AZURE_DPS_PRESHAREDKEY \"YOURPRESHAREDKEYHERE==\" 0. Open an Azure Subscription ~ If you don't already have an Azure Subscription (one is included with most MSDN subscriptions), you can get started here: https://azure.microsoft.com/account/free 1. Create a Device Provisioning Service, IoT Hub and link them together ~ Following: https://docs.microsoft.com/en-us/azure/iot-dps/tutorial-set-up-cloud to create your DPS and IoT Hub. Note your Scope Id for later use as shown below: 2. Create a Group Enrollment with a Symetrical Key ~ In your Device Provisiniong Service, click Manage enrollments and then click Add enrollment group . As shown below, name your group, select Symmetric Key , select your linked IoT Hub and then click Save . Once created you can select the enrollment group to retrieve the Primary Key , as shown below: 3. Compile your binary including support for Azure IoT Device Provisioning Service ~ Following the directions here: https://tasmota.github.io/docs/Compile-your-build/ compile your binary adding the following settings to your my_user_config.h adding your Scope Id and your Primary Key. !!! tip Don't foget your WiFi settings for complete automation. #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT #define USE_MQTT_AZURE_DPS_SCOPEID \"0ne00223A39\" #define USE_MQTT_AZURE_DPS_PRESHAREDKEY \"mVVdX8MPUFUoYaG7Wq6HyMcsz0kZNfwVwiafChvFDxrs0s8pa5gVV6myMbqOBCqGraVFZFupD3RiIgx0B4ZACA==\" 4. Flash your device and configure for WiFi ~ !!! tip If you configured the WiFi in the config file, no WiFi configuration needed. Flash your device as discussed here and then configure the WiFi as discussed here . 5. Verify your automatic (DPS) configuration ~ In the Console of Tasmota, you will see it was registered with Device Provisioning Service (which created the IoT Hub device) and authenticated with a token, connected and it will start sending state: If you look at the Information, you will see it automatically definded: Host , Port , TLS and MQTT Client (device Id) -- which defaulted to the MAC address which is unique: Using a tool like the Azure IoT Explorer , you can see message received in IoT Hub. Note the topic property. 6. Send a message to your Tasmota ~ Using a tool like the Azure IoT Explorer , select Cloud-to-device message set a property of Topic to /power , add toggle to the message body and click the Send message to device button.","title":"Azure IoT Hub"},{"location":"Azure-IoT-Hub/#benefits","text":"Azure IoT Hub supports bi-directional communication between the could and both IoT Devices and/or Intelligent Edge devices base on Azure IoT Edge . Azure IoT Hub supports REST, AMQP and the MQTT 3.1.1 protocol as discussed here . IoT Hub supports Trusted Platform Module (when used with Device Provisioning Service), x509 Certificates and Preshared Keys authentication discussed here .","title":"Benefits"},{"location":"Azure-IoT-Hub/#authentication","text":"This version of Tasmota leverages the Preshared Key authentication, which will create a time bound (one hour by default) SHA256 signature based on a unique key. Only this signed text is sent across the network over a TLS 1.2 channel ensuring mutual authentication. Because of this time bound nature, Tasmota must (by default) be configured to synchronize time with public Network Time Protocol Servers. Developer level information provided here discussed here .","title":"Authentication"},{"location":"Azure-IoT-Hub/#cost","text":"Azure IoT Hub provides a free tier that allows for up to 8,000 message a day.","title":"Cost"},{"location":"Azure-IoT-Hub/#iot-central","text":"In additon to Azure IoT Hub which is a Platform as a Service (PaaS), Tasmota also works with IoT Central which is a more complete Software as a Service (SaaS).","title":"IoT Central"},{"location":"Azure-IoT-Hub/#how-to-configure-without-device-provisioning-service","text":"","title":"How to configure (without Device Provisioning Service)"},{"location":"Azure-IoT-Hub/#0-open-an-azure-subscription","text":"If you don't already have an Azure Subscription (one is included with most MSDN subscriptions), you can get started here: https://azure.microsoft.com/account/free","title":"0. Open an Azure Subscription"},{"location":"Azure-IoT-Hub/#1-create-an-azure-iot-hub-and-a-device","text":"The following steps will walk you through creating an IoT Hub and your first device using a web browser: https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-create-through-portal You will need 3 pieces of information from this step: Information Your Setting Example Value IoT Hub Full Name myiothub.azure-devices.net Device Id myfirstTasmotaDevice Primary Key i2B6TVRnpWGS5i5aZaRddaGTc+tIte1gg4PUkh0t+30=","title":"1. Create an Azure IoT Hub and a Device"},{"location":"Azure-IoT-Hub/#2-compile-your-binary-including-support-for-azure-iot","text":"Following the directions here: https://tasmota.github.io/docs/Compile-your-build/ compile your binary adding the following settings to your my_user_config.h . #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT","title":"2. Compile your binary including support for Azure IoT"},{"location":"Azure-IoT-Hub/#3-flash-your-device-and-configure-for-wifi","text":"Flash your device as discussed here and then configure the WiFi as discussed here .","title":"3. Flash your device and configure for WiFi"},{"location":"Azure-IoT-Hub/#4-configure-your-device-for-you-azure-iot-hub","text":"In the web portal, click the configuration button and then the configure MQTT button. Following the diagram below, set the: Host (IoT Hub Full Name), Port of 8883, select MQTT TLS , type in the Client and User (your Device Id) and the Password (your Primary Key) and click Save . Your device will reboot and connect.","title":"4. Configure your device for you Azure IoT Hub"},{"location":"Azure-IoT-Hub/#5-verify-the-connection","text":"In the Console of Tasmota, you will see it was authenticated with a token, connected and it will start sending state: Using a tool like the Azure IoT Explorer , you can see message received in IoT Hub. Note the topic property.","title":"5. Verify the connection"},{"location":"Azure-IoT-Hub/#6-send-a-message-to-your-tasmota","text":"Using a tool like the Azure IoT Explorer , select Cloud-to-device message set a property of Topic to /power , add toggle to the message body and click Send message to device button. All of the Tasmota Commands are discussed here https://tasmota.github.io/docs/Commands/ .","title":"6. Send a message to your Tasmota"},{"location":"Azure-IoT-Hub/#how-to-configure-with-device-provisioning-service","text":"Azure Device Provisioning Services (DPS) allows for automatic deployment at scale. Simular to Tasmota authenticating to IoT Hub without DPS, authenticating to DPS uses a time bound SHA256 signature to authenticate over TLS 1.2. For this setup, we configure the following settings when building our binary. For full automation, you will want to add STA_SSID1 and STA_PASS1 to your user_config_override.h . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT #define USE_MQTT_AZURE_DPS_SCOPEID \"YOURSCOPEIDHERE\" #define USE_MQTT_AZURE_DPS_PRESHAREDKEY \"YOURPRESHAREDKEYHERE==\"","title":"How to configure (with Device Provisioning Service)"},{"location":"Azure-IoT-Hub/#0-open-an-azure-subscription_1","text":"If you don't already have an Azure Subscription (one is included with most MSDN subscriptions), you can get started here: https://azure.microsoft.com/account/free","title":"0. Open an Azure Subscription"},{"location":"Azure-IoT-Hub/#1-create-a-device-provisioning-service-iot-hub-and-link-them-together","text":"Following: https://docs.microsoft.com/en-us/azure/iot-dps/tutorial-set-up-cloud to create your DPS and IoT Hub. Note your Scope Id for later use as shown below:","title":"1. Create a Device Provisioning Service, IoT Hub and link them together"},{"location":"Azure-IoT-Hub/#2-create-a-group-enrollment-with-a-symetrical-key","text":"In your Device Provisiniong Service, click Manage enrollments and then click Add enrollment group . As shown below, name your group, select Symmetric Key , select your linked IoT Hub and then click Save . Once created you can select the enrollment group to retrieve the Primary Key , as shown below:","title":"2. Create a Group Enrollment with a Symetrical Key"},{"location":"Azure-IoT-Hub/#3-compile-your-binary-including-support-for-azure-iot-device-provisioning-service","text":"Following the directions here: https://tasmota.github.io/docs/Compile-your-build/ compile your binary adding the following settings to your my_user_config.h adding your Scope Id and your Primary Key. !!! tip Don't foget your WiFi settings for complete automation. #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #endif #define USE_MQTT_AZURE_IOT #define USE_MQTT_AZURE_DPS_SCOPEID \"0ne00223A39\" #define USE_MQTT_AZURE_DPS_PRESHAREDKEY \"mVVdX8MPUFUoYaG7Wq6HyMcsz0kZNfwVwiafChvFDxrs0s8pa5gVV6myMbqOBCqGraVFZFupD3RiIgx0B4ZACA==\"","title":"3. Compile your binary including support for Azure IoT Device Provisioning Service"},{"location":"Azure-IoT-Hub/#4-flash-your-device-and-configure-for-wifi","text":"!!! tip If you configured the WiFi in the config file, no WiFi configuration needed. Flash your device as discussed here and then configure the WiFi as discussed here .","title":"4. Flash your device and configure for WiFi"},{"location":"Azure-IoT-Hub/#5-verify-your-automatic-dps-configuration","text":"In the Console of Tasmota, you will see it was registered with Device Provisioning Service (which created the IoT Hub device) and authenticated with a token, connected and it will start sending state: If you look at the Information, you will see it automatically definded: Host , Port , TLS and MQTT Client (device Id) -- which defaulted to the MAC address which is unique: Using a tool like the Azure IoT Explorer , you can see message received in IoT Hub. Note the topic property.","title":"5. Verify your automatic (DPS) configuration"},{"location":"Azure-IoT-Hub/#6-send-a-message-to-your-tasmota_1","text":"Using a tool like the Azure IoT Explorer , select Cloud-to-device message set a property of Topic to /power , add toggle to the message body and click the Send message to device button.","title":"6. Send a message to your Tasmota"},{"location":"BH1750/","text":"BH1750 ambient light sensor ~ This feature is included only in tasmota32 and tasmota-sensors binaries When compiling your build add the following to user_config_override.h : #ifndef USE_BH1750 #define USE_BH1750 // [I2cDriver11] Enable BH1750 sensor (I2C address 0x23 or 0x5C) (+0k5 code) #endif The BH1750 is a digital ambient light sensor module which uses I 2 C to communicate. The BH1750 provides you with a digital value in lux (Lx) over a range of 1 - 65535 lx. See datasheet for more information. Configuration ~ Wiring ~ BH1750 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect BH1750 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T20:45:37\" , \"BH1750\" :{ \"Illuminance\" : 79 }} Commands ~ Command Parameters Bh1750Resolution resolution mode. x = sensor number (1..2) 0..2 = choose sensor resolution ( 0 = high (default) , 1 = high2, 2 = low) Bh1750MTime Measurement Time value. x = sensor number (1..2) 31..254 = set measurement time (default = 69 ) Breakout Boards ~","title":"BH1750 ambient light sensor"},{"location":"BH1750/#bh1750-ambient-light-sensor","text":"This feature is included only in tasmota32 and tasmota-sensors binaries When compiling your build add the following to user_config_override.h : #ifndef USE_BH1750 #define USE_BH1750 // [I2cDriver11] Enable BH1750 sensor (I2C address 0x23 or 0x5C) (+0k5 code) #endif The BH1750 is a digital ambient light sensor module which uses I 2 C to communicate. The BH1750 provides you with a digital value in lux (Lx) over a range of 1 - 65535 lx. See datasheet for more information.","title":"BH1750 ambient light sensor"},{"location":"BH1750/#configuration","text":"","title":"Configuration"},{"location":"BH1750/#wiring","text":"BH1750 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"BH1750/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect BH1750 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T20:45:37\" , \"BH1750\" :{ \"Illuminance\" : 79 }}","title":"Tasmota Settings"},{"location":"BH1750/#commands","text":"Command Parameters Bh1750Resolution resolution mode. x = sensor number (1..2) 0..2 = choose sensor resolution ( 0 = high (default) , 1 = high2, 2 = low) Bh1750MTime Measurement Time value. x = sensor number (1..2) 31..254 = set measurement time (default = 69 )","title":"Commands"},{"location":"BH1750/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"BME280/","text":"BME280 temperature, humidity and pressure sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_BMP #define USE_BMP // [I2cDriver10] Enable BMP085/BMP180/BMP280/BME280 sensors (I2C addresses 0x76 and 0x77) (+4k4 code) #endif BME280 sensor, an environmental sensor with temperature, barometric pressure and humidity\" See BME280 Temperature, Humidity and Pressure Sensor for more information. BME280 driver also supports BMP085 , BMP180 and BMP280 pressure sensors. Configuration ~ Wiring ~ BME280 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL Note If you are using breakout boards which break out pins CSB please ensure that you connect this pin to VCC to ensure that the chip stays in I 2 C mode. This is due to some manufacturers of breakout boards add pull-up resistors to allow for SPI compatibility (some would default to SPI, others to I 2 C)_ Connect the SDO pin to GND or VCC to ensure required I 2 C address is used by the chip - Again some manufacturers add resistors to provide external bias but due to them wanting to retain SPI compatibility such pulldown resistors may not be sufficient to ensure that the pin levels are at the correct transition during power-up / reset state._ Since the chip supports both SPI and I 2 C, but in Tasmota only I 2 C is supported you want to make sure that the chip is in I 2 C mode during reset/power-on and remain in that state during operation otherwise unexpected behaviour may result when the Tasmota firmware polls the chip for sensor data. Sonoff Basic wiring After a reboot the driver will detect BME280 automatically and display temperature, humidity and pressure measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T19:34:28\" , \"BME280\" : { \"Temperature\" : 21.7 , \"Humidity\" : 66.6 , \"Pressure\" : 988.6 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } From v6.1.2.20 you can use multiple BMP Sensors ( #4195 ) Limit is 2 sensors and you have to change the address of one sensor. Than connect your sensor SCL and SDA parallel to the device. BME280 address change example: Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Breakout boards ~ Do NOT buy Breakout boards which supports 5V too. The onboard vreg will heat the PCB and you get false too high readings","title":"BME280 temperature, humidity and pressure sensor"},{"location":"BME280/#bme280-temperature-humidity-and-pressure-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_BMP #define USE_BMP // [I2cDriver10] Enable BMP085/BMP180/BMP280/BME280 sensors (I2C addresses 0x76 and 0x77) (+4k4 code) #endif BME280 sensor, an environmental sensor with temperature, barometric pressure and humidity\" See BME280 Temperature, Humidity and Pressure Sensor for more information. BME280 driver also supports BMP085 , BMP180 and BMP280 pressure sensors.","title":"BME280 temperature, humidity and pressure sensor"},{"location":"BME280/#configuration","text":"","title":"Configuration"},{"location":"BME280/#wiring","text":"BME280 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"BME280/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL Note If you are using breakout boards which break out pins CSB please ensure that you connect this pin to VCC to ensure that the chip stays in I 2 C mode. This is due to some manufacturers of breakout boards add pull-up resistors to allow for SPI compatibility (some would default to SPI, others to I 2 C)_ Connect the SDO pin to GND or VCC to ensure required I 2 C address is used by the chip - Again some manufacturers add resistors to provide external bias but due to them wanting to retain SPI compatibility such pulldown resistors may not be sufficient to ensure that the pin levels are at the correct transition during power-up / reset state._ Since the chip supports both SPI and I 2 C, but in Tasmota only I 2 C is supported you want to make sure that the chip is in I 2 C mode during reset/power-on and remain in that state during operation otherwise unexpected behaviour may result when the Tasmota firmware polls the chip for sensor data. Sonoff Basic wiring After a reboot the driver will detect BME280 automatically and display temperature, humidity and pressure measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T19:34:28\" , \"BME280\" : { \"Temperature\" : 21.7 , \"Humidity\" : 66.6 , \"Pressure\" : 988.6 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } From v6.1.2.20 you can use multiple BMP Sensors ( #4195 ) Limit is 2 sensors and you have to change the address of one sensor. Than connect your sensor SCL and SDA parallel to the device. BME280 address change example:","title":"Tasmota Settings"},{"location":"BME280/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"BME280/#breakout-boards","text":"Do NOT buy Breakout boards which supports 5V too. The onboard vreg will heat the PCB and you get false too high readings","title":"Breakout boards"},{"location":"BME680/","text":"BME680 temperature, humidity, pressure and gas sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_BME68X #define USE_BME68X // Enable support for BME680/BME688 sensor using Bosch BME68x library (+6k9 code) #endif BME680 sensor, an environmental I 2 C sensor with temperature, humidity, barometric pressure and gas. The BME680 takes those sensors to the next step in that it contains a small MOX sensor. The heated metal oxide changes resistance based on the volatile organic compounds (VOC) in the air, so it can be used to detect gasses & alcohols such as Ethanol, Alcohol and Carbon Monoxide, and perform air quality measurements. Note it will give you one resistance value, with overall VOC content, but it cannot differentiate gasses or alcohols. See BME680 - Temperature, Humidity, Pressure and Gas Sensor for more information. Configuration ~ Wiring ~ BME680 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect BME680 automatically and display temperature, humidity, dew point, pressure and gas resistance measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2021-09-22T17:00:00\" , \"BME680\" : { \"Temperature\" : 24.5 , \"Humidity\" : 33.0 , \"DewPoint\" : 7.1 , \"Pressure\" : 987.7 , \"Gas\" : 1086.43 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. TempRes sets temperature resolution. SetOption8 sets temperature unit in Celsius or in Fahrenheit . SetOption24 sets pressure unit in hPa or in mmHg . Breakout Boards ~ Buy from: - Adafruit - AliExpress","title":"BME680 temperature, humidity, pressure and gas sensor"},{"location":"BME680/#bme680-temperature-humidity-pressure-and-gas-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_BME68X #define USE_BME68X // Enable support for BME680/BME688 sensor using Bosch BME68x library (+6k9 code) #endif BME680 sensor, an environmental I 2 C sensor with temperature, humidity, barometric pressure and gas. The BME680 takes those sensors to the next step in that it contains a small MOX sensor. The heated metal oxide changes resistance based on the volatile organic compounds (VOC) in the air, so it can be used to detect gasses & alcohols such as Ethanol, Alcohol and Carbon Monoxide, and perform air quality measurements. Note it will give you one resistance value, with overall VOC content, but it cannot differentiate gasses or alcohols. See BME680 - Temperature, Humidity, Pressure and Gas Sensor for more information.","title":"BME680 temperature, humidity, pressure and gas sensor"},{"location":"BME680/#configuration","text":"","title":"Configuration"},{"location":"BME680/#wiring","text":"BME680 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"BME680/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect BME680 automatically and display temperature, humidity, dew point, pressure and gas resistance measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2021-09-22T17:00:00\" , \"BME680\" : { \"Temperature\" : 24.5 , \"Humidity\" : 33.0 , \"DewPoint\" : 7.1 , \"Pressure\" : 987.7 , \"Gas\" : 1086.43 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"BME680/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. TempRes sets temperature resolution. SetOption8 sets temperature unit in Celsius or in Fahrenheit . SetOption24 sets pressure unit in hPa or in mmHg .","title":"Commands"},{"location":"BME680/#breakout-boards","text":"Buy from: - Adafruit - AliExpress","title":"Breakout Boards"},{"location":"BMP280/","text":"","title":"BMP280"},{"location":"BUILDS/","text":"Available Features and Sensors ~ ESP8266 / ESP32 l = lite, t = tasmota, k = knx, s = sensors, i = ir, d = display Note: minimal variant is not listed as it shouldn't be used outside of the upgrading process. Feature or Sensor l t k s i d Remarks MY_LANGUAGE en_GB x x / x x x x x USE_IMPROV x x / x x x x x USE_UFILESYS - - / x - - - - USE_ARDUINO_OTA - - / - - - - - USE_DOMOTICZ - x / x x x x - USE_HOME_ASSISTANT - - / - - - - - USE_TASMOTA_DISCOVERY x x / x x x x x USE_MQTT_TLS* - - / x - - - - USE_MQTT_AWS_IOT - - / - - - - - USE_4K_RSA - - / - - - - - USE_TELEGRAM - - / - - - - - USE_KNX - - / x x - - - USE_WEBSERVER x x / x x x x x USE_WEBSEND_RESPONSE - - / - - - - - USE_EMULATION_HUE x x / x - x - - USE_EMULATION_WEMO x x / x - x - - USE_DISCOVERY - - / - - - - - WEBSERVER_ADVERTISE - x / - x - - x MQTT_HOST_DISCOVERY - - / - - - - - USE_TIMERS x x / x x x x x USE_TIMERS_WEB x x / x x x x x USE_SUNRISE x x / x x x x x USE_RULES x x / x x x x x USE_SCRIPT - - / - - - - - USE_EXPRESSION - - / - - - - - SUPPORT_IF_STATEMENT - - / - - - - - USE_HOTPLUG - - / - - - - - USE_PROMETHEUS - - / - - - - - USE_PING - - / - - - - - Feature or Sensor l t k s i d Remarks ROTARY_V1 - x / x - x - - USE_SONOFF_RF - x / - x x - - USE_RF_FLASH - x / - x x - - USE_SONOFF_SC - x / - x x - - USE_TUYA_MCU x x / - x x - x USE_ARMTRONIX_DIMMERS - x / - x - - - USE_PS_16_DZ - x / - x - - - USE_SONOFF_IFAN - x / - x - - - USE_BUZZER - x / x x x - - USE_ARILUX_RF - x / - x - - - USE_SHUTTER - x / x x - - - USE_DEEPSLEEP - x / x - x - - USE_EXS_DIMMER - x / - x - - - USE_DEVICE_GROUPS - x / x - - - - USE_PWM_DIMMER - x / - x - - - USE_KEELOQ - - / - - - - - USE_SONOFF_D1 - x / - x - - - USE_SHELLY_DIMMER - x / - - - - - USE_AC_ZERO_CROSS_DIMMER - x / x x x x x Feature or Sensor l t k s i d Remarks USE_LIGHT x x / x x x x x USE_WS2812 - x / x x x - x USE_WS2812_DMA - - / - - - - - USE_MY92X1 - x / - x x - x USE_SM16716 - x / - x x - x USE_SM2135 - x / - x x - x USE_SM2335 - x / - x x - x USE_BP5758D - x / - x x - x USE_SONOFF_L1 - x / - x x - x USE_ELECTRIQ_MOODL - x / - x x - x USE_ENERGY_SENSOR x x / x x x - - USE_ENERGY_DUMMY x x / x x x - - USE_PZEM004T - x / x x x - - USE_PZEM_AC - x / x x x - - USE_PZEM_DC - x / x x x - - USE_MCP39F501 x x / - x x - - USE_SDM72 - - / x - x - - USE_SDM120 - - / x - x - - USE_SDM230 - - / x - - - - USE_SDM630 - - / x - x - - USE_DDS2382 - - / x - x - - USE_DDSU666 - - / x - x - - USE_SOLAX_X1 - - / - - - - - USE_LE01MR - - / - - - - - USE_BL09XX x x / x x x - - USE_TELEINFO - - / - - - - - USE_IEM3000 - - / - - - - - USE_WE517 - - / - - - - - USE_ADC_VCC x - / - - - x - USE_COUNTER - x / x x x - x USE_DS18x20 - x / x x x - x USE_DHT - x / x x x - x USE_MAX31855 - - / x - x - - USE_MAX31865 - - / - - - - - USE_THERMOSTAT - - / - - - - - USE_LMT01 - - / x - x - - Feature or Sensor l t k s i d Remarks USE_I2C - x / x x x - x USE_SHT - - / x - x - - USE_HTU - - / x - x - - USE_BMP - - / x - x - - USE_BME68X - - / x - x - - USE_BH1750 - - / x - x - - USE_VEML6070 - - / x - x - - USE_ADS1115 - - / x - x - - USE_INA219 - - / x - x - - USE_INA226 - - / - - - - - USE_SHT3X - - / x - x - - USE_TSL2561 - - / - - - - - USE_TSL2591 - - / - - - - - USE_MGS - - / x - x - - USE_SGP30 - - / x - x - - USE_SI1145 - - / - - - - - USE_LM75AD - - / x - x - - USE_APDS9960 - - / - - - - - USE_MCP230xx - - / - - - - - USE_PCA9685 - - / - - - - - USE_MPR121 - - / - - - - - USE_CCS811 - - / - - x - - USE_CCS811_V2 - - / x - - - - USE_MPU6050 - - / - - - - - USE_DS3231 - - / - - - - - USE_MGC3130 - - / - - - - - USE_MAX44009 - - / - - - - - USE_SCD30 - - / x - x - - USE_SCD40 - - / x - - - - USE_SPS30 - - / - - - - - USE_ADE7880 - - / - - - - - USE_ADE7953 - x / x x x - x USE_VL53L0X - - / x - x - - USE_VL53L1X - - / - - - - - USE_MLX90614 - - / - - - - - USE_CHIRP - - / - - - - - USE_PAJ7620 - - / - - - - - USE_PCF8574 - - / - - - - - Feature or Sensor l t k s i d Remarks USE_HIH6 - - / x - x - - USE_DHT12 - - / x - x - - USE_DS1624 - - / x - x - - USE_AHT1x - - / - - - - - USE_HDC1080 - - / - - - - - USE_WEMOS_MOTOR_V1 - - / x - x - - USE_IAQ - - / x - x - - USE_AS3935 - - / x - x - - USE_VEML6075 - - / - - - - - USE_VEML7700 - - / - - - - - USE_MCP9808 - - / - - - - - USE_MLX90640 - - / - - - - - USE_HP303B - - / - - - - - USE_EZOCO2 - - / - - - - - USE_EZODO - - / - - - - - USE_EZOEC - - / - - - - - USE_EZOFLO - - / - - - - - USE_EZOHUM - - / - - - - - USE_EZOO2 - - / - - - - - USE_EZOORP - - / - - - - - USE_EZOPH - - / - - - - - USE_EZOPMP - - / - - - - - USE_EZOPRS - - / - - - - - USE_EZORGB - - / - - - - - USE_EZORTD - - / - - - - - USE_SEESAW_SOIL - - / - - - - - USE_TOF10120 - - / - - - - - USE_BM8563 - - / - - - - - USE_AM2320 - - / - - - - - USE_T67XX - - / - - - - - USE_HM330X - - / - - - - - USE_HDC2010 - - / - - - - - USE_PCF85363 - - / - - - - - USE_DS3502 - - / - - - - - USE_HYT - - / - - - - - Feature or Sensor l t k s i d Remarks USE_SPI - - / - - - - x USE_RC522 - - / - - - - - USE_MHZ19 - - / x - x - - USE_SENSEAIR - - / x - x - - USE_PMS5003 - - / x - x - - USE_NOVA_SDS - - / x - x - - USE_HPMA - - / x - x - - USE_SERIAL_BRIDGE - x / x x x - x USE_MODBUS_BRIDGE - - / x - - - - USE_MP3_PLAYER - - / x - x - - USE_AZ7798 - - / - - - - - USE_PN532_HSU - - / x - x - - USE_RDM6300 - - / x - x - - USE_IBEACON - - / x - x - - USE_GPS - - / - - - - - USE_HM10 - - / - - x - - USE_HRXL - - / x - x - - USE_TASMOTA_CLIENT - - / - - - - - USE_OPENTHERM - - / - - - - - USE_MIEL_HVAC - - / - - - - - USE_PROJECTOR_CTRL - - / - - - - - USE_AS608 - - / - - - - - USE_TCP_BRIDGE - - / - - - - - zbbridge / zbbrdgpro USE_NRF24 - - / - - - - - USE_MIBLE - - / - - - - - USE_ZIGBEE - - / - - - - - USE_ZIGBEE_ZNP - - / - - - - - USE_ZIGBEE_EZSP - - / - - - - - Sonoff ZbBridge USE_IR_REMOTE - x / - x x x x USE_IR_RECEIVE - x / - x x x x USE_IR_REMOTE_FULL - - / - - - x - Enable ALL protocols USE_SR04 - - / - - x - - USE_DYP - - / - - - - - USE_TM1638 - - / x - x - - USE_HX711 - - / x - x - - USE_TX2x_WIND_SENSOR - - / - - - - - USE_WINDMETER - - / - - - - - USE_RC_SWITCH - - / x - x - - USE_RF_SENSOR - - / x - x - - AlectoV2 only USE_HRE - - / x - x - - USE_A4988_STEPPER - - / - - - - - USE_NEOPOOL - - / - - - - - USE_FLOWRATEMETER - - / - - - - - Feature or Sensor l t k s i d Remarks USE_DISPLAY - - / - - - - x USE_DISPLAY_LCD - - / - - - - x USE_DISPLAY_SSD1306 - - / - - - - x USE_DISPLAY_MATRIX - - / - - - - x USE_DISPLAY_SH1106 - - / - - - - x USE_DISPLAY_ILI9341 - - / - - - - x USE_DISPLAY_EPAPER_29 - - / - - - - x USE_DISPLAY_EPAPER_42 - - / - - - - x USE_DISPLAY_SSD1351 - - / - - - - x USE_DISPLAY_RA8876 - - / - - - - x USE_DISPLAY_ST7789 - - / - - - - x USE_DISPLAY_TM1637 - - / - - - - x USE_DISPLAY_TM1621_SONOFF - - / x - - - - USE_FT5206 - - / - - - - - USE_FTC532 - - / - - - - - USE_BS814A2 - - / - - - - - ESP32 Feature l t k s i d Remarks USE_HALLEFFECT / x USE_MI_ESP32 / x See SetOption115 USE_IBEACON_ESP32 / - USE_WEBCAM / - USE_ETHERNET / x USE_I2S_AUDIO / - USE_TTGO_WATCH / - USE_SONOFF_SPM / x USE_MQTT_TLS is enabled by default in every ESP32 variants","title":"BUILDS"},{"location":"BUILDS/#available-features-and-sensors","text":"ESP8266 / ESP32 l = lite, t = tasmota, k = knx, s = sensors, i = ir, d = display Note: minimal variant is not listed as it shouldn't be used outside of the upgrading process. Feature or Sensor l t k s i d Remarks MY_LANGUAGE en_GB x x / x x x x x USE_IMPROV x x / x x x x x USE_UFILESYS - - / x - - - - USE_ARDUINO_OTA - - / - - - - - USE_DOMOTICZ - x / x x x x - USE_HOME_ASSISTANT - - / - - - - - USE_TASMOTA_DISCOVERY x x / x x x x x USE_MQTT_TLS* - - / x - - - - USE_MQTT_AWS_IOT - - / - - - - - USE_4K_RSA - - / - - - - - USE_TELEGRAM - - / - - - - - USE_KNX - - / x x - - - USE_WEBSERVER x x / x x x x x USE_WEBSEND_RESPONSE - - / - - - - - USE_EMULATION_HUE x x / x - x - - USE_EMULATION_WEMO x x / x - x - - USE_DISCOVERY - - / - - - - - WEBSERVER_ADVERTISE - x / - x - - x MQTT_HOST_DISCOVERY - - / - - - - - USE_TIMERS x x / x x x x x USE_TIMERS_WEB x x / x x x x x USE_SUNRISE x x / x x x x x USE_RULES x x / x x x x x USE_SCRIPT - - / - - - - - USE_EXPRESSION - - / - - - - - SUPPORT_IF_STATEMENT - - / - - - - - USE_HOTPLUG - - / - - - - - USE_PROMETHEUS - - / - - - - - USE_PING - - / - - - - - Feature or Sensor l t k s i d Remarks ROTARY_V1 - x / x - x - - USE_SONOFF_RF - x / - x x - - USE_RF_FLASH - x / - x x - - USE_SONOFF_SC - x / - x x - - USE_TUYA_MCU x x / - x x - x USE_ARMTRONIX_DIMMERS - x / - x - - - USE_PS_16_DZ - x / - x - - - USE_SONOFF_IFAN - x / - x - - - USE_BUZZER - x / x x x - - USE_ARILUX_RF - x / - x - - - USE_SHUTTER - x / x x - - - USE_DEEPSLEEP - x / x - x - - USE_EXS_DIMMER - x / - x - - - USE_DEVICE_GROUPS - x / x - - - - USE_PWM_DIMMER - x / - x - - - USE_KEELOQ - - / - - - - - USE_SONOFF_D1 - x / - x - - - USE_SHELLY_DIMMER - x / - - - - - USE_AC_ZERO_CROSS_DIMMER - x / x x x x x Feature or Sensor l t k s i d Remarks USE_LIGHT x x / x x x x x USE_WS2812 - x / x x x - x USE_WS2812_DMA - - / - - - - - USE_MY92X1 - x / - x x - x USE_SM16716 - x / - x x - x USE_SM2135 - x / - x x - x USE_SM2335 - x / - x x - x USE_BP5758D - x / - x x - x USE_SONOFF_L1 - x / - x x - x USE_ELECTRIQ_MOODL - x / - x x - x USE_ENERGY_SENSOR x x / x x x - - USE_ENERGY_DUMMY x x / x x x - - USE_PZEM004T - x / x x x - - USE_PZEM_AC - x / x x x - - USE_PZEM_DC - x / x x x - - USE_MCP39F501 x x / - x x - - USE_SDM72 - - / x - x - - USE_SDM120 - - / x - x - - USE_SDM230 - - / x - - - - USE_SDM630 - - / x - x - - USE_DDS2382 - - / x - x - - USE_DDSU666 - - / x - x - - USE_SOLAX_X1 - - / - - - - - USE_LE01MR - - / - - - - - USE_BL09XX x x / x x x - - USE_TELEINFO - - / - - - - - USE_IEM3000 - - / - - - - - USE_WE517 - - / - - - - - USE_ADC_VCC x - / - - - x - USE_COUNTER - x / x x x - x USE_DS18x20 - x / x x x - x USE_DHT - x / x x x - x USE_MAX31855 - - / x - x - - USE_MAX31865 - - / - - - - - USE_THERMOSTAT - - / - - - - - USE_LMT01 - - / x - x - - Feature or Sensor l t k s i d Remarks USE_I2C - x / x x x - x USE_SHT - - / x - x - - USE_HTU - - / x - x - - USE_BMP - - / x - x - - USE_BME68X - - / x - x - - USE_BH1750 - - / x - x - - USE_VEML6070 - - / x - x - - USE_ADS1115 - - / x - x - - USE_INA219 - - / x - x - - USE_INA226 - - / - - - - - USE_SHT3X - - / x - x - - USE_TSL2561 - - / - - - - - USE_TSL2591 - - / - - - - - USE_MGS - - / x - x - - USE_SGP30 - - / x - x - - USE_SI1145 - - / - - - - - USE_LM75AD - - / x - x - - USE_APDS9960 - - / - - - - - USE_MCP230xx - - / - - - - - USE_PCA9685 - - / - - - - - USE_MPR121 - - / - - - - - USE_CCS811 - - / - - x - - USE_CCS811_V2 - - / x - - - - USE_MPU6050 - - / - - - - - USE_DS3231 - - / - - - - - USE_MGC3130 - - / - - - - - USE_MAX44009 - - / - - - - - USE_SCD30 - - / x - x - - USE_SCD40 - - / x - - - - USE_SPS30 - - / - - - - - USE_ADE7880 - - / - - - - - USE_ADE7953 - x / x x x - x USE_VL53L0X - - / x - x - - USE_VL53L1X - - / - - - - - USE_MLX90614 - - / - - - - - USE_CHIRP - - / - - - - - USE_PAJ7620 - - / - - - - - USE_PCF8574 - - / - - - - - Feature or Sensor l t k s i d Remarks USE_HIH6 - - / x - x - - USE_DHT12 - - / x - x - - USE_DS1624 - - / x - x - - USE_AHT1x - - / - - - - - USE_HDC1080 - - / - - - - - USE_WEMOS_MOTOR_V1 - - / x - x - - USE_IAQ - - / x - x - - USE_AS3935 - - / x - x - - USE_VEML6075 - - / - - - - - USE_VEML7700 - - / - - - - - USE_MCP9808 - - / - - - - - USE_MLX90640 - - / - - - - - USE_HP303B - - / - - - - - USE_EZOCO2 - - / - - - - - USE_EZODO - - / - - - - - USE_EZOEC - - / - - - - - USE_EZOFLO - - / - - - - - USE_EZOHUM - - / - - - - - USE_EZOO2 - - / - - - - - USE_EZOORP - - / - - - - - USE_EZOPH - - / - - - - - USE_EZOPMP - - / - - - - - USE_EZOPRS - - / - - - - - USE_EZORGB - - / - - - - - USE_EZORTD - - / - - - - - USE_SEESAW_SOIL - - / - - - - - USE_TOF10120 - - / - - - - - USE_BM8563 - - / - - - - - USE_AM2320 - - / - - - - - USE_T67XX - - / - - - - - USE_HM330X - - / - - - - - USE_HDC2010 - - / - - - - - USE_PCF85363 - - / - - - - - USE_DS3502 - - / - - - - - USE_HYT - - / - - - - - Feature or Sensor l t k s i d Remarks USE_SPI - - / - - - - x USE_RC522 - - / - - - - - USE_MHZ19 - - / x - x - - USE_SENSEAIR - - / x - x - - USE_PMS5003 - - / x - x - - USE_NOVA_SDS - - / x - x - - USE_HPMA - - / x - x - - USE_SERIAL_BRIDGE - x / x x x - x USE_MODBUS_BRIDGE - - / x - - - - USE_MP3_PLAYER - - / x - x - - USE_AZ7798 - - / - - - - - USE_PN532_HSU - - / x - x - - USE_RDM6300 - - / x - x - - USE_IBEACON - - / x - x - - USE_GPS - - / - - - - - USE_HM10 - - / - - x - - USE_HRXL - - / x - x - - USE_TASMOTA_CLIENT - - / - - - - - USE_OPENTHERM - - / - - - - - USE_MIEL_HVAC - - / - - - - - USE_PROJECTOR_CTRL - - / - - - - - USE_AS608 - - / - - - - - USE_TCP_BRIDGE - - / - - - - - zbbridge / zbbrdgpro USE_NRF24 - - / - - - - - USE_MIBLE - - / - - - - - USE_ZIGBEE - - / - - - - - USE_ZIGBEE_ZNP - - / - - - - - USE_ZIGBEE_EZSP - - / - - - - - Sonoff ZbBridge USE_IR_REMOTE - x / - x x x x USE_IR_RECEIVE - x / - x x x x USE_IR_REMOTE_FULL - - / - - - x - Enable ALL protocols USE_SR04 - - / - - x - - USE_DYP - - / - - - - - USE_TM1638 - - / x - x - - USE_HX711 - - / x - x - - USE_TX2x_WIND_SENSOR - - / - - - - - USE_WINDMETER - - / - - - - - USE_RC_SWITCH - - / x - x - - USE_RF_SENSOR - - / x - x - - AlectoV2 only USE_HRE - - / x - x - - USE_A4988_STEPPER - - / - - - - - USE_NEOPOOL - - / - - - - - USE_FLOWRATEMETER - - / - - - - - Feature or Sensor l t k s i d Remarks USE_DISPLAY - - / - - - - x USE_DISPLAY_LCD - - / - - - - x USE_DISPLAY_SSD1306 - - / - - - - x USE_DISPLAY_MATRIX - - / - - - - x USE_DISPLAY_SH1106 - - / - - - - x USE_DISPLAY_ILI9341 - - / - - - - x USE_DISPLAY_EPAPER_29 - - / - - - - x USE_DISPLAY_EPAPER_42 - - / - - - - x USE_DISPLAY_SSD1351 - - / - - - - x USE_DISPLAY_RA8876 - - / - - - - x USE_DISPLAY_ST7789 - - / - - - - x USE_DISPLAY_TM1637 - - / - - - - x USE_DISPLAY_TM1621_SONOFF - - / x - - - - USE_FT5206 - - / - - - - - USE_FTC532 - - / - - - - - USE_BS814A2 - - / - - - - - ESP32 Feature l t k s i d Remarks USE_HALLEFFECT / x USE_MI_ESP32 / x See SetOption115 USE_IBEACON_ESP32 / - USE_WEBCAM / - USE_ETHERNET / x USE_I2S_AUDIO / - USE_TTGO_WATCH / - USE_SONOFF_SPM / x USE_MQTT_TLS is enabled by default in every ESP32 variants","title":"Available Features and Sensors"},{"location":"Berry-Cookbook/","text":"Berry Cookbook ~ Adding commands to Tasmota ~ It is very easy to dynamically add a command to Tasmota with Berry. Trivial example ~ Let's start with the most simple command. Let's define a command BrGC that triggers a garbage collection and returns the memory allocated by Berry. We first define the function: def br_gc () var allocated = tasmota . gc () #- trigger gc and return allocated memory -# import string tasmota . resp_cmnd ( string . format ( '{\"BrGc\": %i }' , allocated )) end And register the function: tasmota . add_cmd ( 'BrGc' , br_gc ) Then in Tasmota Console: brgc 21:04:30.369 CMD : brgc 21:04:30.376 RSL : stat/tasmota_923B34/RESULT = {\"BrGc\":5767} General form of the custom command function ~ The custom command function have the general form below where parameters are optionals: def function_name ( cmd , idx , payload , payload_json ) ... end Parameter Description cmd string name of the command in lower case. Can be used if same function is used for multiple similar commands for example. idx Command's index is the unsigned integer (optionally) added at the end of the command name before the parameters (like Demo1 ). Default to 1 if not specified. payload string of the command line as without any parsing. payload_json if the payload is a valid JSON, it is converted into a Berry map object. More complete example ~ In this example, we will create a new command called LightGold that turns the light on and sets it to color gold #FFD700. This command accepts an optional JSON payload with the argument Dimmer ranging from 0..100. First we define a new Berry function with the logic. This function takes 4 arguments: cmd : the command name (with same case as it was registered). This is useful if you want to share the same code in multiple commands. Here cmd is LightGold idx : the command index used, default to 1. payload : the raw payload of the command as string payload_json : the payload parsed as JSON, or nil if the payload is not JSON Example: command lightgold : cmd = LightGold , idx =1, payload = \"\" , payload_json = nil command LIGHTGOLD2 : cmd = LightGold , idx =2, payload = \"\" , payload_json = nil command lightgold not sure : cmd = LightGold , idx =1, payload = 'not sure' , payload_json = nil command lightgold {\"value\":\"some\"} : cmd = LightGold , idx =1, payload = '{\"value\":\"some\"}' , payload_json = {'value':'some'} In Berry, arguments are always optional, so you don't need to define them if you don't need them. def light_gold ( cmd , idx , payload , payload_json ) var dimmer = 50 #- default brightness to 50% -# var bri # parse payload if payload_json != nil && payload_json . find ( \"Dimmer\" ) != nil # does the payload contain a 'dimmer' field dimmer = int ( payload_json . find ( \"Dimmer\" )) end # set_light expects a brightness in range 0..255 bri = tasmota . scale_uint ( dimmer , 0 , 100 , 0 , 255 ) # build the payload for set_light var light_payload = { 'power' : true , 'rgb' : 'FFD700' , 'bri' : bri } #- set the light values -# tasmota . set_light ( light_payload ) # report the command as successful tasmota . resp_cmnd_done () end Finally you need to register the command: tasmota . add_cmd ( 'LightGold' , light_gold ) Example (in Tasmota console, not Berry console): lightgold 20:53:28.142 CMD : lightgold 20:53:28.151 RSL : stat/tasmota_923B34/RESULT = {\"POWER\":\"ON\"} 20:53:28.153 RSL : stat/tasmota_923B34/POWER = ON 20:53:28.160 RSL : stat/tasmota_923B34/RESULT = {\"LightGold\":\"Done\"} lightgold {\"Dimmer\":20} 20:54:16.837 CMD : lightgold {\"Dimmer\":20} 20:54:16.848 RSL : stat/tasmota_923B34/RESULT = {\"LightGold\":\"Done\"} Responding to commands ~ Tasmota expects that you send a response to commands. You can use the following methods: tasmota.resp_cmnd_done() : report command as Done (including trasnlated versions) tasmota.resp_cmnd_error() : report command as Error tasmota.resp_cmnd_failed() : report command as Failed tasmota.resp_cmnd_str(<msg>) : report an arbitrary string tasmota.resp_cmd(<json>) : report a custom JSON message (not prefixed by command name). Adding a button to the Main menu ~ Adding a button to the e.g. main menu can be achieved by using the message type web_add_main_button() . The method to be performed, when the user clicks the button is achieved by using the web_sensor() method checking for the presence of an argument and a possible value assigned to the argument. The class provides the necessary methods to read the arguments: webserver.has_arg(arg_name:string) : -> boolean, checks if an argument with this name exists webserver.arg_size() : -> integer, returns the number of arguments webserver.arg(arg_name:string or arg_index:int) : -> string, returns the value of the argument either by name or by position number [0..arg_size()-1]. If an argument has multiple values, you need to iterate using ints to get all values webserver.arg_name(arg_index:int) -> string, get the name of argument by index [0..arg_size()-1] Additionally the webserver class provides a new function of sending information to the Web UI by using the following methods webserver.content_send(content:string) webserver.content_send_style(content:string) Let's see an example implementation of button methods in a Driver class import webserver # import webserver class class MyButtonMethods : Driver def myOtherFunction ( myValue ) #- do something -# end #- create a method for adding a button to the main menu -# def web_add_main_button () webserver . content_send ( \"<p></p><button onclick='la( \\\" &m_toggle_main=1 \\\" );'>Toggle Main</button>\" ) end #- create a method for adding a button to the configuration menu-# def web_add_config_button () #- the onclick function \"la\" takes the function name and the respective value you want to send as an argument -# webserver . content_send ( \"<p></p><button onclick='la( \\\" &m_toggle_conf=1 \\\" );'>Toggle Conf</button>\" ) end #- As we can add only one sensor method we will have to combine them besides all other sensor readings in one method -# def web_sensor () if webserver . has_arg ( \"m_toggle_main\" ) print ( \"button pressed\" ) end if webserver . has_arg ( \"m_toggle_conf\" ) # takes a string as argument name and returns a boolean # we can even call another function and use the value as a parameter var myValue = int ( webserver . arg ( \"m_toggle_conf\" )) # takes a string or integer(index of arguments) to get the value of the argument self . myOtherFunction ( myValue ) end end end d1 = MyButtonMethods () tasmota . add_driver ( d1 ) Creating an I2C driver ~ Berry Scripting provides all necessary primitves for a complete I2C driver. Step by step approach ~ We will explore the different steps to write an I2C driver, and will take the MPU6886 as an example. The native driver already exists, and we'll rewrite it in Berry code. Step 1: detect the device I2C device are identified by address, only one device per address is allowed per I2C physical bus. Tasmota32 supports up to 2 I2C buses, using wire1 or wire2 objects. To simplify device detection, we provide the convenience method tasmota.scan_wire() . The first argument is the device address (0x68 for MPU6886). The optional second argument is the I2C Tasmota index, allowing to selectively disable some device families. See I2CDevice command and page XXX. The index number for MPU6886 is 58. class MPU6886 : Driver var wire # contains the wire object if the device was detected def init () self . wire = tasmota . wire_scan ( 0x68 , 58 ) end end self.wire contains a reference to wire1 if the device was detected on I2C bus 1, a reference to wire2 if the device was detected on bus 2, or nil if the device was not detected, or if I2C index 58 was disabled through I2CEnable . Step 2: verify the device To make sure the device is actually an MPU6886, we check it's signature by reading register 0x75. It should respond 0x19 (see datasheet for MPU6886). [ ... ] if self . wire var v = self . wire . read ( 0x68 , 0x75 , 1 ) if v != 0x19 return end #- wrong device -# [ ... ] Step 3: initialize the device We write a series of values in registers to configure the device as expected (see datasheet). [ ... ] self . wire . write ( 0x68 , 0x6B , 0 , 1 ) tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x6B , 1 << 7 , 1 ) # MPU6886_PWR_MGMT_1 tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x6B , 1 << 0 , 1 ) # MPU6886_PWR_MGMT_1 tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x1C , 0x10 , 1 ) # MPU6886_ACCEL_CONFIG - AFS_8G tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1B , 0x18 , 1 ) # MPU6886_GYRO_CONFIG - GFS_2000DPS tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1A , 0x01 , 1 ) # MPU6886_CONFIG tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x19 , 0x05 , 1 ) # MPU6886_SMPLRT_DIV tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x38 , 0x00 , 1 ) # MPU6886_INT_ENABLE tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1D , 0x00 , 1 ) # MPU6886_ACCEL_CONFIG2 tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x6A , 0x00 , 1 ) # MPU6886_USER_CTRL tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x23 , 0x00 , 1 ) # MPU6886_FIFO_EN tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x37 , 0x22 , 1 ) # MPU6886_INT_PIN_CFG tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x38 , 0x01 , 1 ) # MPU6886_INT_ENABLE tasmota . delay ( 100 ) [ ... ] We also pre-compute multipler to convert raw values to actual values: [ ... ] self . gres = 2000.0 / 32768.0 self . ares = 8.0 / 32678.0 print ( \"I2C: MPU6886 detected on bus \" + str ( self . wire . bus )) [ ... ] Step 4: read sensor value We will detail here the acceleration senor; gyroscope works similarly and is not further detailed. Reading the x/y/z sensor requires to read 6 bytes as a bytes() object var b = self . wire . read_bytes ( 0x68 , 0x3B , 6 ) Each value is 2 bytes. We use bytes.get(offset,size) to extract 2-bytes values at offsets 0/2/4. The size is -2 to indicate that values are encoded in Big Endian instead of Little Endian. var a1 = b . get ( 0 , - 2 ) Finally the read value is unsigned 16 bits, but the sensor value is signed 16 bits. We convert 16 bits unsigned to 16 bits signed. if a1 >= 0x8000 a1 -= 0x10000 end We then repeat for y and z: def read_accel () if ! self . wire return nil end #- exit if not initialized -# var b = self . wire . read_bytes ( 0x68 , 0x3B , 6 ) var a1 = b . get ( 0 , - 2 ) if a1 >= 0x8000 a1 -= 0x10000 end var a2 = b . get ( 2 , - 2 ) if a2 >= 0x8000 a2 -= 0x10000 end var a3 = b . get ( 4 , - 2 ) if a3 >= 0x8000 a3 -= 0x10000 end self . accel = [ a1 * self . ares , a2 * self . ares , a3 * self . ares ] return self . accel end Step 5: read sensor every second Simply override every_second() def every_second () if ! self . wire return nil end #- exit if not initialized -# self . read_accel () self . read_gyro () end Step 6: display sensor value in Web UI You need to override web_sensor() and provide the formatted string. tasmota.web_send_decimal() sends a string to the Web UI, and converts decimal numbers according to the locale settings. Tasmota uses specific markers: {s} : start of line {m} : separator between name and value {e} : end of line #- display sensor value in the web UI -# def web_sensor () if ! self . wire return nil end #- exit if not initialized -# import string var msg = string . format ( \" {s} MPU6886 acc_x {m}%.3f G {e} \" .. \" {s} MPU6886 acc_y {m}%.3f G {e} \" .. \" {s} MPU6886 acc_z {m}%.3f G {e} \" .. \" {s} MPU6886 gyr_x {m}%i dps {e} \" .. \" {s} MPU6886 gyr_y {m}%i dps {e} \" .. \" {s} MPU6886 gyr_z {m}%i dps {e} \" , self . accel [ 0 ], self . accel [ 1 ], self . accel [ 2 ], self . gyro [ 0 ], self . gyro [ 1 ], self . gyro [ 2 ]) tasmota . web_send_decimal ( msg ) end Step 7: publish JSON TelePeriod sensor value Similarly to Web UI, publish sensor value as JSON. #- add sensor value to teleperiod -# def json_append () if ! self . wire return nil end #- exit if not initialized -# import string var ax = int ( self . accel [ 0 ] * 1000 ) var ay = int ( self . accel [ 1 ] * 1000 ) var az = int ( self . accel [ 2 ] * 1000 ) var msg = string . format ( \", \\\" MPU6886 \\\" :{ \\\" AX \\\" : %i , \\\" AY \\\" : %i , \\\" AZ \\\" : %i , \\\" GX \\\" : %i , \\\" GY \\\" : %i , \\\" GZ \\\" : %i }\" , ax , ay , az , self . gyro [ 0 ], self . gyro [ 1 ], self . gyro [ 2 ]) tasmota . response_append ( msg ) end Full example ~ The code can be loaded manually with copy/paste, or stored in flash and loaded at startup in autoexec.be as load(\"mpu6886.be\") . Alternatively it can be loaded with a Tasmota native command or rule: Br load(\"mpu6886.be\") See code example below for MPU6886: #- - Example of I2C driver written in Berry - - Support for MPU6886 device found in M5Stack - Alternative to xsns_85_mpu6886 . ino - # class MPU6886 : Driver var wire #- if wire == nil then the module is not initialized -# var gres , ares var accel , gyro def init () self . wire = tasmota . wire_scan ( 0x68 , 58 ) if self . wire var v = self . wire . read ( 0x68 , 0x75 , 1 ) if v != 0x19 return end #- wrong device -# self . wire . write ( 0x68 , 0x6B , 0 , 1 ) tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x6B , 1 << 7 , 1 ) # MPU6886_PWR_MGMT_1 tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x6B , 1 << 0 , 1 ) # MPU6886_PWR_MGMT_1 tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x1C , 0x10 , 1 ) # MPU6886_ACCEL_CONFIG - AFS_8G tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1B , 0x18 , 1 ) # MPU6886_GYRO_CONFIG - GFS_2000DPS tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1A , 0x01 , 1 ) # MPU6886_CONFIG tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x19 , 0x05 , 1 ) # MPU6886_SMPLRT_DIV tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x38 , 0x00 , 1 ) # MPU6886_INT_ENABLE tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1D , 0x00 , 1 ) # MPU6886_ACCEL_CONFIG2 tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x6A , 0x00 , 1 ) # MPU6886_USER_CTRL tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x23 , 0x00 , 1 ) # MPU6886_FIFO_EN tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x37 , 0x22 , 1 ) # MPU6886_INT_PIN_CFG tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x38 , 0x01 , 1 ) # MPU6886_INT_ENABLE tasmota . delay ( 100 ) self . gres = 2000.0 / 32768.0 self . ares = 8.0 / 32678.0 print ( \"I2C: MPU6886 detected on bus \" + str ( self . wire . bus )) end end #- returns a list of 3 axis, float as g acceleration -# def read_accel () if ! self . wire return nil end #- exit if not initialized -# var b = self . wire . read_bytes ( 0x68 , 0x3B , 6 ) var a1 = b . get ( 0 , - 2 ) if a1 >= 0x8000 a1 -= 0x10000 end var a2 = b . get ( 2 , - 2 ) if a2 >= 0x8000 a2 -= 0x10000 end var a3 = b . get ( 4 , - 2 ) if a3 >= 0x8000 a3 -= 0x10000 end self . accel = [ a1 * self . ares , a2 * self . ares , a3 * self . ares ] return self . accel end #- returns a list of 3 gyroscopes, int as dps (degree per second) -# def read_gyro () if ! self . wire return nil end #- exit if not initialized -# var b = self . wire . read_bytes ( 0x68 , 0x43 , 6 ) var g1 = b . get ( 0 , - 2 ) if g1 >= 0x8000 g1 -= 0x10000 end var g2 = b . get ( 2 , - 2 ) if g2 >= 0x8000 g2 -= 0x10000 end var g3 = b . get ( 4 , - 2 ) if g3 >= 0x8000 g3 -= 0x10000 end self . gyro = [ int ( g1 * self . gres ), int ( g2 * self . gres ), int ( g3 * self . gres )] return self . gyro end #- trigger a read every second -# def every_second () if ! self . wire return nil end #- exit if not initialized -# self . read_accel () self . read_gyro () end #- display sensor value in the web UI -# def web_sensor () if ! self . wire return nil end #- exit if not initialized -# import string var msg = string . format ( \" {s} MPU6886 acc_x {m}%.3f G {e} \" .. \" {s} MPU6886 acc_y {m}%.3f G {e} \" .. \" {s} MPU6886 acc_z {m}%.3f G {e} \" .. \" {s} MPU6886 gyr_x {m}%i dps {e} \" .. \" {s} MPU6886 gyr_y {m}%i dps {e} \" .. \" {s} MPU6886 gyr_z {m}%i dps {e} \" , self . accel [ 0 ], self . accel [ 1 ], self . accel [ 2 ], self . gyro [ 0 ], self . gyro [ 1 ], self . gyro [ 2 ]) tasmota . web_send_decimal ( msg ) end #- add sensor value to teleperiod -# def json_append () if ! self . wire return nil end #- exit if not initialized -# import string var ax = int ( self . accel [ 0 ] * 1000 ) var ay = int ( self . accel [ 1 ] * 1000 ) var az = int ( self . accel [ 2 ] * 1000 ) var msg = string . format ( \", \\\" MPU6886 \\\" :{ \\\" AX \\\" : %i , \\\" AY \\\" : %i , \\\" AZ \\\" : %i , \\\" GX \\\" : %i , \\\" GY \\\" : %i , \\\" GZ \\\" : %i }\" , ax , ay , az , self . gyro [ 0 ], self . gyro [ 1 ], self . gyro [ 2 ]) tasmota . response_append ( msg ) end end mpu6886 = MPU6886 () tasmota . add_driver ( mpu6886 ) LVGL Touchscreen with 3 Relays ~ #- start LVGL and init environment -# lv . start () hres = lv . get_hor_res () # should be 240 vres = lv . get_ver_res () # should be 320 scr = lv . scr_act () # default screean object f20 = lv . montserrat_font ( 20 ) # load embedded Montserrat 20 f28 = lv . montserrat_font ( 28 ) # load embedded Montserrat 28 #- Backgroun -# scr . set_style_local_bg_color ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv_color ( 0x000066 )) # backgroun in dark blue #000066 #- Upper state line -# stat_line = lv_label ( scr ) if f20 != nil stat_line . set_style_local_text_font ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , f20 ) end stat_line . set_long_mode ( lv . LABEL_LONG_SROLL ) # auto scrolling if text does not fit stat_line . set_width ( hres ) stat_line . set_align ( lv . LABEL_ALIGN_LEFT ) # align text left stat_line . set_style_local_bg_color ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv_color ( 0x000088 )) # background #000088 stat_line . set_style_local_bg_opa ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv . OPA_COVER ) # 100% background opacity stat_line . set_style_local_text_color ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv_color ( 0xFFFFFF )) # text color #FFFFFF stat_line . set_text ( \"Tasmota\" ) stat_line_height = stat_line . get_height () #- display wifi strength indicator icon (for professionals ;) -# stat_line . set_style_local_pad_right ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , stat_line_height + 1 ) wifi_bars = lv_wifi_bars ( stat_line ) wifi_bars . set_style_local_bg_color ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv_color ( lv . BLACK )) wifi_bars . set_height ( stat_line_height ) wifi_bars . set_width ( stat_line_height ) wifi_bars . set_x ( stat_line . get_width () - stat_line_height ) #- create a style for the buttons -# btn_style = lv_style () btn_style . set_radius ( lv . STATE_DEFAULT , 10 ) # radius of rounded corners btn_style . set_bg_opa ( lv . STATE_DEFAULT , lv . OPA_COVER ) # 100% backgrond opacity if f28 != nil btn_style . set_text_font ( lv . STATE_DEFAULT , f28 ) end btn_style . set_bg_color ( lv . STATE_DEFAULT , lv_color ( 0x33BBFF )) # background color #1FA3EC (Tasmota Blue) btn_style . set_border_color ( lv . STATE_DEFAULT , lv_color ( 0x0000FF )) # border color #0000FF #btn_style.set_bg_color(lv.STATE_FOCUSED, lv_color(0x0000FF)) # background color when pressed #0000FF #btn_style.set_border_color(lv.STATE_FOCUSED, lv_color(0xFFFFFF)) # border color when pressed #FFFFFF btn_style . set_text_color ( lv . STATE_DEFAULT , lv_color ( 0x000000 )) # text color #FFFFFF #- enabled -# btn_style . set_bg_color ( lv . STATE_CHECKED , lv_color ( 0x0000FF )) # background color #1FA3EC (Tasmota Blue) btn_style . set_text_color ( lv . STATE_CHECKED , lv_color ( 0xFFFFFF )) # text color #FFFFFF btn_style . set_outline_width ( lv . STATE_FOCUSED , 0 ) # rmove focus outline, not needed with touchscreen #- register buttons -# var btns = [] # relay buttons are added to this list to match with Tasmota relays #- simple function to find the index of an element in a list -# def findinlist ( l , x ) for i : 0. . size ( l ) - 1 if l [ i ] == x return i end end end #- callback function when a button is pressed -# #- checks if the button is in the list, and react to EVENT_VALUE_CHANGED event -# def btn_event_cb ( o , event ) var btn_idx = findinlist ( btns , o ) if btn_idx != nil && event == lv . EVENT_VALUE_CHANGED var val = o . get_state () < lv . BTN_STATE_CHECKED_RELEASED # true if checked, false if unchecked tasmota . set_power ( btn_idx , ! val ) # toggle the value end end #- create a button object, set style, register callback and add to global list -# #- you still need to re-position the button -# def create_btn_relay ( label ) var btn , btn_label btn = lv_btn ( scr ) btn . set_pos ( 30 , 30 ) btn . set_size ( hres - 60 , 60 ) btn . add_style ( lv . OBJ_PART_MAIN , btn_style ) btn . set_checkable ( true ) # enable toggle mode btn_label = lv_label ( btn ) btn_label . set_text ( label ) btn . set_event_cb ( btn_event_cb ) # set callback to update Tasmota relays btns . push ( btn ) # append button to the list return btn end #- create 3 buttons -# var btn1 = create_btn_relay ( \"Relay 1\" ) btn1 . set_y ( 30 ) var btn2 = create_btn_relay ( \"Relay 2\" ) btn2 . set_y ( 100 ) var btn3 = create_btn_relay ( \"Relay 3\" ) btn3 . set_y ( 170 ) #- update the buttons values according to internal relays status -# def btns_update () var power_list = tasmota . get_power () # get a list of booleans with status of each relay for b : btns var state = b . get_state () var power_state = ( size ( power_list ) > 0 ) ? power_list . pop ( 0 ) : false # avoid exception if less relays than buttons if state != lv . BTN_STATE_PRESSED && state != lv . BTN_STATE_CHECKED_PRESSED # update only if the button is not currently being pressed b . set_state ( power_state ? lv . BTN_STATE_CHECKED_RELEASED : lv . BTN_STATE_RELEASED ) end end end #- update every 500ms -# def btns_update_loop () btns_update () tasmota . set_timer ( 500 , btns_update_loop ) end btns_update_loop () # start # If you change the style after creating the button, you need to update objects: def btns_refresh_style () for b : btns b . refresh_style ( lv . OBJ_PART_MAIN , lv . STYLE_PROP_ALL ) end end # Button states, read and set with: # btn1.get_state() or btn1.set_state(lv.BTN_STATE_CHECKED_RELEASED) # Ex: # btn1.set_state(lv.BTN_STATE_RELEASED) # btn1.set_state(lv.BTN_STATE_CHECKED_RELEASED) #- Here are the states for buttons -# # BTN_STATE_RELEASED # BTN_STATE_PRESSED # BTN_STATE_DISABLED # BTN_STATE_CHECKED_RELEASED # BTN_STATE_CHECKED_PRESSED # BTN_STATE_CHECKED_DISABLED Multi-Zone Heating Controller ~ This project is a multi-zone heating controller written entirely in berry. It demonstrates the use of the persist module for saving/loading data; the webserver module for creating a custom \"Manage Heating\" user interface; dynamic loading of HTML from the file system; subscribing to a variety of rule triggers (using tasmota.add_rule); the implementation of custom commands (using tasmota.add_cmnd). It also makes good use of time functionaity (via tasmota.rtc, tasmota.time_dump, tasmota.set_timer and tasmota.strftime). The project also includes an LCD I2C driver for running a basic 20x4 display. The entire driver is implemented using just the tasmota.wire_scan method. https://github.com/Beormund/Tasmota32-Multi-Zone-Heating-Controller Ethernet Network Flipper ~ Used on board with Ethernet. If both Wi-Fi and Ethernet are active, turn off Wi-Fi. Place code in autoexec.be to execute on boot. You can call the function from Berry console any time with netflip() . def netflip() var eth = tasmota.eth().find('ip') != nil #1 if tasmota.wifi().find('ip') != nil == eth #2 tasmota.cmd('Wifi ' .. (eth ? 0 : 1)) #3 end end tasmota.set_timer(30000,netflip) #4 1. store variable \"eth\" with Ethernet status - \"true\" if Ethernet IP exists and \"false\" if not 2. check if wifi status is true and compare to eth status 3. send command Wifi with parameter depending on eth variable. .. is to concatenate a string. See Berry [manualg(https://github.com/berry-lang/berry/wiki/Chapter-3#-operator-1) 4. set a timer to execute the netflip function 30000ms (30 seconds) after loading autoexec.be TMP117 Driver ~ TomsTek@GitHub Call function at intervals ~ This small helper function allows you to call a function at stable intervals, automatically correcting in case of latency or other deviations. Not suitable for very short intervals; while the delay interval is in milliseconds for consistency with the standard tasmota.set_timer , it would normally be seconds multiplied by 1000, like 60000 for every minute. def set_timer_modulo(delay,f) var now=tasmota.millis() tasmota.set_timer((now+delay/4+delay)/delay*delay-now, def() set_timer_modulo(delay,f) f() end) end H-bridge control ~ An H-bridge is an electronic circuit that switches the polarity of a voltage applied to a load. These circuits are often used in robotics and other applications to allow DC motors to run forwards or backwards. You can typically use 2 PWM channels to pilot a H-bridge, under the condition that both channels are never active at the same time; otherwise you may detroy your device. This means that phasing must be calculated so that one pulse started once the other pulse is inactive, and the sum of both dutys must not exceed 100%. The following Berry function ensures appropriate management of H-bridge: # # H_bridge class in Berry to pilot a H-bridge device # class H_bridge var gpio1 , gpio2 var max # init(phy_gpio1, phy_gpio2) - intialize H-bridge with the 2 GPIOs used to control it def init ( gpio1 , gpio2 ) self . gpio1 = gpio1 self . gpio2 = gpio2 self . max = 1023 # max value of duty end # set the value of both PWM values def set ( v1 , v2 ) if v1 < 0 v1 = 0 end if v2 < 0 v2 = 0 end if v1 + v2 > self . max raise \"value_error\" , \"the sum of duties must not exceed 100%\" end import gpio gpio . set_pwm ( self . gpio1 , v1 , 0 ) gpio . set_pwm ( self . gpio2 , v2 , v1 ) # dephase by value v1 end end Example of use: var hbridge = H_bridge ( 12 , 13 ) # use GPIO12 and GPIO13 hbridge . set ( 100 , 200 ) # set values to 102/1023 and 204/1023, i.e. 10% and 20% hbridge . set ( 100 , 950 ) # set values to 102/1023 and 950/1023, i.e. 10% and 93% BRY : Exception > 'value_error' - the sum of duties must not exceed 100 %","title":"Berry Cookbook"},{"location":"Berry-Cookbook/#berry-cookbook","text":"","title":"Berry Cookbook"},{"location":"Berry-Cookbook/#adding-commands-to-tasmota","text":"It is very easy to dynamically add a command to Tasmota with Berry.","title":"Adding commands to Tasmota"},{"location":"Berry-Cookbook/#trivial-example","text":"Let's start with the most simple command. Let's define a command BrGC that triggers a garbage collection and returns the memory allocated by Berry. We first define the function: def br_gc () var allocated = tasmota . gc () #- trigger gc and return allocated memory -# import string tasmota . resp_cmnd ( string . format ( '{\"BrGc\": %i }' , allocated )) end And register the function: tasmota . add_cmd ( 'BrGc' , br_gc ) Then in Tasmota Console: brgc 21:04:30.369 CMD : brgc 21:04:30.376 RSL : stat/tasmota_923B34/RESULT = {\"BrGc\":5767}","title":"Trivial example"},{"location":"Berry-Cookbook/#general-form-of-the-custom-command-function","text":"The custom command function have the general form below where parameters are optionals: def function_name ( cmd , idx , payload , payload_json ) ... end Parameter Description cmd string name of the command in lower case. Can be used if same function is used for multiple similar commands for example. idx Command's index is the unsigned integer (optionally) added at the end of the command name before the parameters (like Demo1 ). Default to 1 if not specified. payload string of the command line as without any parsing. payload_json if the payload is a valid JSON, it is converted into a Berry map object.","title":"General form of the custom command function"},{"location":"Berry-Cookbook/#more-complete-example","text":"In this example, we will create a new command called LightGold that turns the light on and sets it to color gold #FFD700. This command accepts an optional JSON payload with the argument Dimmer ranging from 0..100. First we define a new Berry function with the logic. This function takes 4 arguments: cmd : the command name (with same case as it was registered). This is useful if you want to share the same code in multiple commands. Here cmd is LightGold idx : the command index used, default to 1. payload : the raw payload of the command as string payload_json : the payload parsed as JSON, or nil if the payload is not JSON Example: command lightgold : cmd = LightGold , idx =1, payload = \"\" , payload_json = nil command LIGHTGOLD2 : cmd = LightGold , idx =2, payload = \"\" , payload_json = nil command lightgold not sure : cmd = LightGold , idx =1, payload = 'not sure' , payload_json = nil command lightgold {\"value\":\"some\"} : cmd = LightGold , idx =1, payload = '{\"value\":\"some\"}' , payload_json = {'value':'some'} In Berry, arguments are always optional, so you don't need to define them if you don't need them. def light_gold ( cmd , idx , payload , payload_json ) var dimmer = 50 #- default brightness to 50% -# var bri # parse payload if payload_json != nil && payload_json . find ( \"Dimmer\" ) != nil # does the payload contain a 'dimmer' field dimmer = int ( payload_json . find ( \"Dimmer\" )) end # set_light expects a brightness in range 0..255 bri = tasmota . scale_uint ( dimmer , 0 , 100 , 0 , 255 ) # build the payload for set_light var light_payload = { 'power' : true , 'rgb' : 'FFD700' , 'bri' : bri } #- set the light values -# tasmota . set_light ( light_payload ) # report the command as successful tasmota . resp_cmnd_done () end Finally you need to register the command: tasmota . add_cmd ( 'LightGold' , light_gold ) Example (in Tasmota console, not Berry console): lightgold 20:53:28.142 CMD : lightgold 20:53:28.151 RSL : stat/tasmota_923B34/RESULT = {\"POWER\":\"ON\"} 20:53:28.153 RSL : stat/tasmota_923B34/POWER = ON 20:53:28.160 RSL : stat/tasmota_923B34/RESULT = {\"LightGold\":\"Done\"} lightgold {\"Dimmer\":20} 20:54:16.837 CMD : lightgold {\"Dimmer\":20} 20:54:16.848 RSL : stat/tasmota_923B34/RESULT = {\"LightGold\":\"Done\"}","title":"More complete example"},{"location":"Berry-Cookbook/#responding-to-commands","text":"Tasmota expects that you send a response to commands. You can use the following methods: tasmota.resp_cmnd_done() : report command as Done (including trasnlated versions) tasmota.resp_cmnd_error() : report command as Error tasmota.resp_cmnd_failed() : report command as Failed tasmota.resp_cmnd_str(<msg>) : report an arbitrary string tasmota.resp_cmd(<json>) : report a custom JSON message (not prefixed by command name).","title":"Responding to commands"},{"location":"Berry-Cookbook/#adding-a-button-to-the-main-menu","text":"Adding a button to the e.g. main menu can be achieved by using the message type web_add_main_button() . The method to be performed, when the user clicks the button is achieved by using the web_sensor() method checking for the presence of an argument and a possible value assigned to the argument. The class provides the necessary methods to read the arguments: webserver.has_arg(arg_name:string) : -> boolean, checks if an argument with this name exists webserver.arg_size() : -> integer, returns the number of arguments webserver.arg(arg_name:string or arg_index:int) : -> string, returns the value of the argument either by name or by position number [0..arg_size()-1]. If an argument has multiple values, you need to iterate using ints to get all values webserver.arg_name(arg_index:int) -> string, get the name of argument by index [0..arg_size()-1] Additionally the webserver class provides a new function of sending information to the Web UI by using the following methods webserver.content_send(content:string) webserver.content_send_style(content:string) Let's see an example implementation of button methods in a Driver class import webserver # import webserver class class MyButtonMethods : Driver def myOtherFunction ( myValue ) #- do something -# end #- create a method for adding a button to the main menu -# def web_add_main_button () webserver . content_send ( \"<p></p><button onclick='la( \\\" &m_toggle_main=1 \\\" );'>Toggle Main</button>\" ) end #- create a method for adding a button to the configuration menu-# def web_add_config_button () #- the onclick function \"la\" takes the function name and the respective value you want to send as an argument -# webserver . content_send ( \"<p></p><button onclick='la( \\\" &m_toggle_conf=1 \\\" );'>Toggle Conf</button>\" ) end #- As we can add only one sensor method we will have to combine them besides all other sensor readings in one method -# def web_sensor () if webserver . has_arg ( \"m_toggle_main\" ) print ( \"button pressed\" ) end if webserver . has_arg ( \"m_toggle_conf\" ) # takes a string as argument name and returns a boolean # we can even call another function and use the value as a parameter var myValue = int ( webserver . arg ( \"m_toggle_conf\" )) # takes a string or integer(index of arguments) to get the value of the argument self . myOtherFunction ( myValue ) end end end d1 = MyButtonMethods () tasmota . add_driver ( d1 )","title":"Adding a button to the Main menu"},{"location":"Berry-Cookbook/#creating-an-i2c-driver","text":"Berry Scripting provides all necessary primitves for a complete I2C driver.","title":"Creating an I2C driver"},{"location":"Berry-Cookbook/#step-by-step-approach","text":"We will explore the different steps to write an I2C driver, and will take the MPU6886 as an example. The native driver already exists, and we'll rewrite it in Berry code. Step 1: detect the device I2C device are identified by address, only one device per address is allowed per I2C physical bus. Tasmota32 supports up to 2 I2C buses, using wire1 or wire2 objects. To simplify device detection, we provide the convenience method tasmota.scan_wire() . The first argument is the device address (0x68 for MPU6886). The optional second argument is the I2C Tasmota index, allowing to selectively disable some device families. See I2CDevice command and page XXX. The index number for MPU6886 is 58. class MPU6886 : Driver var wire # contains the wire object if the device was detected def init () self . wire = tasmota . wire_scan ( 0x68 , 58 ) end end self.wire contains a reference to wire1 if the device was detected on I2C bus 1, a reference to wire2 if the device was detected on bus 2, or nil if the device was not detected, or if I2C index 58 was disabled through I2CEnable . Step 2: verify the device To make sure the device is actually an MPU6886, we check it's signature by reading register 0x75. It should respond 0x19 (see datasheet for MPU6886). [ ... ] if self . wire var v = self . wire . read ( 0x68 , 0x75 , 1 ) if v != 0x19 return end #- wrong device -# [ ... ] Step 3: initialize the device We write a series of values in registers to configure the device as expected (see datasheet). [ ... ] self . wire . write ( 0x68 , 0x6B , 0 , 1 ) tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x6B , 1 << 7 , 1 ) # MPU6886_PWR_MGMT_1 tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x6B , 1 << 0 , 1 ) # MPU6886_PWR_MGMT_1 tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x1C , 0x10 , 1 ) # MPU6886_ACCEL_CONFIG - AFS_8G tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1B , 0x18 , 1 ) # MPU6886_GYRO_CONFIG - GFS_2000DPS tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1A , 0x01 , 1 ) # MPU6886_CONFIG tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x19 , 0x05 , 1 ) # MPU6886_SMPLRT_DIV tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x38 , 0x00 , 1 ) # MPU6886_INT_ENABLE tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1D , 0x00 , 1 ) # MPU6886_ACCEL_CONFIG2 tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x6A , 0x00 , 1 ) # MPU6886_USER_CTRL tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x23 , 0x00 , 1 ) # MPU6886_FIFO_EN tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x37 , 0x22 , 1 ) # MPU6886_INT_PIN_CFG tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x38 , 0x01 , 1 ) # MPU6886_INT_ENABLE tasmota . delay ( 100 ) [ ... ] We also pre-compute multipler to convert raw values to actual values: [ ... ] self . gres = 2000.0 / 32768.0 self . ares = 8.0 / 32678.0 print ( \"I2C: MPU6886 detected on bus \" + str ( self . wire . bus )) [ ... ] Step 4: read sensor value We will detail here the acceleration senor; gyroscope works similarly and is not further detailed. Reading the x/y/z sensor requires to read 6 bytes as a bytes() object var b = self . wire . read_bytes ( 0x68 , 0x3B , 6 ) Each value is 2 bytes. We use bytes.get(offset,size) to extract 2-bytes values at offsets 0/2/4. The size is -2 to indicate that values are encoded in Big Endian instead of Little Endian. var a1 = b . get ( 0 , - 2 ) Finally the read value is unsigned 16 bits, but the sensor value is signed 16 bits. We convert 16 bits unsigned to 16 bits signed. if a1 >= 0x8000 a1 -= 0x10000 end We then repeat for y and z: def read_accel () if ! self . wire return nil end #- exit if not initialized -# var b = self . wire . read_bytes ( 0x68 , 0x3B , 6 ) var a1 = b . get ( 0 , - 2 ) if a1 >= 0x8000 a1 -= 0x10000 end var a2 = b . get ( 2 , - 2 ) if a2 >= 0x8000 a2 -= 0x10000 end var a3 = b . get ( 4 , - 2 ) if a3 >= 0x8000 a3 -= 0x10000 end self . accel = [ a1 * self . ares , a2 * self . ares , a3 * self . ares ] return self . accel end Step 5: read sensor every second Simply override every_second() def every_second () if ! self . wire return nil end #- exit if not initialized -# self . read_accel () self . read_gyro () end Step 6: display sensor value in Web UI You need to override web_sensor() and provide the formatted string. tasmota.web_send_decimal() sends a string to the Web UI, and converts decimal numbers according to the locale settings. Tasmota uses specific markers: {s} : start of line {m} : separator between name and value {e} : end of line #- display sensor value in the web UI -# def web_sensor () if ! self . wire return nil end #- exit if not initialized -# import string var msg = string . format ( \" {s} MPU6886 acc_x {m}%.3f G {e} \" .. \" {s} MPU6886 acc_y {m}%.3f G {e} \" .. \" {s} MPU6886 acc_z {m}%.3f G {e} \" .. \" {s} MPU6886 gyr_x {m}%i dps {e} \" .. \" {s} MPU6886 gyr_y {m}%i dps {e} \" .. \" {s} MPU6886 gyr_z {m}%i dps {e} \" , self . accel [ 0 ], self . accel [ 1 ], self . accel [ 2 ], self . gyro [ 0 ], self . gyro [ 1 ], self . gyro [ 2 ]) tasmota . web_send_decimal ( msg ) end Step 7: publish JSON TelePeriod sensor value Similarly to Web UI, publish sensor value as JSON. #- add sensor value to teleperiod -# def json_append () if ! self . wire return nil end #- exit if not initialized -# import string var ax = int ( self . accel [ 0 ] * 1000 ) var ay = int ( self . accel [ 1 ] * 1000 ) var az = int ( self . accel [ 2 ] * 1000 ) var msg = string . format ( \", \\\" MPU6886 \\\" :{ \\\" AX \\\" : %i , \\\" AY \\\" : %i , \\\" AZ \\\" : %i , \\\" GX \\\" : %i , \\\" GY \\\" : %i , \\\" GZ \\\" : %i }\" , ax , ay , az , self . gyro [ 0 ], self . gyro [ 1 ], self . gyro [ 2 ]) tasmota . response_append ( msg ) end","title":"Step by step approach"},{"location":"Berry-Cookbook/#full-example","text":"The code can be loaded manually with copy/paste, or stored in flash and loaded at startup in autoexec.be as load(\"mpu6886.be\") . Alternatively it can be loaded with a Tasmota native command or rule: Br load(\"mpu6886.be\") See code example below for MPU6886: #- - Example of I2C driver written in Berry - - Support for MPU6886 device found in M5Stack - Alternative to xsns_85_mpu6886 . ino - # class MPU6886 : Driver var wire #- if wire == nil then the module is not initialized -# var gres , ares var accel , gyro def init () self . wire = tasmota . wire_scan ( 0x68 , 58 ) if self . wire var v = self . wire . read ( 0x68 , 0x75 , 1 ) if v != 0x19 return end #- wrong device -# self . wire . write ( 0x68 , 0x6B , 0 , 1 ) tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x6B , 1 << 7 , 1 ) # MPU6886_PWR_MGMT_1 tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x6B , 1 << 0 , 1 ) # MPU6886_PWR_MGMT_1 tasmota . delay ( 10 ) self . wire . write ( 0x68 , 0x1C , 0x10 , 1 ) # MPU6886_ACCEL_CONFIG - AFS_8G tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1B , 0x18 , 1 ) # MPU6886_GYRO_CONFIG - GFS_2000DPS tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1A , 0x01 , 1 ) # MPU6886_CONFIG tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x19 , 0x05 , 1 ) # MPU6886_SMPLRT_DIV tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x38 , 0x00 , 1 ) # MPU6886_INT_ENABLE tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x1D , 0x00 , 1 ) # MPU6886_ACCEL_CONFIG2 tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x6A , 0x00 , 1 ) # MPU6886_USER_CTRL tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x23 , 0x00 , 1 ) # MPU6886_FIFO_EN tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x37 , 0x22 , 1 ) # MPU6886_INT_PIN_CFG tasmota . delay ( 1 ) self . wire . write ( 0x68 , 0x38 , 0x01 , 1 ) # MPU6886_INT_ENABLE tasmota . delay ( 100 ) self . gres = 2000.0 / 32768.0 self . ares = 8.0 / 32678.0 print ( \"I2C: MPU6886 detected on bus \" + str ( self . wire . bus )) end end #- returns a list of 3 axis, float as g acceleration -# def read_accel () if ! self . wire return nil end #- exit if not initialized -# var b = self . wire . read_bytes ( 0x68 , 0x3B , 6 ) var a1 = b . get ( 0 , - 2 ) if a1 >= 0x8000 a1 -= 0x10000 end var a2 = b . get ( 2 , - 2 ) if a2 >= 0x8000 a2 -= 0x10000 end var a3 = b . get ( 4 , - 2 ) if a3 >= 0x8000 a3 -= 0x10000 end self . accel = [ a1 * self . ares , a2 * self . ares , a3 * self . ares ] return self . accel end #- returns a list of 3 gyroscopes, int as dps (degree per second) -# def read_gyro () if ! self . wire return nil end #- exit if not initialized -# var b = self . wire . read_bytes ( 0x68 , 0x43 , 6 ) var g1 = b . get ( 0 , - 2 ) if g1 >= 0x8000 g1 -= 0x10000 end var g2 = b . get ( 2 , - 2 ) if g2 >= 0x8000 g2 -= 0x10000 end var g3 = b . get ( 4 , - 2 ) if g3 >= 0x8000 g3 -= 0x10000 end self . gyro = [ int ( g1 * self . gres ), int ( g2 * self . gres ), int ( g3 * self . gres )] return self . gyro end #- trigger a read every second -# def every_second () if ! self . wire return nil end #- exit if not initialized -# self . read_accel () self . read_gyro () end #- display sensor value in the web UI -# def web_sensor () if ! self . wire return nil end #- exit if not initialized -# import string var msg = string . format ( \" {s} MPU6886 acc_x {m}%.3f G {e} \" .. \" {s} MPU6886 acc_y {m}%.3f G {e} \" .. \" {s} MPU6886 acc_z {m}%.3f G {e} \" .. \" {s} MPU6886 gyr_x {m}%i dps {e} \" .. \" {s} MPU6886 gyr_y {m}%i dps {e} \" .. \" {s} MPU6886 gyr_z {m}%i dps {e} \" , self . accel [ 0 ], self . accel [ 1 ], self . accel [ 2 ], self . gyro [ 0 ], self . gyro [ 1 ], self . gyro [ 2 ]) tasmota . web_send_decimal ( msg ) end #- add sensor value to teleperiod -# def json_append () if ! self . wire return nil end #- exit if not initialized -# import string var ax = int ( self . accel [ 0 ] * 1000 ) var ay = int ( self . accel [ 1 ] * 1000 ) var az = int ( self . accel [ 2 ] * 1000 ) var msg = string . format ( \", \\\" MPU6886 \\\" :{ \\\" AX \\\" : %i , \\\" AY \\\" : %i , \\\" AZ \\\" : %i , \\\" GX \\\" : %i , \\\" GY \\\" : %i , \\\" GZ \\\" : %i }\" , ax , ay , az , self . gyro [ 0 ], self . gyro [ 1 ], self . gyro [ 2 ]) tasmota . response_append ( msg ) end end mpu6886 = MPU6886 () tasmota . add_driver ( mpu6886 )","title":"Full example"},{"location":"Berry-Cookbook/#lvgl-touchscreen-with-3-relays","text":"#- start LVGL and init environment -# lv . start () hres = lv . get_hor_res () # should be 240 vres = lv . get_ver_res () # should be 320 scr = lv . scr_act () # default screean object f20 = lv . montserrat_font ( 20 ) # load embedded Montserrat 20 f28 = lv . montserrat_font ( 28 ) # load embedded Montserrat 28 #- Backgroun -# scr . set_style_local_bg_color ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv_color ( 0x000066 )) # backgroun in dark blue #000066 #- Upper state line -# stat_line = lv_label ( scr ) if f20 != nil stat_line . set_style_local_text_font ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , f20 ) end stat_line . set_long_mode ( lv . LABEL_LONG_SROLL ) # auto scrolling if text does not fit stat_line . set_width ( hres ) stat_line . set_align ( lv . LABEL_ALIGN_LEFT ) # align text left stat_line . set_style_local_bg_color ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv_color ( 0x000088 )) # background #000088 stat_line . set_style_local_bg_opa ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv . OPA_COVER ) # 100% background opacity stat_line . set_style_local_text_color ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv_color ( 0xFFFFFF )) # text color #FFFFFF stat_line . set_text ( \"Tasmota\" ) stat_line_height = stat_line . get_height () #- display wifi strength indicator icon (for professionals ;) -# stat_line . set_style_local_pad_right ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , stat_line_height + 1 ) wifi_bars = lv_wifi_bars ( stat_line ) wifi_bars . set_style_local_bg_color ( lv . OBJ_PART_MAIN , lv . STATE_DEFAULT , lv_color ( lv . BLACK )) wifi_bars . set_height ( stat_line_height ) wifi_bars . set_width ( stat_line_height ) wifi_bars . set_x ( stat_line . get_width () - stat_line_height ) #- create a style for the buttons -# btn_style = lv_style () btn_style . set_radius ( lv . STATE_DEFAULT , 10 ) # radius of rounded corners btn_style . set_bg_opa ( lv . STATE_DEFAULT , lv . OPA_COVER ) # 100% backgrond opacity if f28 != nil btn_style . set_text_font ( lv . STATE_DEFAULT , f28 ) end btn_style . set_bg_color ( lv . STATE_DEFAULT , lv_color ( 0x33BBFF )) # background color #1FA3EC (Tasmota Blue) btn_style . set_border_color ( lv . STATE_DEFAULT , lv_color ( 0x0000FF )) # border color #0000FF #btn_style.set_bg_color(lv.STATE_FOCUSED, lv_color(0x0000FF)) # background color when pressed #0000FF #btn_style.set_border_color(lv.STATE_FOCUSED, lv_color(0xFFFFFF)) # border color when pressed #FFFFFF btn_style . set_text_color ( lv . STATE_DEFAULT , lv_color ( 0x000000 )) # text color #FFFFFF #- enabled -# btn_style . set_bg_color ( lv . STATE_CHECKED , lv_color ( 0x0000FF )) # background color #1FA3EC (Tasmota Blue) btn_style . set_text_color ( lv . STATE_CHECKED , lv_color ( 0xFFFFFF )) # text color #FFFFFF btn_style . set_outline_width ( lv . STATE_FOCUSED , 0 ) # rmove focus outline, not needed with touchscreen #- register buttons -# var btns = [] # relay buttons are added to this list to match with Tasmota relays #- simple function to find the index of an element in a list -# def findinlist ( l , x ) for i : 0. . size ( l ) - 1 if l [ i ] == x return i end end end #- callback function when a button is pressed -# #- checks if the button is in the list, and react to EVENT_VALUE_CHANGED event -# def btn_event_cb ( o , event ) var btn_idx = findinlist ( btns , o ) if btn_idx != nil && event == lv . EVENT_VALUE_CHANGED var val = o . get_state () < lv . BTN_STATE_CHECKED_RELEASED # true if checked, false if unchecked tasmota . set_power ( btn_idx , ! val ) # toggle the value end end #- create a button object, set style, register callback and add to global list -# #- you still need to re-position the button -# def create_btn_relay ( label ) var btn , btn_label btn = lv_btn ( scr ) btn . set_pos ( 30 , 30 ) btn . set_size ( hres - 60 , 60 ) btn . add_style ( lv . OBJ_PART_MAIN , btn_style ) btn . set_checkable ( true ) # enable toggle mode btn_label = lv_label ( btn ) btn_label . set_text ( label ) btn . set_event_cb ( btn_event_cb ) # set callback to update Tasmota relays btns . push ( btn ) # append button to the list return btn end #- create 3 buttons -# var btn1 = create_btn_relay ( \"Relay 1\" ) btn1 . set_y ( 30 ) var btn2 = create_btn_relay ( \"Relay 2\" ) btn2 . set_y ( 100 ) var btn3 = create_btn_relay ( \"Relay 3\" ) btn3 . set_y ( 170 ) #- update the buttons values according to internal relays status -# def btns_update () var power_list = tasmota . get_power () # get a list of booleans with status of each relay for b : btns var state = b . get_state () var power_state = ( size ( power_list ) > 0 ) ? power_list . pop ( 0 ) : false # avoid exception if less relays than buttons if state != lv . BTN_STATE_PRESSED && state != lv . BTN_STATE_CHECKED_PRESSED # update only if the button is not currently being pressed b . set_state ( power_state ? lv . BTN_STATE_CHECKED_RELEASED : lv . BTN_STATE_RELEASED ) end end end #- update every 500ms -# def btns_update_loop () btns_update () tasmota . set_timer ( 500 , btns_update_loop ) end btns_update_loop () # start # If you change the style after creating the button, you need to update objects: def btns_refresh_style () for b : btns b . refresh_style ( lv . OBJ_PART_MAIN , lv . STYLE_PROP_ALL ) end end # Button states, read and set with: # btn1.get_state() or btn1.set_state(lv.BTN_STATE_CHECKED_RELEASED) # Ex: # btn1.set_state(lv.BTN_STATE_RELEASED) # btn1.set_state(lv.BTN_STATE_CHECKED_RELEASED) #- Here are the states for buttons -# # BTN_STATE_RELEASED # BTN_STATE_PRESSED # BTN_STATE_DISABLED # BTN_STATE_CHECKED_RELEASED # BTN_STATE_CHECKED_PRESSED # BTN_STATE_CHECKED_DISABLED","title":"LVGL Touchscreen with 3 Relays"},{"location":"Berry-Cookbook/#multi-zone-heating-controller","text":"This project is a multi-zone heating controller written entirely in berry. It demonstrates the use of the persist module for saving/loading data; the webserver module for creating a custom \"Manage Heating\" user interface; dynamic loading of HTML from the file system; subscribing to a variety of rule triggers (using tasmota.add_rule); the implementation of custom commands (using tasmota.add_cmnd). It also makes good use of time functionaity (via tasmota.rtc, tasmota.time_dump, tasmota.set_timer and tasmota.strftime). The project also includes an LCD I2C driver for running a basic 20x4 display. The entire driver is implemented using just the tasmota.wire_scan method. https://github.com/Beormund/Tasmota32-Multi-Zone-Heating-Controller","title":"Multi-Zone Heating Controller"},{"location":"Berry-Cookbook/#ethernet-network-flipper","text":"Used on board with Ethernet. If both Wi-Fi and Ethernet are active, turn off Wi-Fi. Place code in autoexec.be to execute on boot. You can call the function from Berry console any time with netflip() . def netflip() var eth = tasmota.eth().find('ip') != nil #1 if tasmota.wifi().find('ip') != nil == eth #2 tasmota.cmd('Wifi ' .. (eth ? 0 : 1)) #3 end end tasmota.set_timer(30000,netflip) #4 1. store variable \"eth\" with Ethernet status - \"true\" if Ethernet IP exists and \"false\" if not 2. check if wifi status is true and compare to eth status 3. send command Wifi with parameter depending on eth variable. .. is to concatenate a string. See Berry [manualg(https://github.com/berry-lang/berry/wiki/Chapter-3#-operator-1) 4. set a timer to execute the netflip function 30000ms (30 seconds) after loading autoexec.be","title":"Ethernet Network Flipper"},{"location":"Berry-Cookbook/#tmp117-driver","text":"TomsTek@GitHub","title":"TMP117 Driver"},{"location":"Berry-Cookbook/#call-function-at-intervals","text":"This small helper function allows you to call a function at stable intervals, automatically correcting in case of latency or other deviations. Not suitable for very short intervals; while the delay interval is in milliseconds for consistency with the standard tasmota.set_timer , it would normally be seconds multiplied by 1000, like 60000 for every minute. def set_timer_modulo(delay,f) var now=tasmota.millis() tasmota.set_timer((now+delay/4+delay)/delay*delay-now, def() set_timer_modulo(delay,f) f() end) end","title":"Call function at intervals"},{"location":"Berry-Cookbook/#h-bridge-control","text":"An H-bridge is an electronic circuit that switches the polarity of a voltage applied to a load. These circuits are often used in robotics and other applications to allow DC motors to run forwards or backwards. You can typically use 2 PWM channels to pilot a H-bridge, under the condition that both channels are never active at the same time; otherwise you may detroy your device. This means that phasing must be calculated so that one pulse started once the other pulse is inactive, and the sum of both dutys must not exceed 100%. The following Berry function ensures appropriate management of H-bridge: # # H_bridge class in Berry to pilot a H-bridge device # class H_bridge var gpio1 , gpio2 var max # init(phy_gpio1, phy_gpio2) - intialize H-bridge with the 2 GPIOs used to control it def init ( gpio1 , gpio2 ) self . gpio1 = gpio1 self . gpio2 = gpio2 self . max = 1023 # max value of duty end # set the value of both PWM values def set ( v1 , v2 ) if v1 < 0 v1 = 0 end if v2 < 0 v2 = 0 end if v1 + v2 > self . max raise \"value_error\" , \"the sum of duties must not exceed 100%\" end import gpio gpio . set_pwm ( self . gpio1 , v1 , 0 ) gpio . set_pwm ( self . gpio2 , v2 , v1 ) # dephase by value v1 end end Example of use: var hbridge = H_bridge ( 12 , 13 ) # use GPIO12 and GPIO13 hbridge . set ( 100 , 200 ) # set values to 102/1023 and 204/1023, i.e. 10% and 20% hbridge . set ( 100 , 950 ) # set values to 102/1023 and 950/1023, i.e. 10% and 93% BRY : Exception > 'value_error' - the sum of duties must not exceed 100 %","title":"H-bridge control"},{"location":"Berry-Introduction/","text":"Berry Introduction (in 20 minutes or less) ~ This quick start will drive you in the basics of the Berry language. It should take no more than 20 minutes and is inspired by Ruby in Twenty Minutes Berry is a ultra-lightweight dynamically typed scripting language. It is designed for lower-performance embedded devices. It also runs on a regular computer, and it can run directly in your browser for quick testing. Berry is the next generation scripting for Tasmota, embedded by default in all ESP32 based firmwares. It is used for advanced scripting and superseded Rules. Its advanced features are used to extend Tasmota: adding commands, adding drivers (I2C, serial...), extending the web UI, adding full applications (TAPP files), driving advanced graphics with LVGL . To start with Berry, you have at least 3 choices: use the Berry online console and start in less than 10 seconds flash an ESP32 based device with Tasmota and use the Berry console compile Berry on your computer from sources and run the Berry interpreter (less preferred) Hello, Berry ~ In the console type: > print ( \"Hello, Berry\" ) Hello , Berry What just happened? We just sent the simplest possible Berry program print(\"Hello, Berry\") . Internally this program was compiled into Berry bytecode and ran using the Berry virtual machine. In Berry you can append commands one after the other. Contrary to C you don't need any separator like ; . Unlike Python indentation has no importance. Commands need only to be separated by at least one space-like character: space, tab, newline. > print ( \"Hello, Berry\" ) print ( \"Hello, Berry\" ) Hello , Berry Hello , Berry In this second example, the implicit program contains 2 commands. Your free calculator is here ~ Not surprisingly, like most scripting languages you can do direct calculation. > 3 + 2 5 > 3 * 2 6 The above computations are made against integers. Berry supports either 32 bits or 64 bits integers depending on the underlying platform (usually 32 bits on embedded systems). Berry supports floating point calculation, as soon as at lest one member if floating point. Floating point uses either 32 bits float or 64 bits double depending on compilation options (usually 32 bits on embedded systems). > 3 / 2 1 > 3 . 0 / 2 1 . 5 > 1 / 3 . 0 0 . 333333 The command 3/2 works on integers and returns an integer result. 3.0/2 , 3/2.0 or 3.0/2.0 work on floating point numbers since at least one operand is floating point. You can convert an integer to floating point using real() and truncate to integer with int() . > 3 / 2 1 > real ( 3 ) / 2 1 . 5 > int ( 3 . 0 / 2 ) 1 Beyond the core Berry language, advanced math function are available via the additional module math see documentation . > import math > math . sqrt ( 2 ) # square root of 2 1 . 41421 > math . pow ( 2 , 3 ) # 2^3 8 Defining a function ~ What if you want to say \"Hello\" a lot without getting your fingers all tired? You should define another function: > def hi () print ( \"Hello, Berry\" ) end > Now let's call the function: > hi () Hello , Berry hi is a function that takes no argument, returns nothing, and prints a message in the console. Calling a function always requires sending arguments between parenthesis () . Otherwise Berry thinks that you want to manipulate the function itself as an entity. > hi # return the function entity itself < function : 0x3ffdac6c > > hi () # call the function Hello , Berry What if we want to say hello to one person, and not only to Berry? Just redefine hi function to take a name as an argument. > def hi ( name ) print ( \"Hello, \" + name ) end This way, hi is a function that takes a single argument as string. > hi ( \"Skiars\" ) hi ( \"Theo\" ) Hello , Skiars Hello , Theo This function only works if the argument is a string, and fails if you use any other type of argument. Let's use str() built-in function to force-convert the argument to a string. > def hi ( name ) print ( \"Hello, \" + str ( name )) end > hi ( \"Skiars\" ) hi ( \"Theo\" ) Hello , Skiars Hello , Theo > hi ( 2 ) Hello , 2 What happens if you don't send any argument to a function that expects one? Let's try: > def hi ( name ) print ( \"Hello, \" + str ( name )) end > hi () Hello , nil The knights who say nil ~ What is this nil thing? Berry has a special value nil meaning \"nothing\". nil is the implicit value passed to a function when no argument is sent, or the value returned by a function that does not return anything. > nil nil > hi ( nil ) Hello , nil > hi () Hello , nil As you see, nil is the implicit value passed when arguments are missing, but also a value that you can pass explicitly. Formatting strings ~ In the above example, we only concatenated two strings. Berry provides a more advanced scheme to format numerical values as well. It is widely inspired from C formatting used by printf . Don't forget to import the string module first. > import string > def say_hi ( name ) print ( string . format ( \"Hello, %s!\" , name )) end > def say_bye ( name ) print ( string . format ( \"Bye, %s, come back soon\" , name )) end > say_hi ( \"Bob\" ) Hello , Bob ! > say_bye ( \"Bob\" ) Bye , Bob , come back soon You can combine with string functions like toupper() to convert to uppercase > import string > name = \"Bob\" > string . format ( \"Hello, %s!\" , string . toupper ( name )) Hello , BOB ! In the example above, we have created a global variable called name containing the string \"Bob\" and used string.toupper() to convert it to all uppercase. Evolving into a Greeter ~ What if we want a real greeter around, one that remembers your name and welcomes you and treats you always with respect. You might want to use an object for that. Let\u2019s create a \u201cGreeter\u201d class. Note: since it's a multi-line example, you may need to copy the entire block and paste it at once in the console (not line-by-line). class Greeter var name def init ( name ) self . name = name end def say_hi () import string print ( string . format ( \"Hi %s\" , self . name )) end def say_bye () import string print ( string . format ( \"Bye %s, come back soon.\" , self . name )) end end The new keyword here is class . This defines a new class called Greeter and a bunch of methods for that class. Also notice var name . This is an instance variable, and is available to all the methods of the class. As you can see it\u2019s used by say_hi and say_bye as self.name . The init() method is a special method called a \"constructor\". It is implicitly called when you create a new instance for the class, and the arguments are passed to init() . The constructor is responsible for complete initialization of the object, and it's always the first method called. The above example is typical of any object: it takes an argument name and copies it to an instance variable self.name to make it available to any method. Note: Berry has no concept of private members (contrary to C++). All instance variables and methods are always public. Creating a greeter object ~ Now let\u2019s create a greeter object and use it: > greeter = Greeter ( \"Pat\" ) > greeter . say_hi () Hi Pat > greeter . say_bye () Bye Pat , come back soon . Once the greeter object is created, it remembers that the name is Pat. If you want to get the name from a greeter, you can ask a greeter by accessing the name variable on it (without parenthesis): > greeter . name Pat Subclasses ~ Methods and instance variables are defined at the class creation. You can't add method or instance variables to an already existing class. To extend a class you can create a sub-class: class SurGreeter : Greeter # subclass of Greeter var surname def init ( name , surname ) # sub-class takes 2 arguments super ( self ) . init ( name ) # call constructor of super-class self . surname = surname end def say_hi () import string print ( string . format ( \"Hi %s %s\" , self . name , self . surname )) end end The class SurGreeter extends Greeter with an additional surname field. It overwrides say_hi() but leaves say_bye() unchanged. There is a special syntax for calling a method of the subclass super(self).init(name) . Note: classes have always an init() method, either because it was explicitly defined, or implicitly. It is always ok to call super(self).init() even if the subclass has no explicit init() method. Now let's try this new class: > greet = SurGreeter ( \"John\" , \"Smith\" ) > greet . say_hi () Hi John Smith > greet . say_bye () Bye John , come back soon . > greet . name John > greet . surname Smith Greetings everyone! ~ This greeter isn\u2019t all that interesting though, it can only deal with one person at a time. What if we had some kind of MegaGreeter that could either greet the world, one person, or a whole list of people? Let\u2019s try to build that. We will start with a class definition: class MegaGreeter var names def init ( name ) self . names = [] # empty list if name != nil self . names . push ( name ) end end end So MegaGreeter objects have a list of names. The names field is initialized to the empty list [] . The body of the MegaGreeter constructor adds the given name argument to the end of the list of names if it's not nil . Mega greeters don't have a single name and no name field, so here the name is just an ordinary parameter that we can use in the body of the constructor. Let's try it: > greeter = MegaGreeter () > greeter . names [] > greeter = MegaGreeter ( \"World\" ) > greeter . names [ 'World' ] We can now go ahead and add greeter methods that add more names and show all the names: class MegaGreeter var names def init ( name ) self . names = [] # empty list if name != nil self . names . push ( name ) end end def add ( name ) self . names . push ( name ) end def say_hi () import string for n : self . names print ( string . format ( \"Hello %s!\" , n )) end end def say_bye () import string for n : self . names print ( string . format ( \"Bye %s, come back soon.\" , n )) end end end We introduced here a new construct known as an iterator. for n: self.names creates a new local variable n and iterate the following code for each value in self.names . Let's try the full example now: > greeter = MegaGreeter () > greeter . add ( \"Skiars\" ) > greeter . add ( \"Theo\" ) > greeter . add ( \"Stephan\" ) > greeter . say_hi () Hello Skiars ! Hello Theo ! Hello Stephan ! > greeter . say_bye () Bye Skiars , come back soon . Bye Theo , come back soon . Bye Stephan , come back soon . Comments ~ Sometimes, it is nice just to add comments that explain interesting things related to your code. In the example in the last section, there were a few single line comments: self . names = [] # empty list Such comments start with # and tell the system to ignore the rest of the line. You can also use multi-line comments starting with #- and ending with -# . #- This is a comment - # #- # This is also a comment block (`#` are ignored) - # #----------------------------------------- Alternative way to make comment blocks ----------------------------------------- # Indentation has no impact on Berry compiler, it's only by convention to make source code more readable. Maps ~ Maps are a very common and powerful feature to store key/value pairs. They are declared usin {} . > m1 = {} # empty map > m {} > m2 = { \"k1\" :\"v1\" , \"k2\" :\"v2\" , \"k3\" :\"v3\" } > m2 { 'k2' : 'v2' , 'k1' : 'v1' , 'k3' : 'v3' } Actually keys and values can be of arbitrary type. > m3 = { 1 . 5 : 3 , 2 :\"two\" , true : 1 , false :nil } > m3 { 1 . 5 : 3 , true : 1 , 2 : 'two' , false : nil } The main restriction is that a key can't be nil . Setting adding a key of value nil is silently ignored. > m4 = { nil :\"foo\" } > m4 {} Accessing a value in the map uses [<key>] : > m1 = {} > m1 [ 'k1' ] = \"value1\" > m1 { 'k1' : 'value1' } # working with numerical values > m1 [ 'k2' ] = 0 > m1 [ 'k2' ] += 5 # shortcut for `m1['k2'] = m1['k2'] + 5` > m1 { 'k' : 'value' , 'k2' : 5 } Accessing a non-existent key raises an error. There is an alternative function find() to access a key and return a default value if the key is absent. contains() can also be used to check the presence of the key. > m1 = { \"foo\" :\"bar\" } > m1 . contains ( \"foo\" ) true > m1 . contains ( \"bar\" ) # only checks for keys, not values false > m1 [ \"foo\" ] bar > m1 [ \"bar\" ] key_error : bar stack traceback : < native > : in native function stdin : 1 : in function `main` # alternative with find > m1 . find ( \"foo\" , \"not_found\" ) bar > m1 . find ( \"bar\" , \"not_found\" ) not_found > m1 . find ( \"bar\" ) # returns nil by default if not found Note: m[k] = v is syntactic sugar for m.setitem(k, v) . When reading a value, m[k] is equivalent to m.item(k) . If statements and basic expressions ~ We can program a ridiculously inefficient Fibonacci sequence generator using if and recursion: def fib ( n ) if n <= 1 return n end return fib ( n - 1 ) + fib ( n - 2 ) end This defines a top-level function called fib that is not a member of any class. The fib function is recursive, calling itself, and also makes use of a few new features. The if-statement is well known from other languages. In Berry it works by taking an expression and conditionally evaluating a block. Berry also has the usual array of infix operators, + , - , * , / , % etc. and the relational operators < , <= , > , >= , == and != . > fib ( 10 ) 55 Cycling and Looping ~ As we've seen in MegaGreeter it is very simple to iterate over a list for n: self.names [...] end . Iterators can also be used over ranges like for i:0..4 which will iterate over all values between 0 and 4 inclusive (5 iterations in total). > for i : 0 .. 4 print ( i ) end 0 1 2 3 4 Iterating over maps goes in two flavors: iterating over values, or over keys. > m = { \"k1\" :\"v1\" , \"k2\" :\"v2\" , \"k3\" :\"v3\" } > print ( m ) # keep in mind that there is no order in a map { 'k2' : 'v2' , 'k1' : 'v1' , 'k3' : 'v3' } # iterate over values > for v : m print ( v ) end v2 v1 v3 # iterate over keys > for k : m . keys () print ( k ) end k2 k1 k3 # iterate over both keys and values > for k : m . keys () print ( k , m [ k ] ) end k2 v2 k1 v1 k3 v3 For C programmers, the equivalent of for (int i=0; i<a; i++) { [...] } is for i: 0..a-1 [...] end Functions and arguments ~ In Berry, functions are first class entities (Berry supports functional programming as well as object oriented). Berry is not a strongly types language, which means that you don't define any type as input or output when you define a function. This may seem as a problem, but it's a very powerful feature instead. Berry relies on what is known as \"Duck Typing\", as in \u201cIf it walks like a duck and it quacks like a duck, then it must be a duck\u201d. As long as the type you provide supports the right methods and calls, then it's fine. A function only defines the number of arguments it receives: > def f ( a , b ) return str ( a ) + str ( b ) end # takes only 2 arguments f expects 2 arguments, if you provide less than 2, the non-defined are set to nil . If you provide more than 2, the extra-arguments are silently ignored. > def f ( a , b ) return str ( a ) + str ( b ) end # takes only 2 arguments > f ( \"foo\" , \"bar\" ) foobar > f ( \"foo\" ) foonil > f ( \"foo\" , \"bar\" , \"baz\" ) foobar A function may or may not return a value with return <expression> . If you call just return or the function ends without any return statement, the function returns nil . Closures ~ Let's finish this introduction with a very powerful feature known as closures. It is sometimes seen as intimidating or complex, but it's actually very simple. We will visit only the most common use of closures, if you want to get more details see the Berry documentation . Let's go back to our simple Byer example (class that says Bye). class Byer var name def init ( name ) self . name = name end def say_bye () import string print ( string . format ( \"Bye %s, see you soon.\" , self . name )) end end Let's define an instance of this class: > bye_bob = Byer ( \"Bob\" ) > bye_pat = Byer ( \"Pat\" ) > bye_bob . say_bye () Bye Bob , see you soon . Nothing new until now. Closure are useful as soon as you need callbacks. Let's say that you are using a framework that accepts a callback (a function you provide that will be fired in the future). We want to pass a function that says Bye to Bob. The naive approach would be to use bye_bob.say_bye method, which is a valid function. However this function has no context and can't know which instance you are referring to. > bye_bob . say_bye < function : 0x3ffb3200 > > bye_pat . say_bye < function : 0x3ffb3200 > # same function as above As shown above, since the context is missing, you can't distinguish from the method bye_bob.say_bye and bye_pat.say_bye . They are the same function. Closure allows to create a new synthetic function that encapsulates transparently the context. > cb = def () bye_bob . say_bye () end > cb < function : 0x3ffd9df4 > # let's check that a closure on bye_pat is different > cb_pat = def () bye_pat . say_bye () end > cb_pat < function : 0x3ffdaaa0 > cb is a closure, if creates a function that captures the instance bye_bob and then calls say_bye() on it. Let's call the closures to check they are working. > cb () Bye Bob , see you soon . Tasmota this is widely used in Tasmota for example for deferred functions. For example if you want to run bye_bob.say_bye() in 5 seconds in the future: > tasmota . set_timer ( 5000 , cb ) # cb() is called in 5000 milliseconds Advanced users: there is a compact syntax for simple callbacks: def cb(a,b) return <expr> end becomes / a,b -> <expr> Consider Yourself Introduced ~ So that's a quick tour of Berry. Please have a look at the online Berry documentation . For Tasmota users, also have a look at the Tasmota Berry documentation and Tasmota Berry Cookbook . Extra ~ Here is a short comparison of Berry and Python syntax, courtesy of @Beormund Berry vs Python Berry MicroPython Current object self self Single line comments # # Multi line comments #- ... -# Logical 'and', 'or' and not operators && || ! and or not Shift left, right << >> << >> Integer division / // Statement blocks/grouping (scope) (indent) Class definition & inheritance class a:b class a(b): Class constructor def init(x) ... end def __init__(self, x): Class and superclass constructors def init(x) super(self).init(x) end def __init__(self, x): super(b, self).__init__(x) Class constructor that assigns to fields def init(x) self.x = x end def __init__(self, x): self.x = x Check object's type isinstance(b, a) isinstance(b, a) Call method foo with 2 arguments foo(x, y) foo(x,y) Declare a member variable in a class self.x = nil self.x = None Declare a local variable in a method var x = 2, y = nil x = 2 y = None Define a constant in a class static x = 2 Define a top level function def foo(x,y) end def foo(x,y): Define an instance method in a class def foo(x,y) end def foo(self, x, y): Define a static method in a class static def foo(x,y) end If statement if condition end if condition: Fixed loop for i: range end for i in range(end): Iterate over collection for k: coll.keys() end for x in coll: While loop while condition end while condition: Import from library import library import library Print print('hello world') print('Hello world') Interpolation string.format(\"Hello %s\", name) print(\"Hello %s\" %(name)) Simple types int real bool (true\\|false) string nil int float bool (True\\|False) string None Class types list map range list dict tuple set","title":"Berry Introduction (in 20 minutes or less)"},{"location":"Berry-Introduction/#berry-introduction-in-20-minutes-or-less","text":"This quick start will drive you in the basics of the Berry language. It should take no more than 20 minutes and is inspired by Ruby in Twenty Minutes Berry is a ultra-lightweight dynamically typed scripting language. It is designed for lower-performance embedded devices. It also runs on a regular computer, and it can run directly in your browser for quick testing. Berry is the next generation scripting for Tasmota, embedded by default in all ESP32 based firmwares. It is used for advanced scripting and superseded Rules. Its advanced features are used to extend Tasmota: adding commands, adding drivers (I2C, serial...), extending the web UI, adding full applications (TAPP files), driving advanced graphics with LVGL . To start with Berry, you have at least 3 choices: use the Berry online console and start in less than 10 seconds flash an ESP32 based device with Tasmota and use the Berry console compile Berry on your computer from sources and run the Berry interpreter (less preferred)","title":"Berry Introduction (in 20 minutes or less)"},{"location":"Berry-Introduction/#hello-berry","text":"In the console type: > print ( \"Hello, Berry\" ) Hello , Berry What just happened? We just sent the simplest possible Berry program print(\"Hello, Berry\") . Internally this program was compiled into Berry bytecode and ran using the Berry virtual machine. In Berry you can append commands one after the other. Contrary to C you don't need any separator like ; . Unlike Python indentation has no importance. Commands need only to be separated by at least one space-like character: space, tab, newline. > print ( \"Hello, Berry\" ) print ( \"Hello, Berry\" ) Hello , Berry Hello , Berry In this second example, the implicit program contains 2 commands.","title":"Hello, Berry"},{"location":"Berry-Introduction/#your-free-calculator-is-here","text":"Not surprisingly, like most scripting languages you can do direct calculation. > 3 + 2 5 > 3 * 2 6 The above computations are made against integers. Berry supports either 32 bits or 64 bits integers depending on the underlying platform (usually 32 bits on embedded systems). Berry supports floating point calculation, as soon as at lest one member if floating point. Floating point uses either 32 bits float or 64 bits double depending on compilation options (usually 32 bits on embedded systems). > 3 / 2 1 > 3 . 0 / 2 1 . 5 > 1 / 3 . 0 0 . 333333 The command 3/2 works on integers and returns an integer result. 3.0/2 , 3/2.0 or 3.0/2.0 work on floating point numbers since at least one operand is floating point. You can convert an integer to floating point using real() and truncate to integer with int() . > 3 / 2 1 > real ( 3 ) / 2 1 . 5 > int ( 3 . 0 / 2 ) 1 Beyond the core Berry language, advanced math function are available via the additional module math see documentation . > import math > math . sqrt ( 2 ) # square root of 2 1 . 41421 > math . pow ( 2 , 3 ) # 2^3 8","title":"Your free calculator is here"},{"location":"Berry-Introduction/#defining-a-function","text":"What if you want to say \"Hello\" a lot without getting your fingers all tired? You should define another function: > def hi () print ( \"Hello, Berry\" ) end > Now let's call the function: > hi () Hello , Berry hi is a function that takes no argument, returns nothing, and prints a message in the console. Calling a function always requires sending arguments between parenthesis () . Otherwise Berry thinks that you want to manipulate the function itself as an entity. > hi # return the function entity itself < function : 0x3ffdac6c > > hi () # call the function Hello , Berry What if we want to say hello to one person, and not only to Berry? Just redefine hi function to take a name as an argument. > def hi ( name ) print ( \"Hello, \" + name ) end This way, hi is a function that takes a single argument as string. > hi ( \"Skiars\" ) hi ( \"Theo\" ) Hello , Skiars Hello , Theo This function only works if the argument is a string, and fails if you use any other type of argument. Let's use str() built-in function to force-convert the argument to a string. > def hi ( name ) print ( \"Hello, \" + str ( name )) end > hi ( \"Skiars\" ) hi ( \"Theo\" ) Hello , Skiars Hello , Theo > hi ( 2 ) Hello , 2 What happens if you don't send any argument to a function that expects one? Let's try: > def hi ( name ) print ( \"Hello, \" + str ( name )) end > hi () Hello , nil","title":"Defining a function"},{"location":"Berry-Introduction/#the-knights-who-say-nil","text":"What is this nil thing? Berry has a special value nil meaning \"nothing\". nil is the implicit value passed to a function when no argument is sent, or the value returned by a function that does not return anything. > nil nil > hi ( nil ) Hello , nil > hi () Hello , nil As you see, nil is the implicit value passed when arguments are missing, but also a value that you can pass explicitly.","title":"The knights who say nil"},{"location":"Berry-Introduction/#formatting-strings","text":"In the above example, we only concatenated two strings. Berry provides a more advanced scheme to format numerical values as well. It is widely inspired from C formatting used by printf . Don't forget to import the string module first. > import string > def say_hi ( name ) print ( string . format ( \"Hello, %s!\" , name )) end > def say_bye ( name ) print ( string . format ( \"Bye, %s, come back soon\" , name )) end > say_hi ( \"Bob\" ) Hello , Bob ! > say_bye ( \"Bob\" ) Bye , Bob , come back soon You can combine with string functions like toupper() to convert to uppercase > import string > name = \"Bob\" > string . format ( \"Hello, %s!\" , string . toupper ( name )) Hello , BOB ! In the example above, we have created a global variable called name containing the string \"Bob\" and used string.toupper() to convert it to all uppercase.","title":"Formatting strings"},{"location":"Berry-Introduction/#evolving-into-a-greeter","text":"What if we want a real greeter around, one that remembers your name and welcomes you and treats you always with respect. You might want to use an object for that. Let\u2019s create a \u201cGreeter\u201d class. Note: since it's a multi-line example, you may need to copy the entire block and paste it at once in the console (not line-by-line). class Greeter var name def init ( name ) self . name = name end def say_hi () import string print ( string . format ( \"Hi %s\" , self . name )) end def say_bye () import string print ( string . format ( \"Bye %s, come back soon.\" , self . name )) end end The new keyword here is class . This defines a new class called Greeter and a bunch of methods for that class. Also notice var name . This is an instance variable, and is available to all the methods of the class. As you can see it\u2019s used by say_hi and say_bye as self.name . The init() method is a special method called a \"constructor\". It is implicitly called when you create a new instance for the class, and the arguments are passed to init() . The constructor is responsible for complete initialization of the object, and it's always the first method called. The above example is typical of any object: it takes an argument name and copies it to an instance variable self.name to make it available to any method. Note: Berry has no concept of private members (contrary to C++). All instance variables and methods are always public.","title":"Evolving into a Greeter"},{"location":"Berry-Introduction/#creating-a-greeter-object","text":"Now let\u2019s create a greeter object and use it: > greeter = Greeter ( \"Pat\" ) > greeter . say_hi () Hi Pat > greeter . say_bye () Bye Pat , come back soon . Once the greeter object is created, it remembers that the name is Pat. If you want to get the name from a greeter, you can ask a greeter by accessing the name variable on it (without parenthesis): > greeter . name Pat","title":"Creating a greeter object"},{"location":"Berry-Introduction/#subclasses","text":"Methods and instance variables are defined at the class creation. You can't add method or instance variables to an already existing class. To extend a class you can create a sub-class: class SurGreeter : Greeter # subclass of Greeter var surname def init ( name , surname ) # sub-class takes 2 arguments super ( self ) . init ( name ) # call constructor of super-class self . surname = surname end def say_hi () import string print ( string . format ( \"Hi %s %s\" , self . name , self . surname )) end end The class SurGreeter extends Greeter with an additional surname field. It overwrides say_hi() but leaves say_bye() unchanged. There is a special syntax for calling a method of the subclass super(self).init(name) . Note: classes have always an init() method, either because it was explicitly defined, or implicitly. It is always ok to call super(self).init() even if the subclass has no explicit init() method. Now let's try this new class: > greet = SurGreeter ( \"John\" , \"Smith\" ) > greet . say_hi () Hi John Smith > greet . say_bye () Bye John , come back soon . > greet . name John > greet . surname Smith","title":"Subclasses"},{"location":"Berry-Introduction/#greetings-everyone","text":"This greeter isn\u2019t all that interesting though, it can only deal with one person at a time. What if we had some kind of MegaGreeter that could either greet the world, one person, or a whole list of people? Let\u2019s try to build that. We will start with a class definition: class MegaGreeter var names def init ( name ) self . names = [] # empty list if name != nil self . names . push ( name ) end end end So MegaGreeter objects have a list of names. The names field is initialized to the empty list [] . The body of the MegaGreeter constructor adds the given name argument to the end of the list of names if it's not nil . Mega greeters don't have a single name and no name field, so here the name is just an ordinary parameter that we can use in the body of the constructor. Let's try it: > greeter = MegaGreeter () > greeter . names [] > greeter = MegaGreeter ( \"World\" ) > greeter . names [ 'World' ] We can now go ahead and add greeter methods that add more names and show all the names: class MegaGreeter var names def init ( name ) self . names = [] # empty list if name != nil self . names . push ( name ) end end def add ( name ) self . names . push ( name ) end def say_hi () import string for n : self . names print ( string . format ( \"Hello %s!\" , n )) end end def say_bye () import string for n : self . names print ( string . format ( \"Bye %s, come back soon.\" , n )) end end end We introduced here a new construct known as an iterator. for n: self.names creates a new local variable n and iterate the following code for each value in self.names . Let's try the full example now: > greeter = MegaGreeter () > greeter . add ( \"Skiars\" ) > greeter . add ( \"Theo\" ) > greeter . add ( \"Stephan\" ) > greeter . say_hi () Hello Skiars ! Hello Theo ! Hello Stephan ! > greeter . say_bye () Bye Skiars , come back soon . Bye Theo , come back soon . Bye Stephan , come back soon .","title":"Greetings everyone!"},{"location":"Berry-Introduction/#comments","text":"Sometimes, it is nice just to add comments that explain interesting things related to your code. In the example in the last section, there were a few single line comments: self . names = [] # empty list Such comments start with # and tell the system to ignore the rest of the line. You can also use multi-line comments starting with #- and ending with -# . #- This is a comment - # #- # This is also a comment block (`#` are ignored) - # #----------------------------------------- Alternative way to make comment blocks ----------------------------------------- # Indentation has no impact on Berry compiler, it's only by convention to make source code more readable.","title":"Comments"},{"location":"Berry-Introduction/#maps","text":"Maps are a very common and powerful feature to store key/value pairs. They are declared usin {} . > m1 = {} # empty map > m {} > m2 = { \"k1\" :\"v1\" , \"k2\" :\"v2\" , \"k3\" :\"v3\" } > m2 { 'k2' : 'v2' , 'k1' : 'v1' , 'k3' : 'v3' } Actually keys and values can be of arbitrary type. > m3 = { 1 . 5 : 3 , 2 :\"two\" , true : 1 , false :nil } > m3 { 1 . 5 : 3 , true : 1 , 2 : 'two' , false : nil } The main restriction is that a key can't be nil . Setting adding a key of value nil is silently ignored. > m4 = { nil :\"foo\" } > m4 {} Accessing a value in the map uses [<key>] : > m1 = {} > m1 [ 'k1' ] = \"value1\" > m1 { 'k1' : 'value1' } # working with numerical values > m1 [ 'k2' ] = 0 > m1 [ 'k2' ] += 5 # shortcut for `m1['k2'] = m1['k2'] + 5` > m1 { 'k' : 'value' , 'k2' : 5 } Accessing a non-existent key raises an error. There is an alternative function find() to access a key and return a default value if the key is absent. contains() can also be used to check the presence of the key. > m1 = { \"foo\" :\"bar\" } > m1 . contains ( \"foo\" ) true > m1 . contains ( \"bar\" ) # only checks for keys, not values false > m1 [ \"foo\" ] bar > m1 [ \"bar\" ] key_error : bar stack traceback : < native > : in native function stdin : 1 : in function `main` # alternative with find > m1 . find ( \"foo\" , \"not_found\" ) bar > m1 . find ( \"bar\" , \"not_found\" ) not_found > m1 . find ( \"bar\" ) # returns nil by default if not found Note: m[k] = v is syntactic sugar for m.setitem(k, v) . When reading a value, m[k] is equivalent to m.item(k) .","title":"Maps"},{"location":"Berry-Introduction/#if-statements-and-basic-expressions","text":"We can program a ridiculously inefficient Fibonacci sequence generator using if and recursion: def fib ( n ) if n <= 1 return n end return fib ( n - 1 ) + fib ( n - 2 ) end This defines a top-level function called fib that is not a member of any class. The fib function is recursive, calling itself, and also makes use of a few new features. The if-statement is well known from other languages. In Berry it works by taking an expression and conditionally evaluating a block. Berry also has the usual array of infix operators, + , - , * , / , % etc. and the relational operators < , <= , > , >= , == and != . > fib ( 10 ) 55","title":"If statements and basic expressions"},{"location":"Berry-Introduction/#cycling-and-looping","text":"As we've seen in MegaGreeter it is very simple to iterate over a list for n: self.names [...] end . Iterators can also be used over ranges like for i:0..4 which will iterate over all values between 0 and 4 inclusive (5 iterations in total). > for i : 0 .. 4 print ( i ) end 0 1 2 3 4 Iterating over maps goes in two flavors: iterating over values, or over keys. > m = { \"k1\" :\"v1\" , \"k2\" :\"v2\" , \"k3\" :\"v3\" } > print ( m ) # keep in mind that there is no order in a map { 'k2' : 'v2' , 'k1' : 'v1' , 'k3' : 'v3' } # iterate over values > for v : m print ( v ) end v2 v1 v3 # iterate over keys > for k : m . keys () print ( k ) end k2 k1 k3 # iterate over both keys and values > for k : m . keys () print ( k , m [ k ] ) end k2 v2 k1 v1 k3 v3 For C programmers, the equivalent of for (int i=0; i<a; i++) { [...] } is for i: 0..a-1 [...] end","title":"Cycling and Looping"},{"location":"Berry-Introduction/#functions-and-arguments","text":"In Berry, functions are first class entities (Berry supports functional programming as well as object oriented). Berry is not a strongly types language, which means that you don't define any type as input or output when you define a function. This may seem as a problem, but it's a very powerful feature instead. Berry relies on what is known as \"Duck Typing\", as in \u201cIf it walks like a duck and it quacks like a duck, then it must be a duck\u201d. As long as the type you provide supports the right methods and calls, then it's fine. A function only defines the number of arguments it receives: > def f ( a , b ) return str ( a ) + str ( b ) end # takes only 2 arguments f expects 2 arguments, if you provide less than 2, the non-defined are set to nil . If you provide more than 2, the extra-arguments are silently ignored. > def f ( a , b ) return str ( a ) + str ( b ) end # takes only 2 arguments > f ( \"foo\" , \"bar\" ) foobar > f ( \"foo\" ) foonil > f ( \"foo\" , \"bar\" , \"baz\" ) foobar A function may or may not return a value with return <expression> . If you call just return or the function ends without any return statement, the function returns nil .","title":"Functions and arguments"},{"location":"Berry-Introduction/#closures","text":"Let's finish this introduction with a very powerful feature known as closures. It is sometimes seen as intimidating or complex, but it's actually very simple. We will visit only the most common use of closures, if you want to get more details see the Berry documentation . Let's go back to our simple Byer example (class that says Bye). class Byer var name def init ( name ) self . name = name end def say_bye () import string print ( string . format ( \"Bye %s, see you soon.\" , self . name )) end end Let's define an instance of this class: > bye_bob = Byer ( \"Bob\" ) > bye_pat = Byer ( \"Pat\" ) > bye_bob . say_bye () Bye Bob , see you soon . Nothing new until now. Closure are useful as soon as you need callbacks. Let's say that you are using a framework that accepts a callback (a function you provide that will be fired in the future). We want to pass a function that says Bye to Bob. The naive approach would be to use bye_bob.say_bye method, which is a valid function. However this function has no context and can't know which instance you are referring to. > bye_bob . say_bye < function : 0x3ffb3200 > > bye_pat . say_bye < function : 0x3ffb3200 > # same function as above As shown above, since the context is missing, you can't distinguish from the method bye_bob.say_bye and bye_pat.say_bye . They are the same function. Closure allows to create a new synthetic function that encapsulates transparently the context. > cb = def () bye_bob . say_bye () end > cb < function : 0x3ffd9df4 > # let's check that a closure on bye_pat is different > cb_pat = def () bye_pat . say_bye () end > cb_pat < function : 0x3ffdaaa0 > cb is a closure, if creates a function that captures the instance bye_bob and then calls say_bye() on it. Let's call the closures to check they are working. > cb () Bye Bob , see you soon . Tasmota this is widely used in Tasmota for example for deferred functions. For example if you want to run bye_bob.say_bye() in 5 seconds in the future: > tasmota . set_timer ( 5000 , cb ) # cb() is called in 5000 milliseconds Advanced users: there is a compact syntax for simple callbacks: def cb(a,b) return <expr> end becomes / a,b -> <expr>","title":"Closures"},{"location":"Berry-Introduction/#consider-yourself-introduced","text":"So that's a quick tour of Berry. Please have a look at the online Berry documentation . For Tasmota users, also have a look at the Tasmota Berry documentation and Tasmota Berry Cookbook .","title":"Consider Yourself Introduced"},{"location":"Berry-Introduction/#extra","text":"Here is a short comparison of Berry and Python syntax, courtesy of @Beormund Berry vs Python Berry MicroPython Current object self self Single line comments # # Multi line comments #- ... -# Logical 'and', 'or' and not operators && || ! and or not Shift left, right << >> << >> Integer division / // Statement blocks/grouping (scope) (indent) Class definition & inheritance class a:b class a(b): Class constructor def init(x) ... end def __init__(self, x): Class and superclass constructors def init(x) super(self).init(x) end def __init__(self, x): super(b, self).__init__(x) Class constructor that assigns to fields def init(x) self.x = x end def __init__(self, x): self.x = x Check object's type isinstance(b, a) isinstance(b, a) Call method foo with 2 arguments foo(x, y) foo(x,y) Declare a member variable in a class self.x = nil self.x = None Declare a local variable in a method var x = 2, y = nil x = 2 y = None Define a constant in a class static x = 2 Define a top level function def foo(x,y) end def foo(x,y): Define an instance method in a class def foo(x,y) end def foo(self, x, y): Define a static method in a class static def foo(x,y) end If statement if condition end if condition: Fixed loop for i: range end for i in range(end): Iterate over collection for k: coll.keys() end for x in coll: While loop while condition end while condition: Import from library import library import library Print print('hello world') print('Hello world') Interpolation string.format(\"Hello %s\", name) print(\"Hello %s\" %(name)) Simple types int real bool (true\\|false) string nil int float bool (True\\|False) string None Class types list map range list dict tuple set","title":"Extra"},{"location":"Berry/","text":"Berry Scripting Language ~ Berry Scripting is included in all tasmota32 builds. It is NOT supported on ESP82xx If you plan to code in Berry, you should enable #define USE_BERRY_DEBUG which will give you much more details when coding Useful resources: First time user of Berry: Berry Introduction (in 20 minutes of less) Full language documentation The Berry Script Language Reference Manual Tasmota extension of Berry, see below Full examples in the Berry Cookbook If you're new to Berry, have a look at Berry Introduction (in 20 minutes of less) Introduction to Berry ~ Berry is the next generation scripting for Tasmota. It is based on the open-source Berry project, delivering an ultra-lightweight dynamically typed scripting language designed for lower-performance embedded devices. Github Manual Reference sheet Download Berry Short Manual to get a list of basic functions and capabilities of Berry language Berry Scripting allows simple and also advanced extensions of Tasmota, for example: simple scripting advanced rules, beyond what is possible with native rules advanced automations Berry Scripting takes it one step further and allows to build dynamic extensions to Tasmota, that would previously require native code: build light animations build I 2 C drivers build complete Tasmota drivers integrate native libraries like lvgl see LVGL About the Berry language ~ Berry has the following advantages: Lightweight: A well-optimized interpreter with very little resources. Ideal for use in microprocessors. Fast: optimized one-pass bytecode compiler and register-based virtual machine. Powerful: supports imperative programming, object-oriented programming, functional programming. Flexible: Berry is a dynamic type script, and it's intended for embedding in applications. It can provide good dynamic scalability for the host system. Simple: simple and natural MicroPython-eque syntax, supports garbage collection and easy to use FFI (foreign function interface). RAM saving: With compile-time object construction, most of the constant objects are stored in read-only code data segments, so the RAM usage of the interpreter is very low when it starts. Tasmota Port ~ Berry Scripting in only supported on Tasmota32 for ESP32. The RAM usage starts at ~10kb and will be later optimized. Berry uses PSRAM on ESP32 if available (PSRAM is external RAM attached to ESP32 via SPI, it is slower but larger than internal RAM. Quick Start ~ Click on Configuration then Berry Scripting Console and enjoy the colorful Berry console, also called REPL (Read-Eval-Print-Loop). Drag the bottom corner of each screen to change its size The console is not designed for big coding tasks but it's recommended to use a code editor when dealing with many, many lines of code. An extension for Visual Studio Code exists to make writing Berry scripts even easier with colored syntax. Download the entire folder and copy to VSCode extensions folder. REPL Console ~ Try typing simple commands in the REPL. Since the input can be multi-lines, press Enter twice or click \"Run\" button to run the code. Use Up and Down to navigate through history of previous commands. > 1 + 1 2 > 2.0 / 3 0.666667 > print ( 'Hello Tasmota!' ) Hello Tasmota ! Note: Berry's native print() command displays text in the Berry Console and in the Tasmota logs. To log with finer control, you can also use the log() function which will not display in the Berry Console. > print ( 'Hello Tasmota!' ) log ( 'Hello again' ) Hello Tasmota ! Meanwhile the Tasmota log shows: > tasmota.cmd(\"Dimmer 60\") {'POWER': 'ON', 'Dimmer': 60, 'Color': '996245', 'HSBColor': '21,55,60', 'Channel': [60, 38, 27]} The light is bright Lights and Relays ~ Berry provides complete support for Relays and Lights. You can control individual Relays or lights with tasmota.get_power() and tasmota.set_power() . tasmota.get_power() returns an array of booleans representing the state of each relays and light (light comes last). tasmota.set_power(relay, onoff) changes the state of a single relay/light. 2 relays and 1 light > tasmota . get_power () [ false , true , false ] > tasmota . set_power ( 0 , true ) true > tasmota . get_power () [ true , true , false ] For light control, light.get() and light.set accept a structured object containing the following arguments: Attributes Details power boolean Turns the light off or on. Equivalent to tasmota.set_power() . When brightness is set to 0 , power is automatically set to off. On the contrary, you need to specify power:true to turn the light on. bri int range 0..255 Set the overall brightness. Be aware that the range is 0..255 and not 0..100 as Dimmer. hue int 0..360 Set the color Hue in degree, range 0..360 (0=red). sat int 0..255 Set the color Saturation (0 is grey). ct int 153..500 Set the white color temperature in mired, ranging from 153 (cold white) to 500 (warm white) rgb string 6 hex digits Set the color as hex RRGGBB , changing color and brightness. channels array of int, ranges 0..255 Set the value for each channel, as an array of numbers When setting attributes, they are evaluated in the following order, the latter overriding the previous: power , ct , hue , sat , rgb , channels , bri . # set to yellow, 25% brightness > light . set ({ \"power\" : true , \"hue\" : 60 , \"bri\" : 64 , \"sat\" : 255 }) { 'bri' : 64 , 'hue' : 60 , 'power' : true , 'sat' : 255 , 'rgb' : '404000' , 'channels' : [ 64 , 64 , 0 ]} # set to RGB 000080 (blue 50%) > light . set ({ \"rgb\" : \"000080\" }) { 'bri' : 128 , 'hue' : 240 , 'power' : true , 'sat' : 255 , 'rgb' : '000080' , 'channels' : [ 0 , 0 , 128 ]} # set bri to zero, also powers off > light . set ({ \"bri\" : 0 }) { 'bri' : 0 , 'hue' : 240 , 'power' : false , 'sat' : 255 , 'rgb' : '000000' , 'channels' : [ 0 , 0 , 0 ]} # changing bri doesn't automatically power > light . set ({ \"bri\" : 32 , \"power\" : true }) { 'bri' : 32 , 'hue' : 240 , 'power' : true , 'sat' : 255 , 'rgb' : '000020' , 'channels' : [ 0 , 0 , 32 ]} # set channels as numbers (purple 12%) > light . set ({ \"channels\" : [ 32 , 0 , 32 ]}) { 'bri' : 32 , 'hue' : 300 , 'power' : true , 'sat' : 255 , 'rgb' : '200020' , 'channels' : [ 32 , 0 , 32 ]} Rules ~ The rule function have the general form below where parameters are optional: def function_name ( value , trigger , msg ) end Parameter Description value The value of the trigger. Similar to %value% in native rules. trigger string of the trigger with all levels. Can be used if the same function is used with multiple triggers. msg map Berry structured object of the message, decoded from JSON. If JSON was invalid, it contains the original string Dimmer rule Define the function and add a rule to Tasmota where the function runs if Dimmer value is more than 50 > def dimmer_over_50 () print ( \"The light is bright\" ) end tasmota . add_rule ( \"Dimmer>50\" , dimmer_over_50 ) > tasmota . cmd ( \"Dimmer 30\" ) { 'POWER' : 'ON' , 'Dimmer' : 30 , 'Color' : '4D3223' , 'HSBColor' : '21,55,30' , 'Channel' : [ 30 , 20 , 14 ]} > tasmota . cmd ( \"Dimmer 60\" ) { 'POWER' : 'ON' , 'Dimmer' : 60 , 'Color' : '996245' , 'HSBColor' : '21,55,60' , 'Channel' : [ 60 , 38 , 27 ]} The light is bright The same function can be used with multiple triggers. If the function to process an ADC input should be triggered both by the tele/SENSOR message and the result of a Status 10 command: tasmota . add_rule ( \"ANALOG#A1\" , rule_adc_1 ) tasmota . add_rule ( \"StatusSNS#ANALOG#A1\" , rule_adc_1 ) Or if the same function is used to process similar triggers: import string def rule_adc ( value , trigger ) var i = string . find ( trigger , \"#A\" ) var tr = string . split ( trigger , i + 2 ) var adc = number ( tr [ 1 ]) print ( \"value of adc\" , adc , \" is \" , value ) end tasmota . add_rule ( \"ANALOG#A1\" , rule_adc ) tasmota . add_rule ( \"ANALOG#A2\" , rule_adc ) Another way to address the same using anonymous functions created dynamically def rule_adc ( adc , value ) print ( \"value of adc\" , adc , \" is \" , value ) end tasmota . add_rule ( \"ANALOG#A1\" , def ( value ) rule_adc ( 1 , value ) end ) tasmota . add_rule ( \"ANALOG#A2\" , def ( value ) rule_adc ( 2 , value ) end ) Teleperiod rules Teleperiod rules are supported with a different syntax from Tasmota rules. Instead of using Tele- prefix, you must use Tele# . For example Tele#ANALOG#Temperature1 instead of Tele-ANALOG#Temperature1 Timers ~ Berry code, when it is running, blocks the rest of Tasmota. This means that you should not block for too long, or you may encounter problems. As a rule of thumb, try to never block more than 50ms. If you need to wait longer before the next action, use timers. As you will see, timers are very easy to create thanks to Berry's functional nature. All times are in milliseconds. You can know the current running time in milliseconds since the last boot: > tasmota . millis () 9977038 Sending a timer is as easy as tasmota.set_timer(<delay in ms>,<function>) > def t () print ( \"Booh!\" ) end > tasmota . set_timer ( 5000 , t ) [ 5 seconds later ] Booh ! A word on functions and closure ~ Berry is a functional language, and includes the very powerful concept of a closure . In a nutshell, it means that when you create a function, it can capture the values of variables when the function was created. This roughly means that it does what intuitively you would expect it to do. When using Rules or Timers, you always pass Berry functions. cron recurrent calls ~ You can choose to run some function/closure at regular intervals specified as cron type format. Crontab Guru is an easy way to create and test your cron format. > def f () print ( \"Hi\" ) end > tasmota . add_cron ( \"*/15 * * * * *\" , f , \"every_15_s\" ) Hi Hi # added every 15 seconds > tasmota . remove_cron ( \"every_15_s\" ) # cron stops Like timers, you need to create a closure if you want to register a method of an instance. Example: class A var name def init ( name ) self . name = name end def p () print ( \"Hi,\" , self . name ) end end > bob = A ( \"bob\" ) > bob . p () Hi , bob > tasmota . add_cron ( \"*/15 * * * * *\" , /-> bob.p(), \"hi_bob\") Hi, bob Hi, bob Hi, bob > tasmota.remove_cron(\"hi_bob\") # cron stops You can get the timestamp for the next event by using tasmota.next_cron(id) which returns an epoch in seconds. Loading Filesystem ~ You can upload Berry code in the filesystem using the Consoles - Manage File system menu and load them at runtime. Make careful to use *.be extension for those files. To load a Berry file, use the load(filename) function where filename is the name of the file with .be or .bec extension; if the file has no extension '.be' is automatically appended. You don't need to prefix with / . A leading / will be added automatically if it is not present. When loading a Berry script, the compiled bytecode is automatically saved to the filesystem, with the extension .bec (this is similar to Python's .py / .pyc mechanism). The save(filename,closure) function is used internally to save the bytecode. If a precompiled bytecode (extension .bec ) is present of more recent than the Berry source file, the bytecode is directly loaded which is faster than compiling code. You can eventually remove the *.be file and keep only *.bec file (even with load(\"file.be\") . Creating a Tasmota Driver ~ You can easily create a complete Tasmota driver with Berry. A Driver responds to messages from Tasmota. For each message type, the method with the same name is called. Actually you can register any class as a driver, it does not need to inherit from Driver ; the call mechanism is based on names of methods that must match the name of the event to be called. Driver methods are called with the following parameters: f(cmd, idx, payload, raw) . cmd is a string, idx an integer, payload a Berry object representation of the JSON in payload (if any) or nil , raw is a string. These parameters are meaningful to a small subset of events: every_second() : called every second every_50ms() : called every 50ms (i.e. 20 times per second) every_100ms() : called every 100ms (i.e. 10 times per second) every_200ms() : called every 200ms (i.e. 5 times per second) every_250ms() : called every 250ms (i.e. 4 times per second) web_sensor() : display sensor information on the Web UI json_append() : display sensor information in JSON format for TelePeriod reporting web_add_button() : (deprecated) synonym of web_add_console_button() web_add_main_button() , web_add_management_button() , web_add_console_button() , web_add_config_button() : add a button to Tasmotas Web UI on a specific page web_add_handler() : called when Tasmota web server started, and the right time to call webserver.on() to add handlers button_pressed() : called when a button is pressed save_before_restart() : called just before a restart mqtt_data(topic, idx, data, databytes) : called for MQTT payloads matching mqtt.subscribe . idx is zero, and data is normally unparsed JSON. set_power_handler(cmd, idx) : called whenever a Power command is made. idx contains the index of the relay or light. cmd can be ignored. display() : called by display driver with the following subtypes: init_driver , model , dim , power . Then register the driver with tasmota.add_driver(<driver>) . There are basically two ways to respond to an event: Example Define a class and implement methods with the same name as the events you want to respond to. class MyDriver def every_second () # do something end end d1 = MyDriver () tasmota . add_driver ( d1 ) Fast Loop ~ Beyond the events above, a specific mechanism is available for near-real-time events or fast loops (above 50 times per second). Special attention is made so that there is no or very little impact on performance. Until a first callback is registered, performance is not impacted and Berry is not called. This protects any current use from any performance impact. Once a callback is registered, it is called separately from Berry drivers to ensure minimal overhead. tasmota.add_fast_loop(cl:function) -> nil registers a callback to be called in fast loop mode. The callback is called without any parameter and does not need to return anything. The callback is called at each iteration of Tasmota event loop. The frequency is tightly linked to the Speed <x> command. By default, the sleep period is 50ms, hence fast_loop is called every 50ms. You can reduce the time with Sleep 10 (10ms) hence calling 100 times per second. If you set Sleep 0 , the callback is called as frequently as possible (discouraged unless you have a good reason). tasmota.remove_fast_loop(cl:function) -> nil removes a previously registered function or closure. You need to pass the exact same closure reference. Warning, if you need to register a method from an instance, you need a closure: class my_driver def every_100ms() # called every 100ms via normal way end def fast_loop() # called at each iteration, and needs to be registered separately and explicitly end def init() # register fast_loop method tasmota.add_fast_loop(/-> self.fast_loop()) # variant: # tasmota.add_fast_loop(def () self.fast_loop() end) end end tasmota.add_driver(my_driver()) # register driver tasmota.add_fast_loop(/-> my_driver.fast_loop()) # register a closure to capture the instance of the class as well as the method Tasmota Only Extensions ~ log(msg:string [, level:int = 3]) -> string ~ Logs a message to the Tasmota console. Optional second argument is log_level (0..4), default is 2 LOG_LEVEL_INFO . Example > log(\"A\") A load(filename:string) -> bool ~ Loads a Berry script from the filesystem, and returns true if loaded successfully, false if file not found, or raises an exception in runtime. Filename does not need to start with / , but needs to end with .be (Berry source code) or .bec (precompiled bytecode). When loading a source file, the precompiled bytecode is saved to filesystem using the .bec extension. save(filename:string, f:closure) -> nil ~ Internally used function to save bytecode. It's a wrapper to the Berry's internal API be_savecode() . There is no check made on the filename. There is generally no need to use this function, it is used internally by load() . tasmota object ~ A root level object called tasmota is created and contains numerous functions to interact with Tasmota. Tasmota Function Parameters and details tasmota.get_free_heap () -> int Returns the number of free bytes on the Tasmota heap. tasmota.publish (topic:string, payload:string[, retain:bool, start:int, len:int]) -> nil Deprecated see mqtt.publish tasmota.publish_result (payload:string, subtopic:string) -> nil Publishes a JSON result and triggers any associated rule. payload is expected to be a JSON string, and subtopic the subtopic used to publish the payload. tasmota.publish_rule (payload:string) -> handled:bool sends a JSON stringified message to the rule engine, without actually publishing a message to MQTT. Returns true if the message was handled by a rule. tasmota.cmd (command:string) -> map Sends any command to Tasmota, like it was type in the console. It returns the result of the command if any, as a map parsed from the command output JSON. tasmota.memory () -> map Returns memory stats similar to the Information page. Example: {'iram_free': 41, 'frag': 51, 'program_free': 1856, 'flash': 4096, 'heap_free': 226, 'program': 1679} or when PSRAM {'psram_free': 3703, 'flash': 16384, 'program_free': 3008, 'program': 1854, 'psram': 4086, 'frag': 27, 'heap_free': 150} tasmota.add_rule (pattern:string, f:function [, id:any]) ->nil Adds a rule to the rule engine. See above for rule patterns. Optional id to remove selectively rules. tasmota.remove_rule (pattern:string [, id:any]) ->nil Removes a rule to the rule engine. Silently ignores the pattern if no rule matches. Optional id to remove selectively some rules. tasmota.add_driver (instance) ->nil Registers an instance as a driver tasmota.remove_driver (instance) ->nil Removes a driver tasmota.gc () -> int Triggers garbage collection of Berry objects and returns the bytes currently allocated. This is for debug only and shouldn't be normally used. gc is otherwise automatically triggered when necessary. Functions used to retrieve Tasmota configuration ~ Tasmota Function Parameters and details tasmota.get_option (index:int) -> int Returns the value of SetOption <index> tasmota.wire_scan (addr:int [, index:int]) -> wire instance or nil Scan both I 2 C buses for a device of address addr, optionally taking into account disabled devices via I2CDevice . Returns a wire object corresponding to the bus where the device is, or nil if device is not connected or disabled. tasmota.i2c_enabled (index:int) -> bool Returns true if the I 2 C module is enabled, see I 2 C page. tasmota.arch () -> string Returns the name of the architecture. Currently can be esp32 , esp32s2 , esp32s3 , esp32c3 tasmota.read_sensors ([show_sensor:bool]) -> string Returns the value of sensors as a JSON string similar to the teleperiod. The response is a string, not a JSON object. The reason is that some sensors might produce invalid JSON. It's your code's responsibility to try parsing as JSON. An optional boolean parameter (false by default) can be set to trigger a display of the new values (i.e. sends a FUNC_SHOW_SENSOR` event to drivers). tasmota.wifi () -> map Retrieves Wi-Fi connection info or empty map. Example: {'mac': 'aa:bb:cc:22:11:03', 'quality': 100, 'rssi': -47, 'ip': '192.168.1.102'} tasmota.eth () -> map Retrieves Ethernet connection info or empty map. Example: {'mac': 'aa:bb:cc:22:11:00', 'ip': '192.168.1.101'} Functions for time, timers or cron ~ Tasmota Function Parameters and details tasmota.millis ([delay:int]) -> int Returns the number of milliseconds since last reboot. The optional parameter lets you specify the number of milliseconds in the future; useful for timers. tasmota.time_reached (timer:int) -> bool Checks whether the timer (in milliseconds) has been reached or not. Always use this function and don't do compares between millis() and timers, because of potential sign and overflow issues. tasmota.rtc () -> map Returns clockwall time with variants. Example: {'local': 1619560407, 'utc': 1619556807, 'timezone': 60, 'restart': 1619556779} tasmota.time_dump (timestamp:int) -> map Decompose a timestamp value (in seconds) to its components Example: tasmota.time_dump(1619560407) -> {'weekday': 2, 'sec': 27, 'month': 4, 'year': 2021, 'day': 27, 'min': 53, 'hour': 21} tasmota.time_str (timestamp:int) -> string Converts a timestamp value (in seconds) to an ISO 8601 string Example: tasmota.time_str(1619560407) -> 2021-04-27T21:53:27 tasmota.set_timer (delay:int, f:function [, id:any]) -> nil Runs the closure or function f after delay milliseconds, optional id can be used to remove the timer. tasmota.remove_timer (id:string) -> nil Removes the timer with the id used on tasmota.set_timer . tasmota.strftime (format:string, timestamp:int) -> string Converts a timestamp value (in seconds) to a string using the format conversion specifiers Example: tasmota.strftime(\"%d %B %Y %H:%M:%S\", 1619560407) -> 27 April 2021 21:53:27 tasmota.strptime (time:string, format:string) -> map or nil Converts a string to a date, according to a time format following the C strptime format. Returns a map similar to tasmota.time_dump() or nil if parsing failed. An additional unparsed attribute reports the unparsed string, or empty string if everything was parsed. Example: tasmota.strptime(\"2001-11-12 18:31:01\", \"%Y-%m-%d %H:%M:%S\") -> {'month': 11, 'weekday': 1, 'sec': 1, 'unparsed': '', 'year': 2001, 'day': 12, 'min': 31, 'hour': 18} tasmota.yield () -> nil Calls Arduino framework yield() function to give back some time to low-level functions, like Wifi. Prevents WDT watchdog from happening. tasmota.delay ([delay:int]) -> int Waits and blocks execution for delay milliseconds. Should ideally never wait more than 10ms and absolute max 50ms. Otherwise use set_timer . tasmota.add_cron (pattern:string, f:function [, id:any]) -> nil Adds a cron-type timer, with a cron pattern and a function/closure to call. An optional id can be added to retrieve or delete the cron timer tasmota.remove_cron (id:any) -> nil Remove a cron timer. tasmota.next_cron (id:any) -> int returns the next timestamp for the cron timer. The timestamp is second epoch in local time. You can use tasmota.tasmota.time_str() to convert to a time string. Functions to create custom Tasmota command ~ Tasmota Function Parameters and details tasmota.add_cmd (name:string, f:function) -> nil Adds a command to Tasmota commands. Command names are case-insensitive. Command names are analyzed after native commands and after most commands, so you can't override a native command. tasmota.resp_cmnd_str (message:string) -> nil Sets the output for the command to message . tasmota.resp_cmnd_done () -> nil Sets the output for the command to \"Done\" (localized message). tasmota.resp_cmnd_error () -> nil Sets the output for the command to \"Error\" (localized message). tasmota.resp_cmnd_failed () -> nil Sets the output for the command to \"Fail\" (localized message). tasmota.resp_cmnd (message:string) -> nil Overrides the entire command response. Should be a valid JSON string. tasmota.remove_cmd (name:string) -> nil Remove a command to Tasmota commands. Removing an non-existing command is skipped silently. Functions to add custom responses to JSON and Web UI to sensors ~ Tasmota Function Parameters and details tasmota.response_append (name:string) -> nil Adds JSON fragment to the current response. Used for example for sensors to add JSON to teleperiod. Can be called only in json_append() method of a registered driver (see cookbook). It is called at least at each teleperiod, or when reading sensor data in JSON. tasmota.web_send (message:string) -> nil Adds an HTML fragment to the Web output. Can be called only in web_sensor() method of a registered driver (see cookbook). It is called at each main page refresh. tasmota.web_send_decimal (message:string) -> nil Adds an HTML fragment to the Web output, similar to web_send but converts decimal dot . to the locale decimal separator. Can be called only in web_sensor() method of a registered driver (see cookbook). It is called at each main page refresh. See examples in the Berry-Cookbook Functions to manage Relays and Lights ~ Tasmota Function Parameters and details tasmota.get_power () -> list[bool] Returns the state On/Off of each Relay and Light as a list of bool. tasmota.set_power (index:int, onoff:bool) -> bool Sets the on/off state of a Relay/Light. Returns the previous status of the Relay/Light of nil if index is invalid. Example: > tasmota.get_power() [true] tasmota.get_light deprecated use light.get tasmota.set_light deprecated use light.set tasmota.get_switches () -> list(bool) Returns as many values as switches are present. true means PRESSED and false means NOT_PRESSED . (Warning: this is the opposite of the internal representation where PRESSED=0) Note: if there are holes in the switch definition, the values will be skipped. I.e. if you define SWITCH1 and SWITCH3, the array will return the two consecutive values for switches 1/3. Low-level access to Tasmota globals and settings. ~ Use with care and only if you know what you are doing. The construct is to use tasmota.global or tasmota.settings to read or write attributes. You can do bad things with these features Value Details tasmota.global.sleep Current sleep value tasmota.settings.sleep Sleep value stored in flash mqtt module ~ Use with import mqtt . Since v11.1.0.1, there is an easier way than registering a driver, and listening to mqtt_data event. You can now just attach a function or closure to a MQTT topic, and it does the magic for you. The function you attach to a topic pattern received only the matching MQTT messages, not all messages unlike mqtt_data() would. The function takes the same parameters as mqtt_data() : - topic : full topic received from the broker - idx : not used - payload_s : payload as string, usually converted to JSON with import json json.load(payloas_s) - payload_b : payload as a binary payload, bytes() array - the function should return true if the event was parsed or if the event should not trigger a Tasmota command. If you return nil or nothing, it is considered as true which is the usual behavior you want (i.e. not trigger a Tasmota command from random MQTT messages). Tasmota Function Parameters and details mqtt.publish (topic:string, payload:string[, retain:bool, start:int, len:int]) -> nil Equivalent of publish command, publishes a MQTT message on topic with payload . Optional retain parameter. payload can be a string or a bytes() binary array start and len allow to specificy a sub-part of the string or bytes buffer, useful when sending only a portion of a larger buffer. mqtt.subscribe mqtt.subscribe(topic:string [, function:closure]) -> nil Subscribes to a topic (exact match or pattern). Contrary to Tasmota's Subscribe command, the topic is sent as-is and not appended with /# . You need to add wildcards yourself. Driver method mqtt_data is called for each matching payload. If a function/closure is added, the function is called whenever and only if an incoming messages matches the pattern for this function. The function should return true if message was processed, false if not which will let the message flow to Tasmota eventually as a command. mqtt.unsubscribe (topic:string) -> nil Unubscribe to a topic (exact match). light object ~ Module light is automatically imported via a hidden import light command. Tasmota Function Parameters and details light.get (index:int) -> map Get the current status if light number index (default:0). Example: > light.get {'bri': 77, 'hue': 21, 'power': true, 'sat': 140, 'rgb': '4D3223', 'channels': [77, 50, 35]} light.set (settings:map[, index:int]) -> map Sets the current state for light index (default: 0. Example: > light.set({'hue':120,'bri':50,'power':true}) {'bri': 50, 'hue': 120, 'power': true, 'sat': 140, 'rgb': '173217', 'channels': [23, 50, 23]} light.gamma10 (channel) -> int Computes the gamma corrected value with 10 bits resolution for input and output. Note: Gamma is optimized for speed and smooth fading, and is not 100% mathematically accurate. Input and output are in range 0..1023. light.reverse_gamma10 (gamma) -> int Computes the reverse gamma with 10 bits resolution for input and output. Input and output are in range 0..1023. light.gamma8 (channel) -> int Computes the gamma corrected value with 8 bits resolution for input and output. Input and output are in range 0..255. gpio module ~ This module allows to retrieve the GPIO configuration set in the templates. You need to distinguish between logical gpio (like PWM, or I2C) and physical gpio which represent the GPIO number of the physical pin. gpio.pin() transforms a logical GPIO to a physical GPIO, or -1 if the logical GPIO is not set. Currently there is limited support for GPIO: you can only read/write in digital mode and set the GPIO mode. Tasmota Function Parameters and details gpio.pin_used (gpio [,index]) -> bool returns if a specific GPIO is used. index allows to iterate through GPIOs. Example: gpio.pin_used(gpio.REL1) to check Relay1, or gpio.pin_used(gpio.REL1,1) to check Relay2 (index is zero-based) gpio.pin (gpio [,index]) -> int returns the physical GPIO number assigned to the Tasmota GPIO, or -1 if the GPIO is not assigned gpio.digital_write (phy_gpio, val) -> nil needs the physical GPIO number sets the GPIO to LOW/HIGH. val can be 0 , 1 , gpio.LOW or gpio.HIGH . Example: gpio.digital_write(gpio.pin(gpio.REL1), gpio.HIGH) sets Relay1 to High. gpio.digital_read (phy_gpio) -> int needs the physical GPIO number reads the value of a GPIO. Returns 0 or 1. gpio.pin_mode (phy_gpio, mode) -> nil needs the physical GPIO number Changes the GPIO mode. It should be called very cautiously. Normally Tasmota handles automatically GPIO modes. mode can have the following values: gpio.INPUT , gpio.OUTPUT , gpio.PULLUP , gpio.INPUT_PULLUP , gpio.PULLDOWN , gpio.OPEN_DRAIN , gpio.OUTPUT_OPEN_DRAIN , gpio.DAC gpio.dac_voltage (phy_gpio:int, voltage_mv:int) -> int Sets the DAC voltage in mV. The resolution is 8 bits over a range of 0..3.3V, i.e. an increment of ~13mV, this function returns the actual voltage output rounded to the closest value. See below for constraints of DAC GPIOs. gpio.set_pwm (phy_gpio:int, duty:int [, phase:int]) -> nil Sets the value of a PWM output phy_gpio : physical GPIO number duty : analog value for the pwm, range is 0..1023 unless you change the PWM range phase : (opt) set the starting point in time for this pulse from start of cycle. Range is 0..1023 unless you change PWM range. This allows to dephase pulses, for example for H-bridge. Low-level this is a low-level function that bypasses all the Tasmota logic around PWM. Use with caution as a PWM command might overwrite your settings. Any internal error or using unsupported GPIO yields an Berry exception. Possible values for Tasmota GPIOs: gpio.NONE , gpio.KEY1 , gpio.KEY1_NP , gpio.KEY1_INV , gpio.KEY1_INV_NP , gpio.SWT1 , gpio.SWT1_NP , gpio.REL1 , gpio.REL1_INV , gpio.LED1 , gpio.LED1_INV , gpio.CNTR1 , gpio.CNTR1_NP , gpio.PWM1 , gpio.PWM1_INV , gpio.BUZZER , gpio.BUZZER_INV , gpio.LEDLNK , gpio.LEDLNK_INV , gpio.I2C_SCL , gpio.I2C_SDA , gpio.SPI_MISO , gpio.SPI_MOSI , gpio.SPI_CLK , gpio.SPI_CS , gpio.SPI_DC , gpio.SSPI_MISO , gpio.SSPI_MOSI , gpio.SSPI_SCLK , gpio.SSPI_CS , gpio.SSPI_DC , gpio.BACKLIGHT , gpio.OLED_RESET , gpio.IRSEND , gpio.IRRECV , gpio.RFSEND , gpio.RFRECV , gpio.DHT11 , gpio.DHT22 , gpio.SI7021 , gpio.DHT11_OUT , gpio.DSB , gpio.DSB_OUT , gpio.WS2812 , gpio.MHZ_TXD , gpio.MHZ_RXD , gpio.PZEM0XX_TX , gpio.PZEM004_RX , gpio.PZEM016_RX , gpio.PZEM017_RX , gpio.SAIR_TX , gpio.SAIR_RX , gpio.PMS5003_TX , gpio.PMS5003_RX , gpio.SDS0X1_TX , gpio.SDS0X1_RX , gpio.SBR_TX , gpio.SBR_RX , gpio.SR04_TRIG , gpio.SR04_ECHO , gpio.SDM120_TX , gpio.SDM120_RX , gpio.SDM630_TX , gpio.SDM630_RX , gpio.TM1638CLK , gpio.TM1638DIO , gpio.TM1638STB , gpio.MP3_DFR562 , gpio.HX711_SCK , gpio.HX711_DAT , gpio.TX2X_TXD_BLACK , gpio.TUYA_TX , gpio.TUYA_RX , gpio.MGC3130_XFER , gpio.MGC3130_RESET , gpio.RF_SENSOR , gpio.AZ_TXD , gpio.AZ_RXD , gpio.MAX31855CS , gpio.MAX31855CLK , gpio.MAX31855DO , gpio.NRG_SEL , gpio.NRG_SEL_INV , gpio.NRG_CF1 , gpio.HLW_CF , gpio.HJL_CF , gpio.MCP39F5_TX , gpio.MCP39F5_RX , gpio.MCP39F5_RST , gpio.PN532_TXD , gpio.PN532_RXD , gpio.SM16716_CLK , gpio.SM16716_DAT , gpio.SM16716_SEL , gpio.DI , gpio.DCKI , gpio.CSE7766_TX , gpio.CSE7766_RX , gpio.ARIRFRCV , gpio.ARIRFSEL , gpio.TXD , gpio.RXD , gpio.ROT1A , gpio.ROT1B , gpio.ADC_JOY , gpio.SSPI_MAX31865_CS1 , gpio.HRE_CLOCK , gpio.HRE_DATA , gpio.ADE7953_IRQ , gpio.SOLAXX1_TX , gpio.SOLAXX1_RX , gpio.ZIGBEE_TX , gpio.ZIGBEE_RX , gpio.RDM6300_RX , gpio.IBEACON_TX , gpio.IBEACON_RX , gpio.A4988_DIR , gpio.A4988_STP , gpio.A4988_ENA , gpio.A4988_MS1 , gpio.OUTPUT_HI , gpio.OUTPUT_LO , gpio.DDS2382_TX , gpio.DDS2382_RX , gpio.DDSU666_TX , gpio.DDSU666_RX , gpio.SM2135_CLK , gpio.SM2135_DAT , gpio.DEEPSLEEP , gpio.EXS_ENABLE , gpio.TASMOTACLIENT_TXD , gpio.TASMOTACLIENT_RXD , gpio.TASMOTACLIENT_RST , gpio.TASMOTACLIENT_RST_INV , gpio.HPMA_RX , gpio.HPMA_TX , gpio.GPS_RX , gpio.GPS_TX , gpio.HM10_RX , gpio.HM10_TX , gpio.LE01MR_RX , gpio.LE01MR_TX , gpio.CC1101_GDO0 , gpio.CC1101_GDO2 , gpio.HRXL_RX , gpio.ELECTRIQ_MOODL_TX , gpio.AS3935 , gpio.ADC_INPUT , gpio.ADC_TEMP , gpio.ADC_LIGHT , gpio.ADC_BUTTON , gpio.ADC_BUTTON_INV , gpio.ADC_RANGE , gpio.ADC_CT_POWER , gpio.WEBCAM_PWDN , gpio.WEBCAM_RESET , gpio.WEBCAM_XCLK , gpio.WEBCAM_SIOD , gpio.WEBCAM_SIOC , gpio.WEBCAM_DATA , gpio.WEBCAM_VSYNC , gpio.WEBCAM_HREF , gpio.WEBCAM_PCLK , gpio.WEBCAM_PSCLK , gpio.WEBCAM_HSD , gpio.WEBCAM_PSRCS , gpio.BOILER_OT_RX , gpio.BOILER_OT_TX , gpio.WINDMETER_SPEED , gpio.KEY1_TC , gpio.BL0940_RX , gpio.TCP_TX , gpio.TCP_RX , gpio.ETH_PHY_POWER , gpio.ETH_PHY_MDC , gpio.ETH_PHY_MDIO , gpio.TELEINFO_RX , gpio.TELEINFO_ENABLE , gpio.LMT01 , gpio.IEM3000_TX , gpio.IEM3000_RX , gpio.ZIGBEE_RST , gpio.DYP_RX , gpio.MIEL_HVAC_TX , gpio.MIEL_HVAC_RX , gpio.WE517_TX , gpio.WE517_RX , gpio.AS608_TX , gpio.AS608_RX , gpio.SHELLY_DIMMER_BOOT0 , gpio.SHELLY_DIMMER_RST_INV , gpio.RC522_RST , gpio.P9813_CLK , gpio.P9813_DAT , gpio.OPTION_A , gpio.FTC532 , gpio.RC522_CS , gpio.NRF24_CS , gpio.NRF24_DC , gpio.ILI9341_CS , gpio.ILI9341_DC , gpio.ILI9488_CS , gpio.EPAPER29_CS , gpio.EPAPER42_CS , gpio.SSD1351_CS , gpio.RA8876_CS , gpio.ST7789_CS , gpio.ST7789_DC , gpio.SSD1331_CS , gpio.SSD1331_DC , gpio.SDCARD_CS , gpio.ROT1A_NP , gpio.ROT1B_NP , gpio.ADC_PH , gpio.BS814_CLK , gpio.BS814_DAT , gpio.WIEGAND_D0 , gpio.WIEGAND_D1 , gpio.NEOPOOL_TX , gpio.NEOPOOL_RX , gpio.SDM72_TX , gpio.SDM72_RX , gpio.TM1637CLK , gpio.TM1637DIO , gpio.PROJECTOR_CTRL_TX , gpio.PROJECTOR_CTRL_RX , gpio.SSD1351_DC , gpio.XPT2046_CS , gpio.CSE7761_TX , gpio.CSE7761_RX , gpio.VL53LXX_XSHUT1 , gpio.MAX7219CLK , gpio.MAX7219DIN , gpio.MAX7219CS , gpio.TFMINIPLUS_TX , gpio.TFMINIPLUS_RX , gpio.ZEROCROSS , gpio.HALLEFFECT , gpio.EPD_DATA , gpio.INPUT , gpio.KEY1_PD , gpio.KEY1_INV_PD , gpio.SWT1_PD , gpio.I2S_OUT_DATA , gpio.I2S_OUT_CLK , gpio.I2S_OUT_SLCT , gpio.I2S_IN_DATA , gpio.I2S_IN_CLK , gpio.I2S_IN_SLCT , gpio.INTERRUPT , gpio.MCP2515_CS , gpio.HRG15_TX , gpio.VINDRIKTNING_RX , gpio.BL0939_RX , gpio.BL0942_RX , gpio.HM330X_SET , gpio.HEARTBEAT , gpio.HEARTBEAT_INV , gpio.SHIFT595_SRCLK , gpio.SHIFT595_RCLK , gpio.SHIFT595_OE , gpio.SHIFT595_SER , gpio.SOLAXX1_RTS , gpio.OPTION_E , gpio.SDM230_TX , gpio.SDM230_RX , gpio.ADC_MQ , gpio.CM11_TXD , gpio.CM11_RXD , gpio.BL6523_TX , gpio.BL6523_RX , gpio.ADE7880_IRQ , gpio.RESET , gpio.MS01 , gpio.SDIO_CMD , gpio.SDIO_CLK , gpio.SDIO_D0 , gpio.SDIO_D1 , gpio.SDIO_D2 , gpio.SDIO_D3 , gpio.FLOWRATEMETER_SIGNAL , gpio.SENSOR_END An H-bridge is an electronic circuit that switches the polarity of a voltage applied to a load. These circuits are often used in robotics and other applications to allow DC motors to run forwards or backwards. See the Berry cookbook for H-bridge control DAC GPIOs ~ DAC is limited to specific GPIOs: ESP32: only GPIO 25-26 ESP32-S2: only GPIO 17-18 ESP32-C3: not supported Example > gpio.pin_mode(25, gpio.DAC) # sets GPIO25 to a DAC pin > gpio.dac_voltage(25, 1250) # set voltage to 1250mV 1255 Function returns closes voltage found. In this case its 1255 for setting to 1250. I2S ~ DAC can also be used via Esp8266Audio through the ESP32 I2S -> DAC bridge. Example class MP3_Player : Driver var audio_output , audio_mp3 def init () self . audio_output = AudioOutputI2S ( gpio . pin ( gpio . I2S_OUT_CLK ), gpio . pin ( gpio . I2S_OUT_SLCT ), gpio . pin ( gpio . I2S_OUT_DATA ), 0 , #- I2S port -# 64 ) #- number of DMA buffers of 64 bytes each, this is the value required since we update every 50ms -# self . audio_mp3 = AudioGeneratorMP3 () end def play ( mp3_fname ) if self . audio_mp3 . isrunning () self . audio_mp3 . stop () end var audio_file = AudioFileSourceFS ( mp3_fname ) self . audio_mp3 . begin ( audio_file , self . audio_output ) self . audio_mp3 . loop () #- start playing now -# end def every_50ms () if self . audio_mp3 . isrunning () self . audio_mp3 . loop () end end end mp3_player = MP3_Player () tasmota . add_driver ( mp3_player ) mp3_player . play ( \"/pno-cs.mp3\" ) energy module ~ The energy module provides ways to read current energy counters and values (if you're creating your own automation) or updating the energy counters (if you're writing a driver). It relies on a new Berry feature that provides a direct mapping between the internal C structure called struct Energy and the energy module in Berry. For example, if you want to read or update an energy value: > energy.active_power 0 > energy.active_power = 460 > energy.active_power 460 # internally it updates the C value `Energy.active_power[0]` (float) You don't need to do import energy since Tasmota does it for you at boot. The special energy.read() function dumps all current values to a single map . Be aware that the object is very long. Prefer accessing individual attributes instead. Tasmota Function Parameters and details energy.read() () -> map Returns all current values for the energy module. Some values may be unused by the current driver. List of energy attributes that you can read or write: Attribute Type Description voltage voltage_2 voltage_3 float Voltage (V) for main phase or 3 phases current current_2 current_3 float Current (A) for main phase or 3 phases active_power active_power_2 active_power_3 float Active Power (W) for main phase or 3 phases reactive_power reactive_power_2 reactive_power_3 float Reactive Power (W) for main phase or 3 phases power_factor power_factor_2 power_factor_3 float Power Factor (no unit) for main phase or 3 phases frequency frequency_2 frequency_3 float Frequency (Hz) for main phase or 3 phases export_active export_active_2 export_active_3 float (kWh) start_energy float Total previous energy (kWh) daily float Daily energy (kWh) total float Total energy (kWh) today_delta_kwh uint32 (deca milli Watt hours) 5764 = 0.05764 kWh = 0.058 kWh today_offset_kwh uint32 (deca milli Watt hours) today_kwh uint32 (deca milli Watt hours) period uint32 (deca milli Watt hours) fifth_second uint8 command_code uint8 data_valid data_valid_2 data_valid_3 uint8 phase_count uint8 Number of phases (1,2 or 3) voltage_common bool Use single voltage frequency_common bool Use single frequency use_overtemp bool Use global temperature as overtemp trigger on internal energy monitor hardware today_offset_init_kwh bool voltage_available bool Enable if voltage is measured current_available bool Enable if current is measured type_dc bool power_on bool power_history_0 power_history_0_2 power_history_0_3 power_history_1 power_history_1_2 power_history_1_3 power_history_2 power_history_2_2 power_history_2_3 uint16 power_steady_counter uint8 Allow for power on stabilization min_power_flag bool max_power_flag bool min_voltage_flag bool max_voltage_flag bool min_current_flag bool max_current_flag bool mplh_counter uint16 mplw_counter uint16 mplr_counter uint8 max_energy_state uint8 wire object for I 2 C ~ Berry Scripting provides 2 objects: wire1 and wire2 to communicate with both I 2 C buses. Use wire1.scan() and wire2.scan() to scan both buses: > wire1.scan() [] > wire2.scan() [140] You generally use tasmota.wire_scan() to find a device and the corresponding I 2 C bus. MPU6886 on bus 2 > mpuwire = tasmota.wire_scan(0x68, 58) > mpuwire <instance: Wire()> Wire Function Parameters and details bus read only attribute, 1 or 2 Bus number for this wire instance. enabled () -> bool Returns true is the I2C bus is initialized (i.e. GPIOs are defined) scan () -> array of int Scan the bus and return all responding addresses. Note: addresses are displayed as decimal ints, not hex. scan () -> array of int Scan the bus and return all responding addresses. Note: addresses are displayed as decimal ints, not hex. detect (addr:int) -> bool Returns true if the device of address addr is connected to this bus. read (addr:int, reg:int, size:int) -> int or nil Read a value of 1..4 bytes from address addr and register reg . Returns nil if no response. write (addr:int, reg:int, val:int, size:int) -> bool Writes a value of 1..4 bytes to address addr , register reg with value val . Returns true if successful, false if not. read_bytes (addr:int, reg:int ,size:int) -> instance of bytes() Reads a sequence of size bytes from address addr register reg . Result is a bytes() instance or bytes() if not successful.` write_bytes (addr:int, reg:int, val:bytes) -> nil Writes the val bytes sequence as bytes() to address addr register reg . Low-level commands if you need finer control: Wire Function Parameters and details _begin_transmission (address:int) -> nil _end_transmission ([stop:bool]) -> nil Send stop if stop is true . _request_from (addr:int, size:int [stop:bool = true]) -> nil _available () -> bool _read read() -> int Reads a single byte. _write (value:int or s:string) -> nil Sends either single byte or an arbitrary string. path module ~ A simplified version of os.path module of standard Berry which is disabled in Tasmota because we don't have a full OS. The default file-system is the ESP32 internal flash. If you have a SD card mounted, it is mapped to the /sd/ subdirectory. Example: import path print ( path . listdir ( \"/sd/\" ) # outputs a list of filenames at the root dir of the SD card Tasmota Function Parameters and details path.exists (file_name:string) -> bool Returns true if the file exists. You don't need to prefix with / , as it will automatically be added if the file does not start with / path.last_modified (file_name:string) -> int Returns the timestamp when the file was last modified, or nil if the file does not exist. You don't need to prefix with / , as it will automatically be added if the file does not start with / path.listdir (dir_name:string) -> list(string) List a directory, typically root dir \"/\" and returns a list of filenames in the directory. Returns an empty list if the directory is invalid path.remove (file_name:string) -> bool Deletes a file by name, return true if successful path.format (true:bool) -> bool Re-formats the LittleFS file system (internal ESP32 flash) and erases all content. The parameter needs to be true as to avoid unwanted calls. Returns true if reformatting was successful. This is sometimes useful when the file-system becomes unstable or corrupt after multiple re-partitionings. persist module ~ Easy way to persist simple values in Berry and read/write any attribute. Values are written in JSON format in _persist.json file. Example import persist persist.a = 1 persist.b = \"foobar\" print(persist) persist.save() # save to _persist.json Tasmota Function Parameters and details persist.save () triggers saving to file system. It is called automatically before a restart but you might want to call it yourself to prevent losing data in case of power loss or crash. persist.save() writes to flash, so be careful of not calling it too often, or it will cause wearing of flash and reduce its lifetime. persist.has (param:string) -> bool returns true or false if the key exists persist.remove (param:string) -> bool removes a key or ignores if key doesn't exist persist.find my_param:string [, \"default value\"] -> string | bool returns the value for a key, or nil or the default value. Similar to map.find introspect module ~ Allows to do introspection on instances and modules, to programmatically list attributes, set and get them. > class A var a , b def f () return 1 end end > ins = A () > ins . a = \"foo\" > import introspect > introspect . members ( ins ) [ 'b' , 'a' , 'f' ] > introspect . get ( ins , \"a\" ) foo > introspect . set ( ins , \"a\" , \"bar\" ) bar > ins . a bar Tasmota Function Parameters and details introspect.members (nil | instance | module | class) -> list Returns the list of members of the object. If nil is passed, it returns the list of globals (similar to global module). Note: virtual dynamic members are not listed. introspect.get (instance | module, name:string) -> any Returns the member of name name or nil if it does not exist. Note: virtual dynamic members are not yet supported. Note2: classes are not yet supported. introspect.set (instance | module, name:string, value:any) -> any Sets the member of name name to value or ignores the call if the member does not exist. Note: virtual dynamic members are not yet supported. introspect.module (name:string) -> module or nil Loads a module by name or return nil if not found. The import command works only for static predefined names, this addition makes it dynamic. Contrary to import command, this function does not create an entry in the current scope (i.e. does not either create a global variable with the module's name). introspect.toptr (any) -> comptr Converts an int to a comptr pointer. This is sage in Tasmota since pointers and ints are both 32 bits in size. If argument is a general object, this returns a pointer to the object, and can be converted back to the original object with introspect.fromptr . introspect.fromptr (comptr) -> any Converts a comptr pointer to its original object. Warning: this operation is considered dagerous and should be used with extreme care. If the pointer is invalid or the object was garbage collected, Tasmota will crash. introspect.ismethod (function or closure) -> bool Returns true if the function passed as argument is a method of a class, or false if the argument is a simple function or a static method. This is typically used to check callbacks and make sure that you don't pass a method as argument; methods typically need to be wrapped in a closure to capture the target object. webclient class ~ Class webclient provides an implementation of an HTTP/HTTPS web client and make requests on the LAN or over the Internet. Features: Support HTTP and HTTPS requests to IPv4 addresses and domain names, to arbitrary ports, via a full URL. Support for HTTPS and TLS via BearSSL (which is much lighter than default mbedTLS) HTTPS (TLS) only supports cipher ECDHE_RSA_WITH_AES_128_GCM_SHA256 which is both secure and widely supported Support for URL redirections (tbc) Ability to set custom User-Agent Ability to set custom headers Ability to set Authentication header Support for Chunked encoding response (so works well with Tasmota devices) The current implementation is based on a fork of Arduino's HttpClient customized to use BearSSL Current limitations (if you need extra features please open a feature request on GitHub): Only supports text responses (html, json...) but not binary content yet (no NULL char allowed) Maximum response size is 32KB, requests are dropped if larger HTTPS (TLS) is in 'insecure' mode and does not check the server's certificate; it is subject to Man-in-the-Middle attack No access to response headers No support for compressed response Example > cl = webclient () > cl . begin ( \"http://ota.tasmota.com/tasmota32/release/\" ) < instance : webclient () > > r = cl . GET () > print ( r ) 200 > s = cl . get_string () > print ( s ) < pre > < b ></ b > Alternative firmware for ESP32 based devices with web UI , [ .../... ] Example > cl = webclient () > cl . begin ( \"https://raw.githubusercontent.com/tasmota/autoconf/main/esp32/M5Stack_Fire_autoconf.zip\" ) < instance : webclient () > > r = cl . GET () > print ( r ) 200 > cl . write_file ( \"M5Stack_Fire_autoconf.zip\" ) 950 Main functions: WebClient Function Parameters and details begin (url:string) -> self Set the complete URL, including protocol ( http or https ), IPv4 or domain name, port... This should be the first call. The connection is not established at this point. GET () -> result_code:int Establish a connection to server, send GET request and wait for response header. Returns the HTTP result code or an error code if negative, 200 means OK. POST (payload:string or bytes) -> result_code:string Establish a connection to server, send POST request with payload and wait for response header. Returns the HTTP result code or an error code if negative, 200 means OK. read (addr:int, reg:int, size:int) -> int or nil Read a value of 1..4 bytes from address addr and register reg . Returns nil if no response. get_size () -> int Once a connection succeeded (GET or POST), reads the size of the response as returned by the server in headers (before actually reading the content). A value -1 means that the response size is unknown until you read it. get_string () -> string Once a connection succeeded (GET or POST), reads the content of the response in a string. The response max size is 32KB, any response larger is dropped. Connection is closed and resources are freed after this call completes. close () -> nil Closes the connection and frees buffers. close can be called after GET or POST and is implicitly called by get_string . You don't usually need to use close unless you are only retrieving the result_code for a request and not interested in the content. write_file (file_name:string) -> int Downloads the binary content of the resource and stores it on the file system. Returns the number of bytes downloaded or -1 if an error occurred Request customization: webclient Function Parameters and details add_header (name:string, value:string [, first:bool=false [, replace:bool=true]]) -> nil Sets an arbitrary header for name : value . first moves the header in the first place, replace replaces a header with the same name or adds one line if false. set_timeouts (req_timeout:int [, tcp_timeout:int]) -> self Sets the request timeout in ms and optionally the TCP connection timeout in ms. set_useragent (useragent:string) -> self Sets the User-Agent header used in request. set_auth (auth:string) or (user:string, password:string) -> self Sets the authentication header, either using pre-encoded string, or standard user/password encoding. webserver module ~ Module webserver provides functions to enrich Tasmota's Web UI. It is tightly linked to Tasmota page layout. Functions used to add UI elements like buttons to Tasmota pages, and analyze the current request. See above Driver to add buttons to Tasmota UI. General Function Parameters and details arg_size () -> int Returns the number of arguments in the request arg (arg_name:string or arg_index:int): -> string Returns the value of the argument either by name or by position number [0..arg_size()-1]. If an argument has multiple values, you need to iterate using ints to get all values arg_name (arg_index:int) -> string Returns the name of argument by index [0..arg_size()-1] has_arg (arg_name:string): -> bool Checks if an argument with this name exists check_privileged_access () -> bool Returns true if the page needs privileged access content_send (string) -> nil Sends the HTML content to the client. Tasmota uses Chunked encoding, which means than the content is regularly sent to the client and not buffered in Tasmota's memory content_button ([button:int]) -> nil Displays a standard button by code, using Tasmota localization. Possible values are webserver.BUTTON_CONFIGURATION , webserver.BUTTON_INFORMATION , webserver.BUTTON_MAIN , webserver.BUTTON_MANAGEMENT , webserver.BUTTON_MODULE . Default is webserver.BUTTON_MAIN . Low-level functions if you want to display custom pages and content: General Function Parameters and details on (prefix:string, callback:closure [, method:int]) -> nil Attaches a handler (any closure or function) to a prefix. An optional method argument (defaults to webserver.HTTP_ANY specifies the HTTP methods to be received (ANY, GET, POST, OPTIONS, POST) WARNING - this should be called only when receiving web_add_handler event. If called before the WebServer is set up and Wi-Fi on, it will crash. For debug purpose, it can be called later when you are sure that Wi-Fi or Ethernet is up. state () -> int Returns the internal state of Tasmota web server. Possible values are webserver.HTTP_OFF , webserver.HTTP_USER , webserver.HTTP_ADMIN , webserver.HTTP_MANAGER , webserver.HTTP_MANAGER_RESET_ONLY . content_start () -> nil Start response page content_response (string) -> nil Sends a response to a XMLHttpRequest content_send_style () -> nil Sends the standard Tasmota style content_flush () -> nil Flush the buffer and send any buffered content to the client content_stop () -> nil End of the response, closes the connection Module webserver also defines the following constants: Tasmota's web server states: webserver.HTTP_OFF , webserver.HTTP_USER , webserver.HTTP_ADMIN , webserver.HTTP_MANAGER , webserver.HTTP_MANAGER_RESET_ONLY Tasmota's pages: webserver.BUTTON_CONFIGURATION , webserver.BUTTON_INFORMATION , webserver.BUTTON_MAIN , webserver.BUTTON_MANAGEMENT , webserver.BUTTON_MODULE Methods received by handler: webserver.HTTP_ANY , webserver.HTTP_GET , webserver.HTTP_OPTIONS , webserver.HTTP_POST See the Berry Cookbook for examples. tcpclient class ~ Simple tcp client supporting string and binary transfers: create an instance of the client with var tcp = tcpclient() connect to the server tcp.connect(address:string, port:int [, timeout_ms:int]) -> bool Address can be numerical IPv4 or domain name. Returns true if the connection succeeded. Optional timeout in milliseconds. The default timeout is USE_BERRY_WEBCLIENT_TIMEOUT (2 seconds). check if the socket is connected with tcp.connected() send content with tcp.write(content:string or bytes) -> int . Accepts either a string or a bytes buffer, returns the number of bytes sent. It's you responsibility to resend the missing bytes check if bytes are available for reading tcp.available() -> int . Returns 0 if nothing was received. This is the call you should make in loops for polling. read incoming content as string tcp.read() -> string or as bytes tcp.readbytes() -> bytes . It is best to call tcp.available() first to avoid creating empty response objects when not needed close the socket with tcp.close() tcpclient Function Parameters and details connect connect(address:string, port:int [, timeout_ms:int]) -> bool Connect to addr:port with optional timeout in milliseconds (default 2s). Returns true if connection was successful, the call is blocking until the connection succeeded to the timeout expired. connected connected() -> bool Returns true if the connection was successful and is still valid (not dropped by server or closed by client) close close() -> nil Drops the current connection. write content:string or bytes) -> int Accepts either a string or a bytes buffer, returns the number of bytes sent. It's you responsibility to resend the missing bytes. Returns 0 if something went wrong. available available() -> int Returns the number of bytes received in buffer and ready to be read. read read([max_len:int]) -> string Returns all the bytes received in Rx buffer as string . Optional max_len parameter limits the number of characters returned, or read as much as possible by default. readbytes read([max_bytes:int]) -> bytes() Returns all the bytes received in Rx buffer as bytes() . Optional max_bytes parameter limits the number of bytes returned, or read as much as possible by default. Full example: tcp = tcpclient() tcp.connect(\"192.168.2.204\", 80) print(\"connected:\", tcp.connected()) s= \"GET / HTTP/1.0\\r\\n\\r\\n\" tcp.write(s) print(\"available1:\", tcp.available()) tasmota.delay(100) print(\"available1:\", tcp.available()) r = tcp.read() tcp.close() print(r) tcpserver class ~ Simple tcp server (socket) listening for incoming connection on any port. create an instance of the tcpserver on a specific port with s = tcpserver(8888) periodically call s.hasclient() to know if a new client has connected if the previous returned true , call var c = s.accept() to accept the connection. It returns an instance of tcpclient as above; it responds to the same APIs as outgoing TCP connection and allows text and binary transfers. you can call c.close() to close the connection, or call c.connected() to know if it's still connected (i.e. the client hasn't closed the connection on their side) close the server with s.close() . This will prevent the server from receinving any new connection, but existing connections are kept alive. tcpserver Function Parameters and details constructor tcpserver(port:int) -> nit Opens a socket on port and starts lisenting to new incoming connections. If the server can't open the socket (ex: it is already in use) an exception is raised hasclient hasclient() -> bool Returns true if a new client connected to the socket, in such case you shoult call accept() . You need to call this method regularly (ex: in event loop or fast_loop) accept accept() -> instance:tcpclient or nil Returns an instance of tcpclient for the new incoming connection, or raise an exception if no connection is available. You should call hasclient() returning true before calling accept() . Full example: > s = tcpserver ( 8888 ) # listen on port 8888 > s . hasclient () false # in parallel connect on this port with `nc <ip_address> 8888` > s . hasclient () true # we have an incoming connection > c = s . accept () > c < instance : tcpclient () > # send 'foobar' from the client > c . read () foobar # send 'foobar2' again from the client > c . readbytes () bytes ( '666F6F626172320A' ) > c . close () # this closes the connection udp class ~ Class udp provides ability to send and received UDP packets, including multicast addresses. You need to create an object of class udp . Such object can send packets and listen to local ports. If you don't specify a local port, the client will take a random source port. Otherwise the local port is used as source port. When creating a local port, you need to use udp->begin(<ip>, <port)> . If <ip> is empty string \"\" then the port is open on all interfaces (wifi and ethernet). General Function Parameters and details udp() udp() -> <instance udp> Creates an instance of udp class. begin begin(ip:string, port:int) -> bool Create a UDP listener and sender on interface ip and port . If ip is an empty string, the listener connects to all interfaces (aka 0.0.0.0) Returns true if successful. begin_multicast begin(ip:string, port:int) -> bool Create a UDP listener and sender on interface ip and port . ip must be a multicast address. Returns true if successful. send send(addr:string, port:int, payload:bytes) -> bool Sends a packet to address addr , port port and message as bytes() buffer. Returns true if successful. send_multicast send(payload:bytes) -> bool Sends a payload as bytes() buffer to the multicast address. begin_multicast() must have been previously called. Returns true if successful. read read() -> bytes() or nil Reads any received udp packet as bytes() buffer, or nil if no packet was received. remote_ip remote_ip (string or nil) Instance variable containing the remote ip (as string) from the last successful read() command. remote_port remote_port (int or nil) Instance variable containing the remote port (as int) from the last successful read() command. Sending udp packets ~ > u = udp () > u . begin ( \"\" , 2000 ) # listen on all interfaces, port 2000 true > u . send ( \"192.168.1.10\" , 2000 , bytes ( \"414243\" )) # send 'ABC' to 192.168.1.10:2000, source port is 2000 true Receive udp packets ~ You need to do polling on udp->read() . If no packet was received, the call immediately returns nil . > u = udp () > u . begin ( \"\" , 2000 ) # listen on all interfaces, port 2000 true > u . read () # if no packet received, returns `nil` > > u . read () # if no packet received, returns `nil` bytes ( \"414243\" ) # received packet as `bytes()` Send and receive multicast ~ > u = udp () > u . begin_multicast ( \"224.3.0.1\" , 3000 ) # connect to multicast 224.3.0.1:3000 on all interfaces true > client . send_multicast ( bytes ( \"33303030\" )) > u . read () # if no packet received, returns `nil` > u . read () bytes ( \"414243\" ) # received packet as `bytes()` Addressable leds (WS2812, SK6812) ~ There is native support for addressable leds via NeoPixelBus, with support for animations. Currently supported: WS2812, SK6812. Details are in Berry leds serial class ~ The serial class provides a low-level interface to hardware UART. The serial GPIOs don't need to be configured in the template. Example # gpio_rx:4 gpio_tx:5 ser = serial(4, 5, 9600, serial.SERIAL_7E1) ser.write(bytes(203132)) # send binary 203132 ser.write(bytes().fromstring(\"Hello)) # send string \"Hello\" msg = ser.read() # read bytes from serial as bytes print(msg.asstring()) # print the message as string Tasmota Function Parameters and details serial (constructor) serial(gpio_rx:int, gpio_tx:int, baud:int [, mode:int]) Creates a serial object gpio_rx receive GPIO (or -1 if transmit only) gpio_tx transmit GPIO (or -1 if receive only) baud speed, ex: 9600, 115200 mode serial message format, default is serial.SERIAL_8N1 (8 bits, no parity, 1 stop bit). Other mode values are described below. write write(val:int || bytes()) -> bytes_sent:int Send either a single byte if argument is int, or send a binary message from a bytes() object. The methods blocks until all messages are sent to the UART hardware buffer; they may not all have been sent over the wire read read(void) -> bytes() Read all bytes received in the incoming buffer. If the buffer is empty, returns an empty bytes() object flush flush(void) -> void Flushes all buffers. Waits for all outgoing messages to be sent over the wire and clear the incoming buffer. available available(void) -> int Returns the number of incoming bytes in the incoming buffer, 0 in none. Supported serial message formats: SERIAL_5N1 , SERIAL_6N1 , SERIAL_7N1 , SERIAL_8N1 , SERIAL_5N2 , SERIAL_6N2 , SERIAL_7N2 , SERIAL_8N2 , SERIAL_5E1 , SERIAL_6E1 , SERIAL_7E1 , SERIAL_8E1 , SERIAL_5E2 , SERIAL_6E2 , SERIAL_7E2 , SERIAL_8E2 , SERIAL_5O1 , SERIAL_6O1 , SERIAL_7O1 , SERIAL_8O1 , SERIAL_5O2 , SERIAL_6O2 , SERIAL_7O2 , SERIAL_8O2 display module ~ The display module provides a simple API to initialize the Universal Display Driver with data provided as a string. It is used by autoconf mechanism. Tasmota Function Parameters and details start display.start(displayini:string) -> nil Initializes the Universal Display Driver with the string provided as argument, similar to content in display.ini . It is typically read from a file in the file-system. started display.started() -> bool Returns true if display is already initialized, false if not started. dimmer display.started([dim:int]) -> int Sets the dimmer of display, value 0..100. If 0 then turn off display. If no arg, read the current value. driver_name display.driver_name() -> string Returns the Display driver name as specified in display.ini touch_update display.touch_update(touches:int, raw_x:int, raw_y:int, gesture:int) -> nil Sets the last Touch Screen update values to be passed to LVGL. This allows an external touchscreen driver to periodically update the touch information. touches : number of touches ( 0 = no touch, 1 = screen touched). Multiple touch is not supported raw_x and raw_y = coordinates before conversion (resistive touch screens need conversion) gesture : type of gesture. 0 = no gesture, 16 = move up, 17 = move down, 18 = move left, 19 = move right, 32 = zoom in, 33 = zoom out. uuid module ~ The uuid module allows to generate uuid4 random ids. > import uuid > uuid . uuid4 () 1 a8b7f78 - 59 d8 - 4868 - 96 a7 - b7ff3477d43f Tasmota Function Parameters and details uuid4 uuid.uuid4() -> string Generates a uuid4 random id as string. crc module ~ The crc module allows to compute crc32/16/8 from bytes() arrays. > import crc > crc . crc32 ( 0xFFFFFFFF , bytes ( \"AABBCC\" )) - 1091314015 > crc . crc16 ( 0xFFFF , bytes ( \"AABBCC\" )) 20980 > crc . crc8 ( 0xFF , bytes ( \"AABBCC\" )) 139 Tasmota Function Parameters and details crc32 crc.crc32(crc:int, payload:bytes) -> int Compute crc32 from an initial value and a bytes() buffer crc16 crc.crc16(crc:int, payload:bytes) -> int Compute crc16 from an initial value and a bytes() buffer crc8 crc.crc8(crc:int, payload:bytes) -> int Compute crc8 from an initial value and a bytes() buffer log_reader class ~ The log_reader class allows you to read and potentially parse the Tasmota logs. It keeps track of what logs were already read in the past and feeds you with new log lines if some are available. It is for example used by the LVGL tasmota_log widget to display logs on a display. Note: calling log_reader can be expensive in string allocations, and adds pressure on the garbage collector. Use wisely. Example: var lr = log_reader () # do this regularly var ret = lr . get_log ( 2 ) # read at log level 2 if ret != nil var lines = r . split ( '\\n' ) # extract as a list of lines # do whatever you need end Tasmota Function Parameters and details log_reader() log_reader(void) -> instance(log_reader) Instantiate a new log_reader . Multiple readers can coexist and they each keep track of already read log lines get_log get_log(log_level:int) -> string or nil Returns new log lines as a big string object. Lines are separated by \\n . Returns nil if no new logs are available. log_level can be 0..4 and specifies the highest log level that we be reported (it is usually wise to start with 2 ). Higher log level will be reported only if they are recorded, i.e. there is at least one logger that asks for it. This class does not cause log-level 4 to be recorded if none other loggers are recording them ( weblog , mqttlog or seriallog ). ULP module ~ The ULP module exposes the third computing unit of the ESP32, which is a simple finite state machine (FSM) that is designed to perform measurements using the ADC, temperature sensor and even external I2C sensors. This small ultra low power coprocessor can run in parallel to the main cores and in deep sleep mode, where it is capable to wake up the system, i.e. in reaction to sensor measurements. The binding to Berry consists of some lightweight wrapper functions and the communication with the main cores works by accessing the RTC_SLOW_MEM from both sides, which is the same way as in any other ESP32 ULP project. # simple LED blink example import ULP ULP . wake_period ( 0 , 500000 ) # off time ULP . wake_period ( 1 , 200000 ) # on time c = bytes ( \"756c70000c006c00000000001000008000000000000000000000000010008072010000d0e5af2c72340040802705cc190005681d10008072e1af8c720100006821008072040000d0120080720800207004000068010005825c0000800405681d00000092680000800505681d0100009268000080000000b0\" ) ULP . load ( c ) ULP . run () Tasmota Function Parameters and details run ULP.run() -> nil Execute ULP prgramm load ULP.load(code:bytes) -> nil Load ULP code from a bytes() buffer into memory set_mem ULP.set_mem(addr:int, value:int) -> nil Set memory position in RTC_SLOW_MEM to value. Address and Value are 32-bit!! get_mem ULP.set_mem(addr:int) -> int16_t Get value from memory position in RTC_SLOW_MEM. By hardware design only the lower 16-bit are usable, so this function already masks out the upper 16-bit gpio_init ULP.gpio_init(pin:int, mode:int) -> pin:int Makes a valid GPIO pin accessible to the ULP and sets the mode according to the enum 'rtc_gpio_mode_t', returns the same pin, but translated to the RTC system, which is the numbering scheme in the assembly code adc_config ULP.adc_config(channel:int, attenuation:int, width:int) -> nil Configures ADC pin usage for the ULP according to the enums ' adc1_channel_t', 'adc_atten_t' and 'adc_bits_width_t' wake_period ULP.wake_period(register:int, time:int) -> nil Configures one of 5 (0..4) wake timer registers with the time value in microseconds sleep ULP.wake_period([time:int]) -> nil Starts deep sleep mode and allow wake up by the ULP, with an optional time value in seconds an additional wake up timer gets started More infos (including suggestions for a toolchain) on the ULP page . re regex module ~ Use with import re . There are two ways to use regex, first is to call directly the module which triggers a compilation of the regex at each call. The second one is to pre-compile the regex once into an object which is much more efficient if you need to use the regex multiple times. Any error in the compilation of the regex pattern yields an exception. > import re > re . search ( \"a.*?b(z+)\" , \"zaaaabbbccbbzzzee\" ) [ 'aaaabbbccbbzzz' , 'zzz' ] > re . match ( \"a.*?b(z+)\" , \"aaaabbbccbbzzzee\" ) [ 'aaaabbbccbbzzz' , 'zzz' ] > rr = re . compile ( \"/\" ) > rr < instance : re_pattern () > > rr . split ( \"foo/bar//baz\" ) [ 'foo' , 'bar' , '' , 'baz' ] > rr . split ( \"/b\" ) [ '' , 'b' ] Tasmota Function Parameters and details search re.search(pattern:string, payload:string) -> list of strings Returns the list of matches, or empty list of no match match re.match(pattern:string, payload:string) -> list of strings Returns the list of matches, or empty list of no match. The difference with search is that match must match the entire string (from beginning to end). split re.search(pattern:string, payload:string) -> list of strings Returns the list of strings from split, or a list with a single element containing the entire string if no match compile re.compile(pattern:string) -> instance of <re_pattern> Compiles the regex into a reusable faster bytecode. You can then call the following methods: search() , match() , split() similarly to the module's functions. Note: for match and search , the first element in the list contains the global match of the pattern. Additional elements correspond to the sub-groups (in parenthesis). The regex engine is based on re1.5 also used in Micropython. Compiling Berry ~ Berry is included if the following is defined in user_config_override.h : #define USE_BERRY Other options that can be changed: Option Description #define USE_BERRY_PSRAM Use PSRAM to allocate memory instead of main RAM. If no PSRAM is connected, this option has no effect. Enabled by default #define USE_BERRY_DEBUG Provide additional information in case of a Berry exception, adding line number in the call chain. This feature adds ~8% of memory consumption to Berry compiled code. Disabled by default #define USE_WEBCLIENT Enable the webclient module allowing to do HTTP requests. Enabled by default #define USE_WEBCLIENT_HTTPS Adds support for HTTPS to webclient . This feature adds ~45KB of Flash space for TLS support. Disabled by default #define USE_BERRY_WEBCLIENT_USERAGENT \"TasmotaClient\" Specifies the default User-Agent field sent by webclient . Can be changed on a per request basis. #define USE_BERRY_WEBCLIENT_TIMEOUT 5000 Specifies the default timeout in millisecond for webclient . Can be changed on a per request basis. Berry Cookbook ~ Find complete examples and use scenarios of Berry in the Berry Cookbook","title":"Berry"},{"location":"Berry/#berry-scripting-language","text":"Berry Scripting is included in all tasmota32 builds. It is NOT supported on ESP82xx If you plan to code in Berry, you should enable #define USE_BERRY_DEBUG which will give you much more details when coding Useful resources: First time user of Berry: Berry Introduction (in 20 minutes of less) Full language documentation The Berry Script Language Reference Manual Tasmota extension of Berry, see below Full examples in the Berry Cookbook If you're new to Berry, have a look at Berry Introduction (in 20 minutes of less)","title":"Berry Scripting Language "},{"location":"Berry/#introduction-to-berry","text":"Berry is the next generation scripting for Tasmota. It is based on the open-source Berry project, delivering an ultra-lightweight dynamically typed scripting language designed for lower-performance embedded devices. Github Manual Reference sheet Download Berry Short Manual to get a list of basic functions and capabilities of Berry language Berry Scripting allows simple and also advanced extensions of Tasmota, for example: simple scripting advanced rules, beyond what is possible with native rules advanced automations Berry Scripting takes it one step further and allows to build dynamic extensions to Tasmota, that would previously require native code: build light animations build I 2 C drivers build complete Tasmota drivers integrate native libraries like lvgl see LVGL","title":"Introduction to Berry"},{"location":"Berry/#about-the-berry-language","text":"Berry has the following advantages: Lightweight: A well-optimized interpreter with very little resources. Ideal for use in microprocessors. Fast: optimized one-pass bytecode compiler and register-based virtual machine. Powerful: supports imperative programming, object-oriented programming, functional programming. Flexible: Berry is a dynamic type script, and it's intended for embedding in applications. It can provide good dynamic scalability for the host system. Simple: simple and natural MicroPython-eque syntax, supports garbage collection and easy to use FFI (foreign function interface). RAM saving: With compile-time object construction, most of the constant objects are stored in read-only code data segments, so the RAM usage of the interpreter is very low when it starts.","title":"About the Berry language"},{"location":"Berry/#tasmota-port","text":"Berry Scripting in only supported on Tasmota32 for ESP32. The RAM usage starts at ~10kb and will be later optimized. Berry uses PSRAM on ESP32 if available (PSRAM is external RAM attached to ESP32 via SPI, it is slower but larger than internal RAM.","title":"Tasmota Port"},{"location":"Berry/#quick-start","text":"Click on Configuration then Berry Scripting Console and enjoy the colorful Berry console, also called REPL (Read-Eval-Print-Loop). Drag the bottom corner of each screen to change its size The console is not designed for big coding tasks but it's recommended to use a code editor when dealing with many, many lines of code. An extension for Visual Studio Code exists to make writing Berry scripts even easier with colored syntax. Download the entire folder and copy to VSCode extensions folder.","title":"Quick Start"},{"location":"Berry/#repl-console","text":"Try typing simple commands in the REPL. Since the input can be multi-lines, press Enter twice or click \"Run\" button to run the code. Use Up and Down to navigate through history of previous commands. > 1 + 1 2 > 2.0 / 3 0.666667 > print ( 'Hello Tasmota!' ) Hello Tasmota ! Note: Berry's native print() command displays text in the Berry Console and in the Tasmota logs. To log with finer control, you can also use the log() function which will not display in the Berry Console. > print ( 'Hello Tasmota!' ) log ( 'Hello again' ) Hello Tasmota ! Meanwhile the Tasmota log shows: > tasmota.cmd(\"Dimmer 60\") {'POWER': 'ON', 'Dimmer': 60, 'Color': '996245', 'HSBColor': '21,55,60', 'Channel': [60, 38, 27]} The light is bright","title":"REPL Console"},{"location":"Berry/#lights-and-relays","text":"Berry provides complete support for Relays and Lights. You can control individual Relays or lights with tasmota.get_power() and tasmota.set_power() . tasmota.get_power() returns an array of booleans representing the state of each relays and light (light comes last). tasmota.set_power(relay, onoff) changes the state of a single relay/light. 2 relays and 1 light > tasmota . get_power () [ false , true , false ] > tasmota . set_power ( 0 , true ) true > tasmota . get_power () [ true , true , false ] For light control, light.get() and light.set accept a structured object containing the following arguments: Attributes Details power boolean Turns the light off or on. Equivalent to tasmota.set_power() . When brightness is set to 0 , power is automatically set to off. On the contrary, you need to specify power:true to turn the light on. bri int range 0..255 Set the overall brightness. Be aware that the range is 0..255 and not 0..100 as Dimmer. hue int 0..360 Set the color Hue in degree, range 0..360 (0=red). sat int 0..255 Set the color Saturation (0 is grey). ct int 153..500 Set the white color temperature in mired, ranging from 153 (cold white) to 500 (warm white) rgb string 6 hex digits Set the color as hex RRGGBB , changing color and brightness. channels array of int, ranges 0..255 Set the value for each channel, as an array of numbers When setting attributes, they are evaluated in the following order, the latter overriding the previous: power , ct , hue , sat , rgb , channels , bri . # set to yellow, 25% brightness > light . set ({ \"power\" : true , \"hue\" : 60 , \"bri\" : 64 , \"sat\" : 255 }) { 'bri' : 64 , 'hue' : 60 , 'power' : true , 'sat' : 255 , 'rgb' : '404000' , 'channels' : [ 64 , 64 , 0 ]} # set to RGB 000080 (blue 50%) > light . set ({ \"rgb\" : \"000080\" }) { 'bri' : 128 , 'hue' : 240 , 'power' : true , 'sat' : 255 , 'rgb' : '000080' , 'channels' : [ 0 , 0 , 128 ]} # set bri to zero, also powers off > light . set ({ \"bri\" : 0 }) { 'bri' : 0 , 'hue' : 240 , 'power' : false , 'sat' : 255 , 'rgb' : '000000' , 'channels' : [ 0 , 0 , 0 ]} # changing bri doesn't automatically power > light . set ({ \"bri\" : 32 , \"power\" : true }) { 'bri' : 32 , 'hue' : 240 , 'power' : true , 'sat' : 255 , 'rgb' : '000020' , 'channels' : [ 0 , 0 , 32 ]} # set channels as numbers (purple 12%) > light . set ({ \"channels\" : [ 32 , 0 , 32 ]}) { 'bri' : 32 , 'hue' : 300 , 'power' : true , 'sat' : 255 , 'rgb' : '200020' , 'channels' : [ 32 , 0 , 32 ]}","title":"Lights and Relays"},{"location":"Berry/#rules","text":"The rule function have the general form below where parameters are optional: def function_name ( value , trigger , msg ) end Parameter Description value The value of the trigger. Similar to %value% in native rules. trigger string of the trigger with all levels. Can be used if the same function is used with multiple triggers. msg map Berry structured object of the message, decoded from JSON. If JSON was invalid, it contains the original string Dimmer rule Define the function and add a rule to Tasmota where the function runs if Dimmer value is more than 50 > def dimmer_over_50 () print ( \"The light is bright\" ) end tasmota . add_rule ( \"Dimmer>50\" , dimmer_over_50 ) > tasmota . cmd ( \"Dimmer 30\" ) { 'POWER' : 'ON' , 'Dimmer' : 30 , 'Color' : '4D3223' , 'HSBColor' : '21,55,30' , 'Channel' : [ 30 , 20 , 14 ]} > tasmota . cmd ( \"Dimmer 60\" ) { 'POWER' : 'ON' , 'Dimmer' : 60 , 'Color' : '996245' , 'HSBColor' : '21,55,60' , 'Channel' : [ 60 , 38 , 27 ]} The light is bright The same function can be used with multiple triggers. If the function to process an ADC input should be triggered both by the tele/SENSOR message and the result of a Status 10 command: tasmota . add_rule ( \"ANALOG#A1\" , rule_adc_1 ) tasmota . add_rule ( \"StatusSNS#ANALOG#A1\" , rule_adc_1 ) Or if the same function is used to process similar triggers: import string def rule_adc ( value , trigger ) var i = string . find ( trigger , \"#A\" ) var tr = string . split ( trigger , i + 2 ) var adc = number ( tr [ 1 ]) print ( \"value of adc\" , adc , \" is \" , value ) end tasmota . add_rule ( \"ANALOG#A1\" , rule_adc ) tasmota . add_rule ( \"ANALOG#A2\" , rule_adc ) Another way to address the same using anonymous functions created dynamically def rule_adc ( adc , value ) print ( \"value of adc\" , adc , \" is \" , value ) end tasmota . add_rule ( \"ANALOG#A1\" , def ( value ) rule_adc ( 1 , value ) end ) tasmota . add_rule ( \"ANALOG#A2\" , def ( value ) rule_adc ( 2 , value ) end ) Teleperiod rules Teleperiod rules are supported with a different syntax from Tasmota rules. Instead of using Tele- prefix, you must use Tele# . For example Tele#ANALOG#Temperature1 instead of Tele-ANALOG#Temperature1","title":"Rules"},{"location":"Berry/#timers","text":"Berry code, when it is running, blocks the rest of Tasmota. This means that you should not block for too long, or you may encounter problems. As a rule of thumb, try to never block more than 50ms. If you need to wait longer before the next action, use timers. As you will see, timers are very easy to create thanks to Berry's functional nature. All times are in milliseconds. You can know the current running time in milliseconds since the last boot: > tasmota . millis () 9977038 Sending a timer is as easy as tasmota.set_timer(<delay in ms>,<function>) > def t () print ( \"Booh!\" ) end > tasmota . set_timer ( 5000 , t ) [ 5 seconds later ] Booh !","title":"Timers"},{"location":"Berry/#cron-recurrent-calls","text":"You can choose to run some function/closure at regular intervals specified as cron type format. Crontab Guru is an easy way to create and test your cron format. > def f () print ( \"Hi\" ) end > tasmota . add_cron ( \"*/15 * * * * *\" , f , \"every_15_s\" ) Hi Hi # added every 15 seconds > tasmota . remove_cron ( \"every_15_s\" ) # cron stops Like timers, you need to create a closure if you want to register a method of an instance. Example: class A var name def init ( name ) self . name = name end def p () print ( \"Hi,\" , self . name ) end end > bob = A ( \"bob\" ) > bob . p () Hi , bob > tasmota . add_cron ( \"*/15 * * * * *\" , /-> bob.p(), \"hi_bob\") Hi, bob Hi, bob Hi, bob > tasmota.remove_cron(\"hi_bob\") # cron stops You can get the timestamp for the next event by using tasmota.next_cron(id) which returns an epoch in seconds.","title":"cron recurrent calls"},{"location":"Berry/#loading-filesystem","text":"You can upload Berry code in the filesystem using the Consoles - Manage File system menu and load them at runtime. Make careful to use *.be extension for those files. To load a Berry file, use the load(filename) function where filename is the name of the file with .be or .bec extension; if the file has no extension '.be' is automatically appended. You don't need to prefix with / . A leading / will be added automatically if it is not present. When loading a Berry script, the compiled bytecode is automatically saved to the filesystem, with the extension .bec (this is similar to Python's .py / .pyc mechanism). The save(filename,closure) function is used internally to save the bytecode. If a precompiled bytecode (extension .bec ) is present of more recent than the Berry source file, the bytecode is directly loaded which is faster than compiling code. You can eventually remove the *.be file and keep only *.bec file (even with load(\"file.be\") .","title":"Loading Filesystem"},{"location":"Berry/#creating-a-tasmota-driver","text":"You can easily create a complete Tasmota driver with Berry. A Driver responds to messages from Tasmota. For each message type, the method with the same name is called. Actually you can register any class as a driver, it does not need to inherit from Driver ; the call mechanism is based on names of methods that must match the name of the event to be called. Driver methods are called with the following parameters: f(cmd, idx, payload, raw) . cmd is a string, idx an integer, payload a Berry object representation of the JSON in payload (if any) or nil , raw is a string. These parameters are meaningful to a small subset of events: every_second() : called every second every_50ms() : called every 50ms (i.e. 20 times per second) every_100ms() : called every 100ms (i.e. 10 times per second) every_200ms() : called every 200ms (i.e. 5 times per second) every_250ms() : called every 250ms (i.e. 4 times per second) web_sensor() : display sensor information on the Web UI json_append() : display sensor information in JSON format for TelePeriod reporting web_add_button() : (deprecated) synonym of web_add_console_button() web_add_main_button() , web_add_management_button() , web_add_console_button() , web_add_config_button() : add a button to Tasmotas Web UI on a specific page web_add_handler() : called when Tasmota web server started, and the right time to call webserver.on() to add handlers button_pressed() : called when a button is pressed save_before_restart() : called just before a restart mqtt_data(topic, idx, data, databytes) : called for MQTT payloads matching mqtt.subscribe . idx is zero, and data is normally unparsed JSON. set_power_handler(cmd, idx) : called whenever a Power command is made. idx contains the index of the relay or light. cmd can be ignored. display() : called by display driver with the following subtypes: init_driver , model , dim , power . Then register the driver with tasmota.add_driver(<driver>) . There are basically two ways to respond to an event: Example Define a class and implement methods with the same name as the events you want to respond to. class MyDriver def every_second () # do something end end d1 = MyDriver () tasmota . add_driver ( d1 )","title":"Creating a Tasmota Driver"},{"location":"Berry/#fast-loop","text":"Beyond the events above, a specific mechanism is available for near-real-time events or fast loops (above 50 times per second). Special attention is made so that there is no or very little impact on performance. Until a first callback is registered, performance is not impacted and Berry is not called. This protects any current use from any performance impact. Once a callback is registered, it is called separately from Berry drivers to ensure minimal overhead. tasmota.add_fast_loop(cl:function) -> nil registers a callback to be called in fast loop mode. The callback is called without any parameter and does not need to return anything. The callback is called at each iteration of Tasmota event loop. The frequency is tightly linked to the Speed <x> command. By default, the sleep period is 50ms, hence fast_loop is called every 50ms. You can reduce the time with Sleep 10 (10ms) hence calling 100 times per second. If you set Sleep 0 , the callback is called as frequently as possible (discouraged unless you have a good reason). tasmota.remove_fast_loop(cl:function) -> nil removes a previously registered function or closure. You need to pass the exact same closure reference. Warning, if you need to register a method from an instance, you need a closure: class my_driver def every_100ms() # called every 100ms via normal way end def fast_loop() # called at each iteration, and needs to be registered separately and explicitly end def init() # register fast_loop method tasmota.add_fast_loop(/-> self.fast_loop()) # variant: # tasmota.add_fast_loop(def () self.fast_loop() end) end end tasmota.add_driver(my_driver()) # register driver tasmota.add_fast_loop(/-> my_driver.fast_loop()) # register a closure to capture the instance of the class as well as the method","title":"Fast Loop"},{"location":"Berry/#tasmota-only-extensions","text":"","title":"Tasmota Only Extensions"},{"location":"Berry/#tasmota-object","text":"A root level object called tasmota is created and contains numerous functions to interact with Tasmota. Tasmota Function Parameters and details tasmota.get_free_heap () -> int Returns the number of free bytes on the Tasmota heap. tasmota.publish (topic:string, payload:string[, retain:bool, start:int, len:int]) -> nil Deprecated see mqtt.publish tasmota.publish_result (payload:string, subtopic:string) -> nil Publishes a JSON result and triggers any associated rule. payload is expected to be a JSON string, and subtopic the subtopic used to publish the payload. tasmota.publish_rule (payload:string) -> handled:bool sends a JSON stringified message to the rule engine, without actually publishing a message to MQTT. Returns true if the message was handled by a rule. tasmota.cmd (command:string) -> map Sends any command to Tasmota, like it was type in the console. It returns the result of the command if any, as a map parsed from the command output JSON. tasmota.memory () -> map Returns memory stats similar to the Information page. Example: {'iram_free': 41, 'frag': 51, 'program_free': 1856, 'flash': 4096, 'heap_free': 226, 'program': 1679} or when PSRAM {'psram_free': 3703, 'flash': 16384, 'program_free': 3008, 'program': 1854, 'psram': 4086, 'frag': 27, 'heap_free': 150} tasmota.add_rule (pattern:string, f:function [, id:any]) ->nil Adds a rule to the rule engine. See above for rule patterns. Optional id to remove selectively rules. tasmota.remove_rule (pattern:string [, id:any]) ->nil Removes a rule to the rule engine. Silently ignores the pattern if no rule matches. Optional id to remove selectively some rules. tasmota.add_driver (instance) ->nil Registers an instance as a driver tasmota.remove_driver (instance) ->nil Removes a driver tasmota.gc () -> int Triggers garbage collection of Berry objects and returns the bytes currently allocated. This is for debug only and shouldn't be normally used. gc is otherwise automatically triggered when necessary.","title":"tasmota object"},{"location":"Berry/#mqtt-module","text":"Use with import mqtt . Since v11.1.0.1, there is an easier way than registering a driver, and listening to mqtt_data event. You can now just attach a function or closure to a MQTT topic, and it does the magic for you. The function you attach to a topic pattern received only the matching MQTT messages, not all messages unlike mqtt_data() would. The function takes the same parameters as mqtt_data() : - topic : full topic received from the broker - idx : not used - payload_s : payload as string, usually converted to JSON with import json json.load(payloas_s) - payload_b : payload as a binary payload, bytes() array - the function should return true if the event was parsed or if the event should not trigger a Tasmota command. If you return nil or nothing, it is considered as true which is the usual behavior you want (i.e. not trigger a Tasmota command from random MQTT messages). Tasmota Function Parameters and details mqtt.publish (topic:string, payload:string[, retain:bool, start:int, len:int]) -> nil Equivalent of publish command, publishes a MQTT message on topic with payload . Optional retain parameter. payload can be a string or a bytes() binary array start and len allow to specificy a sub-part of the string or bytes buffer, useful when sending only a portion of a larger buffer. mqtt.subscribe mqtt.subscribe(topic:string [, function:closure]) -> nil Subscribes to a topic (exact match or pattern). Contrary to Tasmota's Subscribe command, the topic is sent as-is and not appended with /# . You need to add wildcards yourself. Driver method mqtt_data is called for each matching payload. If a function/closure is added, the function is called whenever and only if an incoming messages matches the pattern for this function. The function should return true if message was processed, false if not which will let the message flow to Tasmota eventually as a command. mqtt.unsubscribe (topic:string) -> nil Unubscribe to a topic (exact match).","title":"mqtt module"},{"location":"Berry/#light-object","text":"Module light is automatically imported via a hidden import light command. Tasmota Function Parameters and details light.get (index:int) -> map Get the current status if light number index (default:0). Example: > light.get {'bri': 77, 'hue': 21, 'power': true, 'sat': 140, 'rgb': '4D3223', 'channels': [77, 50, 35]} light.set (settings:map[, index:int]) -> map Sets the current state for light index (default: 0. Example: > light.set({'hue':120,'bri':50,'power':true}) {'bri': 50, 'hue': 120, 'power': true, 'sat': 140, 'rgb': '173217', 'channels': [23, 50, 23]} light.gamma10 (channel) -> int Computes the gamma corrected value with 10 bits resolution for input and output. Note: Gamma is optimized for speed and smooth fading, and is not 100% mathematically accurate. Input and output are in range 0..1023. light.reverse_gamma10 (gamma) -> int Computes the reverse gamma with 10 bits resolution for input and output. Input and output are in range 0..1023. light.gamma8 (channel) -> int Computes the gamma corrected value with 8 bits resolution for input and output. Input and output are in range 0..255.","title":"light object"},{"location":"Berry/#gpio-module","text":"This module allows to retrieve the GPIO configuration set in the templates. You need to distinguish between logical gpio (like PWM, or I2C) and physical gpio which represent the GPIO number of the physical pin. gpio.pin() transforms a logical GPIO to a physical GPIO, or -1 if the logical GPIO is not set. Currently there is limited support for GPIO: you can only read/write in digital mode and set the GPIO mode. Tasmota Function Parameters and details gpio.pin_used (gpio [,index]) -> bool returns if a specific GPIO is used. index allows to iterate through GPIOs. Example: gpio.pin_used(gpio.REL1) to check Relay1, or gpio.pin_used(gpio.REL1,1) to check Relay2 (index is zero-based) gpio.pin (gpio [,index]) -> int returns the physical GPIO number assigned to the Tasmota GPIO, or -1 if the GPIO is not assigned gpio.digital_write (phy_gpio, val) -> nil needs the physical GPIO number sets the GPIO to LOW/HIGH. val can be 0 , 1 , gpio.LOW or gpio.HIGH . Example: gpio.digital_write(gpio.pin(gpio.REL1), gpio.HIGH) sets Relay1 to High. gpio.digital_read (phy_gpio) -> int needs the physical GPIO number reads the value of a GPIO. Returns 0 or 1. gpio.pin_mode (phy_gpio, mode) -> nil needs the physical GPIO number Changes the GPIO mode. It should be called very cautiously. Normally Tasmota handles automatically GPIO modes. mode can have the following values: gpio.INPUT , gpio.OUTPUT , gpio.PULLUP , gpio.INPUT_PULLUP , gpio.PULLDOWN , gpio.OPEN_DRAIN , gpio.OUTPUT_OPEN_DRAIN , gpio.DAC gpio.dac_voltage (phy_gpio:int, voltage_mv:int) -> int Sets the DAC voltage in mV. The resolution is 8 bits over a range of 0..3.3V, i.e. an increment of ~13mV, this function returns the actual voltage output rounded to the closest value. See below for constraints of DAC GPIOs. gpio.set_pwm (phy_gpio:int, duty:int [, phase:int]) -> nil Sets the value of a PWM output phy_gpio : physical GPIO number duty : analog value for the pwm, range is 0..1023 unless you change the PWM range phase : (opt) set the starting point in time for this pulse from start of cycle. Range is 0..1023 unless you change PWM range. This allows to dephase pulses, for example for H-bridge. Low-level this is a low-level function that bypasses all the Tasmota logic around PWM. Use with caution as a PWM command might overwrite your settings. Any internal error or using unsupported GPIO yields an Berry exception. Possible values for Tasmota GPIOs: gpio.NONE , gpio.KEY1 , gpio.KEY1_NP , gpio.KEY1_INV , gpio.KEY1_INV_NP , gpio.SWT1 , gpio.SWT1_NP , gpio.REL1 , gpio.REL1_INV , gpio.LED1 , gpio.LED1_INV , gpio.CNTR1 , gpio.CNTR1_NP , gpio.PWM1 , gpio.PWM1_INV , gpio.BUZZER , gpio.BUZZER_INV , gpio.LEDLNK , gpio.LEDLNK_INV , gpio.I2C_SCL , gpio.I2C_SDA , gpio.SPI_MISO , gpio.SPI_MOSI , gpio.SPI_CLK , gpio.SPI_CS , gpio.SPI_DC , gpio.SSPI_MISO , gpio.SSPI_MOSI , gpio.SSPI_SCLK , gpio.SSPI_CS , gpio.SSPI_DC , gpio.BACKLIGHT , gpio.OLED_RESET , gpio.IRSEND , gpio.IRRECV , gpio.RFSEND , gpio.RFRECV , gpio.DHT11 , gpio.DHT22 , gpio.SI7021 , gpio.DHT11_OUT , gpio.DSB , gpio.DSB_OUT , gpio.WS2812 , gpio.MHZ_TXD , gpio.MHZ_RXD , gpio.PZEM0XX_TX , gpio.PZEM004_RX , gpio.PZEM016_RX , gpio.PZEM017_RX , gpio.SAIR_TX , gpio.SAIR_RX , gpio.PMS5003_TX , gpio.PMS5003_RX , gpio.SDS0X1_TX , gpio.SDS0X1_RX , gpio.SBR_TX , gpio.SBR_RX , gpio.SR04_TRIG , gpio.SR04_ECHO , gpio.SDM120_TX , gpio.SDM120_RX , gpio.SDM630_TX , gpio.SDM630_RX , gpio.TM1638CLK , gpio.TM1638DIO , gpio.TM1638STB , gpio.MP3_DFR562 , gpio.HX711_SCK , gpio.HX711_DAT , gpio.TX2X_TXD_BLACK , gpio.TUYA_TX , gpio.TUYA_RX , gpio.MGC3130_XFER , gpio.MGC3130_RESET , gpio.RF_SENSOR , gpio.AZ_TXD , gpio.AZ_RXD , gpio.MAX31855CS , gpio.MAX31855CLK , gpio.MAX31855DO , gpio.NRG_SEL , gpio.NRG_SEL_INV , gpio.NRG_CF1 , gpio.HLW_CF , gpio.HJL_CF , gpio.MCP39F5_TX , gpio.MCP39F5_RX , gpio.MCP39F5_RST , gpio.PN532_TXD , gpio.PN532_RXD , gpio.SM16716_CLK , gpio.SM16716_DAT , gpio.SM16716_SEL , gpio.DI , gpio.DCKI , gpio.CSE7766_TX , gpio.CSE7766_RX , gpio.ARIRFRCV , gpio.ARIRFSEL , gpio.TXD , gpio.RXD , gpio.ROT1A , gpio.ROT1B , gpio.ADC_JOY , gpio.SSPI_MAX31865_CS1 , gpio.HRE_CLOCK , gpio.HRE_DATA , gpio.ADE7953_IRQ , gpio.SOLAXX1_TX , gpio.SOLAXX1_RX , gpio.ZIGBEE_TX , gpio.ZIGBEE_RX , gpio.RDM6300_RX , gpio.IBEACON_TX , gpio.IBEACON_RX , gpio.A4988_DIR , gpio.A4988_STP , gpio.A4988_ENA , gpio.A4988_MS1 , gpio.OUTPUT_HI , gpio.OUTPUT_LO , gpio.DDS2382_TX , gpio.DDS2382_RX , gpio.DDSU666_TX , gpio.DDSU666_RX , gpio.SM2135_CLK , gpio.SM2135_DAT , gpio.DEEPSLEEP , gpio.EXS_ENABLE , gpio.TASMOTACLIENT_TXD , gpio.TASMOTACLIENT_RXD , gpio.TASMOTACLIENT_RST , gpio.TASMOTACLIENT_RST_INV , gpio.HPMA_RX , gpio.HPMA_TX , gpio.GPS_RX , gpio.GPS_TX , gpio.HM10_RX , gpio.HM10_TX , gpio.LE01MR_RX , gpio.LE01MR_TX , gpio.CC1101_GDO0 , gpio.CC1101_GDO2 , gpio.HRXL_RX , gpio.ELECTRIQ_MOODL_TX , gpio.AS3935 , gpio.ADC_INPUT , gpio.ADC_TEMP , gpio.ADC_LIGHT , gpio.ADC_BUTTON , gpio.ADC_BUTTON_INV , gpio.ADC_RANGE , gpio.ADC_CT_POWER , gpio.WEBCAM_PWDN , gpio.WEBCAM_RESET , gpio.WEBCAM_XCLK , gpio.WEBCAM_SIOD , gpio.WEBCAM_SIOC , gpio.WEBCAM_DATA , gpio.WEBCAM_VSYNC , gpio.WEBCAM_HREF , gpio.WEBCAM_PCLK , gpio.WEBCAM_PSCLK , gpio.WEBCAM_HSD , gpio.WEBCAM_PSRCS , gpio.BOILER_OT_RX , gpio.BOILER_OT_TX , gpio.WINDMETER_SPEED , gpio.KEY1_TC , gpio.BL0940_RX , gpio.TCP_TX , gpio.TCP_RX , gpio.ETH_PHY_POWER , gpio.ETH_PHY_MDC , gpio.ETH_PHY_MDIO , gpio.TELEINFO_RX , gpio.TELEINFO_ENABLE , gpio.LMT01 , gpio.IEM3000_TX , gpio.IEM3000_RX , gpio.ZIGBEE_RST , gpio.DYP_RX , gpio.MIEL_HVAC_TX , gpio.MIEL_HVAC_RX , gpio.WE517_TX , gpio.WE517_RX , gpio.AS608_TX , gpio.AS608_RX , gpio.SHELLY_DIMMER_BOOT0 , gpio.SHELLY_DIMMER_RST_INV , gpio.RC522_RST , gpio.P9813_CLK , gpio.P9813_DAT , gpio.OPTION_A , gpio.FTC532 , gpio.RC522_CS , gpio.NRF24_CS , gpio.NRF24_DC , gpio.ILI9341_CS , gpio.ILI9341_DC , gpio.ILI9488_CS , gpio.EPAPER29_CS , gpio.EPAPER42_CS , gpio.SSD1351_CS , gpio.RA8876_CS , gpio.ST7789_CS , gpio.ST7789_DC , gpio.SSD1331_CS , gpio.SSD1331_DC , gpio.SDCARD_CS , gpio.ROT1A_NP , gpio.ROT1B_NP , gpio.ADC_PH , gpio.BS814_CLK , gpio.BS814_DAT , gpio.WIEGAND_D0 , gpio.WIEGAND_D1 , gpio.NEOPOOL_TX , gpio.NEOPOOL_RX , gpio.SDM72_TX , gpio.SDM72_RX , gpio.TM1637CLK , gpio.TM1637DIO , gpio.PROJECTOR_CTRL_TX , gpio.PROJECTOR_CTRL_RX , gpio.SSD1351_DC , gpio.XPT2046_CS , gpio.CSE7761_TX , gpio.CSE7761_RX , gpio.VL53LXX_XSHUT1 , gpio.MAX7219CLK , gpio.MAX7219DIN , gpio.MAX7219CS , gpio.TFMINIPLUS_TX , gpio.TFMINIPLUS_RX , gpio.ZEROCROSS , gpio.HALLEFFECT , gpio.EPD_DATA , gpio.INPUT , gpio.KEY1_PD , gpio.KEY1_INV_PD , gpio.SWT1_PD , gpio.I2S_OUT_DATA , gpio.I2S_OUT_CLK , gpio.I2S_OUT_SLCT , gpio.I2S_IN_DATA , gpio.I2S_IN_CLK , gpio.I2S_IN_SLCT , gpio.INTERRUPT , gpio.MCP2515_CS , gpio.HRG15_TX , gpio.VINDRIKTNING_RX , gpio.BL0939_RX , gpio.BL0942_RX , gpio.HM330X_SET , gpio.HEARTBEAT , gpio.HEARTBEAT_INV , gpio.SHIFT595_SRCLK , gpio.SHIFT595_RCLK , gpio.SHIFT595_OE , gpio.SHIFT595_SER , gpio.SOLAXX1_RTS , gpio.OPTION_E , gpio.SDM230_TX , gpio.SDM230_RX , gpio.ADC_MQ , gpio.CM11_TXD , gpio.CM11_RXD , gpio.BL6523_TX , gpio.BL6523_RX , gpio.ADE7880_IRQ , gpio.RESET , gpio.MS01 , gpio.SDIO_CMD , gpio.SDIO_CLK , gpio.SDIO_D0 , gpio.SDIO_D1 , gpio.SDIO_D2 , gpio.SDIO_D3 , gpio.FLOWRATEMETER_SIGNAL , gpio.SENSOR_END An H-bridge is an electronic circuit that switches the polarity of a voltage applied to a load. These circuits are often used in robotics and other applications to allow DC motors to run forwards or backwards. See the Berry cookbook for H-bridge control","title":"gpio module"},{"location":"Berry/#dac-gpios","text":"DAC is limited to specific GPIOs: ESP32: only GPIO 25-26 ESP32-S2: only GPIO 17-18 ESP32-C3: not supported Example > gpio.pin_mode(25, gpio.DAC) # sets GPIO25 to a DAC pin > gpio.dac_voltage(25, 1250) # set voltage to 1250mV 1255 Function returns closes voltage found. In this case its 1255 for setting to 1250.","title":"DAC GPIOs"},{"location":"Berry/#i2s","text":"DAC can also be used via Esp8266Audio through the ESP32 I2S -> DAC bridge. Example class MP3_Player : Driver var audio_output , audio_mp3 def init () self . audio_output = AudioOutputI2S ( gpio . pin ( gpio . I2S_OUT_CLK ), gpio . pin ( gpio . I2S_OUT_SLCT ), gpio . pin ( gpio . I2S_OUT_DATA ), 0 , #- I2S port -# 64 ) #- number of DMA buffers of 64 bytes each, this is the value required since we update every 50ms -# self . audio_mp3 = AudioGeneratorMP3 () end def play ( mp3_fname ) if self . audio_mp3 . isrunning () self . audio_mp3 . stop () end var audio_file = AudioFileSourceFS ( mp3_fname ) self . audio_mp3 . begin ( audio_file , self . audio_output ) self . audio_mp3 . loop () #- start playing now -# end def every_50ms () if self . audio_mp3 . isrunning () self . audio_mp3 . loop () end end end mp3_player = MP3_Player () tasmota . add_driver ( mp3_player ) mp3_player . play ( \"/pno-cs.mp3\" )","title":"I2S"},{"location":"Berry/#energy-module","text":"The energy module provides ways to read current energy counters and values (if you're creating your own automation) or updating the energy counters (if you're writing a driver). It relies on a new Berry feature that provides a direct mapping between the internal C structure called struct Energy and the energy module in Berry. For example, if you want to read or update an energy value: > energy.active_power 0 > energy.active_power = 460 > energy.active_power 460 # internally it updates the C value `Energy.active_power[0]` (float) You don't need to do import energy since Tasmota does it for you at boot. The special energy.read() function dumps all current values to a single map . Be aware that the object is very long. Prefer accessing individual attributes instead. Tasmota Function Parameters and details energy.read() () -> map Returns all current values for the energy module. Some values may be unused by the current driver. List of energy attributes that you can read or write: Attribute Type Description voltage voltage_2 voltage_3 float Voltage (V) for main phase or 3 phases current current_2 current_3 float Current (A) for main phase or 3 phases active_power active_power_2 active_power_3 float Active Power (W) for main phase or 3 phases reactive_power reactive_power_2 reactive_power_3 float Reactive Power (W) for main phase or 3 phases power_factor power_factor_2 power_factor_3 float Power Factor (no unit) for main phase or 3 phases frequency frequency_2 frequency_3 float Frequency (Hz) for main phase or 3 phases export_active export_active_2 export_active_3 float (kWh) start_energy float Total previous energy (kWh) daily float Daily energy (kWh) total float Total energy (kWh) today_delta_kwh uint32 (deca milli Watt hours) 5764 = 0.05764 kWh = 0.058 kWh today_offset_kwh uint32 (deca milli Watt hours) today_kwh uint32 (deca milli Watt hours) period uint32 (deca milli Watt hours) fifth_second uint8 command_code uint8 data_valid data_valid_2 data_valid_3 uint8 phase_count uint8 Number of phases (1,2 or 3) voltage_common bool Use single voltage frequency_common bool Use single frequency use_overtemp bool Use global temperature as overtemp trigger on internal energy monitor hardware today_offset_init_kwh bool voltage_available bool Enable if voltage is measured current_available bool Enable if current is measured type_dc bool power_on bool power_history_0 power_history_0_2 power_history_0_3 power_history_1 power_history_1_2 power_history_1_3 power_history_2 power_history_2_2 power_history_2_3 uint16 power_steady_counter uint8 Allow for power on stabilization min_power_flag bool max_power_flag bool min_voltage_flag bool max_voltage_flag bool min_current_flag bool max_current_flag bool mplh_counter uint16 mplw_counter uint16 mplr_counter uint8 max_energy_state uint8","title":"energy module"},{"location":"Berry/#wire-object-for-i2c","text":"Berry Scripting provides 2 objects: wire1 and wire2 to communicate with both I 2 C buses. Use wire1.scan() and wire2.scan() to scan both buses: > wire1.scan() [] > wire2.scan() [140] You generally use tasmota.wire_scan() to find a device and the corresponding I 2 C bus. MPU6886 on bus 2 > mpuwire = tasmota.wire_scan(0x68, 58) > mpuwire <instance: Wire()> Wire Function Parameters and details bus read only attribute, 1 or 2 Bus number for this wire instance. enabled () -> bool Returns true is the I2C bus is initialized (i.e. GPIOs are defined) scan () -> array of int Scan the bus and return all responding addresses. Note: addresses are displayed as decimal ints, not hex. scan () -> array of int Scan the bus and return all responding addresses. Note: addresses are displayed as decimal ints, not hex. detect (addr:int) -> bool Returns true if the device of address addr is connected to this bus. read (addr:int, reg:int, size:int) -> int or nil Read a value of 1..4 bytes from address addr and register reg . Returns nil if no response. write (addr:int, reg:int, val:int, size:int) -> bool Writes a value of 1..4 bytes to address addr , register reg with value val . Returns true if successful, false if not. read_bytes (addr:int, reg:int ,size:int) -> instance of bytes() Reads a sequence of size bytes from address addr register reg . Result is a bytes() instance or bytes() if not successful.` write_bytes (addr:int, reg:int, val:bytes) -> nil Writes the val bytes sequence as bytes() to address addr register reg . Low-level commands if you need finer control: Wire Function Parameters and details _begin_transmission (address:int) -> nil _end_transmission ([stop:bool]) -> nil Send stop if stop is true . _request_from (addr:int, size:int [stop:bool = true]) -> nil _available () -> bool _read read() -> int Reads a single byte. _write (value:int or s:string) -> nil Sends either single byte or an arbitrary string.","title":"wire object for I2C"},{"location":"Berry/#path-module","text":"A simplified version of os.path module of standard Berry which is disabled in Tasmota because we don't have a full OS. The default file-system is the ESP32 internal flash. If you have a SD card mounted, it is mapped to the /sd/ subdirectory. Example: import path print ( path . listdir ( \"/sd/\" ) # outputs a list of filenames at the root dir of the SD card Tasmota Function Parameters and details path.exists (file_name:string) -> bool Returns true if the file exists. You don't need to prefix with / , as it will automatically be added if the file does not start with / path.last_modified (file_name:string) -> int Returns the timestamp when the file was last modified, or nil if the file does not exist. You don't need to prefix with / , as it will automatically be added if the file does not start with / path.listdir (dir_name:string) -> list(string) List a directory, typically root dir \"/\" and returns a list of filenames in the directory. Returns an empty list if the directory is invalid path.remove (file_name:string) -> bool Deletes a file by name, return true if successful path.format (true:bool) -> bool Re-formats the LittleFS file system (internal ESP32 flash) and erases all content. The parameter needs to be true as to avoid unwanted calls. Returns true if reformatting was successful. This is sometimes useful when the file-system becomes unstable or corrupt after multiple re-partitionings.","title":"path module"},{"location":"Berry/#persist-module","text":"Easy way to persist simple values in Berry and read/write any attribute. Values are written in JSON format in _persist.json file. Example import persist persist.a = 1 persist.b = \"foobar\" print(persist) persist.save() # save to _persist.json Tasmota Function Parameters and details persist.save () triggers saving to file system. It is called automatically before a restart but you might want to call it yourself to prevent losing data in case of power loss or crash. persist.save() writes to flash, so be careful of not calling it too often, or it will cause wearing of flash and reduce its lifetime. persist.has (param:string) -> bool returns true or false if the key exists persist.remove (param:string) -> bool removes a key or ignores if key doesn't exist persist.find my_param:string [, \"default value\"] -> string | bool returns the value for a key, or nil or the default value. Similar to map.find","title":"persist module"},{"location":"Berry/#introspect-module","text":"Allows to do introspection on instances and modules, to programmatically list attributes, set and get them. > class A var a , b def f () return 1 end end > ins = A () > ins . a = \"foo\" > import introspect > introspect . members ( ins ) [ 'b' , 'a' , 'f' ] > introspect . get ( ins , \"a\" ) foo > introspect . set ( ins , \"a\" , \"bar\" ) bar > ins . a bar Tasmota Function Parameters and details introspect.members (nil | instance | module | class) -> list Returns the list of members of the object. If nil is passed, it returns the list of globals (similar to global module). Note: virtual dynamic members are not listed. introspect.get (instance | module, name:string) -> any Returns the member of name name or nil if it does not exist. Note: virtual dynamic members are not yet supported. Note2: classes are not yet supported. introspect.set (instance | module, name:string, value:any) -> any Sets the member of name name to value or ignores the call if the member does not exist. Note: virtual dynamic members are not yet supported. introspect.module (name:string) -> module or nil Loads a module by name or return nil if not found. The import command works only for static predefined names, this addition makes it dynamic. Contrary to import command, this function does not create an entry in the current scope (i.e. does not either create a global variable with the module's name). introspect.toptr (any) -> comptr Converts an int to a comptr pointer. This is sage in Tasmota since pointers and ints are both 32 bits in size. If argument is a general object, this returns a pointer to the object, and can be converted back to the original object with introspect.fromptr . introspect.fromptr (comptr) -> any Converts a comptr pointer to its original object. Warning: this operation is considered dagerous and should be used with extreme care. If the pointer is invalid or the object was garbage collected, Tasmota will crash. introspect.ismethod (function or closure) -> bool Returns true if the function passed as argument is a method of a class, or false if the argument is a simple function or a static method. This is typically used to check callbacks and make sure that you don't pass a method as argument; methods typically need to be wrapped in a closure to capture the target object.","title":"introspect module"},{"location":"Berry/#webclient-class","text":"Class webclient provides an implementation of an HTTP/HTTPS web client and make requests on the LAN or over the Internet. Features: Support HTTP and HTTPS requests to IPv4 addresses and domain names, to arbitrary ports, via a full URL. Support for HTTPS and TLS via BearSSL (which is much lighter than default mbedTLS) HTTPS (TLS) only supports cipher ECDHE_RSA_WITH_AES_128_GCM_SHA256 which is both secure and widely supported Support for URL redirections (tbc) Ability to set custom User-Agent Ability to set custom headers Ability to set Authentication header Support for Chunked encoding response (so works well with Tasmota devices) The current implementation is based on a fork of Arduino's HttpClient customized to use BearSSL Current limitations (if you need extra features please open a feature request on GitHub): Only supports text responses (html, json...) but not binary content yet (no NULL char allowed) Maximum response size is 32KB, requests are dropped if larger HTTPS (TLS) is in 'insecure' mode and does not check the server's certificate; it is subject to Man-in-the-Middle attack No access to response headers No support for compressed response Example > cl = webclient () > cl . begin ( \"http://ota.tasmota.com/tasmota32/release/\" ) < instance : webclient () > > r = cl . GET () > print ( r ) 200 > s = cl . get_string () > print ( s ) < pre > < b ></ b > Alternative firmware for ESP32 based devices with web UI , [ .../... ] Example > cl = webclient () > cl . begin ( \"https://raw.githubusercontent.com/tasmota/autoconf/main/esp32/M5Stack_Fire_autoconf.zip\" ) < instance : webclient () > > r = cl . GET () > print ( r ) 200 > cl . write_file ( \"M5Stack_Fire_autoconf.zip\" ) 950 Main functions: WebClient Function Parameters and details begin (url:string) -> self Set the complete URL, including protocol ( http or https ), IPv4 or domain name, port... This should be the first call. The connection is not established at this point. GET () -> result_code:int Establish a connection to server, send GET request and wait for response header. Returns the HTTP result code or an error code if negative, 200 means OK. POST (payload:string or bytes) -> result_code:string Establish a connection to server, send POST request with payload and wait for response header. Returns the HTTP result code or an error code if negative, 200 means OK. read (addr:int, reg:int, size:int) -> int or nil Read a value of 1..4 bytes from address addr and register reg . Returns nil if no response. get_size () -> int Once a connection succeeded (GET or POST), reads the size of the response as returned by the server in headers (before actually reading the content). A value -1 means that the response size is unknown until you read it. get_string () -> string Once a connection succeeded (GET or POST), reads the content of the response in a string. The response max size is 32KB, any response larger is dropped. Connection is closed and resources are freed after this call completes. close () -> nil Closes the connection and frees buffers. close can be called after GET or POST and is implicitly called by get_string . You don't usually need to use close unless you are only retrieving the result_code for a request and not interested in the content. write_file (file_name:string) -> int Downloads the binary content of the resource and stores it on the file system. Returns the number of bytes downloaded or -1 if an error occurred Request customization: webclient Function Parameters and details add_header (name:string, value:string [, first:bool=false [, replace:bool=true]]) -> nil Sets an arbitrary header for name : value . first moves the header in the first place, replace replaces a header with the same name or adds one line if false. set_timeouts (req_timeout:int [, tcp_timeout:int]) -> self Sets the request timeout in ms and optionally the TCP connection timeout in ms. set_useragent (useragent:string) -> self Sets the User-Agent header used in request. set_auth (auth:string) or (user:string, password:string) -> self Sets the authentication header, either using pre-encoded string, or standard user/password encoding.","title":"webclient class"},{"location":"Berry/#webserver-module","text":"Module webserver provides functions to enrich Tasmota's Web UI. It is tightly linked to Tasmota page layout. Functions used to add UI elements like buttons to Tasmota pages, and analyze the current request. See above Driver to add buttons to Tasmota UI. General Function Parameters and details arg_size () -> int Returns the number of arguments in the request arg (arg_name:string or arg_index:int): -> string Returns the value of the argument either by name or by position number [0..arg_size()-1]. If an argument has multiple values, you need to iterate using ints to get all values arg_name (arg_index:int) -> string Returns the name of argument by index [0..arg_size()-1] has_arg (arg_name:string): -> bool Checks if an argument with this name exists check_privileged_access () -> bool Returns true if the page needs privileged access content_send (string) -> nil Sends the HTML content to the client. Tasmota uses Chunked encoding, which means than the content is regularly sent to the client and not buffered in Tasmota's memory content_button ([button:int]) -> nil Displays a standard button by code, using Tasmota localization. Possible values are webserver.BUTTON_CONFIGURATION , webserver.BUTTON_INFORMATION , webserver.BUTTON_MAIN , webserver.BUTTON_MANAGEMENT , webserver.BUTTON_MODULE . Default is webserver.BUTTON_MAIN . Low-level functions if you want to display custom pages and content: General Function Parameters and details on (prefix:string, callback:closure [, method:int]) -> nil Attaches a handler (any closure or function) to a prefix. An optional method argument (defaults to webserver.HTTP_ANY specifies the HTTP methods to be received (ANY, GET, POST, OPTIONS, POST) WARNING - this should be called only when receiving web_add_handler event. If called before the WebServer is set up and Wi-Fi on, it will crash. For debug purpose, it can be called later when you are sure that Wi-Fi or Ethernet is up. state () -> int Returns the internal state of Tasmota web server. Possible values are webserver.HTTP_OFF , webserver.HTTP_USER , webserver.HTTP_ADMIN , webserver.HTTP_MANAGER , webserver.HTTP_MANAGER_RESET_ONLY . content_start () -> nil Start response page content_response (string) -> nil Sends a response to a XMLHttpRequest content_send_style () -> nil Sends the standard Tasmota style content_flush () -> nil Flush the buffer and send any buffered content to the client content_stop () -> nil End of the response, closes the connection Module webserver also defines the following constants: Tasmota's web server states: webserver.HTTP_OFF , webserver.HTTP_USER , webserver.HTTP_ADMIN , webserver.HTTP_MANAGER , webserver.HTTP_MANAGER_RESET_ONLY Tasmota's pages: webserver.BUTTON_CONFIGURATION , webserver.BUTTON_INFORMATION , webserver.BUTTON_MAIN , webserver.BUTTON_MANAGEMENT , webserver.BUTTON_MODULE Methods received by handler: webserver.HTTP_ANY , webserver.HTTP_GET , webserver.HTTP_OPTIONS , webserver.HTTP_POST See the Berry Cookbook for examples.","title":"webserver module"},{"location":"Berry/#tcpclient-class","text":"Simple tcp client supporting string and binary transfers: create an instance of the client with var tcp = tcpclient() connect to the server tcp.connect(address:string, port:int [, timeout_ms:int]) -> bool Address can be numerical IPv4 or domain name. Returns true if the connection succeeded. Optional timeout in milliseconds. The default timeout is USE_BERRY_WEBCLIENT_TIMEOUT (2 seconds). check if the socket is connected with tcp.connected() send content with tcp.write(content:string or bytes) -> int . Accepts either a string or a bytes buffer, returns the number of bytes sent. It's you responsibility to resend the missing bytes check if bytes are available for reading tcp.available() -> int . Returns 0 if nothing was received. This is the call you should make in loops for polling. read incoming content as string tcp.read() -> string or as bytes tcp.readbytes() -> bytes . It is best to call tcp.available() first to avoid creating empty response objects when not needed close the socket with tcp.close() tcpclient Function Parameters and details connect connect(address:string, port:int [, timeout_ms:int]) -> bool Connect to addr:port with optional timeout in milliseconds (default 2s). Returns true if connection was successful, the call is blocking until the connection succeeded to the timeout expired. connected connected() -> bool Returns true if the connection was successful and is still valid (not dropped by server or closed by client) close close() -> nil Drops the current connection. write content:string or bytes) -> int Accepts either a string or a bytes buffer, returns the number of bytes sent. It's you responsibility to resend the missing bytes. Returns 0 if something went wrong. available available() -> int Returns the number of bytes received in buffer and ready to be read. read read([max_len:int]) -> string Returns all the bytes received in Rx buffer as string . Optional max_len parameter limits the number of characters returned, or read as much as possible by default. readbytes read([max_bytes:int]) -> bytes() Returns all the bytes received in Rx buffer as bytes() . Optional max_bytes parameter limits the number of bytes returned, or read as much as possible by default. Full example: tcp = tcpclient() tcp.connect(\"192.168.2.204\", 80) print(\"connected:\", tcp.connected()) s= \"GET / HTTP/1.0\\r\\n\\r\\n\" tcp.write(s) print(\"available1:\", tcp.available()) tasmota.delay(100) print(\"available1:\", tcp.available()) r = tcp.read() tcp.close() print(r)","title":"tcpclient class"},{"location":"Berry/#tcpserver-class","text":"Simple tcp server (socket) listening for incoming connection on any port. create an instance of the tcpserver on a specific port with s = tcpserver(8888) periodically call s.hasclient() to know if a new client has connected if the previous returned true , call var c = s.accept() to accept the connection. It returns an instance of tcpclient as above; it responds to the same APIs as outgoing TCP connection and allows text and binary transfers. you can call c.close() to close the connection, or call c.connected() to know if it's still connected (i.e. the client hasn't closed the connection on their side) close the server with s.close() . This will prevent the server from receinving any new connection, but existing connections are kept alive. tcpserver Function Parameters and details constructor tcpserver(port:int) -> nit Opens a socket on port and starts lisenting to new incoming connections. If the server can't open the socket (ex: it is already in use) an exception is raised hasclient hasclient() -> bool Returns true if a new client connected to the socket, in such case you shoult call accept() . You need to call this method regularly (ex: in event loop or fast_loop) accept accept() -> instance:tcpclient or nil Returns an instance of tcpclient for the new incoming connection, or raise an exception if no connection is available. You should call hasclient() returning true before calling accept() . Full example: > s = tcpserver ( 8888 ) # listen on port 8888 > s . hasclient () false # in parallel connect on this port with `nc <ip_address> 8888` > s . hasclient () true # we have an incoming connection > c = s . accept () > c < instance : tcpclient () > # send 'foobar' from the client > c . read () foobar # send 'foobar2' again from the client > c . readbytes () bytes ( '666F6F626172320A' ) > c . close () # this closes the connection","title":"tcpserver class"},{"location":"Berry/#udp-class","text":"Class udp provides ability to send and received UDP packets, including multicast addresses. You need to create an object of class udp . Such object can send packets and listen to local ports. If you don't specify a local port, the client will take a random source port. Otherwise the local port is used as source port. When creating a local port, you need to use udp->begin(<ip>, <port)> . If <ip> is empty string \"\" then the port is open on all interfaces (wifi and ethernet). General Function Parameters and details udp() udp() -> <instance udp> Creates an instance of udp class. begin begin(ip:string, port:int) -> bool Create a UDP listener and sender on interface ip and port . If ip is an empty string, the listener connects to all interfaces (aka 0.0.0.0) Returns true if successful. begin_multicast begin(ip:string, port:int) -> bool Create a UDP listener and sender on interface ip and port . ip must be a multicast address. Returns true if successful. send send(addr:string, port:int, payload:bytes) -> bool Sends a packet to address addr , port port and message as bytes() buffer. Returns true if successful. send_multicast send(payload:bytes) -> bool Sends a payload as bytes() buffer to the multicast address. begin_multicast() must have been previously called. Returns true if successful. read read() -> bytes() or nil Reads any received udp packet as bytes() buffer, or nil if no packet was received. remote_ip remote_ip (string or nil) Instance variable containing the remote ip (as string) from the last successful read() command. remote_port remote_port (int or nil) Instance variable containing the remote port (as int) from the last successful read() command.","title":"udp class"},{"location":"Berry/#addressable-leds-ws2812-sk6812","text":"There is native support for addressable leds via NeoPixelBus, with support for animations. Currently supported: WS2812, SK6812. Details are in Berry leds","title":"Addressable leds (WS2812, SK6812)"},{"location":"Berry/#serial-class","text":"The serial class provides a low-level interface to hardware UART. The serial GPIOs don't need to be configured in the template. Example # gpio_rx:4 gpio_tx:5 ser = serial(4, 5, 9600, serial.SERIAL_7E1) ser.write(bytes(203132)) # send binary 203132 ser.write(bytes().fromstring(\"Hello)) # send string \"Hello\" msg = ser.read() # read bytes from serial as bytes print(msg.asstring()) # print the message as string Tasmota Function Parameters and details serial (constructor) serial(gpio_rx:int, gpio_tx:int, baud:int [, mode:int]) Creates a serial object gpio_rx receive GPIO (or -1 if transmit only) gpio_tx transmit GPIO (or -1 if receive only) baud speed, ex: 9600, 115200 mode serial message format, default is serial.SERIAL_8N1 (8 bits, no parity, 1 stop bit). Other mode values are described below. write write(val:int || bytes()) -> bytes_sent:int Send either a single byte if argument is int, or send a binary message from a bytes() object. The methods blocks until all messages are sent to the UART hardware buffer; they may not all have been sent over the wire read read(void) -> bytes() Read all bytes received in the incoming buffer. If the buffer is empty, returns an empty bytes() object flush flush(void) -> void Flushes all buffers. Waits for all outgoing messages to be sent over the wire and clear the incoming buffer. available available(void) -> int Returns the number of incoming bytes in the incoming buffer, 0 in none. Supported serial message formats: SERIAL_5N1 , SERIAL_6N1 , SERIAL_7N1 , SERIAL_8N1 , SERIAL_5N2 , SERIAL_6N2 , SERIAL_7N2 , SERIAL_8N2 , SERIAL_5E1 , SERIAL_6E1 , SERIAL_7E1 , SERIAL_8E1 , SERIAL_5E2 , SERIAL_6E2 , SERIAL_7E2 , SERIAL_8E2 , SERIAL_5O1 , SERIAL_6O1 , SERIAL_7O1 , SERIAL_8O1 , SERIAL_5O2 , SERIAL_6O2 , SERIAL_7O2 , SERIAL_8O2","title":"serial class"},{"location":"Berry/#display-module","text":"The display module provides a simple API to initialize the Universal Display Driver with data provided as a string. It is used by autoconf mechanism. Tasmota Function Parameters and details start display.start(displayini:string) -> nil Initializes the Universal Display Driver with the string provided as argument, similar to content in display.ini . It is typically read from a file in the file-system. started display.started() -> bool Returns true if display is already initialized, false if not started. dimmer display.started([dim:int]) -> int Sets the dimmer of display, value 0..100. If 0 then turn off display. If no arg, read the current value. driver_name display.driver_name() -> string Returns the Display driver name as specified in display.ini touch_update display.touch_update(touches:int, raw_x:int, raw_y:int, gesture:int) -> nil Sets the last Touch Screen update values to be passed to LVGL. This allows an external touchscreen driver to periodically update the touch information. touches : number of touches ( 0 = no touch, 1 = screen touched). Multiple touch is not supported raw_x and raw_y = coordinates before conversion (resistive touch screens need conversion) gesture : type of gesture. 0 = no gesture, 16 = move up, 17 = move down, 18 = move left, 19 = move right, 32 = zoom in, 33 = zoom out.","title":"display module"},{"location":"Berry/#uuid-module","text":"The uuid module allows to generate uuid4 random ids. > import uuid > uuid . uuid4 () 1 a8b7f78 - 59 d8 - 4868 - 96 a7 - b7ff3477d43f Tasmota Function Parameters and details uuid4 uuid.uuid4() -> string Generates a uuid4 random id as string.","title":"uuid module"},{"location":"Berry/#crc-module","text":"The crc module allows to compute crc32/16/8 from bytes() arrays. > import crc > crc . crc32 ( 0xFFFFFFFF , bytes ( \"AABBCC\" )) - 1091314015 > crc . crc16 ( 0xFFFF , bytes ( \"AABBCC\" )) 20980 > crc . crc8 ( 0xFF , bytes ( \"AABBCC\" )) 139 Tasmota Function Parameters and details crc32 crc.crc32(crc:int, payload:bytes) -> int Compute crc32 from an initial value and a bytes() buffer crc16 crc.crc16(crc:int, payload:bytes) -> int Compute crc16 from an initial value and a bytes() buffer crc8 crc.crc8(crc:int, payload:bytes) -> int Compute crc8 from an initial value and a bytes() buffer","title":"crc module"},{"location":"Berry/#log_reader-class","text":"The log_reader class allows you to read and potentially parse the Tasmota logs. It keeps track of what logs were already read in the past and feeds you with new log lines if some are available. It is for example used by the LVGL tasmota_log widget to display logs on a display. Note: calling log_reader can be expensive in string allocations, and adds pressure on the garbage collector. Use wisely. Example: var lr = log_reader () # do this regularly var ret = lr . get_log ( 2 ) # read at log level 2 if ret != nil var lines = r . split ( '\\n' ) # extract as a list of lines # do whatever you need end Tasmota Function Parameters and details log_reader() log_reader(void) -> instance(log_reader) Instantiate a new log_reader . Multiple readers can coexist and they each keep track of already read log lines get_log get_log(log_level:int) -> string or nil Returns new log lines as a big string object. Lines are separated by \\n . Returns nil if no new logs are available. log_level can be 0..4 and specifies the highest log level that we be reported (it is usually wise to start with 2 ). Higher log level will be reported only if they are recorded, i.e. there is at least one logger that asks for it. This class does not cause log-level 4 to be recorded if none other loggers are recording them ( weblog , mqttlog or seriallog ).","title":"log_reader class"},{"location":"Berry/#ulp-module","text":"The ULP module exposes the third computing unit of the ESP32, which is a simple finite state machine (FSM) that is designed to perform measurements using the ADC, temperature sensor and even external I2C sensors. This small ultra low power coprocessor can run in parallel to the main cores and in deep sleep mode, where it is capable to wake up the system, i.e. in reaction to sensor measurements. The binding to Berry consists of some lightweight wrapper functions and the communication with the main cores works by accessing the RTC_SLOW_MEM from both sides, which is the same way as in any other ESP32 ULP project. # simple LED blink example import ULP ULP . wake_period ( 0 , 500000 ) # off time ULP . wake_period ( 1 , 200000 ) # on time c = bytes ( \"756c70000c006c00000000001000008000000000000000000000000010008072010000d0e5af2c72340040802705cc190005681d10008072e1af8c720100006821008072040000d0120080720800207004000068010005825c0000800405681d00000092680000800505681d0100009268000080000000b0\" ) ULP . load ( c ) ULP . run () Tasmota Function Parameters and details run ULP.run() -> nil Execute ULP prgramm load ULP.load(code:bytes) -> nil Load ULP code from a bytes() buffer into memory set_mem ULP.set_mem(addr:int, value:int) -> nil Set memory position in RTC_SLOW_MEM to value. Address and Value are 32-bit!! get_mem ULP.set_mem(addr:int) -> int16_t Get value from memory position in RTC_SLOW_MEM. By hardware design only the lower 16-bit are usable, so this function already masks out the upper 16-bit gpio_init ULP.gpio_init(pin:int, mode:int) -> pin:int Makes a valid GPIO pin accessible to the ULP and sets the mode according to the enum 'rtc_gpio_mode_t', returns the same pin, but translated to the RTC system, which is the numbering scheme in the assembly code adc_config ULP.adc_config(channel:int, attenuation:int, width:int) -> nil Configures ADC pin usage for the ULP according to the enums ' adc1_channel_t', 'adc_atten_t' and 'adc_bits_width_t' wake_period ULP.wake_period(register:int, time:int) -> nil Configures one of 5 (0..4) wake timer registers with the time value in microseconds sleep ULP.wake_period([time:int]) -> nil Starts deep sleep mode and allow wake up by the ULP, with an optional time value in seconds an additional wake up timer gets started More infos (including suggestions for a toolchain) on the ULP page .","title":"ULP module"},{"location":"Berry/#re-regex-module","text":"Use with import re . There are two ways to use regex, first is to call directly the module which triggers a compilation of the regex at each call. The second one is to pre-compile the regex once into an object which is much more efficient if you need to use the regex multiple times. Any error in the compilation of the regex pattern yields an exception. > import re > re . search ( \"a.*?b(z+)\" , \"zaaaabbbccbbzzzee\" ) [ 'aaaabbbccbbzzz' , 'zzz' ] > re . match ( \"a.*?b(z+)\" , \"aaaabbbccbbzzzee\" ) [ 'aaaabbbccbbzzz' , 'zzz' ] > rr = re . compile ( \"/\" ) > rr < instance : re_pattern () > > rr . split ( \"foo/bar//baz\" ) [ 'foo' , 'bar' , '' , 'baz' ] > rr . split ( \"/b\" ) [ '' , 'b' ] Tasmota Function Parameters and details search re.search(pattern:string, payload:string) -> list of strings Returns the list of matches, or empty list of no match match re.match(pattern:string, payload:string) -> list of strings Returns the list of matches, or empty list of no match. The difference with search is that match must match the entire string (from beginning to end). split re.search(pattern:string, payload:string) -> list of strings Returns the list of strings from split, or a list with a single element containing the entire string if no match compile re.compile(pattern:string) -> instance of <re_pattern> Compiles the regex into a reusable faster bytecode. You can then call the following methods: search() , match() , split() similarly to the module's functions. Note: for match and search , the first element in the list contains the global match of the pattern. Additional elements correspond to the sub-groups (in parenthesis). The regex engine is based on re1.5 also used in Micropython.","title":"re regex module"},{"location":"Berry/#compiling-berry","text":"Berry is included if the following is defined in user_config_override.h : #define USE_BERRY Other options that can be changed: Option Description #define USE_BERRY_PSRAM Use PSRAM to allocate memory instead of main RAM. If no PSRAM is connected, this option has no effect. Enabled by default #define USE_BERRY_DEBUG Provide additional information in case of a Berry exception, adding line number in the call chain. This feature adds ~8% of memory consumption to Berry compiled code. Disabled by default #define USE_WEBCLIENT Enable the webclient module allowing to do HTTP requests. Enabled by default #define USE_WEBCLIENT_HTTPS Adds support for HTTPS to webclient . This feature adds ~45KB of Flash space for TLS support. Disabled by default #define USE_BERRY_WEBCLIENT_USERAGENT \"TasmotaClient\" Specifies the default User-Agent field sent by webclient . Can be changed on a per request basis. #define USE_BERRY_WEBCLIENT_TIMEOUT 5000 Specifies the default timeout in millisecond for webclient . Can be changed on a per request basis.","title":"Compiling Berry"},{"location":"Berry/#berry-cookbook","text":"Find complete examples and use scenarios of Berry in the Berry Cookbook","title":"Berry Cookbook"},{"location":"Berry_Addressable-LED/","text":"Addressable LEDs in Berry ~ Requires #define USE_WS2812 . Support for addressable leds strips or matrix, including animation. Internally relies on NeoPixelBus library and currently supports WS2812 and SK6812. Example ~ Pulsating round on M5Stack Atom Matrix if GPIO 27 is configured as WS1812 - 2 var strip = Leds_matrix ( 5 , 5 , gpio . pin ( gpio . WS2812 , 1 )) var r = Round ( strip , 2 , 30 ) r . start () VIDEO How to use ~ Compatibility with Templates ~ Leds strip must be either controlled by Tasmota's lights features or by Berry, but they can't be controlled by both at the same time. For Berry control, it is highly recommended to use WS2812 - 2 and higher (for multiple strips) Leds and Leds_matrix classes ~ All leds features rely on the low-level Leds or Leds_matrix classes. Attributes Details Leds Leds(pixels:int, gpio:int [,model:int ,rmt:int]) -> instance<Leds> Creates a Leds instance for a linear leds strip pixels : number of leds gpio : gpio number model : (opt) LED model, default:Leds.WS2812_GRB <br> rmt : (opt) RMT`channel to use, or auto-select (see below) Leds.matrix Leds_matrix(width:int, height:int, gpio:int [,model:int ,rmt:int]) -> instance<Leds_matrix> Creates a Leds instance for a matrix of leds width : number of leds horizontally height : number of leds vertically gpio : gpio number model : (opt) LED model, default:Leds.WS2812_GRB <br> rmt : (opt) RMT`channel to use, or auto-select (see below) .create_segment <strip>.create_segment(offset:int, pixels:int) -> instance<Leds_segment> Creates a virtual segment from a physical Leds strip, from Led number offset with pixels leds. LED model Details Leds.WS2812_GRB WS2812b Leds (GRB) - takes 24 bits RGB colors Leds.SK6812_GRBW SK6812 Leds (GRBW) - takes 32 bits RGBW colors (with white channel) Methods are the equivalent low-level from NeoPixelBus. All colors are in 0xRRGGBB format (24 bits) or 0xWWRRGGBB format (32 bits). Attributes Details clear clear() -> nil Clear all led (set to black) show show() -> nil Pushes the internal buffer to leds. May be ignored if a show command is already in progress. Use can_show() to see if show() is possible can_show can_show() -> bool Indicates if show() is possible, i.e. no transfer is ongoing is_dirty is_dirty() -> bool Indicates if a led was changed since last show() dirty dirty() -> nil Forces a refresh during next show() pixel_size pixel_size() -> int Returns the number of bytes per pixel pixel_count pixel_count() -> int Returns the number of leds in the strip/matrix clear_to clear_to(col:color [, bri:int]) -> nil Clears all leds to the specified color. bri is optional and default to 100% set_pixel_color set_pixel_color(idx:int, col:color [, bri:int]) -> nil Set led number idx to the specified color. bri is optional and default to 100% set_matrix_pixel_color set_matrix_pixel_color(x:int, y:int, col:color [, bri:int]) -> nil (only Leds_matrix ) Set led number of coordinates x / y to the specified color. bri is optional and default to 100% get_pixel_color get_pixel_color(idx:int) -> color:int Returns the color (including brightness and gamma correction) of led number idx gamma gamma:bool Applies gamma correction if true (default) pixels_buffer pixels_buffer() -> bytes() Returns the internal buffer used by NeoPixelBus. The byte() object points to the original buffer, no new buffer is allocated; which means that raw data can be changed directly. Don't forget to call dirty() and show() afterwards Animation framework ~ The class Leds_animator sets the necessary methods to facilitate animations. You just need create a sub-class or Leds_animator , provide a Leds or Leds_matrix instance and implement the animate method. You can also register animators (see below). The instance is automatically registered as driver. Call start() to start the animation, and stop() to stop it. Attributes Details Leds_animator Leds_animator(strip:instance) -> instance<Leds_animator> Constructors only needs an instance of Leds or Leds_matrix start start() -> nil Register the animator as Tasmota driver (with tasmota.add_driver ) and start the animation stop stop() -> nil Stop the animation and removes the driver from Tasmota drivers list clear clear() -> nil Call stop() and clear all leds (set to black) remove remove() -> nil Removes the instance from Tasmota's list of drivers, and stops the animation set_bri set_bri(bri:int) -> nil Sets the brightness of the animation (0..100) add_anim add_anim(anim:instance) -> nil Registers an animator to be called just before the call to animate (see below) get_bri get_bri() -> int Returns the brightness of the animation (0..100) animate animate() -> nil Place-holder for the actual animation. You need to override this method Example: import animate class Rainbow_stripes : Leds_animator var cur_offset # current offset in the palette static palette = [ 0xFF0000 , #- red -# 0xFFA500 , #- orange -# 0xFFFF00 , #- yellow -# 0x008800 , #- green -# 0x0000FF , #- blue -# 0x4B0082 , #- indigo -# 0xEE82EE , #- violet -# ] # duration in seconds def init ( strip , duration ) super ( self ) . init ( strip ) self . cur_offset = 0 # add an animator to change `self.cur_offset` to each value of the palette self . add_anim ( animate . rotate ( def ( v ) self . cur_offset = v end , 0 , size ( self . palette ), int ( duration * 1000 ))) end def animate () var i = 0 while i < self . pixel_count # doing a loop rather than a `for` prevents from allocating a new object var col = self . palette [( self . cur_offset + i ) % size ( self . palette )] strip . set_pixel_color ( i , col , self . bri ) # simulate the method call without GETMET i += 1 end strip . show () end end How to use: var strip = Leds_matrix ( 5 , 5 , gpio . pin ( gpio . WS2812 , 1 )) var r = Rainbow_stripes ( strip , 1.0 ) r . start () Advanced features ~ Hardware RMT channels ~ This library uses NeoPixelBus library, and RMT hardware support in ESP32. The number of RMT channels, hence the number of simultaneous strips, depends on the CPU type. Tasmota native support for WS2812 uses RMT channel 0; it is not usable in such case. CPU type RMT channels ESP32 8 ESP32S2 4 ESP32C3 2 Currently RMT channel 0 is used by default if no GPIO WS2812-1 is configured, RMT channel 1 otherwise.","title":"Addressable LEDs in Berry"},{"location":"Berry_Addressable-LED/#addressable-leds-in-berry","text":"Requires #define USE_WS2812 . Support for addressable leds strips or matrix, including animation. Internally relies on NeoPixelBus library and currently supports WS2812 and SK6812.","title":"Addressable LEDs in Berry"},{"location":"Berry_Addressable-LED/#example","text":"Pulsating round on M5Stack Atom Matrix if GPIO 27 is configured as WS1812 - 2 var strip = Leds_matrix ( 5 , 5 , gpio . pin ( gpio . WS2812 , 1 )) var r = Round ( strip , 2 , 30 ) r . start () VIDEO","title":"Example"},{"location":"Berry_Addressable-LED/#how-to-use","text":"","title":"How to use"},{"location":"Berry_Addressable-LED/#compatibility-with-templates","text":"Leds strip must be either controlled by Tasmota's lights features or by Berry, but they can't be controlled by both at the same time. For Berry control, it is highly recommended to use WS2812 - 2 and higher (for multiple strips)","title":"Compatibility with Templates"},{"location":"Berry_Addressable-LED/#ledsand-leds_matrix-classes","text":"All leds features rely on the low-level Leds or Leds_matrix classes. Attributes Details Leds Leds(pixels:int, gpio:int [,model:int ,rmt:int]) -> instance<Leds> Creates a Leds instance for a linear leds strip pixels : number of leds gpio : gpio number model : (opt) LED model, default:Leds.WS2812_GRB <br> rmt : (opt) RMT`channel to use, or auto-select (see below) Leds.matrix Leds_matrix(width:int, height:int, gpio:int [,model:int ,rmt:int]) -> instance<Leds_matrix> Creates a Leds instance for a matrix of leds width : number of leds horizontally height : number of leds vertically gpio : gpio number model : (opt) LED model, default:Leds.WS2812_GRB <br> rmt : (opt) RMT`channel to use, or auto-select (see below) .create_segment <strip>.create_segment(offset:int, pixels:int) -> instance<Leds_segment> Creates a virtual segment from a physical Leds strip, from Led number offset with pixels leds. LED model Details Leds.WS2812_GRB WS2812b Leds (GRB) - takes 24 bits RGB colors Leds.SK6812_GRBW SK6812 Leds (GRBW) - takes 32 bits RGBW colors (with white channel) Methods are the equivalent low-level from NeoPixelBus. All colors are in 0xRRGGBB format (24 bits) or 0xWWRRGGBB format (32 bits). Attributes Details clear clear() -> nil Clear all led (set to black) show show() -> nil Pushes the internal buffer to leds. May be ignored if a show command is already in progress. Use can_show() to see if show() is possible can_show can_show() -> bool Indicates if show() is possible, i.e. no transfer is ongoing is_dirty is_dirty() -> bool Indicates if a led was changed since last show() dirty dirty() -> nil Forces a refresh during next show() pixel_size pixel_size() -> int Returns the number of bytes per pixel pixel_count pixel_count() -> int Returns the number of leds in the strip/matrix clear_to clear_to(col:color [, bri:int]) -> nil Clears all leds to the specified color. bri is optional and default to 100% set_pixel_color set_pixel_color(idx:int, col:color [, bri:int]) -> nil Set led number idx to the specified color. bri is optional and default to 100% set_matrix_pixel_color set_matrix_pixel_color(x:int, y:int, col:color [, bri:int]) -> nil (only Leds_matrix ) Set led number of coordinates x / y to the specified color. bri is optional and default to 100% get_pixel_color get_pixel_color(idx:int) -> color:int Returns the color (including brightness and gamma correction) of led number idx gamma gamma:bool Applies gamma correction if true (default) pixels_buffer pixels_buffer() -> bytes() Returns the internal buffer used by NeoPixelBus. The byte() object points to the original buffer, no new buffer is allocated; which means that raw data can be changed directly. Don't forget to call dirty() and show() afterwards","title":"Ledsand Leds_matrix classes"},{"location":"Berry_Addressable-LED/#animation-framework","text":"The class Leds_animator sets the necessary methods to facilitate animations. You just need create a sub-class or Leds_animator , provide a Leds or Leds_matrix instance and implement the animate method. You can also register animators (see below). The instance is automatically registered as driver. Call start() to start the animation, and stop() to stop it. Attributes Details Leds_animator Leds_animator(strip:instance) -> instance<Leds_animator> Constructors only needs an instance of Leds or Leds_matrix start start() -> nil Register the animator as Tasmota driver (with tasmota.add_driver ) and start the animation stop stop() -> nil Stop the animation and removes the driver from Tasmota drivers list clear clear() -> nil Call stop() and clear all leds (set to black) remove remove() -> nil Removes the instance from Tasmota's list of drivers, and stops the animation set_bri set_bri(bri:int) -> nil Sets the brightness of the animation (0..100) add_anim add_anim(anim:instance) -> nil Registers an animator to be called just before the call to animate (see below) get_bri get_bri() -> int Returns the brightness of the animation (0..100) animate animate() -> nil Place-holder for the actual animation. You need to override this method Example: import animate class Rainbow_stripes : Leds_animator var cur_offset # current offset in the palette static palette = [ 0xFF0000 , #- red -# 0xFFA500 , #- orange -# 0xFFFF00 , #- yellow -# 0x008800 , #- green -# 0x0000FF , #- blue -# 0x4B0082 , #- indigo -# 0xEE82EE , #- violet -# ] # duration in seconds def init ( strip , duration ) super ( self ) . init ( strip ) self . cur_offset = 0 # add an animator to change `self.cur_offset` to each value of the palette self . add_anim ( animate . rotate ( def ( v ) self . cur_offset = v end , 0 , size ( self . palette ), int ( duration * 1000 ))) end def animate () var i = 0 while i < self . pixel_count # doing a loop rather than a `for` prevents from allocating a new object var col = self . palette [( self . cur_offset + i ) % size ( self . palette )] strip . set_pixel_color ( i , col , self . bri ) # simulate the method call without GETMET i += 1 end strip . show () end end How to use: var strip = Leds_matrix ( 5 , 5 , gpio . pin ( gpio . WS2812 , 1 )) var r = Rainbow_stripes ( strip , 1.0 ) r . start ()","title":"Animation framework"},{"location":"Berry_Addressable-LED/#advanced-features","text":"","title":"Advanced features"},{"location":"Berry_Addressable-LED/#hardware-rmt-channels","text":"This library uses NeoPixelBus library, and RMT hardware support in ESP32. The number of RMT channels, hence the number of simultaneous strips, depends on the CPU type. Tasmota native support for WS2812 uses RMT channel 0; it is not usable in such case. CPU type RMT channels ESP32 8 ESP32S2 4 ESP32C3 2 Currently RMT channel 0 is used by default if no GPIO WS2812-1 is configured, RMT channel 1 otherwise.","title":"Hardware RMT channels"},{"location":"Blinds-and-Shutters/","text":"Shutters and Blinds ~ Control blinds and roller shades connected to regular ON/OFF motors,stepper motors or position servos Before starting you have to enable shutter support with SetOption80 1 Commands ~ Complete list of commands is available at Blinds, Shutters and Roller Shades Commands . Shutter Modes ~ There are five shutter modes which define how the relays operate. Additionally you can define PulseTime on any relay to change the relay into a pulse relay where the pulse changes start/stop. We recommend at least for Shutter mode 1 to define an Interlock setting. The examples below are for a ShutterRelay1 1 configuration (using Relay1 and Relay2). Shutter mode 1 - Normal Operation Relay1: UP/OFF, Relay2: DOWN/OFF Interlock 1,2 (Interlocked relay pair) Interlock ON Shutter mode 2 - Circuit Safe Relay1: ON/OFF, Relay2: UP/DOWN Interlock OFF Shutter mode 3 - Garage Motors Relay1: OFF/DOWN PULSE, Relay2: OFF/UP PULSE Shutter mode 4 - Stepper Motors Relay1: ON/OFF, Relay2: UP/DOWN PWM: Stepper signal, COUNTER: Stepper position signal PWM and COUNTER defined Shutter mode 5 - Servo Motors (PWM position based servo) Relay1: ON/OFF, Relay2: UP/DOWN (optional not used) PWM: Stepper signal PWMfrequency 200 ( This is mandatory for most relay to get correct PWM duty cylces) SetOption15 0 (required to store value and make it reboot save) Wiring diagrams for Normal, Stepper motor, and Short Circuit-Safe configurations are available at the end of this page. Even if the shutter does not have two motors, three wires have to be connected. Note After setting the options for shutter mode, the device must be rebooted. Otherwise, the sliders won't be available in the web UI, and the ShutterOpenDuration<x> and ShutterCloseDuration<x> commands will report \"Shutter unknown\". Issue ShutterRelay<x> 1 command and check in console which ShutterMode is displayed: Issue Status 13 command and check in console how the shutter is defined Shutter accuracy digits: 1 Shutter 0 (Relay:1): Init. Pos: 20000 [100 %], Open Vel.: 100 Close Vel.: 100 , Max Way: 20000, Opentime 10.0 [s], Closetime 10.0 [s], CoedffCalc: c0: 0, c1 200, c2: 200, c3: 0, c4: 0, binmask 3, is inverted 1, <span style=\"font-weight:bold;color:lime\">ShutterMode 0</span>, motordelay 0 Operation ~ Turning a device relay on or off directly (i.e., using Power ) will function to affect a shutter's movement. In momentary mode (i.e., stepper motor), the relays start or stop the motor. The driver takes care of the direction and proper update of the shutter position. The shutter reports its position and can also be sent to a dedicated position. ShutterPosition 0 means the shutter is closed and ShutterPosition 100 means the shutter is open. If you need the position values reversed ( 0 = open, 100 = closed), define and calibrate your shutter as documented below . Then tell Tasmota to reverse the shutter position meaning via the ShutterInvert<x> 1 command. All internal calculations are the same (the log output is the same). Only the interaction with the user and other systems changes. Now ShutterPosition<x> 0 will open the shutter and ShutterPosition<x> 100 will close the shutter. By default, only Shutter1 is enabled when SetOption80 1 is invoked. If possible to avoid any injury on unexpected movement all RELAYS should start in OFF mode when the device reboots: PowerOnState 0 A maximum of four shutters per device are supported. To enable additional shutters, ShutterRelay<x> <value> must be executed for each additional shutter. Additional shutter declarations must be sequentially numbered, and without gaps (i.e., second shutter is 2, next shutter 3 and finally shutter 4). Disabling a shutter in the middle of the defined set of shutters will disable all other higher numbered shutters. If the disabled shutter is restored, the higher numbered shutters previously declared will also be restored. When a shutter is added or removed, a list of the active shutters, with their parameters, is output to the log. If you intend to remove shutters, explicitly remove each one beginning with the highest numbered shutter. With four shutters, eight Relay<x> components are needed. If manual operation switches ( Switch<x> or Button<x> pairs) are also used, additional input GPIO are required. The ESP82xx device may not have enough free GPIO to support all the shutter connections required. A GPIO expander such as a PCF8574 or MCP230xx can be used with additional effort. When using a switch for manual operation Switch<x> pairs should usually be set to SwitchMode<x> 2 (inverse follow) for proper switch behavior. Any shutter positioning can be locked ShutterLock<x> 1 . Once executed an ongoing movement is finished while further positioning commands like ShutterOpen<x> , ShutterClose<x> , ShutterStop<x> , ShutterPosition<x> , ... as well as web UI buttons, web UI sliders, and shutter buttons are disabled. This can be used to lock an outdoor blind in case of high wind or rain. You may also disable shutter positioning games by your children. Shutter positioning can be unlocked using ShutterLock<x> 0 . Please be aware that the shutter can still be moved by direct relay control (i.e., Power<x> ), or physical switches and buttons. Use the ShutterButton<x> command prior to ShutterLock to be able to lock buttons. Calibration ~ Shutter calibration video tutorial Shutter calibration Google Spreadsheet Start your shutter in a closed position preferably. Set internal position to closed with ShutterSetClose<x> . Set the time needed to open the shutter completely with ShutterOpenDuration<x> . If the shutter opens more than needed, move it to the desired position with ShutterSetPosition<x> then set the position to fully open (100) with ShutterSetOpen<x> and decrease the open time. Set the time needed to close the shutters with ShutterCloseDuration<x> . If the shutter does not close completely, open again and adjust close time. If it runs too long, move it back to desired closed position with ShutterSetPosition<x> , reset to 0 with ShutterSetClose<x> and decrease open time. Alternate between opening and closing the shutter until you find out the exact times needed to get the same positions multiple times Now set the 50% open position of the shutter. Some shutters need some time from totally closed until they begin moving the bottom-most part and opening. This often results in a shutter that is less than 50% open when the shutter has been operating for 50% of the set time. This can be corrected by using ShutterSetHalfway<x> . Use this procedure to calibrate the half-open position: ShutterClose<x> (confirm that the shutter is completely closed) ShutterSetHalfway<x> 50 (reset to default) Move the shutter to actual 50% open position. Use ShutterPosition<x> to inquire the shutter's current position and record the value. This value is a percentage of the total opening (e.g., 63 = 63% of opening). ShutterClose<x> ShutterSetHalfway<x> 63 (using the value from step #4 above) Restart 1 After calibration is complete, you might want to enable an additional 1 second motor movement with ShutterEnableEndStopTime<x> 1 when the shutter is asked to move to its end positions (0% and 100%). With this you can guarantee that end positions are still reached in case of inaccuracies. Take care to disable this with ShutterEnableEndStopTime<x> 0 before further open or close duration measurements. Increasing Calibration Granularity ~ If you desire that the %-opening closely match what ShutterPosition<x> and web UI indicate, there is a granular calibration matrix available. Ensure that ShutterClose<x> and ShutterOpen<x> moves the shutter more or less to the limit positions and follow this procedure: ShutterSetHalfway<x> 50 (reset to default) ShutterCalibration<x> 30 50 70 90 100 Restart 1 ShutterClose<x> Move the shutter to each of the following opening percentages and measure the shutter's position for each. ShutterPosition<x> 30 (e.g., measurement = 15 ) ShutterPosition<x> 50 (e.g., measurement = 50 ) ShutterPosition<x> 70 (e.g., measurement = 100 ) ShutterPosition<x> 90 (e.g., measurement = 150 ) ShutterPosition<x> 100 (e.g., measurement = 180 ) Finally, enter the position measurements as the calibration values: ShutterCalibration<x> 15 50 100 150 180 ShutterCalibration<x> takes position measurements ( not the time it takes to move). During calibration you position the shutter to an indicated percentage (e.g., 30% ) of opening and measure the shutter position (e.g., 15 ). Use the same unit of measure for all your measurements (e.g., centimeters, inches, steps, etc.). After calibration ShutterPosition<x> 30 will move to 30% opening. This will be 30% from 180 (full open) == 54 . Now the percentage match the percent in cm/inch/steps. Notice that there is no calibration for the 10% position. On many shutters, there is no movement during the initial phase (i.e., nearly 10% of total time). Therefore the opening could be 0 . This measurement would cause an execution DIV 0 exception. Therefore the first calibration point is 30%. In most cases this is not a large opening so the calibration will be near enough. Yes, until ~10%, the position will be a bit \"off\" but not enough for concern. Motor Movement Delays ~ Some motors need up to one second after power is turned on before they start moving. You can confirm if you are having this issue if opening and closing as a single action works properly but doing this in smaller steps result in a shift of the position. Shutterposition<x> 30 Measure the shutter position. This is the reference_position Shutterposition<x> 80 Measure the shutter position. This is the max_position Shutterposition<x> 30 Return the shutter to starting position. This must be the same position as measured in step #1 ( reference_position ). If not, ShutterCloseDuration must be adjusted. Shutterposition<x> 50 Shutterposition<x> 70 Shutterposition<x> 80 If you do not reach max_position you have a motor delay problem. Measure the shutter position. This is the real_max . Use this value in the calculation below. ShutterMotorDelay<x> <delay> Motor <delay> calculation - fine tune in 0.05 second increments (e.g. 0.65 ) as required. <delay> = ((max_position-real_max) / 2) / (((100/80) * max_position) / ShutterOpenDuration) Close the shutter and repeat this procedure until the motor delay is set properly. Following defaults are pre-compiled into the code and can only be changed by compiling you own binary and use the user_config.override - The default waiting time after the motor is stopped and before e.g. moving into the other direction is 0.5 sec. This avoids unexpected massive loads when changing direction. The time in [ms] can be changed by adding following line with a different value: #define MOTOR_STOP_TIME 500 // wait 0.5 second after stop to do any other action. e.g. move in the opposite direction - In Failsafe-Mode the driver waits for 0.1sec to let the direction relay execute and be stable before switching on the power relay starting the movement. The time in [ms] can be changed by adding following line with a different value: #define SHUTTER_RELAY_OPERATION_TIME 100 // wait for direction relay 0.1sec before power up main relay Button Control ~ When shutter is running in ShutterMode 1 (normal two relay up/off down/off), you already have basic control over the shutter movement using switches or buttons in the module configuration to directly drive the shutter relays. For short circuit safe operation ShutterMode 2 direct control of the relays will not give you a nice user interface since you have to 1st set the direction with one switch/button and 2nd switch on the power by the other switch/button. To have shutter mode independent button control over the shutter and not over its relays one can use the ShutterButton<x> command. It also introduces some more features, see below: ShutterButton<x> <button> <func> <mqtt> This assigns a Tasmota button <button> to control your shutter <x> having functionality <func> . The Tasmota button <button> must already be configured in the module configuration. You can assign multiple buttons to a single shutter. Any button can only control one shutter (beside the <mqtt> broadcast feature, see description below). Any press of the button while the shutter is moving will immediately stop the shutter. One can remove all button control for shutter <x> by ShutterButton<x> 0 . The assigned button can have one of the following functionalities: Setup for an \"up\" button: ShutterButton<x> <button> up <mqtt> Single press will move shutter to 100%, double press to 50% and tripple press to 74%. Holding the button for more than the hold time ( SetOption32 ) moves all shutters with same <grouptopic> to 100% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for a \"down\" button: ShutterButton<x> <button> down <mqtt> Single press will move shutter to 0%, double press to 50% and triple press to 24%. Holding the button for more than the hold time (SetOption32) moves all shutters with same <grouptopic> to 0% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for an \"updown\" button: ShutterButton<x> <button> updown <mqtt> Single press will move shutter to 100%, double press down to 0% and triple press to 50%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. Setup for an \"toggle\" button: ShutterButton<x> <button> toggle <mqtt> Single press will toggle shutter, double press will move it to 50%. Be aware that the toggle select direction based on the current position. If the position is between 0..50% the shutter move to 100%. If the position is 51%..100% it moves to 0%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. More advanced control of the button press actions is given by the following ShutterButton<x> command syntax: ShutterButton<x> <button> <p1> <p2> <p3> <ph> <m1> <m2> <m3> <mh> <mi> <button> 1..4 : Button number, 0/- : disable buttons for this shutter <p1> 0..100 : single press position, t : toggle, - : disable <p2> 0..100 : double press position, t : toggle, - : disable <p3> 0..100 : tripple press position, t : toggle, - : disable <ph> 0..100 : hold press position, shutter stop after releasing the hold button, t : toggle, - : disable <m1> 1 : enable single press position MQTT broadcast, 0/- : disable <m2> 1 : enable double press position MQTT broadcast, 0/- : disable <m3> 1 : enable tripple press position MQTT broadcast, 0/- : disable <mh> 1 : enable hold press position MQTT broadcast, 0/- : disable <mi> 1 : enable MQTT broadcast to all shutter indices, 0/- : disable Parameters are optional. When missing, all subsequent parameters are set to disable . By a button single press the shutter is set to position <p1> . Double press will drive the shutter to position <p2> and triple press to position <p3> . Holding the button for more than the SetOption32 time sets the shutter position to <ph> max if button is hold until positon. If the hold button is released during the shutter moves the shutter will stop. Any button action <p1> to <ph> can be disabled by setting the parameter to - . Independent from configuration <p1> to <ph> any press of the button while the shutter is moving will immediately stop the shutter. Global steering of all your shutters at home is supported by additional MQTT broadcast. By any button action a corresponding MQTT command can be initiated to the <grouptopic> of the device. For single press this can be enabled by <m1> equal to 1 , disabling is indicated by - . Double to hold MQTT configurations are given by <m2> to <mh> , correspondingly. When <mi> is equal to - only cmnd/<grouptopic>/Shutterposition<x> <p1..h> is fired. When <mi> is equal to 1 , <x> = 1..4 is used to control any shutter number of a Tasmota device having same <grouptopic> . Example ShutterButton<x> <button> 100 50 74 100 0 0 0 1 1 is same as ShutterButton<x> <button> up 1 . ShutterButton<x> <button> 0 50 24 0 0 0 0 1 1 is same as ShutterButton<x> <button> down 1 . ShutterButton<x> <button> 100 0 50 - 0 0 0 0 0 is same as ShutterButton<x> <button> updown 0 . ShutterButton<x> <button> t 50 - - 0 0 0 0 0 is same as ShutterButton<x> <button> toggle 0 . Module WiFi setup, restart, upgrade and reset according to Buttons and Switches are supported \"child and fool proof\" only when no button restriction ( SetOption1 ) is given and when all configured shutter buttons of that shutter are pressed 5x, 6x, 7x times or hold long simultaneously. Remote Control ~ Use any other Tasmota device with buttons or switches to control remotely a shutter using rules. Similar behavior as direct button control can be achieved by applying ShutterStopClose, ShutterStopOpen, ShutterStopToggle, ShutterStopPosition commands. They stop shutter movement if it is in motion and otherwise execute close, open, toggle or position commands. Example Run this rule on another Tasmota device with a switch configured. rule1 on switch1#state=2 do publish cmnd/%shutter-topic%/ShutterStopToggle endon Specific Configuration ~ Note The PWM remains on even after the end position has been reached. The motor then permanently tries to hold the position and could thereby trigger noises or a slight \"twitching\". If this is not desired, you can switch off the PWM after reaching the end position with #define SHUTTER_CLEAR_PWM_ONSTOP . Pulse Motors ~ There are shutters that have two relays but only need a pulse to start or stop. Depending on the current situation a pulse will stop the shutter or send it into a specific direction. To use these kinds of shutters a PulseTime must be defined on each relay. The minimum setting that seems to make it work consistently is 2 . A setting of 1 does not work. If the shutter moves too fast and does not react to a stop command, increase the setting to 3 or 4 . Stepper Motors ~ Stepper motors can also be used to operate shutters and blinds. Additionally you can operate sliding doors with this configuration. Currently ESP32 12.0.2 does not support shutter with stepper motors. ESP8266 and ESP32 12.0.3+ supports up to 4 shutters. Servo Motors ~ Servos are small devices with typical 180\u00b0 or 360\" rotation movement. The position will be drived by the PWM duty cycle time. This will all automatically calculated Note If you miss low angles (i.e 2\u00b0) you should be able to get this by changing the minimum ShutterPWMRange . If this does not help you can customize PwmFrequency . Normally for PWM servos, there is no calibration required, but you have the option to do a calibration. Check the documentation for shuttercallibration. Maybe ShutterSetHalfway is already enough. Otherwise you can do a fine granular calibration. Note If you change the shutteropenduration/closeduration the servo will operate slower, but now the servo also achieves small angle changes. More info DC Motors ~ More info Smooth RAMP-UP and RAMP-DOWN Support ~ Servos and Steppers also have a velocity control. With ShutterMotorDelay<x> 1.5 you can define a 1.5second soft start/stop before the device reaches it final moving speed. Usefull for moving heavy items like doors. using normal Motors ~ Short Circuit safe wire configuration with a PCF as digital I/O. Avoid electrical shortage also on wrong configuration. ~ using Stepper Motors ~ Stepper motors can be used to operate shutters and blinds. The configuration is very similar to the Circuit Safe (Shuttermode 1) configuration. To operate a stepper motor requires driver module such as the A4988 and uses EN (enable), DIR (direction), STP (Stepper) for controls. If everything is defined correctly Shuttermode 4 will be reported at boot time. ESP32 only supports one shutter with steppermotors. ESP8266 up to 4. Tasmota supports a maximum of four shutters with one stepper motor per shutter simultaneously. In very rare conditions where two or more shutters simultaneously move the last mm it can happen than one shutter moves to far. Stepper drivers configuration tutorials: A4988 DRV8825 TMC2208 Modifying a 28BYJ-48 12V stepper motor from unipolar to bipolar tutorial Bill of Materials Example configuration ~ EN and DIR are on Relay1i and Relay2 respectively. Please be aware to use the inverse relay for the enable signal. The STP signal is assigned as a PWM<x> component where <x> matches the number of the shutter (e.g., PWM1 for Shutter1 ). The shutter feature adjusts the PWM frequency to operate the motor for proper shutter operation. The stepper motor frequency setting is a global setting all PWM components on the device. This means that all shutters on the device will operate at the same speed. Therefore no PWM devices other than shutters can be connected to the same Tasmota device. The frequency of the PWM can be changed from 1000Hz to any value up to 10,000Hz. The command ShutterFrequency globally changes this. Be aware that most 12V operated motors cannot work faster than 2,000Hz. 5,000Hz.10,000Hz is possible by increasing the supplied voltage to 24V and use ShutterMotorDelay to allow a slow speed up/speed down. The maximum voltage of the A4988 is 36V. The TMC2208 is much more silent than the others but also significant slower and does not like high frequencies. For example, the speed at 24V is half o A4988 Finally a GPIO must be assigned as Counter1 . This counter is used to keep track of the steps and send the stepper to the correct position. The Counter1 GPIO must be connected to the PWM1 GPIO. Otherwise the stepper and your shutter will run continually or freeze up randomly. Only bipolar stepper motors may be used (see above). You must properly configure the stepper motor driver (see above). ShutterOpenDuration and ShutterCloseDuration can be different. Shutter with Stepper motors always match positions exact. There is no need to vary ShutterOpenDuration and ShutterCloseDuration . Anyhow, if you decrease ShutterCloseDuration the Shutter will close with a higher speed on a virtual higher ShutterFrequency if possible. Same vice versa. You can define a soft start/stop by defining a ShutterMotorDelay . This causes the driver to ramp the speed up and down during the defined duration. The change of the ShutterMotorDelay does NOT change the distance the shutter makes. This is very convenient to trim the accelerate and decelerate rate without changing the distance. Wemos Pin GPIO Component Stepper Signal D1 5 Relay1i EN D2 4 Relay2 DIR D3 0 PWM1 STP D4 2 Counter1 STP a) Set ShutterMode 4 Backlog PulseTime1 0; PulseTime2 0 // for relay Relay1i and Relay2 Interlock OFF // this is a global variable for all Relays or at least the RELAYS NOT in the Interlock group PWM1 and COUNTER1 defined b) Enable Shutters SetOption80 1 // this is a global variable for all Shutters c) Configure Shutter 1 and test ShutterMode 1 is working ShutterRelay1 1 // for relay Relay1i and Relay2 d) Set the stepper motor speed (optional setting) ShutterFrequency 1500 // this is a global variable for all steppers (1000rpm by default) e) Set at least a small ramp-up/ramp down period 1.0 second (optional) ShutterMotorDelay1 1.0 // Stepper do not like infinite momentum. Ramp up/down speed allow much higher frequencies. f) Restart Tasmota Restart 1 g) Test the shutter ShutterOpen1 ShutterStop1 // to stop the STEPPER1 ShutterClose1 ShutterInvert1 // to change the direction of rotation of the STEPPER1 h) Perform the shutter calibration Configuration for additional shutters ~ You must first set up the first shutter and only then the next. Wemos Pin GPIO Component Stepper Signal D5 14 Relay3i EN D6 12 Relay4 DIR D7 13 PWM2 STP D8 15 Counter2 STP a) Set ShutterMode 4 Backlog PulseTime3 0; PulseTime4 0 // for relay Relay3i and Relay4 PWM2 and COUNTER2 defined c) Configure Shutter 2 and test ShutterMode 1 is working ShutterRelay2 3 // for relay Relay3i and Relay4 b) Restart Tasmota Restart 1 d) Test the shutter ShutterOpen2 ShutterStop2 // to stop the STEPPER2 ShutterClose2 ShutterInvert2 // to change the direction of rotation of the STEPPER2 e) Perform the shutter calibration Motor Wiring Diagrams ~ One Shutter ~ - Diagram v412: simple universal setup. For example, the control of horizontal curtain or vertical shutters, blinds adjuster or window opener, pet feeders, opening of a water tap for watering the lawn, rotating table for subject photography, opening the ventilation flap, PTZ camera, 3D Scanner Table, linear Actuator. - Diagram v414: parallel setup is to run two parallel steppers motors from the same controller. For example, to control a large and heavy hanging screen for an LCD projector, or two curtains at once on one large window. - Diagram v416: minimum setup size. For example, for small curtains located in a limited space. 2 Shutters ~ - Diagram v422: parallel setup is to run two shutters and independent control of two stepper motors from one controller. For example, to control two independent curtains. - Diagram v424: big parallel setup is to run two shutters and independent control of two pairs of stepper motors from one controller. For example, to control four curtains on one very large window. Bill of Materials ~ ESP8266 Boards: Wemos D1 mini NodeMCU ESP-01S Stepper motors (NEMA 17): Standard 5:1 Planetary Gearbox Stepper motors (28BYJ-48): Standard Stepper Drivers: A4988 DRV8825 TMC 2208 Stepper Motor Control Development Boards: x1 board x2 board DC-DC Step Down Power Supply Module: MP1584EN LM2596 XL4015 Power Supplies (AC-DC): DC 12V 2.5A DC 12V 4A DC 24v 4A Aluminum Capacitors: 35V 100UF 35V 10UF Motor Testing PWM Signal Generator: 1 type 2 type using Sonoff Dual R2 ~ If using a Sonoff Dual R2, use the following Template: {\"NAME\":\"Sonoff Dual R2\",\"GPIO\":[17,255,0,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":39} Checklist ~ Ensure that the first relay opens the shutter Ensure that the second relay closes the shutter Set ShutterRelay<x> Set ShutterOpenDuration<x> Set ShutterCloseDuration<x> Set ShutterSetHalfway<x> (optional) Set ShutterInvert<x> (optional) Set ShutterInvertWebButtons<x> (optional) (eg. useful for horizontal awnings) If the shutter uses a pulse motor instead of a motors with one wire for each direction (i.e., duration based), define PulseTime<x> 2 on both relays. The driver's behavior will change to a pulse motor that needs pulses to start and stop. Rules ~ Tasmota rule triggers: Shutter<x>#Position is triggered at start, during and at the end of movement reporting actual position ( %value% =0-100) Shutter<x>#Direction is triggered at start, during and at the end of movement reporting actual direction ( %value% : -1 =close direction, 0 =no movement, 1 =open direction) Shutter<x>#Target is triggered at start, during and at the end of movement reporting current target ( %value% 0-100) Shutter#Moving is triggered during movement and just before moving (shutter independently). If VAR<x> is set to 99 then this trigger will be executed BEFORE the shutter starts. You can start the shutter after rule execution by setting VAR<x> to 0 or wait 10seconds before the timeout kicks in. After the movement with shutter#moved the VAR must be set back to 99 and the initial rule must be enabled again. The initial rule has to be defined to run ONCE. EXAMPLE: power3 on and wait 2sec before start. After movement: power off rule1 on shutter#moving=1 do backlog power3 on;delay 20;var1 0 endon rule1 5 rule2 on shutter#moved do backlog power3 off;var1 99;rule1 5 endon rule2 1 Shutter#Moved is triggered at end of movement (shutter independently) Shutter<x>#Button<button>=0 is triggered when button is hold Shutter<x>#Button<button>=<n> is triggered when button is pressed n times Shutter<x>#Button0=0 is triggered when all buttons of that shutter are hold simultaneously Shutter<x>#Button0=<n> is triggered when all buttons of that shutter are pressed simultaneously n times Examples Publish a message with the position of the shutter: Rule1 ON Shutter1#Position DO Publish status/%topic%/level {\"%value%\"} ENDON Open/Close or set a specific position for a shutter. This example drives the second shutter to the same position as the first shutter: Rule1 ON Shutter1#Position DO ShutterPosition2 %value%\" ENDON Jarolift Shutter Support ~ Jarolift shutters operates by the 3 commands up/stop/down. Compile with the KeeLoq Option and provide the extracted master keys to communicate. Please see KeeLoq description how to do that. After this create a rule to allow the shutter to control the Jarolift devices. Shutter must be in ShutterMode 0. Rule1 On Power1#state=0 DO KeeloqSendButton 4 endon On Power2#state=0 DO KeeloqSendButton 4 endon on Power1#state=1 DO KeeloqSendButton 8 endon on Power2#State=1 DO KeeloqSendButton 2 endon Venetian Blind Support ~ All time based shutters (not stepper, pwm) can be enhanced with Venetian Blind functionality. The configuration need following parameters: angle of blinds during opening phase, angle of blinds during closing phase. This are the max and the min values of the venetian blinds (e.g. opening at 0\u00b0 - closing at 90\u00b0). Additionally the runtime is required from min to max. This is typically 1-2sec. The resolution of the time is 0.05sec. Duration in [sec] must be multiplied by 20. e.g. 1.2sec => 1.2 x 20 = 24. To open and close the tilt you must define the angle for CLOSE and the angle for OPEN of the tilt (be careful about the correct order, refer to the following example) Example: - Angle of the slats when the blind is opening: 0\u00b0 - Angle of the slats when the blind is closing: 90\u00b0 - Time needed to flip in 1/20 seconds (1 second = 20): 40 - Desired angle of the slats when set to CLOSE : 90\u00b0 - Desired angle of the slats when set to OPEN : 0\u00b0 ShutterTiltConfig1 0 90 40 90 0 Tilt configuration can be set for every shutter independently. The tilt can be set with one of the following commands: shuttertilt1 open set tilt to defined open angle shuttertilt1 close set tilt to defined close angle shuttertilt1 20 set tilt to 20\u00b0 angle If the shutter is moved from one position to another position the tilt will be restored AFTER the movement. If the shutter is fully opened or fully closed the tilt will be resetted. This means there is no tilt restore at the endpoints. Similar to shutterchange to make relative movements there is also a shuttertiltchange with the same behavior. If the shutter is operated with wall buttons or the web interface and stopped during a tilte change before the shutter starts moving the NEW tilt position is stored. Now any additional position movements will restore this new tilt position. This makes is possible with small ON/OFF to change the tilt and with long ON/OFF to change the position and retain the tilt after movement. Similar to shutterposition there is a minimum runtime of the motor required that TASMOTA can control. This is 0.2sec. Because the tiltmovement from one position into the other takes often about 1sec it is very common that you cannot make small tilt changes of 10\u00b0 or sometimes even 20\".","title":"Shutters and Blinds"},{"location":"Blinds-and-Shutters/#shutters-and-blinds","text":"Control blinds and roller shades connected to regular ON/OFF motors,stepper motors or position servos Before starting you have to enable shutter support with SetOption80 1","title":"Shutters and Blinds"},{"location":"Blinds-and-Shutters/#commands","text":"Complete list of commands is available at Blinds, Shutters and Roller Shades Commands .","title":"Commands"},{"location":"Blinds-and-Shutters/#shutter-modes","text":"There are five shutter modes which define how the relays operate. Additionally you can define PulseTime on any relay to change the relay into a pulse relay where the pulse changes start/stop. We recommend at least for Shutter mode 1 to define an Interlock setting. The examples below are for a ShutterRelay1 1 configuration (using Relay1 and Relay2). Shutter mode 1 - Normal Operation Relay1: UP/OFF, Relay2: DOWN/OFF Interlock 1,2 (Interlocked relay pair) Interlock ON Shutter mode 2 - Circuit Safe Relay1: ON/OFF, Relay2: UP/DOWN Interlock OFF Shutter mode 3 - Garage Motors Relay1: OFF/DOWN PULSE, Relay2: OFF/UP PULSE Shutter mode 4 - Stepper Motors Relay1: ON/OFF, Relay2: UP/DOWN PWM: Stepper signal, COUNTER: Stepper position signal PWM and COUNTER defined Shutter mode 5 - Servo Motors (PWM position based servo) Relay1: ON/OFF, Relay2: UP/DOWN (optional not used) PWM: Stepper signal PWMfrequency 200 ( This is mandatory for most relay to get correct PWM duty cylces) SetOption15 0 (required to store value and make it reboot save) Wiring diagrams for Normal, Stepper motor, and Short Circuit-Safe configurations are available at the end of this page. Even if the shutter does not have two motors, three wires have to be connected. Note After setting the options for shutter mode, the device must be rebooted. Otherwise, the sliders won't be available in the web UI, and the ShutterOpenDuration<x> and ShutterCloseDuration<x> commands will report \"Shutter unknown\". Issue ShutterRelay<x> 1 command and check in console which ShutterMode is displayed: Issue Status 13 command and check in console how the shutter is defined Shutter accuracy digits: 1 Shutter 0 (Relay:1): Init. Pos: 20000 [100 %], Open Vel.: 100 Close Vel.: 100 , Max Way: 20000, Opentime 10.0 [s], Closetime 10.0 [s], CoedffCalc: c0: 0, c1 200, c2: 200, c3: 0, c4: 0, binmask 3, is inverted 1, <span style=\"font-weight:bold;color:lime\">ShutterMode 0</span>, motordelay 0","title":"Shutter Modes"},{"location":"Blinds-and-Shutters/#operation","text":"Turning a device relay on or off directly (i.e., using Power ) will function to affect a shutter's movement. In momentary mode (i.e., stepper motor), the relays start or stop the motor. The driver takes care of the direction and proper update of the shutter position. The shutter reports its position and can also be sent to a dedicated position. ShutterPosition 0 means the shutter is closed and ShutterPosition 100 means the shutter is open. If you need the position values reversed ( 0 = open, 100 = closed), define and calibrate your shutter as documented below . Then tell Tasmota to reverse the shutter position meaning via the ShutterInvert<x> 1 command. All internal calculations are the same (the log output is the same). Only the interaction with the user and other systems changes. Now ShutterPosition<x> 0 will open the shutter and ShutterPosition<x> 100 will close the shutter. By default, only Shutter1 is enabled when SetOption80 1 is invoked. If possible to avoid any injury on unexpected movement all RELAYS should start in OFF mode when the device reboots: PowerOnState 0 A maximum of four shutters per device are supported. To enable additional shutters, ShutterRelay<x> <value> must be executed for each additional shutter. Additional shutter declarations must be sequentially numbered, and without gaps (i.e., second shutter is 2, next shutter 3 and finally shutter 4). Disabling a shutter in the middle of the defined set of shutters will disable all other higher numbered shutters. If the disabled shutter is restored, the higher numbered shutters previously declared will also be restored. When a shutter is added or removed, a list of the active shutters, with their parameters, is output to the log. If you intend to remove shutters, explicitly remove each one beginning with the highest numbered shutter. With four shutters, eight Relay<x> components are needed. If manual operation switches ( Switch<x> or Button<x> pairs) are also used, additional input GPIO are required. The ESP82xx device may not have enough free GPIO to support all the shutter connections required. A GPIO expander such as a PCF8574 or MCP230xx can be used with additional effort. When using a switch for manual operation Switch<x> pairs should usually be set to SwitchMode<x> 2 (inverse follow) for proper switch behavior. Any shutter positioning can be locked ShutterLock<x> 1 . Once executed an ongoing movement is finished while further positioning commands like ShutterOpen<x> , ShutterClose<x> , ShutterStop<x> , ShutterPosition<x> , ... as well as web UI buttons, web UI sliders, and shutter buttons are disabled. This can be used to lock an outdoor blind in case of high wind or rain. You may also disable shutter positioning games by your children. Shutter positioning can be unlocked using ShutterLock<x> 0 . Please be aware that the shutter can still be moved by direct relay control (i.e., Power<x> ), or physical switches and buttons. Use the ShutterButton<x> command prior to ShutterLock to be able to lock buttons.","title":"Operation"},{"location":"Blinds-and-Shutters/#calibration","text":"Shutter calibration video tutorial Shutter calibration Google Spreadsheet Start your shutter in a closed position preferably. Set internal position to closed with ShutterSetClose<x> . Set the time needed to open the shutter completely with ShutterOpenDuration<x> . If the shutter opens more than needed, move it to the desired position with ShutterSetPosition<x> then set the position to fully open (100) with ShutterSetOpen<x> and decrease the open time. Set the time needed to close the shutters with ShutterCloseDuration<x> . If the shutter does not close completely, open again and adjust close time. If it runs too long, move it back to desired closed position with ShutterSetPosition<x> , reset to 0 with ShutterSetClose<x> and decrease open time. Alternate between opening and closing the shutter until you find out the exact times needed to get the same positions multiple times Now set the 50% open position of the shutter. Some shutters need some time from totally closed until they begin moving the bottom-most part and opening. This often results in a shutter that is less than 50% open when the shutter has been operating for 50% of the set time. This can be corrected by using ShutterSetHalfway<x> . Use this procedure to calibrate the half-open position: ShutterClose<x> (confirm that the shutter is completely closed) ShutterSetHalfway<x> 50 (reset to default) Move the shutter to actual 50% open position. Use ShutterPosition<x> to inquire the shutter's current position and record the value. This value is a percentage of the total opening (e.g., 63 = 63% of opening). ShutterClose<x> ShutterSetHalfway<x> 63 (using the value from step #4 above) Restart 1 After calibration is complete, you might want to enable an additional 1 second motor movement with ShutterEnableEndStopTime<x> 1 when the shutter is asked to move to its end positions (0% and 100%). With this you can guarantee that end positions are still reached in case of inaccuracies. Take care to disable this with ShutterEnableEndStopTime<x> 0 before further open or close duration measurements.","title":"Calibration"},{"location":"Blinds-and-Shutters/#motor-movement-delays","text":"Some motors need up to one second after power is turned on before they start moving. You can confirm if you are having this issue if opening and closing as a single action works properly but doing this in smaller steps result in a shift of the position. Shutterposition<x> 30 Measure the shutter position. This is the reference_position Shutterposition<x> 80 Measure the shutter position. This is the max_position Shutterposition<x> 30 Return the shutter to starting position. This must be the same position as measured in step #1 ( reference_position ). If not, ShutterCloseDuration must be adjusted. Shutterposition<x> 50 Shutterposition<x> 70 Shutterposition<x> 80 If you do not reach max_position you have a motor delay problem. Measure the shutter position. This is the real_max . Use this value in the calculation below. ShutterMotorDelay<x> <delay> Motor <delay> calculation - fine tune in 0.05 second increments (e.g. 0.65 ) as required. <delay> = ((max_position-real_max) / 2) / (((100/80) * max_position) / ShutterOpenDuration) Close the shutter and repeat this procedure until the motor delay is set properly. Following defaults are pre-compiled into the code and can only be changed by compiling you own binary and use the user_config.override - The default waiting time after the motor is stopped and before e.g. moving into the other direction is 0.5 sec. This avoids unexpected massive loads when changing direction. The time in [ms] can be changed by adding following line with a different value: #define MOTOR_STOP_TIME 500 // wait 0.5 second after stop to do any other action. e.g. move in the opposite direction - In Failsafe-Mode the driver waits for 0.1sec to let the direction relay execute and be stable before switching on the power relay starting the movement. The time in [ms] can be changed by adding following line with a different value: #define SHUTTER_RELAY_OPERATION_TIME 100 // wait for direction relay 0.1sec before power up main relay","title":"Motor Movement Delays"},{"location":"Blinds-and-Shutters/#button-control","text":"When shutter is running in ShutterMode 1 (normal two relay up/off down/off), you already have basic control over the shutter movement using switches or buttons in the module configuration to directly drive the shutter relays. For short circuit safe operation ShutterMode 2 direct control of the relays will not give you a nice user interface since you have to 1st set the direction with one switch/button and 2nd switch on the power by the other switch/button. To have shutter mode independent button control over the shutter and not over its relays one can use the ShutterButton<x> command. It also introduces some more features, see below: ShutterButton<x> <button> <func> <mqtt> This assigns a Tasmota button <button> to control your shutter <x> having functionality <func> . The Tasmota button <button> must already be configured in the module configuration. You can assign multiple buttons to a single shutter. Any button can only control one shutter (beside the <mqtt> broadcast feature, see description below). Any press of the button while the shutter is moving will immediately stop the shutter. One can remove all button control for shutter <x> by ShutterButton<x> 0 . The assigned button can have one of the following functionalities: Setup for an \"up\" button: ShutterButton<x> <button> up <mqtt> Single press will move shutter to 100%, double press to 50% and tripple press to 74%. Holding the button for more than the hold time ( SetOption32 ) moves all shutters with same <grouptopic> to 100% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for a \"down\" button: ShutterButton<x> <button> down <mqtt> Single press will move shutter to 0%, double press to 50% and triple press to 24%. Holding the button for more than the hold time (SetOption32) moves all shutters with same <grouptopic> to 0% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for an \"updown\" button: ShutterButton<x> <button> updown <mqtt> Single press will move shutter to 100%, double press down to 0% and triple press to 50%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. Setup for an \"toggle\" button: ShutterButton<x> <button> toggle <mqtt> Single press will toggle shutter, double press will move it to 50%. Be aware that the toggle select direction based on the current position. If the position is between 0..50% the shutter move to 100%. If the position is 51%..100% it moves to 0%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. More advanced control of the button press actions is given by the following ShutterButton<x> command syntax: ShutterButton<x> <button> <p1> <p2> <p3> <ph> <m1> <m2> <m3> <mh> <mi> <button> 1..4 : Button number, 0/- : disable buttons for this shutter <p1> 0..100 : single press position, t : toggle, - : disable <p2> 0..100 : double press position, t : toggle, - : disable <p3> 0..100 : tripple press position, t : toggle, - : disable <ph> 0..100 : hold press position, shutter stop after releasing the hold button, t : toggle, - : disable <m1> 1 : enable single press position MQTT broadcast, 0/- : disable <m2> 1 : enable double press position MQTT broadcast, 0/- : disable <m3> 1 : enable tripple press position MQTT broadcast, 0/- : disable <mh> 1 : enable hold press position MQTT broadcast, 0/- : disable <mi> 1 : enable MQTT broadcast to all shutter indices, 0/- : disable Parameters are optional. When missing, all subsequent parameters are set to disable . By a button single press the shutter is set to position <p1> . Double press will drive the shutter to position <p2> and triple press to position <p3> . Holding the button for more than the SetOption32 time sets the shutter position to <ph> max if button is hold until positon. If the hold button is released during the shutter moves the shutter will stop. Any button action <p1> to <ph> can be disabled by setting the parameter to - . Independent from configuration <p1> to <ph> any press of the button while the shutter is moving will immediately stop the shutter. Global steering of all your shutters at home is supported by additional MQTT broadcast. By any button action a corresponding MQTT command can be initiated to the <grouptopic> of the device. For single press this can be enabled by <m1> equal to 1 , disabling is indicated by - . Double to hold MQTT configurations are given by <m2> to <mh> , correspondingly. When <mi> is equal to - only cmnd/<grouptopic>/Shutterposition<x> <p1..h> is fired. When <mi> is equal to 1 , <x> = 1..4 is used to control any shutter number of a Tasmota device having same <grouptopic> . Example ShutterButton<x> <button> 100 50 74 100 0 0 0 1 1 is same as ShutterButton<x> <button> up 1 . ShutterButton<x> <button> 0 50 24 0 0 0 0 1 1 is same as ShutterButton<x> <button> down 1 . ShutterButton<x> <button> 100 0 50 - 0 0 0 0 0 is same as ShutterButton<x> <button> updown 0 . ShutterButton<x> <button> t 50 - - 0 0 0 0 0 is same as ShutterButton<x> <button> toggle 0 . Module WiFi setup, restart, upgrade and reset according to Buttons and Switches are supported \"child and fool proof\" only when no button restriction ( SetOption1 ) is given and when all configured shutter buttons of that shutter are pressed 5x, 6x, 7x times or hold long simultaneously.","title":"Button Control"},{"location":"Blinds-and-Shutters/#remote-control","text":"Use any other Tasmota device with buttons or switches to control remotely a shutter using rules. Similar behavior as direct button control can be achieved by applying ShutterStopClose, ShutterStopOpen, ShutterStopToggle, ShutterStopPosition commands. They stop shutter movement if it is in motion and otherwise execute close, open, toggle or position commands. Example Run this rule on another Tasmota device with a switch configured. rule1 on switch1#state=2 do publish cmnd/%shutter-topic%/ShutterStopToggle endon","title":"Remote Control"},{"location":"Blinds-and-Shutters/#specific-configuration","text":"Note The PWM remains on even after the end position has been reached. The motor then permanently tries to hold the position and could thereby trigger noises or a slight \"twitching\". If this is not desired, you can switch off the PWM after reaching the end position with #define SHUTTER_CLEAR_PWM_ONSTOP .","title":"Specific Configuration"},{"location":"Blinds-and-Shutters/#pulse-motors","text":"There are shutters that have two relays but only need a pulse to start or stop. Depending on the current situation a pulse will stop the shutter or send it into a specific direction. To use these kinds of shutters a PulseTime must be defined on each relay. The minimum setting that seems to make it work consistently is 2 . A setting of 1 does not work. If the shutter moves too fast and does not react to a stop command, increase the setting to 3 or 4 .","title":"Pulse Motors"},{"location":"Blinds-and-Shutters/#stepper-motors","text":"Stepper motors can also be used to operate shutters and blinds. Additionally you can operate sliding doors with this configuration. Currently ESP32 12.0.2 does not support shutter with stepper motors. ESP8266 and ESP32 12.0.3+ supports up to 4 shutters.","title":"Stepper Motors"},{"location":"Blinds-and-Shutters/#servo-motors","text":"Servos are small devices with typical 180\u00b0 or 360\" rotation movement. The position will be drived by the PWM duty cycle time. This will all automatically calculated Note If you miss low angles (i.e 2\u00b0) you should be able to get this by changing the minimum ShutterPWMRange . If this does not help you can customize PwmFrequency . Normally for PWM servos, there is no calibration required, but you have the option to do a calibration. Check the documentation for shuttercallibration. Maybe ShutterSetHalfway is already enough. Otherwise you can do a fine granular calibration. Note If you change the shutteropenduration/closeduration the servo will operate slower, but now the servo also achieves small angle changes. More info","title":"Servo Motors"},{"location":"Blinds-and-Shutters/#dc-motors","text":"More info","title":"DC Motors"},{"location":"Blinds-and-Shutters/#smooth-ramp-up-and-ramp-down-support","text":"Servos and Steppers also have a velocity control. With ShutterMotorDelay<x> 1.5 you can define a 1.5second soft start/stop before the device reaches it final moving speed. Usefull for moving heavy items like doors.","title":"Smooth RAMP-UP and RAMP-DOWN Support"},{"location":"Blinds-and-Shutters/#using-normal-motors","text":"","title":"using normal Motors"},{"location":"Blinds-and-Shutters/#using-stepper-motors","text":"Stepper motors can be used to operate shutters and blinds. The configuration is very similar to the Circuit Safe (Shuttermode 1) configuration. To operate a stepper motor requires driver module such as the A4988 and uses EN (enable), DIR (direction), STP (Stepper) for controls. If everything is defined correctly Shuttermode 4 will be reported at boot time. ESP32 only supports one shutter with steppermotors. ESP8266 up to 4. Tasmota supports a maximum of four shutters with one stepper motor per shutter simultaneously. In very rare conditions where two or more shutters simultaneously move the last mm it can happen than one shutter moves to far. Stepper drivers configuration tutorials: A4988 DRV8825 TMC2208 Modifying a 28BYJ-48 12V stepper motor from unipolar to bipolar tutorial Bill of Materials","title":"using Stepper Motors"},{"location":"Blinds-and-Shutters/#using-sonoff-dual-r2","text":"If using a Sonoff Dual R2, use the following Template: {\"NAME\":\"Sonoff Dual R2\",\"GPIO\":[17,255,0,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":39}","title":"using Sonoff Dual R2"},{"location":"Blinds-and-Shutters/#jarolift-shutter-support","text":"Jarolift shutters operates by the 3 commands up/stop/down. Compile with the KeeLoq Option and provide the extracted master keys to communicate. Please see KeeLoq description how to do that. After this create a rule to allow the shutter to control the Jarolift devices. Shutter must be in ShutterMode 0. Rule1 On Power1#state=0 DO KeeloqSendButton 4 endon On Power2#state=0 DO KeeloqSendButton 4 endon on Power1#state=1 DO KeeloqSendButton 8 endon on Power2#State=1 DO KeeloqSendButton 2 endon","title":"Jarolift Shutter Support"},{"location":"Blinds-and-Shutters/#venetian-blind-support","text":"All time based shutters (not stepper, pwm) can be enhanced with Venetian Blind functionality. The configuration need following parameters: angle of blinds during opening phase, angle of blinds during closing phase. This are the max and the min values of the venetian blinds (e.g. opening at 0\u00b0 - closing at 90\u00b0). Additionally the runtime is required from min to max. This is typically 1-2sec. The resolution of the time is 0.05sec. Duration in [sec] must be multiplied by 20. e.g. 1.2sec => 1.2 x 20 = 24. To open and close the tilt you must define the angle for CLOSE and the angle for OPEN of the tilt (be careful about the correct order, refer to the following example) Example: - Angle of the slats when the blind is opening: 0\u00b0 - Angle of the slats when the blind is closing: 90\u00b0 - Time needed to flip in 1/20 seconds (1 second = 20): 40 - Desired angle of the slats when set to CLOSE : 90\u00b0 - Desired angle of the slats when set to OPEN : 0\u00b0 ShutterTiltConfig1 0 90 40 90 0 Tilt configuration can be set for every shutter independently. The tilt can be set with one of the following commands: shuttertilt1 open set tilt to defined open angle shuttertilt1 close set tilt to defined close angle shuttertilt1 20 set tilt to 20\u00b0 angle If the shutter is moved from one position to another position the tilt will be restored AFTER the movement. If the shutter is fully opened or fully closed the tilt will be resetted. This means there is no tilt restore at the endpoints. Similar to shutterchange to make relative movements there is also a shuttertiltchange with the same behavior. If the shutter is operated with wall buttons or the web interface and stopped during a tilte change before the shutter starts moving the NEW tilt position is stored. Now any additional position movements will restore this new tilt position. This makes is possible with small ON/OFF to change the tilt and with long ON/OFF to change the position and retain the tilt after movement. Similar to shutterposition there is a minimum runtime of the motor required that TASMOTA can control. This is 0.2sec. Because the tiltmovement from one position into the other takes often about 1sec it is very common that you cannot make small tilt changes of 10\u00b0 or sometimes even 20\".","title":"Venetian Blind Support"},{"location":"Bluetooth/","text":"For ESP32 Bluetooth go here Bluetooth Low Energy Sensors ~ Different vendors offer Bluetooth solutions, mostly as part of the Xiaomi brand, often under the Mijia label. The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use the so-called \"MiBeacons\" which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active Bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (f.e. for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (very quickly one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if supported by the sensor. Supported Devices ~ It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of Bluetooth sensors in Xiaomi universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 button press (single and long) temperature, humidity, battery temperature, humidity, battery passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive means data is received via BLE advertisements while active means data is received via a bidirectional connection to the sensor. LYWSD03MMC sends encrypted sensor data every 10 minutes. As there are no confirmed reports about correct battery presentation of the sensor (always shows 99%), this function is currently not supported. MJYD2S sends motion detection events and 2 discrete illuminance levels (1 lux or 100 lux for a dark or bright environment). Additionally battery level and contiguous time without motion in discrete growing steps (no motion time = NMT). Encryption and bind_key ~ Most of the older sensors use unencrypted messages, which can be read by all kinds of BLE devices or even a NRF24L01. With the arrival of newer sensors, such as LYWSD03MMC, MHO-C401 or MJYD2S, came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota (not yet with the HM-1x). Some sensor still allow an unencrypted connection the reading of the sensor data using normal subscription methods to GATT-services (currently used on the HM-1x). This is more power hungry than the passive reading of BLE advertisements. Some other sensors like the MJYD2S are not usable without the \"bind_key\". It is recommended to obtain the bind_key if usable by your BLE driver to reduce the battery drain. Obtain bind_key ~ To get the necessary decryption key (\"bind_key\") use: Xiaomi Cloud Tokens Extractor (Windows executable or Python) - works on any device in the Mi Home app pvvx Telink Flasher (Webpage) - LYWSD03MMC, MHO-C401 and CGG1 only ATC Telink Flasher (Webpage) - LYWSD03MMC only Telink Flashers allow the generation of a bind_key by faking a pairing with the Xiaomi cloud. Use bind_key ~ Use the bind_key and MAC address of the sensor to use with command NRFkey . Tasmota will receive the sensor data roughly every 10 minutes (in two chunks for humidity and temperature with about a minute in between) and decode the data. This is the most energy efficient way. The current way of storing these keys on the NRF24L01 is to use NRFkey ): rule1 on System # Boot do backlog NRFkey 00112233445566778899 AABBCCDDEEFF112233445566 ; NRFkey 00112233445566778899 AABBCCDDEEFF112233445566 ; NRFPage 6 ; NRFUse 0 ; NRFUse 4 endon (key for two sensors, 6 sensors per page in the WebUI, turn off all sensors, turn on LYWSD03MMC) Note This option is currently not available for the HM-10 because of memory considerations as part of the standard sensor-firmware package. Encryption is not supported on HM-1x (for legacy reasons). The only method is to connect to the sensor from time to time. This circumvents the data encryption but drains the battery fast. Thus it is only recommended as a last resort. Custom firmware ~ pvvx Telink Flasher also allows to flash custom firmware on supported sensors . This will work out of the box with Tasmota. This firmware does send data more frequently and is a bit more power hungry than the stock firmware. Working principle of Tasmota BLE drivers (>8.5.) ~ The idea is to provide drivers with as many automatic functions as possible. Besides the hardware setup, there are zero or very few things to configure. The sensor namings are based on the original sensor names and shortened if appropriate (Flower care -> Flora). A part of the MAC will be added to the name as a suffix. All sensors are treated as if they are physically connected to the ESP8266 device. For motion and remote control sensors, MQTT messages will be published in (nearly) real time. Take note that only the ESP32 and the HM-1x modules are real BLE devices whereas the NRF24L01(+) is only a generic 2.4 GHz transceiver with very limited capabilities that was finagled into reading BLE packets. using HM-1x ~ This feature is included only in tasmota-sensors.bin Otherwise you must [compile your build]Compile-your-build). Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support for HM-10 as a BLE-bridge (+9k3 code) #endif Features ~ Supported sensors will be connected to at a set interval (default interval equals TelePeriod). A subscription is established for 5 seconds and data (e.g. temperature, humidity and battery) is read and reported to an mqtt topic (Dew point is calculated): tele /% t opic%/SENSOR = { \"Time\" : \"2020-03-24T12:47:51\" , \"LYWSD03-52680f\" :{ \"Temperature\" : 21.1 , \"Humidity\" : 58.0 , \"DewPoint\" : 12.5 , \"Battery\" : 100 }, \"LYWSD02-a2fd09\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 57.0 , \"DewPoint\" : 12.5 , \"Battery\" : 2 }, \"MJ_HT_V1-d8799d\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 54.6 , \"DewPoint\" : 11.9 }, \"TempUnit\" : \"C\" } After a completed discovery scan, the driver will report the number of found sensors. As Tasmota can not know how many sensors are meant to be discovered you have to force a re-scan until the desired number of devices is found. Rule1 ON HM10 # Found < 6 DO Add1 1 ENDON ON Var1 # State <= 3 DO HM10Scan ENDON This will re-scan up to 3 times if less than 6 sensors are found. using nRF24L01(+) ~ Configuration ~ You must [compile your build]Compile-your-build). Change the following in my_user_config.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifdef USE_SPI #define USE_NRF24 // Add SPI support for NRF24L01(+) (+2k6 code) #ifdef USE_NRF24 #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) Sensors will be discriminated by using the Product ID of the MiBeacon. A human readable short product name will be shown instead of the company-assigned ID of the BLE Public Device Address (the \"lower\" 24 bits). A Tele message could like look this: 10:13:38 RSL: stat/tasmota/STATUS8 = {\"StatusSNS\":{\"Time\":\"2019-12-18T10:13:38\",\"Flora-6ab577\":{\"Temperature\":21.7,\"Illuminance\":21,\"Humidity\":0,\"Fertility\":0},\"MJ_HT_V1-3108be\":{\"Temperature\":22.3,\"Humidity\":56.1},\"TempUnit\":\"C\"}} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24L01. As we can not use a checksum to test data integrity of the packet, only data of sensors whose adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically. Commands ~ Full list of available Bluetooth commands . iBeacon ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-1x or nRF24L01(+) ~ Tasmota uses a BLE 4.x module to scan for iBeacon devices. This driver is working with HM-10 and clones and HM16/HM17 modules and potentially other from the HM-1x series, depending on firmware capabilities. Tip If using an external module, When first connected some modules will be in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . Features ~ For a list of all available commands see Sensor52 command. This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"ON\" }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"OFF\" }} Additional fields will be present depending upon the beacon, e.g. NAME, UID, MAJOR, MINOR. Supported Devices ~ All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. (untested on ESP32 native BLE)","title":"BLE Gateway"},{"location":"Bluetooth/#bluetooth-low-energy-sensors","text":"Different vendors offer Bluetooth solutions, mostly as part of the Xiaomi brand, often under the Mijia label. The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use the so-called \"MiBeacons\" which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active Bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (f.e. for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (very quickly one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if supported by the sensor.","title":"Bluetooth Low Energy Sensors"},{"location":"Bluetooth/#supported-devices","text":"It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of Bluetooth sensors in Xiaomi universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 button press (single and long) temperature, humidity, battery temperature, humidity, battery passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive means data is received via BLE advertisements while active means data is received via a bidirectional connection to the sensor. LYWSD03MMC sends encrypted sensor data every 10 minutes. As there are no confirmed reports about correct battery presentation of the sensor (always shows 99%), this function is currently not supported. MJYD2S sends motion detection events and 2 discrete illuminance levels (1 lux or 100 lux for a dark or bright environment). Additionally battery level and contiguous time without motion in discrete growing steps (no motion time = NMT).","title":"Supported Devices"},{"location":"Bluetooth/#encryption-and-bind_key","text":"Most of the older sensors use unencrypted messages, which can be read by all kinds of BLE devices or even a NRF24L01. With the arrival of newer sensors, such as LYWSD03MMC, MHO-C401 or MJYD2S, came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota (not yet with the HM-1x). Some sensor still allow an unencrypted connection the reading of the sensor data using normal subscription methods to GATT-services (currently used on the HM-1x). This is more power hungry than the passive reading of BLE advertisements. Some other sensors like the MJYD2S are not usable without the \"bind_key\". It is recommended to obtain the bind_key if usable by your BLE driver to reduce the battery drain.","title":"Encryption and bind_key"},{"location":"Bluetooth/#using-hm-1x","text":"This feature is included only in tasmota-sensors.bin Otherwise you must [compile your build]Compile-your-build). Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support for HM-10 as a BLE-bridge (+9k3 code) #endif","title":"using HM-1x"},{"location":"Bluetooth/#features","text":"Supported sensors will be connected to at a set interval (default interval equals TelePeriod). A subscription is established for 5 seconds and data (e.g. temperature, humidity and battery) is read and reported to an mqtt topic (Dew point is calculated): tele /% t opic%/SENSOR = { \"Time\" : \"2020-03-24T12:47:51\" , \"LYWSD03-52680f\" :{ \"Temperature\" : 21.1 , \"Humidity\" : 58.0 , \"DewPoint\" : 12.5 , \"Battery\" : 100 }, \"LYWSD02-a2fd09\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 57.0 , \"DewPoint\" : 12.5 , \"Battery\" : 2 }, \"MJ_HT_V1-d8799d\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 54.6 , \"DewPoint\" : 11.9 }, \"TempUnit\" : \"C\" } After a completed discovery scan, the driver will report the number of found sensors. As Tasmota can not know how many sensors are meant to be discovered you have to force a re-scan until the desired number of devices is found. Rule1 ON HM10 # Found < 6 DO Add1 1 ENDON ON Var1 # State <= 3 DO HM10Scan ENDON This will re-scan up to 3 times if less than 6 sensors are found.","title":"Features"},{"location":"Bluetooth/#using-nrf24l01","text":"","title":"using nRF24L01(+)"},{"location":"Bluetooth/#configuration","text":"You must [compile your build]Compile-your-build). Change the following in my_user_config.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifdef USE_SPI #define USE_NRF24 // Add SPI support for NRF24L01(+) (+2k6 code) #ifdef USE_NRF24 #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) Sensors will be discriminated by using the Product ID of the MiBeacon. A human readable short product name will be shown instead of the company-assigned ID of the BLE Public Device Address (the \"lower\" 24 bits). A Tele message could like look this: 10:13:38 RSL: stat/tasmota/STATUS8 = {\"StatusSNS\":{\"Time\":\"2019-12-18T10:13:38\",\"Flora-6ab577\":{\"Temperature\":21.7,\"Illuminance\":21,\"Humidity\":0,\"Fertility\":0},\"MJ_HT_V1-3108be\":{\"Temperature\":22.3,\"Humidity\":56.1},\"TempUnit\":\"C\"}} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24L01. As we can not use a checksum to test data integrity of the packet, only data of sensors whose adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically.","title":"Configuration"},{"location":"Bluetooth/#commands","text":"Full list of available Bluetooth commands .","title":"Commands"},{"location":"Bluetooth/#ibeacon","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif","title":"iBeacon"},{"location":"Bluetooth/#hm-1x-or-nrf24l01","text":"Tasmota uses a BLE 4.x module to scan for iBeacon devices. This driver is working with HM-10 and clones and HM16/HM17 modules and potentially other from the HM-1x series, depending on firmware capabilities. Tip If using an external module, When first connected some modules will be in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 .","title":"HM-1x or nRF24L01(+)"},{"location":"Bluetooth/#features_1","text":"For a list of all available commands see Sensor52 command. This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"ON\" }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"OFF\" }} Additional fields will be present depending upon the beacon, e.g. NAME, UID, MAJOR, MINOR.","title":"Features"},{"location":"Bluetooth/#supported-devices_1","text":"All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. (untested on ESP32 native BLE)","title":"Supported Devices"},{"location":"Bluetooth_ESP32/","text":"Bluetooth for ESP32 ~ MI32 Sensors ~ This feature is included only in tasmota32-bluetooth.bin When compiling your build add the following to user_config_override.h : #define USE_MI_ESP32 // (ESP32 only) Add support for ESP32 as a BLE-bridge (+9k2 mem, +292k flash) Different vendors offer Bluetooth solutions, mostly as part of the Xiaomi brand, often under the Mijia label. The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use the so-called \"MiBeacons\" which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active Bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (f.e. for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (very quickly one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if supported by the sensor. Supported Devices ~ It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of Bluetooth sensors in Xiaomi universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 MCCGQ02HL button press (single and long) temperature, humidity, battery temperature, humidity, battery door opening/closing, light present passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive, difficult to get key (must be close, press button) passive means data is received via BLE advertisements while active means data is received via a bidirectional connection to the sensor. LYWSD03MMC sends encrypted sensor data every 10 minutes. As there are no confirmed reports about correct battery presentation of the sensor (always shows 99%), this function is currently not supported. MJYD2S sends motion detection events and 2 discrete illuminance levels (1 lux or 100 lux for a dark or bright environment). Additionally battery level and contiguous time without motion in discrete growing steps (no motion time = NMT). Encryption and bind_key ~ Most of the older sensors use unencrypted messages, which can be read by all kinds of BLE devices or even a NRF24L01. With the arrival of newer sensors, such as LYWSD03MMC, MHO-C401 or MJYD2S, came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota. Some sensor still allow an unencrypted connection the reading of the sensor data using normal subscription methods to GATT-services. This is more power hungry than the passive reading of BLE advertisements. Some other sensors like the MJYD2S are not usable without the \"bind_key\". It is recommended to obtain the bind_key in any case to reduce the battery drain. Obtain bind_key ~ To get the necessary decryption key (\"bind_key\") use: Xiaomi Cloud Tokens Extractor (Windows executable or Python) - works on any device in the Mi Home app pvvx Telink Flasher (Webpage) - LYWSD03MMC, MHO-C401 and CGG1 only ATC Telink Flasher (Webpage) - LYWSD03MMC only Telink Flashers allow the generation of a bind_key by faking a pairing with the Xiaomi cloud. Use bind_key ~ Use the bind_key and MAC address of the sensor to use with commands Mi32Keys or Mi32Key . Tasmota will receive the sensor data roughly every 10 minutes (in two chunks for humidity and temperature with about a minute in between) and decode the data. This is the most energy efficient way. The current way of storing these keys on the ESP32 is to use Mi32Key command: MI32Keys <mac or blealias>=<bind_key> <mac or blealias>=<key> The Key is the 32 character (16 byte) key retrieved by above methods. Older way of using MI32Key is retained for backward compatibility. Mi32Key needs a 44 character combination of bind_key and MAC: MI32Keys <bind_keymac> To retain the data use a rule on startup: rule1 on System # Boot do backlog MI32key 00112233445566778899 AABBCCDDEEFF112233445566 ; MI32key 00112233445566778899 AABBCCDDEEFFAABBCCDDEEFF endon Commands ~ Full list of available Mi Sensors commands . Tip If you really want to read battery for LYWSD02, Flora and CGD1, consider doing it once a day with a rule: Backlog Rule1 on Time # Minute = 30 do MI32Battery endon ; Rule1 1 This will update every day at 00:30 AM. BLE ESP32 ~ This allows for the receiving of BLE advertisements from BLE devices, including \"iBeacons\" and BLE sensors, but also for the control of simple BLE devices, providing for reading, writing and receiving notifications. This feature is included only in tasmota32-bluetooth.bin When compiling your build add the following to user_config_override.h : #define USE_BLE_ESP32 // Add support for ESP32 as a BLE-bridge (+9k2? mem, +292k? flash) Be aware, enabling of the native BLE on ESP32 has an impact on Wi-Fi performance. Although later SDK helped a bit, expect more lag on the web interface and on MQTT. If only controlling BLE devices, then scanning can be disabled, which will minimize Wi-Fi impact. BLE can be enabled from the web UI menus. This is compiled by default in the Bluetooth firmware, but you need to enable it using the webUI Configure BLE button or SetOption115 1 command. Note that the only configuration stored is the SetOption115 to turn BLE on and off. All other configurations can be set at boot if necessary using Rules. iBeacon ~ Hear adverts from BLE devices, and produce MQTT messages containing RSSI and other information about them. Break out iBeacon specific data if present. This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_IBEACON_ESP32 // Add support for Bluetooth LE passive scan of iBeacon devices This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"ON\" }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"OFF\" }} Additional fields will be present depending upon the beacon, e.g. NAME, UID, MAJOR, MINOR. iBeacon MQTT Fields ~ Always present ~ json meaning Time time of MQTT send IBEACON.MAC mac addr IBEACON.RSSI signal strength IBEACON.STATE ON - present, OFF - last MQTT you will get for now (device removed) Optional ~ json meaning IBEACON.NAME name if in scan, or BLEAlias if set - only present if NAME present IBEACON.PERSEC count of adverts per sec. Useful for detecting button press IBEACON.MAJOR some iBeacon related term? - only present for some IBEACON.MINOR some iBeacon related term? - only present for some Examples ~ Setup a rule to set some aliases at boot time, and only allow those starting iB ~ Rule1 ON System#Boot DO backlog iBeacon 1; BLEAlias A4C1386A1E24=iBfred A4C1387FC1E1=iBjames; iBeaconOnlyAliased 2 endon Rule1 1 Supported Devices ~ All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. (untested on ESP32 native BLE) MI32 MQTT Messages ~ Because we can have many sensors reporting, tele messages are chunked to have a maximum of four sensors per message. If you enable MQTT discovery ( SetOption19 1 ), additional MQTT messages are send. Primarily, at teleperiod or MI32period, discovery messages are sent. These inform Home Assistant about the devices. Device names can be dependent upon BLEAlias, so set BLEAlias at boot. Additional actual data messages are sent on topics including the device name: tele/tasmota_ble/<name> Each message for one sensor. These messages can be used without Home Assistant if it is a preferred format. Note The topic would be the same from all Tasmotas if they have the same BLEAlias or no BLEAlias. So if you wish to 'hear' the same device separately from different Tasmotas, use different BLEAlias names. EQ3 TRV ~ A preliminary EQ3 driver is in production. Documentation . Commands ~ Full list of available BLE ESP32 commands . If you enable MQTT discovery ( SetOption19 1 ), additional MQTT messages are send. Primarily, at teleperiod or MI32period, discovery messages are sent. These inform Home Assistant about the devices. Device names can be dependent upon BLEAlias, so set BLEAlias at boot. Backlog Rule1 ON System # Boot DO BLEAlias A4C1386A1E24 = fred A4C1387FC1E1 = james endon ; Rule1 1 Enable static random mac addresses in addition to public mac addresses ~ If you have a device which does not appear, it may be advertising on a 'static random' address. Using this command may make it appear, but will also make other devices appear that you may not wish to see... For example phones advertising Covid messages. To know more, google 'BLE static random'. Be aware you can set 2 or 3.... Note The topic would be the same from all Tasmotas if they have the same BLEAlias or no BLEAlias. So if you wish to 'hear' the same device separately from different Tasmotas, use different BLEAlias names. Setup a rule to set some aliases at boot time ~ Backlog Rule1 ON System # Boot DO BLEAlias A4C1386A1E24 = fred A4C1387FC1E1 = james endon ; Rule1 1 Enable static random mac addresses in addition to public mac addresses ~ BLEAddrFilter 1 Check the interval between BLE tele messages ~ BLEPeriod Set it to 40s: BLEPeriod 40","title":"Bluetooth Low Energy"},{"location":"Bluetooth_ESP32/#bluetooth-for-esp32","text":"","title":"Bluetooth for ESP32 "},{"location":"Bluetooth_ESP32/#mi32-sensors","text":"This feature is included only in tasmota32-bluetooth.bin When compiling your build add the following to user_config_override.h : #define USE_MI_ESP32 // (ESP32 only) Add support for ESP32 as a BLE-bridge (+9k2 mem, +292k flash) Different vendors offer Bluetooth solutions, mostly as part of the Xiaomi brand, often under the Mijia label. The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use the so-called \"MiBeacons\" which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active Bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (f.e. for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (very quickly one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if supported by the sensor.","title":"MI32 Sensors"},{"location":"Bluetooth_ESP32/#supported-devices","text":"It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of Bluetooth sensors in Xiaomi universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 MCCGQ02HL button press (single and long) temperature, humidity, battery temperature, humidity, battery door opening/closing, light present passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive, difficult to get key (must be close, press button) passive means data is received via BLE advertisements while active means data is received via a bidirectional connection to the sensor. LYWSD03MMC sends encrypted sensor data every 10 minutes. As there are no confirmed reports about correct battery presentation of the sensor (always shows 99%), this function is currently not supported. MJYD2S sends motion detection events and 2 discrete illuminance levels (1 lux or 100 lux for a dark or bright environment). Additionally battery level and contiguous time without motion in discrete growing steps (no motion time = NMT).","title":"Supported Devices"},{"location":"Bluetooth_ESP32/#encryption-and-bind_key","text":"Most of the older sensors use unencrypted messages, which can be read by all kinds of BLE devices or even a NRF24L01. With the arrival of newer sensors, such as LYWSD03MMC, MHO-C401 or MJYD2S, came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota. Some sensor still allow an unencrypted connection the reading of the sensor data using normal subscription methods to GATT-services. This is more power hungry than the passive reading of BLE advertisements. Some other sensors like the MJYD2S are not usable without the \"bind_key\". It is recommended to obtain the bind_key in any case to reduce the battery drain.","title":"Encryption and bind_key"},{"location":"Bluetooth_ESP32/#commands","text":"Full list of available Mi Sensors commands . Tip If you really want to read battery for LYWSD02, Flora and CGD1, consider doing it once a day with a rule: Backlog Rule1 on Time # Minute = 30 do MI32Battery endon ; Rule1 1 This will update every day at 00:30 AM.","title":"Commands"},{"location":"Bluetooth_ESP32/#ble-esp32","text":"This allows for the receiving of BLE advertisements from BLE devices, including \"iBeacons\" and BLE sensors, but also for the control of simple BLE devices, providing for reading, writing and receiving notifications. This feature is included only in tasmota32-bluetooth.bin When compiling your build add the following to user_config_override.h : #define USE_BLE_ESP32 // Add support for ESP32 as a BLE-bridge (+9k2? mem, +292k? flash) Be aware, enabling of the native BLE on ESP32 has an impact on Wi-Fi performance. Although later SDK helped a bit, expect more lag on the web interface and on MQTT. If only controlling BLE devices, then scanning can be disabled, which will minimize Wi-Fi impact. BLE can be enabled from the web UI menus. This is compiled by default in the Bluetooth firmware, but you need to enable it using the webUI Configure BLE button or SetOption115 1 command. Note that the only configuration stored is the SetOption115 to turn BLE on and off. All other configurations can be set at boot if necessary using Rules.","title":"BLE ESP32"},{"location":"Bluetooth_ESP32/#ibeacon","text":"Hear adverts from BLE devices, and produce MQTT messages containing RSSI and other information about them. Break out iBeacon specific data if present. This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_IBEACON_ESP32 // Add support for Bluetooth LE passive scan of iBeacon devices This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"ON\" }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2021-01-02T12:08:40\" , \"IBEACON\" :{ \"MAC\" : \"A4C1387FC1E1\" , \"RSSI\" : -56 , \"STATE\" : \"OFF\" }} Additional fields will be present depending upon the beacon, e.g. NAME, UID, MAJOR, MINOR.","title":"iBeacon"},{"location":"Bluetooth_ESP32/#ibeacon-mqtt-fields","text":"","title":"iBeacon MQTT Fields"},{"location":"Bluetooth_ESP32/#examples","text":"","title":"Examples"},{"location":"Bluetooth_ESP32/#supported-devices_1","text":"All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. (untested on ESP32 native BLE)","title":"Supported Devices"},{"location":"Bluetooth_ESP32/#mi32-mqtt-messages","text":"Because we can have many sensors reporting, tele messages are chunked to have a maximum of four sensors per message. If you enable MQTT discovery ( SetOption19 1 ), additional MQTT messages are send. Primarily, at teleperiod or MI32period, discovery messages are sent. These inform Home Assistant about the devices. Device names can be dependent upon BLEAlias, so set BLEAlias at boot. Additional actual data messages are sent on topics including the device name: tele/tasmota_ble/<name> Each message for one sensor. These messages can be used without Home Assistant if it is a preferred format. Note The topic would be the same from all Tasmotas if they have the same BLEAlias or no BLEAlias. So if you wish to 'hear' the same device separately from different Tasmotas, use different BLEAlias names.","title":"MI32 MQTT Messages"},{"location":"Bluetooth_ESP32/#eq3-trv","text":"A preliminary EQ3 driver is in production. Documentation .","title":"EQ3 TRV"},{"location":"Bluetooth_ESP32/#commands_1","text":"Full list of available BLE ESP32 commands . If you enable MQTT discovery ( SetOption19 1 ), additional MQTT messages are send. Primarily, at teleperiod or MI32period, discovery messages are sent. These inform Home Assistant about the devices. Device names can be dependent upon BLEAlias, so set BLEAlias at boot. Backlog Rule1 ON System # Boot DO BLEAlias A4C1386A1E24 = fred A4C1387FC1E1 = james endon ; Rule1 1","title":"Commands"},{"location":"Bluetooth_old/","text":"The Bluetooth section of Tasmota currently consists of 2 driver classes, which, not least due to hardware restrictions, cannot be used together. On the one hand there is support for the use of \"iBeacons\" on some modules of the HM-1x family and on ESP32 internal Bluetooth. The second part consists of 3 drivers that can read the data from BLE sensors from the relatively diverse Xiaomi universe. These drivers offer very basic beacon functionality too. Presence detection with iBeacons or BLE sensor gateway using HM-1x or nRF24L01(+) peripherals iBeacon ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif Tasmota uses a BLE 4.x module to scan for iBeacon devices. This driver is working with HM-10 and clones and HM16/HM17 Bluetooth modules and potentially with other HM-1x modules depending on firmware capabilities. Using ESP32 built-in Bluetooth ~ You must compile your build for the ESP32 (since v9.1). Change the following to user_config_override.h : #ifdef ESP32 #define USE_IBEACON_ESP32 // Use internal ESP32 Bluetooth module #endif // ESP32 Features ~ For a list of all available commands see Sensor52 command. This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2020-03-24T20:09:40\" , \"IBEACON_FF34C21G2174\" :{ \"RSSI\" : -81 }} tele /ibeaco n /SENSOR = { \"Time\" : \"2020-03-24T20:09:42\" , \"IBEACON_DEAABC788BC1\" :{ \"RSSI\" : -60 }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2020-03-24T20:05:00\" , \"IBEACON_DEAABC788BC1\" :{ \"RSSI\" : -0 }} Tip When first connected some modules will be in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . Supported Devices ~ All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. Tasmota and BLE-sensors ~ Different vendors offer Bluetooth solutions as part of the XIAOMI family often under the MIJIA-brand (while AQUARA is the typical name for a ZigBee sensor). The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (= very quick one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if technically possible (= for the supported sensors). Most of the \u201eolder\u201c BLE-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. With the arrival of \"newer\" sensors came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota (not yet with the HM-1x). Meanwhile it is possible to get the needed \"bind_key\" with the help of an open-source project: https://atc1441.github.io/TelinkFlasher.html At least the LYWSD03 allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services (currently used on the HM-1x). This is more power hungry than the passive reading of BLE advertisements. Other sensors like the MJYD2S are not usable without the \"bind_key\". Supported Devices ~ It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 button press (single and long) temperature, humidity, battery temperature, humidity, battery passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive: data is received via BLE advertisments active: data is received via bidrectional connection to the sensor Devices with payload encryption ~ The LYWSD03MMC, MHO-C401 and the MJYD2S will start to send advertisements with encrypted sensor data after pairing it with the official Xiaomi app. Out-of-the-box the sensors do only publish a static advertisement. It is possible to do a pairing and get the necessary decryption key (\"bind_key\") here: https://atc1441.github.io/TelinkFlasher.html This project also provides a custom firmware for the LYWSD03MMC, which then becomes an ATC and is supported by Tasmota too. Default ATC-setting will drain the battery more than stock firmware, because of very frequent data sending. This key and the corresponding MAC of the sensor can be injected with the NRFKEY-command (or NRFMJYD2S). It is probably a good idea to save the whole config as RULE like that: rule1 on System # Boot do backlog NRFkey 00112233445566778899 AABBCCDDEEFF112233445566 ; NRFkey 00112233445566778899 AABBCCDDEEFF112233445566 ; NRFPage 6 ; NRFUse 0 ; NRFUse 4 endon (key for two sensors, 6 sensors per page in the WebUI, turn off all sensors, turn on LYWS03) LYWSD03MMC sends encrypted sensor data every 10 minutes. As there are no confirmed reports about correct battery presentation of the sensor (always shows 99%), this function is currently not supported. MJYD2S sends motion detection events and 2 discrete illuminance levels (1 lux or 100 lux for a dark or bright environment). Additionally battery level and contiguous time without motion in discrete growing steps (no motion time = NMT). Working principle of Tasmota BLE drivers (>8.5.) ~ The idea is to provide drivers with as many automatic functions as possible. Besides the hardware setup, there are zero or very few things to configure. The sensor namings are based on the original sensor names and shortened if appropriate (Flower care -> Flora). A part of the MAC will be added to the name as a suffix. All sensors are treated as if they are physically connected to the ESP8266 device. For motion and remote control sensors MQTT-messages will be published in (nearly) real time. The ESP32 and the HM-1x-modules are real BLE devices whereas the NRF24L01 (+) is only a generic 2.4 GHz transceiver with very limited capabilities. Options to read out the LYWSD03MMC ~ Generate a bind_key The web-tool https://atc1441.github.io/TelinkFlasher.html allows the generation of a so-called bind_key by faking a pairing with the Xiaomi cloud. You can copy-paste this key and add the MAC to use this resultig key-MAC-string with key-command (NRFkey or MI32key). Then the driver will receive the sensors data roughly every 10 minutes (in two chunks for humidity and temperature with about a minute in between) and decode the data. This is the most energy efficient way. The current way of storing these keys on the ESP32 is to use RULES like that (for the NRF24L01 you would use NRFkey): rule1 on System # Boot do backlog MI32key 00112233445566778899 AABBCCDDEEFF112233445566 ; MI32key 00112233445566778899 AABBCCDDEEFFAABBCCDDEEFF endon This option is currently not available for the HM-10 because of memory considerations as part of the standard sensor-firmware package. Flash custom ATC-firmware Use the same https://atc1441.github.io/TelinkFlasher.html to flash a custom ATC-firmware on the LYWSD03MMC. This will work out of the box with all three Tasmota-drivers. There is a slight chance of bricking the sensor, which would require some soldering and compiling skills to un-brick. This firmware does send data more frequently and is a little bit more power hungry than the stock firmware. Use active connections By default on the HM-10 (for legacy reasons) and at compile-time selectable on the ESP32 is the method to connect to the sensor from time to time. This circumvents the data encryption. This is very power hungry and drains the battery fast. Thus it is only recommended as fallback mechanism. BLE Sensors using HM-1x ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support for HM-10 as a BLE-bridge (+9k3 code) #endif Features ~ Supported sensors will be connected to at a set interval (default interval equals TelePeriod). A subscription is established for 5 seconds and data (e.g. temperature, humidity and battery) is read and reported to an mqtt topic (Dew point is calculated): tele /% t opic%/SENSOR = { \"Time\" : \"2020-03-24T12:47:51\" , \"LYWSD03-52680f\" :{ \"Temperature\" : 21.1 , \"Humidity\" : 58.0 , \"DewPoint\" : 12.5 , \"Battery\" : 100 }, \"LYWSD02-a2fd09\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 57.0 , \"DewPoint\" : 12.5 , \"Battery\" : 2 }, \"MJ_HT_V1-d8799d\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 54.6 , \"DewPoint\" : 11.9 }, \"TempUnit\" : \"C\" } After a completed discovery scan, the driver will report the number of found sensors. As Tasmota can not know how many sensors are meant to be discovered you have to force a re-scan until the desired number of devices is found. Rule1 ON HM10 # Found < 6 DO Add1 1 ENDON ON Var1 # State <= 3 DO HM10Scan ENDON This will re-scan up to 3 times if less than 6 sensors are found. Commands ~ Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is a passive scan and does not produce a scan response from the BLE sensor. It does not increase the sensors battery drain. HM10Page Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) HM10Beaconx Set a BLE device as a beacon using the (fixed) MAC-address x - set beacon 1 .. 4 x= 0 - will start a BLE scan and print result to the console <value> (12 or 17 characters) = use beacon given the MAC interpreted as a string AABBCCDDEEFF (also valid: aa:BB:cc:dd:EE:FF ) MAC of 00:00:00:00:00:00 will stop beacon x BLE Sensors using nRF24L01(+) ~ Configuration ~ You must compile your build . Change the following in my_user_config.h : // -- SPI sensors --------------------------------- #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifdef USE_SPI #define USE_NRF24 // Add SPI support for NRF24L01(+) (+2k6 code) #ifdef USE_NRF24 #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) Sensors will be discriminated by using the Product-ID of the MiBeacon. A human readable short product name will be shown instead of the company-assigned ID of the BLE Public Device Address (= the \"lower\" 24 bits). A TELE message could like look this: 10 : 13 : 38 RSL : s tat / tas mo ta /STATUS 8 = { \"StatusSNS\" :{ \"Time\" : \"2019-12-18T10:13:38\" , \"Flora-6ab577\" :{ \"Temperature\" : 21.7 , \"Illuminance\" : 21 , \"Humidity\" : 0 , \"Fertility\" : 0 }, \"MJ_HT_V1-3108be\" :{ \"Temperature\" : 22.3 , \"Humidity\" : 56.1 }, \"TempUnit\" : \"C\" }} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24l01. As we can not use a checksum to test data integrity of the packet, only data of sensors whose adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically. Commands ~ Command Parameters NRFPage Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) NRFIgnore 0 = all known sensor types active_(default)_ <value> = ignore certain sensor type ( 1 = Flora, 2 = MJ_HT_V1, 3 = LYWSD02, 4 = LYWSD03, 5 = CGG1, 6 = CGD1, 7 = NLIGHT, 8 = MJYD2S, 9 = YEERC (DEPRECATED, please switch to NRFUSE) NRFUse 0 = all known sensor types inactive <value> = ignore certain sensor type ( 1 = Flora, 2 = MJ_HT_V1, 3 = LYWSD02, 4 = LYWSD03, 5 = CGG1, 6 = CGD1, 7 = NLIGHT, 8 = MJYD2S, 9 = YEERC NRFScan Scan for regular BLE-advertisements and show a list in the console 0 = start a new scan list 1 = append to the scan list 2 = stop running scan NRFBeacon Set a BLE device as a beacon using the (fixed) MAC-address <value> (1-3 digits) = use beacon from scan list <value> (12 characters) = use beacon given the MAC interpreted as an uppercase string AABBCCDDEEFF NRFKey Set a \"bind_key\" for a MAC-address to decrypt (LYWSD03MMC & MHO-C401). The argument is a 44 uppercase characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string NRFMjyd2s Set a \"bind_key\" for a MAC-address to decrypt sensor data of the MJYD2S. The argument is a 44 characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string NRFNlight Set the MAC of an NLIGHT <value> (12 characters) = MAC interpreted as an uppercase string AABBCCDDEEFF Beacon ~ A simplified presence dection will scan for regular BLE advertisements of a given BT-device defined by its MAC-address. It is important to know, that many new devices (nearly every Apple-device) will change its MAC every few minutes to prevent tracking. If the driver receives a packet from the \"beacon\" a counter will be (re-)started with an increment every second. This timer is published in the TELE-message, presented in the webUI and processed as a RULE. The stability of regular readings will be strongly influenced by the local environment (many BLE-devices nearby or general noise in the 2.4-GHz-band). BLE Sensors on ESP32 using built-in Bluetooth ~ Since Tasmota v9.1.0.1 this driver is part of the standard build 'tasmota32'. It must be enabled at runtime via setoption115 1 . To turn on/off support for decyrption, change the following in the driver code: # define USE_MI_DECRYPTION Without encryption support the driver will read data from found LYWSD03MMC via connection. This will increase power consumption of the sensor, but no \"bind_key\" is needed. The driver will start to scan for known sensors automatically using a hybrid approach, when encryption support is deactivated. In the first place MiBeacons are passively received and only found LYWSD03MMC- and MHO-C401-sensors will be connected at the given period to read data in order to be as energy efficient as possible. Battery data is in general of questionable value for the LYWSD0x, CGD1, MHO-C401 and (maybe) Flora (some are even hard coded on the device to 99%). That's why only MJ_HT_V1, CGG1 (untested) and LYWSD03 (calculated battery level) will automatically update battery data. The other battery levels can be read by command. The internally very similiar LYWS03MMC and MHO-C401 behave very confusing in delivering battery status. Both report (fixed) 99% or 100% via encrypted payload or connected reading of the battery characteristic. But they can deliver a correct battery voltage in their payload of the temperature and humidity data, which will be mapped to a percentage level by the driver. Commands ~ Command Parameters MI32Period Show interval in seconds between sensor read cycles for the LYWSD03. Set to TelePeriod value at boot. MI32Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). MI32Unit <n> = toggle the displayed temperature units of a LYWSD02 only sensor. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). Reporting of the temperature is always in Celcius, this only changes the value shown on the device. MI32Page Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) MI32Battery Reads missing battery data for LYWSD02, Flora and CGD1. MI32Key Set a \"bind_key\" for a MAC-address to decrypt sensor data (LYWSD03MMC, MJYD2S). The argument is a 44 uppercase characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string MI32Beaconx Set a BLE device as a beacon using the (fixed) MAC-address x - set beacon 1 .. 4 x=0 - will start a BLE scan and send result via TELE-message <value> (12 or 17 characters) = use beacon given the MAC interpreted as a string AABBCCDDEEFF (also valid: aa:BB:cc:dd:EE:FF ) MAC of 00:00:00:00:00:00 will stop beacon x MI32Blockx Ignore Xiaomi sensors using the (fixed) MAC-address x=1 - show block list x=0 - delete block list x=1 + MAC-address - add MAC to to be blocked to the block list x=0 + MAC-address - remove MAC to to be blocked to the block list <value> (12 or 17 characters) = MAC interpreted as a string AABBCCDDEEFF (also valid: aa:BB:cc:dd:EE:FF ) MI32Option0 0 = sends only recently received sensor data 1 = aggregates all recent sensors data types MI32Option1 0 = shows full sensor data at Teleperiod 1 = shows no sensor data at Teleperiod MI32Option2 0 = sensor data only at Teleperiod ( default ) 1 = direct bridging of BLE data to MQTT messages Tip If you really want to read battery for LYWSD02, Flora and CGD1, consider doing it once a day with a RULE: RULE1 on Time#Minute=30 do MI32Battery endon This will update every day at 00:30 AM. Beacon ~ A count-up-timer starts for every beacon a with every received advertisement, starting with 0. TELE-output: \"Beacon1\":{\"MAC\":\"11:22:33:44:55:66\",\"CID\":\"0x0000\",\"SVC\":\"0x0000\",\"UUID\":\"0x0000\",\"Time\":4,\"RSSI\":0}} RULE-example: on Beacon2#time==30 do SOMETHING endon - is triggered 30 seconds after last packet was received on system#boot do MI32Beacon2 AABBCCDDEEFF endon - save configuration for beacon 2 (following AD type, read here: https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile/) CID - company identifier SVC - service data UUID - service or class UUID","title":"Bluetooth old"},{"location":"Bluetooth_old/#ibeacon","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif Tasmota uses a BLE 4.x module to scan for iBeacon devices. This driver is working with HM-10 and clones and HM16/HM17 Bluetooth modules and potentially with other HM-1x modules depending on firmware capabilities.","title":"iBeacon"},{"location":"Bluetooth_old/#using-esp32-built-in-bluetooth","text":"You must compile your build for the ESP32 (since v9.1). Change the following to user_config_override.h : #ifdef ESP32 #define USE_IBEACON_ESP32 // Use internal ESP32 Bluetooth module #endif // ESP32","title":"Using ESP32 built-in Bluetooth"},{"location":"Bluetooth_old/#features","text":"For a list of all available commands see Sensor52 command. This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele /ibeaco n /SENSOR = { \"Time\" : \"2020-03-24T20:09:40\" , \"IBEACON_FF34C21G2174\" :{ \"RSSI\" : -81 }} tele /ibeaco n /SENSOR = { \"Time\" : \"2020-03-24T20:09:42\" , \"IBEACON_DEAABC788BC1\" :{ \"RSSI\" : -60 }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele /ibeaco n /SENSOR = { \"Time\" : \"2020-03-24T20:05:00\" , \"IBEACON_DEAABC788BC1\" :{ \"RSSI\" : -0 }} Tip When first connected some modules will be in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 .","title":"Features"},{"location":"Bluetooth_old/#supported-devices","text":"All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume.","title":"Supported Devices"},{"location":"Bluetooth_old/#tasmota-and-ble-sensors","text":"Different vendors offer Bluetooth solutions as part of the XIAOMI family often under the MIJIA-brand (while AQUARA is the typical name for a ZigBee sensor). The sensors supported by Tasmota use BLE (Bluetooth Low Energy) to transmit the sensor data, but they differ in their accessibilities quite substantially. Basically all of them use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically while the device is not in an active bluetooth connection. The frequency of these messages is set by the vendor and ranges from one per 3 seconds to one per hour (for the battery status of the LYWSD03MMC). Motion sensors and BLE remote controls start to send when an event is triggered. These packets already contain the sensor data and can be passively received by other devices and will be published regardless if a user decides to read out the sensors via connections or not. Thus the battery life of a BLE sensor is not influenced by reading these advertisements and the big advantage is the power efficiency as no active bi-directional connection has to be established. The other advantage is, that scanning for BLE advertisements can happen nearly parallel (= very quick one after the other), while a direct connection must be established for at least a few seconds and will then block both involved devices for that time. This is therefore the preferred option, if technically possible (= for the supported sensors). Most of the \u201eolder\u201c BLE-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. With the arrival of \"newer\" sensors came the problem of encrypted data in MiBeacons, which can be decrypted in Tasmota (not yet with the HM-1x). Meanwhile it is possible to get the needed \"bind_key\" with the help of an open-source project: https://atc1441.github.io/TelinkFlasher.html At least the LYWSD03 allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services (currently used on the HM-1x). This is more power hungry than the passive reading of BLE advertisements. Other sensors like the MJYD2S are not usable without the \"bind_key\".","title":"Tasmota and BLE-sensors"},{"location":"Bluetooth_old/#supported-devices_1","text":"It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, set clock and unit, very frequent data sending passive for all entities, reliable battery value battery only active, thus not on the NRF24L01, no reliable battery value, no clock functions MiFlora LYWSD03MMC / ATC NLIGHT MJYD2S temperature, illuminance, soil humidity, soil fertility, battery, firmware version temperature, humidity, battery motion motion, illuminance, battery, no-motion-time passive only with newer firmware (>3.0?), battery only active, thus not on the NRF24L01 passive only with decryption or using custom ATC-firmware, no reliable battery value with stock firmware NRF24L01, ESP32 passive only with decryption, thus only NRF24L01, ESP32 YEE RC MHO-C401 MHO-C303 button press (single and long) temperature, humidity, battery temperature, humidity, battery passive equal to the LYWS03MMC, but no custom firmware yet passive for all entities, set clock and unit, no alarm functions, very frequent data sending passive: data is received via BLE advertisments active: data is received via bidrectional connection to the sensor","title":"Supported Devices"},{"location":"Bluetooth_old/#ble-sensors-using-hm-1x","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support for HM-10 as a BLE-bridge (+9k3 code) #endif","title":"BLE Sensors using HM-1x"},{"location":"Bluetooth_old/#features_1","text":"Supported sensors will be connected to at a set interval (default interval equals TelePeriod). A subscription is established for 5 seconds and data (e.g. temperature, humidity and battery) is read and reported to an mqtt topic (Dew point is calculated): tele /% t opic%/SENSOR = { \"Time\" : \"2020-03-24T12:47:51\" , \"LYWSD03-52680f\" :{ \"Temperature\" : 21.1 , \"Humidity\" : 58.0 , \"DewPoint\" : 12.5 , \"Battery\" : 100 }, \"LYWSD02-a2fd09\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 57.0 , \"DewPoint\" : 12.5 , \"Battery\" : 2 }, \"MJ_HT_V1-d8799d\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 54.6 , \"DewPoint\" : 11.9 }, \"TempUnit\" : \"C\" } After a completed discovery scan, the driver will report the number of found sensors. As Tasmota can not know how many sensors are meant to be discovered you have to force a re-scan until the desired number of devices is found. Rule1 ON HM10 # Found < 6 DO Add1 1 ENDON ON Var1 # State <= 3 DO HM10Scan ENDON This will re-scan up to 3 times if less than 6 sensors are found.","title":"Features"},{"location":"Bluetooth_old/#ble-sensors-using-nrf24l01","text":"","title":"BLE Sensors using nRF24L01(+)"},{"location":"Bluetooth_old/#configuration","text":"You must compile your build . Change the following in my_user_config.h : // -- SPI sensors --------------------------------- #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifdef USE_SPI #define USE_NRF24 // Add SPI support for NRF24L01(+) (+2k6 code) #ifdef USE_NRF24 #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) Sensors will be discriminated by using the Product-ID of the MiBeacon. A human readable short product name will be shown instead of the company-assigned ID of the BLE Public Device Address (= the \"lower\" 24 bits). A TELE message could like look this: 10 : 13 : 38 RSL : s tat / tas mo ta /STATUS 8 = { \"StatusSNS\" :{ \"Time\" : \"2019-12-18T10:13:38\" , \"Flora-6ab577\" :{ \"Temperature\" : 21.7 , \"Illuminance\" : 21 , \"Humidity\" : 0 , \"Fertility\" : 0 }, \"MJ_HT_V1-3108be\" :{ \"Temperature\" : 22.3 , \"Humidity\" : 56.1 }, \"TempUnit\" : \"C\" }} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24l01. As we can not use a checksum to test data integrity of the packet, only data of sensors whose adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically.","title":"Configuration"},{"location":"Bluetooth_old/#beacon","text":"A simplified presence dection will scan for regular BLE advertisements of a given BT-device defined by its MAC-address. It is important to know, that many new devices (nearly every Apple-device) will change its MAC every few minutes to prevent tracking. If the driver receives a packet from the \"beacon\" a counter will be (re-)started with an increment every second. This timer is published in the TELE-message, presented in the webUI and processed as a RULE. The stability of regular readings will be strongly influenced by the local environment (many BLE-devices nearby or general noise in the 2.4-GHz-band).","title":"Beacon"},{"location":"Bluetooth_old/#ble-sensors-on-esp32-using-built-in-bluetooth","text":"Since Tasmota v9.1.0.1 this driver is part of the standard build 'tasmota32'. It must be enabled at runtime via setoption115 1 . To turn on/off support for decyrption, change the following in the driver code: # define USE_MI_DECRYPTION Without encryption support the driver will read data from found LYWSD03MMC via connection. This will increase power consumption of the sensor, but no \"bind_key\" is needed. The driver will start to scan for known sensors automatically using a hybrid approach, when encryption support is deactivated. In the first place MiBeacons are passively received and only found LYWSD03MMC- and MHO-C401-sensors will be connected at the given period to read data in order to be as energy efficient as possible. Battery data is in general of questionable value for the LYWSD0x, CGD1, MHO-C401 and (maybe) Flora (some are even hard coded on the device to 99%). That's why only MJ_HT_V1, CGG1 (untested) and LYWSD03 (calculated battery level) will automatically update battery data. The other battery levels can be read by command. The internally very similiar LYWS03MMC and MHO-C401 behave very confusing in delivering battery status. Both report (fixed) 99% or 100% via encrypted payload or connected reading of the battery characteristic. But they can deliver a correct battery voltage in their payload of the temperature and humidity data, which will be mapped to a percentage level by the driver.","title":"BLE Sensors on ESP32 using built-in Bluetooth"},{"location":"Bluetooth_old/#beacon_1","text":"A count-up-timer starts for every beacon a with every received advertisement, starting with 0. TELE-output: \"Beacon1\":{\"MAC\":\"11:22:33:44:55:66\",\"CID\":\"0x0000\",\"SVC\":\"0x0000\",\"UUID\":\"0x0000\",\"Time\":4,\"RSSI\":0}} RULE-example: on Beacon2#time==30 do SOMETHING endon - is triggered 30 seconds after last packet was received on system#boot do MI32Beacon2 AABBCCDDEEFF endon - save configuration for beacon 2 (following AD type, read here: https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile/) CID - company identifier SVC - service data UUID - service or class UUID","title":"Beacon"},{"location":"Buttons-and-Switches/","text":"Buttons and switches: why the difference and how to configure them A typical device usually has at least one button (exception being bulbs and some lights) to control the power state(s). Additional buttons and switches can be wired to a free GPIO and configured in Module or Template settings. Note Other than relays/lights, Tasmota does not publish the state of components (switches, buttons, sensors, etc.) in real-time. State of components is transmitted automatically each TelePeriod via the SENSORS message. Button vs. Switch ~ A button (also called a push-button) is a momentary or non-latching switch which causes a temporary change in the state of an electrical circuit only while the switch is pressed. An automatic mechanism (i.e. a spring) returns the switch to its default position immediately afterwards, restoring the initial circuit condition. A switch (more precisely a latching or toggle switch), when activated by the user, remains in that state until activated again. Learn more about buttons and switches in this video . Both have a similar function, but Tasmota distinguishes between a \"Button\" and a \"Switch\" in other ways. Switch ~ In Tasmota a Switch is any switch or push-button additionally connected to a free GPIO. Some possibilities include: mechanical toggle switch - also called a rocker switch capacitive touch switch reed switch PIR sensor - even though it's technically a sensor it is configured as a switch in Tasmota mechanical push-button By default a switch toggles the corresponding power state (f.e. Switch1 controls Power1 ). Every time the switch gets flipped the power state of the relay toggles. If you want to detach switches from relays read here . Warning If you define a switch with a number higher than available power outputs it will default to controlling Power1 . Example: Switch4 on a device with Power1 and Power2 will control Power1 . And now, to make everything completely confusing: A push-button can be configured as a Switch and a toggle switch can be configured as a Button . Configuring a toggle switch as a Button is not recommended! SwitchMode ~ To change the behavior of a physical input peripheral configured as a Tasmota Switch<x> component, whether a toggle switch or a momentary switch (i.e., a push-button), use the SwitchMode command. If there is more than one Switch<x> component, use SwitchMode<x> where <x> is the number of your switch from the Tasmota GPIO configuration. SwitchMode, as the name implies, applies ONLY to GPIO configured in Tasmota as a Switch<x> component . SwitchMode has NO impact on the behavior of GPIO configured as Button<x> components . SwitchMode sets the desired behavior of a Switch<x> component based on whether it's a switch or a push-button (i.e., a momentary switch) that is physically connected to the GPIO. SwitchMode 0 Default mode Set switch to toggle mode ( 0 = TOGGLE , 1 = TOGGLE ). Tasmota sends TOGGLE command each time the state of the circuit changes (closing or opening). In case of a push button attached Tasmota will send a TOGGLE command when pressed and another TOGGLE command when released. Example When the button is pressed, toggle the power to ring the doorbell; when the button is released, ring the doorbell again. SwitchMode 1 Set switch to follow mode ( 0 = OFF , 1 = ON ) At the time when the circuit is closed, Tasmota will send ON and opening the circuit sends OFF . Tip You want to use SwitchMode 1 when connecting a toggle switch (e.g. a classic light switch) to your device. This way the \"software switch\" will mirror the state of the \"hardware switch\". If the real switch is in the \"ON\" position, the state in Tasmota is ON as well. SwitchMode 2 Set switch to inverted follow mode ( 0 = ON , 1 = OFF ) At the time when the circuit is closed, Tasmota will send OFF and opening the circuit sends ON . Tip When connecting a momentary switch (i.e., a push-button) you will want to use SwitchMode 3..7 . SwitchMode 3 Set push-button mode ( 0 = TOGGLE , 1 = ON ( default )) Tasmota will send a TOGGLE command when the button is pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. (This trigger is known as rising-edge ) SwitchMode 4 Set inverted push-button mode ( 0 = OFF ( default ), 1 = TOGGLE ) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. (This trigger is known as falling-edge ) SwitchMode 5 Set push-button with long press mode ( 0 = TOGGLE , 1 = ON ( default ), long press = HOLD ) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). SwitchMode 6 Set inverted push-button with long press mode ( 0 = OFF ( default ), 1 = TOGGLE , long press = HOLD ) Tasmota will send a TOGGLE command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). Long press or hold can be used in conjunction with rules to create additional features or to control another Tasmota device SwitchMode 7 Set toggle push-button mode. Same as SwitchMode 0 . SwitchMode 8 Set switch to multi change toggle mode ( 0 = TOGGLE , 1 = TOGGLE , 2x change = HOLD ). Same as SwitchMode 0 but when the state of the circuit changes within 0.5s twice no TOGGLE commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON and OFF power states are only changed when there is no second switch change within 0.5s. SwitchMode 9 Set switch to multi change follow mode ( 0 = OFF , 1 = ON , 2x change = HOLD ) Same as SwitchMode 1 but when the state of the circuit changes within 0.5s twice no OFF/ON commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 10 Set switch to multi change inverted follow mode ( 0 = ON , 1 = OFF , 2x change = HOLD ) Same as SwitchMode 2 but when the state of the circuit changes within 0.5s twice no ON/OFF commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 11 Set switch to pushbutton with dimmer mode incl. double press feature Note Setoption32 must be smaller than 64, when you use switchmode 11 and 12 !! Tasmota will send a TOGGLE command when the button is pressed for a short time and then is released (use Switch<x>#state=2 in rules). When pressing the button (closing the circuit) for a long time (set in SetOption32 ), Tasmota will send repeated INC_DEC (increment or decrement the dimmer) commands for as long as the button is pressed (use Switch<x>#state=4 in rules). Two different CLEAR commands are available. An immediate CLEAR command is send upon button release - no delay (use Switch<x>#state=7 in rules). Releasing the button also starts an internal timer (time is set in SetOption32 ). When released for the time set in SetOption32 , Tasmota will send a 'delayed' CLEAR command (use Switch<x>#state=6 in rules). If the button is pressed again before the timeout, Tasmota will send an INV command. The INV command is for the controlling software (Home Assistant) to switch between incrementing and decrementing the dimmer (use Switch<x>#state=5 in rules). If button is pressed twice (within time set in SetOption32 ), Tasmota will send a DOUBLE command. Note that this doesn't change behaviour of other switch states. So along with the DOUBLE command, TOGGLE command will also be fired twice upon a double press (use Switch<x>#state=8 in rules). If the button is pressed only once and shorter than the time set in SetOption32 , Tasmota will also send the POWER_DELAYED command (use Switch<x>#state=10 in rules) when no second press occurs within time set in SetOption32 . You can use this for triggering single press events instead of using TOGGLE if you want to use single and double press individually (since TOGGLE is triggered for both single and double press). Keep in mind, that this event is delayed in comparison to TOGGLE . Tip Possible use case: using rules to create additional features or to control another Tasmota device. SwitchMode 12 Set switch to inverted pushbutton with dimmer mode incl. double press feature. Same as Switchmode 11 but with inverted behaviour. Note Setoption32 must be smaller than 64, when you use switchmode 11 and 12 !! SwitchMode 13 Set switch to \"push to on\" mode ( 1 = ON , 0 = nothing ) Tasmota will send an ON command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Switch off using PulseTime . SwitchMode 14 Set switch to inverted \"push to on\" mode ( 0 = ON , 1 = nothing ) This mode is useful with PIR sensors SwitchMode 15 Send only MQTT message on switch change. This will stop the switch from controlling power outputs. tele/tasmota/SENSOR = {\"Time\":\"2021-01-01T00:00:00\",\"Switch1\":\"OFF\"} tele/tasmota/SENSOR = {\"Time\":\"2021-01-01T00:00:00\",\"Switch1\":\"ON\"} Also see SetOption114 below. Button ~ For Tasmota, a Button is typically a momentary push-button (or a capacitive touch button in some light switches). By default a button toggles the corresponding power state. Every time the button gets pressed a relay or light changes its Power state (ON or OFF). Besides toggling the Power state, a button is also used to activate multi press button functions , to do long press (HOLD) actions, or send messages to different MQTT topics. Depending if you are using a push-to-make button or push-to-break button, as well as connecting the button between GPIO and GND or GPIO and VCC, different configurations are possible. The diagram beside (click to enlarge) present the various options: To ignore default button behaviour of controlling power outputs you can: use SetOption73 1 use ButtonTopic define a rule which triggers on Button<x>#State . Take note: If the rule trigger only certain states, default behaviour is supressed only for those states. Make Button1 publish its value to stat/custom-topic/BUTTON and not control Power1 Backlog ButtonTopic 0 Rule1 on Button1 # state do Publish stat / custom - topic / BUTTON % value % endon Rule1 1 Multi-Press Functions ~ Multipress functions for 2 and more presses cannot be changed using SetOptions or rules. Danger If you have changed ButtonTopic , SetOption1 , SetOption11 or SetOption13 some of the listed functionality will be changed or removed. Note Button1 can directly control up to five relays. The number of the activated relay corresponds to the number of button presses and this feature is not present in the other buttons. When ButtonTopic is set to default 0 a button will always send its state for rules. 1 short press Toggles the power state. This will blink the LED once and send an MQTT status message like stat/tasmota/POWER = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"SINGLE\"} when SetOption73 is enabled. The button state for rules is 2 ( 10 if Setoption73 is enabled). 2 short presses When using Button1 toggles the second power state (if available on the device). This will blink the LED twice and send an MQTT status message like stat/tasmota/POWER2 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"DOUBLE\"} when SetOption73 is enabled. The button state for rules is 11 . 3 short presses When using Button1 toggles the third power state (if available on the device). This will blink the LED three times and send an MQTT status message like stat/tasmota/POWER3 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"TRIPLE\"} when SetOption73 is enabled. The button state for rules is 12 . 4 short presses When using Button1 toggles the fourth power state (if available on the device). This will blink the LED for times and send an MQTT status message like stat/tasmota/POWER4 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"QUAD\"} when SetOption73 is enabled. The button state for rules is 13 . 5 short presses When using Button1 toggles the fifth power state (if available on the device). This will blink the LED five times and send an MQTT status message like stat/tasmota/POWER5 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"PENTA\"} when SetOption73 is enabled. The button state for rules is 14 . 6 short presses Start WifiConfig 2 . Can be disabled using SetOption1 1 **Long press** There are two separate functions associated with a button long press based on how long it is held: When held continuously for 40 seconds (Configurable with SetOption32 , value is 10x the configured hold time) Tasmota will reset to firmware defaults and restart. If enabled, button pressed for 4 seconds (Configurable with SetOption32 ) creates a HOLD action and send an MQTT status message like stat/tasmota/BUTTON<x> = {\"ACTION\":\"HOLD\"} when SetOption73 is enabled. The button state for rules is 3 . If ButtonRetain has been enabled the MQTT message will also contain the MQTT retain flag. Danger When a button is configured as inverted or with a Switchmode that keeps it as ON while depressed it activates the reset to firmware defaults function. Change the Button configuration or SwitchMode to avoid repeated reset to defaults or use Setoption1 1 to disable that function. Warning If you define a button with a number higher than available power outputs it will default to controlling Power1 . Example: Button4 on a device with Power1 and Power2 will control Power1 . ButtonTopic ~ ButtonTopic 0 Default option By default a button controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new button state. The message you see in console is the new power state that is controlled and not the button state. ButtonTopic 1 Sets MQTT button topic to device %topic%. When changing the state of the button an MQTT message is sent to the device topic with the payload according to SwitchMode set. Example Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = ON Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT command to this device, the device power state will be set to the defined state. ButtonTopic <value> Set button topic to a custom topic (32 characters max). This will send an MQTT message to a custom defined topic similarly to option 1. Example For example, we set the topic to tasmota02 with ButtonTopic tasmota02 . With SwitchMode 1 the device yields the following message: MQT: cmnd/tasmota02/POWER = TOGGLE If you have another device with the topic tasmota02 this action will toggle its power state while not affecting anything on the tasmota device. ButtonTopic Summary ~ ButtonTopic 0 controls the power state directly. ButtonTopic 1 sends an MQTT message to the device topic. This sets the state of the devices power state accordingly. ButtonTopic <value> sends an MQTT message command to the custom topic. This does not change the state of the devices power state. When a Button is set to a different topic than 0 is not possible to use Button#State as a trigger for rules. Changing Default Functionality ~ If a ButtonTopic (and if SetOption1 1 ) or SwitchTopic 1 is defined (and SwitchMode is set to 5 or 6 ) and a button is pressed longer than defined Key Hold Time ( SetOption32 default 4 seconds) an MQTT message like cmnd/%topic%/POWER HOLD will be sent. HOLD can be changed with StateText4 . Command SetOption11 allows for swapping the functionality between the SINGLE and DOUBLE press of the push button. These changes result in the following: Example ~ You can control a ceiling fan from a Sonoff Touch: If your standard topic of Sonoff Touch is light and the ceiling fan topic is ceilingfan issue these commands on the Sonoff Touch to activate the double press feature. ButtonTopic ceilingfan SetOption11 1 All of the above is easier accomplished using Rules ! AC Frequency Detection Switch ~ Some devices, such as BlitzWolf BW-SS5 or Moes MS-104B , use mains frequency detection on their switch inputs. Whenever the connected switch or button is pressed there are 50/60 Hz pulses on the switch input. Inside the switch there's a frequency detection circuit which is connected to a GPIO of the ESP8266 chip which counts those pulses. Prior to Tasmota 8.4 this kind of switching was handled using Counter sensors and scripting which is now simplified. You can imagine this algorithm as a leaking bucket. Every pulse adds water to the bucket (little more than leaking out in a cycle), but the water is dripping countinously. If the bucket is full, we will treat the switch on. If there's no pulses, the bucket will be empty, and the we will turn off the switch. The size of the bucket is the debouncing time which controls the sensitivity of the algorithm. If the mains frequency is 50 Hz, a whole AC wave is 20 msec long (for 60 Hz it's about 17 msec; 1000 / frequeny if we want the result in milliseconds). The exact frequency is not really important, because we add more water for every pulse. After you have assigned a Switch<x> to the GPIO connected to the AC frequency detection circuit use the 'SwitchDebounce' command to set the number of pulses required for the switch to be recognized as on or off. For example: SwitchDebounce 69 will turn the switch on after three pulses and turn it off after three missing ones (3 * 20 msec is 60 and the last digit must be 9 to activate the AC detection). You will probably have to experiment with the values depending on your AC frequency and the devices frequency detection implementation. Once the feature is enabled you can use this switch as any regular switch! Detach Switches with... ~ SetOption114 ~ When SetOption114 1 all switches are detached from their respective relays and will send MQTT messages instead in the form of {\"Switch<x>\":{\"Action\":\"<state>\"}} . Example When switch one is toggle to \"ON\": {\"Switch1\":{\"Action\":\"ON\"}} SwitchMode 15 ~ With command SwitchMode<x> 15 you can decouple Switch<x> from its power output and it will instead send MQTT messages in the following format: MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2021-01-01T00:00:00\" , \"Switch1\" : \"OFF\" } MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2021-01-01T00:00:01\" , \"Switch1\" : \"ON\" } You can globally change the status text with StateText command. You can change the default \"Switch1\" text using SwitchText<x> command. For exemple: SwitchText1 Garage_Door_State When Setoption114 1 is used together with SwitchMode<x> 15 , Tasmota Integration in Home Assistant will create a binary sensor in HA using the Default text \"String1\" or the text mentionned in the SwitchText command. Rules ~ Use rules to send messages to different MQTT topics or send commands to other Tasmota devices when switch state (defined by SwitchMode ) changes. To ignore the default behaviour define a rule which triggers on Switch<x> for all state changes or on Switch<x>#State for specific state changes. If a rule matches only certain states, default switch behaviour is suppressed only for those states. Example Make Switch1 publish any value change to stat/custom-topic/SWITCH1 and not control Power1 Backlog SwitchMode 1 ; SwitchTopic 0 Backlog Rule1 on Switch1 # state do Publish stat / custom - topic / SWITCH1 % value % endon ; Rule1 1 SwitchTopic ~ Warning When using SwitchTopic 1 or 2 (or ButtonTopic 1 or 2 ) and your MQTT broker becomes unavailable, Tasmota falls back to default SwitchTopic 0 (or ButtonTopic 0 ), which is not optimal. To avoid this, we recommend using first two options instead. If you still need to use SwitchTopic read on! SwitchTopic 0 Default mode By default a switch controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new switch state. The message you see in console is the new power state that is controlled and not the switch state. SwitchTopic 1 Sets MQTT switch topic to device %topic% When changing the state of the switch an MQTT message is sent to the device topic with the payload according to SwitchMode set. Example Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = TOGGLE Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT commands to this device, the device power state will be set to the defined state. SwitchTopic <value> Set switch topic to a custom topic (32 characters max) This will send an MQTT message to a custom defined topic similarly to option 1. In the following example, we set the topic to tasmota02 with SwitchTopic tasmota02 . Example Device topic tasmota with SwitchMode 1 and custom topic tasmota02 yields the following message: MQT: cmnd/tasmota02/POWER = ON If you have another device with the topic tasmota02 this action will turn on its power while not affecting anything on the tasmota device. SwitchTopic Summary ~ SwitchTopic 0 controls the power state directly. SwitchTopic 1 sends an MQTT message to the device topic. This sets the state of the devices power accordingly. SwitchTopic <value> sends an MQTT message command to the custom topic. This does not change the state of the devices power. For a practical application of everything mentioned in this article read about this excellent LEGO nightstand switch project .","title":"Buttons and Switches"},{"location":"Buttons-and-Switches/#button-vs-switch","text":"A button (also called a push-button) is a momentary or non-latching switch which causes a temporary change in the state of an electrical circuit only while the switch is pressed. An automatic mechanism (i.e. a spring) returns the switch to its default position immediately afterwards, restoring the initial circuit condition. A switch (more precisely a latching or toggle switch), when activated by the user, remains in that state until activated again. Learn more about buttons and switches in this video . Both have a similar function, but Tasmota distinguishes between a \"Button\" and a \"Switch\" in other ways.","title":"Button vs. Switch"},{"location":"Buttons-and-Switches/#switch","text":"In Tasmota a Switch is any switch or push-button additionally connected to a free GPIO. Some possibilities include: mechanical toggle switch - also called a rocker switch capacitive touch switch reed switch PIR sensor - even though it's technically a sensor it is configured as a switch in Tasmota mechanical push-button By default a switch toggles the corresponding power state (f.e. Switch1 controls Power1 ). Every time the switch gets flipped the power state of the relay toggles. If you want to detach switches from relays read here . Warning If you define a switch with a number higher than available power outputs it will default to controlling Power1 . Example: Switch4 on a device with Power1 and Power2 will control Power1 . And now, to make everything completely confusing: A push-button can be configured as a Switch and a toggle switch can be configured as a Button . Configuring a toggle switch as a Button is not recommended!","title":"Switch"},{"location":"Buttons-and-Switches/#switchmode","text":"To change the behavior of a physical input peripheral configured as a Tasmota Switch<x> component, whether a toggle switch or a momentary switch (i.e., a push-button), use the SwitchMode command. If there is more than one Switch<x> component, use SwitchMode<x> where <x> is the number of your switch from the Tasmota GPIO configuration. SwitchMode, as the name implies, applies ONLY to GPIO configured in Tasmota as a Switch<x> component . SwitchMode has NO impact on the behavior of GPIO configured as Button<x> components . SwitchMode sets the desired behavior of a Switch<x> component based on whether it's a switch or a push-button (i.e., a momentary switch) that is physically connected to the GPIO. SwitchMode 0 Default mode Set switch to toggle mode ( 0 = TOGGLE , 1 = TOGGLE ). Tasmota sends TOGGLE command each time the state of the circuit changes (closing or opening). In case of a push button attached Tasmota will send a TOGGLE command when pressed and another TOGGLE command when released. Example When the button is pressed, toggle the power to ring the doorbell; when the button is released, ring the doorbell again. SwitchMode 1 Set switch to follow mode ( 0 = OFF , 1 = ON ) At the time when the circuit is closed, Tasmota will send ON and opening the circuit sends OFF . Tip You want to use SwitchMode 1 when connecting a toggle switch (e.g. a classic light switch) to your device. This way the \"software switch\" will mirror the state of the \"hardware switch\". If the real switch is in the \"ON\" position, the state in Tasmota is ON as well. SwitchMode 2 Set switch to inverted follow mode ( 0 = ON , 1 = OFF ) At the time when the circuit is closed, Tasmota will send OFF and opening the circuit sends ON . Tip When connecting a momentary switch (i.e., a push-button) you will want to use SwitchMode 3..7 . SwitchMode 3 Set push-button mode ( 0 = TOGGLE , 1 = ON ( default )) Tasmota will send a TOGGLE command when the button is pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. (This trigger is known as rising-edge ) SwitchMode 4 Set inverted push-button mode ( 0 = OFF ( default ), 1 = TOGGLE ) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. (This trigger is known as falling-edge ) SwitchMode 5 Set push-button with long press mode ( 0 = TOGGLE , 1 = ON ( default ), long press = HOLD ) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). SwitchMode 6 Set inverted push-button with long press mode ( 0 = OFF ( default ), 1 = TOGGLE , long press = HOLD ) Tasmota will send a TOGGLE command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). Long press or hold can be used in conjunction with rules to create additional features or to control another Tasmota device SwitchMode 7 Set toggle push-button mode. Same as SwitchMode 0 . SwitchMode 8 Set switch to multi change toggle mode ( 0 = TOGGLE , 1 = TOGGLE , 2x change = HOLD ). Same as SwitchMode 0 but when the state of the circuit changes within 0.5s twice no TOGGLE commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON and OFF power states are only changed when there is no second switch change within 0.5s. SwitchMode 9 Set switch to multi change follow mode ( 0 = OFF , 1 = ON , 2x change = HOLD ) Same as SwitchMode 1 but when the state of the circuit changes within 0.5s twice no OFF/ON commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 10 Set switch to multi change inverted follow mode ( 0 = ON , 1 = OFF , 2x change = HOLD ) Same as SwitchMode 2 but when the state of the circuit changes within 0.5s twice no ON/OFF commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 11 Set switch to pushbutton with dimmer mode incl. double press feature Note Setoption32 must be smaller than 64, when you use switchmode 11 and 12 !! Tasmota will send a TOGGLE command when the button is pressed for a short time and then is released (use Switch<x>#state=2 in rules). When pressing the button (closing the circuit) for a long time (set in SetOption32 ), Tasmota will send repeated INC_DEC (increment or decrement the dimmer) commands for as long as the button is pressed (use Switch<x>#state=4 in rules). Two different CLEAR commands are available. An immediate CLEAR command is send upon button release - no delay (use Switch<x>#state=7 in rules). Releasing the button also starts an internal timer (time is set in SetOption32 ). When released for the time set in SetOption32 , Tasmota will send a 'delayed' CLEAR command (use Switch<x>#state=6 in rules). If the button is pressed again before the timeout, Tasmota will send an INV command. The INV command is for the controlling software (Home Assistant) to switch between incrementing and decrementing the dimmer (use Switch<x>#state=5 in rules). If button is pressed twice (within time set in SetOption32 ), Tasmota will send a DOUBLE command. Note that this doesn't change behaviour of other switch states. So along with the DOUBLE command, TOGGLE command will also be fired twice upon a double press (use Switch<x>#state=8 in rules). If the button is pressed only once and shorter than the time set in SetOption32 , Tasmota will also send the POWER_DELAYED command (use Switch<x>#state=10 in rules) when no second press occurs within time set in SetOption32 . You can use this for triggering single press events instead of using TOGGLE if you want to use single and double press individually (since TOGGLE is triggered for both single and double press). Keep in mind, that this event is delayed in comparison to TOGGLE . Tip Possible use case: using rules to create additional features or to control another Tasmota device. SwitchMode 12 Set switch to inverted pushbutton with dimmer mode incl. double press feature. Same as Switchmode 11 but with inverted behaviour. Note Setoption32 must be smaller than 64, when you use switchmode 11 and 12 !! SwitchMode 13 Set switch to \"push to on\" mode ( 1 = ON , 0 = nothing ) Tasmota will send an ON command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Switch off using PulseTime . SwitchMode 14 Set switch to inverted \"push to on\" mode ( 0 = ON , 1 = nothing ) This mode is useful with PIR sensors SwitchMode 15 Send only MQTT message on switch change. This will stop the switch from controlling power outputs. tele/tasmota/SENSOR = {\"Time\":\"2021-01-01T00:00:00\",\"Switch1\":\"OFF\"} tele/tasmota/SENSOR = {\"Time\":\"2021-01-01T00:00:00\",\"Switch1\":\"ON\"} Also see SetOption114 below.","title":"SwitchMode"},{"location":"Buttons-and-Switches/#button","text":"For Tasmota, a Button is typically a momentary push-button (or a capacitive touch button in some light switches). By default a button toggles the corresponding power state. Every time the button gets pressed a relay or light changes its Power state (ON or OFF). Besides toggling the Power state, a button is also used to activate multi press button functions , to do long press (HOLD) actions, or send messages to different MQTT topics. Depending if you are using a push-to-make button or push-to-break button, as well as connecting the button between GPIO and GND or GPIO and VCC, different configurations are possible. The diagram beside (click to enlarge) present the various options: To ignore default button behaviour of controlling power outputs you can: use SetOption73 1 use ButtonTopic define a rule which triggers on Button<x>#State . Take note: If the rule trigger only certain states, default behaviour is supressed only for those states. Make Button1 publish its value to stat/custom-topic/BUTTON and not control Power1 Backlog ButtonTopic 0 Rule1 on Button1 # state do Publish stat / custom - topic / BUTTON % value % endon Rule1 1","title":"Button"},{"location":"Buttons-and-Switches/#multi-press-functions","text":"Multipress functions for 2 and more presses cannot be changed using SetOptions or rules. Danger If you have changed ButtonTopic , SetOption1 , SetOption11 or SetOption13 some of the listed functionality will be changed or removed. Note Button1 can directly control up to five relays. The number of the activated relay corresponds to the number of button presses and this feature is not present in the other buttons. When ButtonTopic is set to default 0 a button will always send its state for rules. 1 short press Toggles the power state. This will blink the LED once and send an MQTT status message like stat/tasmota/POWER = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"SINGLE\"} when SetOption73 is enabled. The button state for rules is 2 ( 10 if Setoption73 is enabled). 2 short presses When using Button1 toggles the second power state (if available on the device). This will blink the LED twice and send an MQTT status message like stat/tasmota/POWER2 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"DOUBLE\"} when SetOption73 is enabled. The button state for rules is 11 . 3 short presses When using Button1 toggles the third power state (if available on the device). This will blink the LED three times and send an MQTT status message like stat/tasmota/POWER3 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"TRIPLE\"} when SetOption73 is enabled. The button state for rules is 12 . 4 short presses When using Button1 toggles the fourth power state (if available on the device). This will blink the LED for times and send an MQTT status message like stat/tasmota/POWER4 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"QUAD\"} when SetOption73 is enabled. The button state for rules is 13 . 5 short presses When using Button1 toggles the fifth power state (if available on the device). This will blink the LED five times and send an MQTT status message like stat/tasmota/POWER5 = ON or another one like stat/tasmota/BUTTON<x> = {\"ACTION\":\"PENTA\"} when SetOption73 is enabled. The button state for rules is 14 . 6 short presses Start WifiConfig 2 . Can be disabled using SetOption1 1 **Long press** There are two separate functions associated with a button long press based on how long it is held: When held continuously for 40 seconds (Configurable with SetOption32 , value is 10x the configured hold time) Tasmota will reset to firmware defaults and restart. If enabled, button pressed for 4 seconds (Configurable with SetOption32 ) creates a HOLD action and send an MQTT status message like stat/tasmota/BUTTON<x> = {\"ACTION\":\"HOLD\"} when SetOption73 is enabled. The button state for rules is 3 . If ButtonRetain has been enabled the MQTT message will also contain the MQTT retain flag. Danger When a button is configured as inverted or with a Switchmode that keeps it as ON while depressed it activates the reset to firmware defaults function. Change the Button configuration or SwitchMode to avoid repeated reset to defaults or use Setoption1 1 to disable that function. Warning If you define a button with a number higher than available power outputs it will default to controlling Power1 . Example: Button4 on a device with Power1 and Power2 will control Power1 .","title":"Multi-Press Functions"},{"location":"Buttons-and-Switches/#buttontopic","text":"ButtonTopic 0 Default option By default a button controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new button state. The message you see in console is the new power state that is controlled and not the button state. ButtonTopic 1 Sets MQTT button topic to device %topic%. When changing the state of the button an MQTT message is sent to the device topic with the payload according to SwitchMode set. Example Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = ON Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT command to this device, the device power state will be set to the defined state. ButtonTopic <value> Set button topic to a custom topic (32 characters max). This will send an MQTT message to a custom defined topic similarly to option 1. Example For example, we set the topic to tasmota02 with ButtonTopic tasmota02 . With SwitchMode 1 the device yields the following message: MQT: cmnd/tasmota02/POWER = TOGGLE If you have another device with the topic tasmota02 this action will toggle its power state while not affecting anything on the tasmota device.","title":"ButtonTopic"},{"location":"Buttons-and-Switches/#changing-default-functionality","text":"If a ButtonTopic (and if SetOption1 1 ) or SwitchTopic 1 is defined (and SwitchMode is set to 5 or 6 ) and a button is pressed longer than defined Key Hold Time ( SetOption32 default 4 seconds) an MQTT message like cmnd/%topic%/POWER HOLD will be sent. HOLD can be changed with StateText4 . Command SetOption11 allows for swapping the functionality between the SINGLE and DOUBLE press of the push button. These changes result in the following:","title":"Changing Default Functionality"},{"location":"Buttons-and-Switches/#ac-frequency-detection-switch","text":"Some devices, such as BlitzWolf BW-SS5 or Moes MS-104B , use mains frequency detection on their switch inputs. Whenever the connected switch or button is pressed there are 50/60 Hz pulses on the switch input. Inside the switch there's a frequency detection circuit which is connected to a GPIO of the ESP8266 chip which counts those pulses. Prior to Tasmota 8.4 this kind of switching was handled using Counter sensors and scripting which is now simplified. You can imagine this algorithm as a leaking bucket. Every pulse adds water to the bucket (little more than leaking out in a cycle), but the water is dripping countinously. If the bucket is full, we will treat the switch on. If there's no pulses, the bucket will be empty, and the we will turn off the switch. The size of the bucket is the debouncing time which controls the sensitivity of the algorithm. If the mains frequency is 50 Hz, a whole AC wave is 20 msec long (for 60 Hz it's about 17 msec; 1000 / frequeny if we want the result in milliseconds). The exact frequency is not really important, because we add more water for every pulse. After you have assigned a Switch<x> to the GPIO connected to the AC frequency detection circuit use the 'SwitchDebounce' command to set the number of pulses required for the switch to be recognized as on or off. For example: SwitchDebounce 69 will turn the switch on after three pulses and turn it off after three missing ones (3 * 20 msec is 60 and the last digit must be 9 to activate the AC detection). You will probably have to experiment with the values depending on your AC frequency and the devices frequency detection implementation. Once the feature is enabled you can use this switch as any regular switch!","title":"AC Frequency Detection Switch"},{"location":"Buttons-and-Switches/#detach-switches-with","text":"","title":"Detach Switches with..."},{"location":"Buttons-and-Switches/#setoption114","text":"When SetOption114 1 all switches are detached from their respective relays and will send MQTT messages instead in the form of {\"Switch<x>\":{\"Action\":\"<state>\"}} . Example When switch one is toggle to \"ON\": {\"Switch1\":{\"Action\":\"ON\"}}","title":"SetOption114"},{"location":"Buttons-and-Switches/#switchmode-15","text":"With command SwitchMode<x> 15 you can decouple Switch<x> from its power output and it will instead send MQTT messages in the following format: MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2021-01-01T00:00:00\" , \"Switch1\" : \"OFF\" } MQT : tele / tas mo ta /SENSOR = { \"Time\" : \"2021-01-01T00:00:01\" , \"Switch1\" : \"ON\" } You can globally change the status text with StateText command. You can change the default \"Switch1\" text using SwitchText<x> command. For exemple: SwitchText1 Garage_Door_State When Setoption114 1 is used together with SwitchMode<x> 15 , Tasmota Integration in Home Assistant will create a binary sensor in HA using the Default text \"String1\" or the text mentionned in the SwitchText command.","title":"SwitchMode 15"},{"location":"Buttons-and-Switches/#rules","text":"Use rules to send messages to different MQTT topics or send commands to other Tasmota devices when switch state (defined by SwitchMode ) changes. To ignore the default behaviour define a rule which triggers on Switch<x> for all state changes or on Switch<x>#State for specific state changes. If a rule matches only certain states, default switch behaviour is suppressed only for those states. Example Make Switch1 publish any value change to stat/custom-topic/SWITCH1 and not control Power1 Backlog SwitchMode 1 ; SwitchTopic 0 Backlog Rule1 on Switch1 # state do Publish stat / custom - topic / SWITCH1 % value % endon ; Rule1 1","title":"Rules"},{"location":"Buttons-and-Switches/#switchtopic","text":"Warning When using SwitchTopic 1 or 2 (or ButtonTopic 1 or 2 ) and your MQTT broker becomes unavailable, Tasmota falls back to default SwitchTopic 0 (or ButtonTopic 0 ), which is not optimal. To avoid this, we recommend using first two options instead. If you still need to use SwitchTopic read on! SwitchTopic 0 Default mode By default a switch controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new switch state. The message you see in console is the new power state that is controlled and not the switch state. SwitchTopic 1 Sets MQTT switch topic to device %topic% When changing the state of the switch an MQTT message is sent to the device topic with the payload according to SwitchMode set. Example Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = TOGGLE Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT commands to this device, the device power state will be set to the defined state. SwitchTopic <value> Set switch topic to a custom topic (32 characters max) This will send an MQTT message to a custom defined topic similarly to option 1. In the following example, we set the topic to tasmota02 with SwitchTopic tasmota02 . Example Device topic tasmota with SwitchMode 1 and custom topic tasmota02 yields the following message: MQT: cmnd/tasmota02/POWER = ON If you have another device with the topic tasmota02 this action will turn on its power while not affecting anything on the tasmota device.","title":"SwitchTopic"},{"location":"Buttons-schematics/","text":"","title":"Buttons schematics"},{"location":"Buzzer/","text":"Tasmota gives you the option to control the sound pattern of a buzzer. Note A device LED can be assigned as a Buzzer component to display a blink pattern. Buzzer command ~ Parameters for the Buzzer command can be <count>,<beep>,<silence>,<tune> all parameters are optional. (default is 1,1,1 (one 100 millisecond beep)) . <count> number of beeps -1 for infinite, -2 to follow state of LED1;\u00bb v8.1.0.6 <beep> duration of one beep in 100 millisecond steps <silence> duration of silence between beeps 100 millisecond steps <tune> is a 32-bit bitmask where a 1 bit beeps and a 0 bit is silence according to <beep> and <silence> , respectively. The tune is played from most significant bit (MSB) to least significant bit (LSB). Leading and trailing 0 bits are ignored. If <tune> is specified, <count> is ignored ( <count> for <tune> supported in \u00bb v8.1.0.6). If <tune> is 0 , it is ignored. Examples: 3 - Beep three times with 100 milliseconds duration and 100 milliseconds pause 2,3 - Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 - Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds 0 = stop active buzzer cycle \u2003\u00bb v6.6.0.18","title":"Buzzer"},{"location":"Buzzer/#buzzer-command","text":"Parameters for the Buzzer command can be <count>,<beep>,<silence>,<tune> all parameters are optional. (default is 1,1,1 (one 100 millisecond beep)) . <count> number of beeps -1 for infinite, -2 to follow state of LED1;\u00bb v8.1.0.6 <beep> duration of one beep in 100 millisecond steps <silence> duration of silence between beeps 100 millisecond steps <tune> is a 32-bit bitmask where a 1 bit beeps and a 0 bit is silence according to <beep> and <silence> , respectively. The tune is played from most significant bit (MSB) to least significant bit (LSB). Leading and trailing 0 bits are ignored. If <tune> is specified, <count> is ignored ( <count> for <tune> supported in \u00bb v8.1.0.6). If <tune> is 0 , it is ignored. Examples: 3 - Beep three times with 100 milliseconds duration and 100 milliseconds pause 2,3 - Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 - Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds 0 = stop active buzzer cycle \u2003\u00bb v6.6.0.18","title":"Buzzer command"},{"location":"CC2530/","text":"CC253x Zigbee module ~ CC2530, CC2531, and CC2538 are Texas Instruments system-on-chips (SoCs) for Zigbee communication Any Texas Instruments CC253x series based module can serve as a coordinator if it has Z-Stack firmware flashed . See list of supported modules with their pinouts and flashing instructions since they are different for each device. Info Z-Stack Home 1.2 is fully supported in Tasmota allow the use of CC2530, CC2531, and CC2538 Zigbee MCU chips/SoCs/modules. There is also preliminary support for Z-Stack 3.x as of Tasmota v9.2.0.4 which allow the use of more powerful Zigbee MCU chips/SoCs/modules from Texas Intruments CC26x2 and CC13x2 series (example CC2652P, CC2652R, CC2652RB, CC1352P and CC1352R). Info You cannot use a Zigbee adapter in USB mode! Flash it with Z-Stack firmware and it will work in serial mode. You will have to wire the Zigbee MCU chips/SoC/modules for serial communication using TX and RX pins or solder-pads. USB port cannot be used for communicating with a Zigbee MCU chip/module. Wi-Fi Adapter ~ Using an ESP82xx device such as a Wemos D1 Mini or a NodeMCU to flash the CC2530 is a lower cost alternative than using a single purpose CC_DEBUGGER . In normal operation two free GPIOs are needed for the serial communication with the CC2530. Custom PCBs ~ These PCBs make all the connections required to flash the CC2530 and to run Z2T: SuperHouse.tv ~ Jon Oxer created a custom PCB to connect a Wemos D1 Mini and a CC2530 board (with or without CC2591). Complete module Charles (aka hallard) ~ Mainly based on Jon Oxer PCB, Charles created a new one with multi connect option for CC2538 + CC2592 to connect a Wemos D1 Mini/Raspberry PI or even with USB a CC2538 with CC2592 module. This works with awesome support of ZStack V3 by @s-hadinger Complete module Check the dedicated github repo for detailled information H4NC ~ User h4nc created a custom PCB to connect a NodeMCU and a CC2530 board. You can also get a complete Z2T module with case, pre-flashed and ready to configure and deploy. Configuration ~ Flash Zigbee Adapter ~ Zigbee2Tasmota requires a TI CC2530 based module flashed with Z-Stack CC2530 firmware file from Koen Kanters . Due to memory constraints of the CC2530, you can only pair 16 devices to a coordinator ( See details ). Note There is an alternative firmware allowing for Zigbee routers to create a mesh network and go beyond 16 devices. This is currently not tested nor supported by Zigbee2Tasmota. It may be added later. Flashing options: Flashing with CCLoader and ESP8266 (recommended) Flashing with CCLib and ESP8266 Flash with a dedicated CC Debugger and PC Flash Tasmota ~ Once the flashing process completes, you can re-use the ESP82xx and flash Tasmota with Zigbee2Tasmota enabled tasmota-zigbee.bin binary. Otherwise, you can use any ESP82xx device. Optional ~ Run the ESP at 160MHz instead of 80MHz which ensures higher reliability in serial communication with CC2530. In platformio_override.ini uncomment line 51: board_build.f_cpu = 160000000L If you find that your Zigbee2Tasmota operation is unstable, you may have an ESP82xx device that cannot operate reliably at the higher frequency. If you are using hardware serial (see below) and you still have unreliability, try compiling for 80MHz (reverse the options above) and flash the ESP82xx device again to see if operating at a lower frequency improves stability. Running at 80MHz will impact software serial communications so hardware serial is highly recommended if running the ESP82xx at 80MHz. Flash the newly compiled binary usig the normal flashing process . Connect CC2530 to Tasmota ~ If you are using your ESP82xx device to flash the Zigbee adapter as described in tutorials you may want to leave these connections in place in case you ever need to update Zigbee firmware. If not, any of the free GPIOs can be used. It is recommended that hardware serial pins be used (GPIO1/GPIO3 or GPIO13[Rx]/GPIO15[Tx]) Due to ESP82xx GPIO pin constraints, GPIO15 can only be used as serial Tx. The interface between the ESP82xx Wi-Fi device and the Zigbee module uses high speed serial. Tip Tasmota also provides serial communications emulation through software (i.e., software serial). This allows any GPIO to be used. TasmotaSerial version 2.4.x (PR #6377 ) has improved the reliability of software serial making it feasible for use in this application. However, if you have an option to use hardware serial, choose that. Z2T uses software serial by default to allow for serial logging on GPIO1/GPIO3 Use SerialLog 0 to enable hardware serial on GPIO13[Rx]/GPIO15[Tx] . Recommended wiring: ESP Device Tasmota Zigbee Module GPIO13 Zigbee RX (166) CC_TXD (A.K.A. P0_3) GPIO15 Zigbee TX (165) CC_RXD (A.K.A. P0_2) 3V3 VCC GND GND Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIO13 to Zigbee RX GPIO15 to Zigbee TX You can quickly configure Tasmota using a custom template instead. Use this one for the recommended wiring scheme: { \"NAME\" : \"Zigbee\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 166 , 0 , 165 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } First Run ~ When the Tasmota device boots, Zigbee2Tasmota will wait for 15 seconds before initializing the CC2530. This time allows for Wi-Fi and MQTT to connect (hopefully). First boot: MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":1,\"Message\":\"CC2530 booted\",\"RestartReason\":\"Watchdog\",\"MajorRel\":2,\"MinorRel\":6}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":50,\"MajorRel\":2,\"MinorRel\":6,\"MaintRel\":3,\"Revision\":20190608}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":2,\"Message\":\"Reseting configuration\"}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":3,\"Message\":\"Configured, starting coordinator\"}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":51,\"IEEEAddr\":\"0x00124B00199DF06F\",\"ShortAddr\":\"0x0000\",\"DeviceType\":7,\"DeviceState\":9,\"NumAssocDevices\":0}} MQT: tele/tasmota/Zigbee_home/RESULT = {\"ZbState\":{\"Status\":0,\"Message\":\"Started\"}} ZIG: Zigbee started ZIG: No zigbee devices data in Flash Zigbee will automatically boot the CC2530 device, configure the device and wait for Zigbee messages. Normal boot looks like: MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":1,\"Message\":\"CC2530 booted\",\"RestartReason\":\"Watchdog\",\"MajorRel\":2,\"MinorRel\":6}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":50,\"MajorRel\":2,\"MinorRel\":6,\"MaintRel\":3,\"Revision\":20190608}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":3,\"Message\":\"Configured, starting coordinator\"}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":51,\"IEEEAddr\":\"0x00124B00199DF06F\",\"ShortAddr\":\"0x0000\",\"DeviceType\":7,\"DeviceState\":9,\"NumAssocDevices\":0}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":0,\"Message\":\"Started\"}} ZIG: Zigbee started ZIG: Zigbee devices data in Flash (516 bytes) You can force a factory reset of your CC2530 with ZigbeeReset 1 and reboot","title":"CC253x Zigbee module"},{"location":"CC2530/#cc253x-zigbee-module","text":"CC2530, CC2531, and CC2538 are Texas Instruments system-on-chips (SoCs) for Zigbee communication Any Texas Instruments CC253x series based module can serve as a coordinator if it has Z-Stack firmware flashed . See list of supported modules with their pinouts and flashing instructions since they are different for each device. Info Z-Stack Home 1.2 is fully supported in Tasmota allow the use of CC2530, CC2531, and CC2538 Zigbee MCU chips/SoCs/modules. There is also preliminary support for Z-Stack 3.x as of Tasmota v9.2.0.4 which allow the use of more powerful Zigbee MCU chips/SoCs/modules from Texas Intruments CC26x2 and CC13x2 series (example CC2652P, CC2652R, CC2652RB, CC1352P and CC1352R). Info You cannot use a Zigbee adapter in USB mode! Flash it with Z-Stack firmware and it will work in serial mode. You will have to wire the Zigbee MCU chips/SoC/modules for serial communication using TX and RX pins or solder-pads. USB port cannot be used for communicating with a Zigbee MCU chip/module.","title":"CC253x Zigbee module"},{"location":"CC2530/#wi-fi-adapter","text":"Using an ESP82xx device such as a Wemos D1 Mini or a NodeMCU to flash the CC2530 is a lower cost alternative than using a single purpose CC_DEBUGGER . In normal operation two free GPIOs are needed for the serial communication with the CC2530.","title":"Wi-Fi Adapter"},{"location":"CC2530/#custom-pcbs","text":"These PCBs make all the connections required to flash the CC2530 and to run Z2T:","title":"Custom PCBs"},{"location":"CC2530/#configuration","text":"","title":"Configuration"},{"location":"CC2530/#flash-zigbee-adapter","text":"Zigbee2Tasmota requires a TI CC2530 based module flashed with Z-Stack CC2530 firmware file from Koen Kanters . Due to memory constraints of the CC2530, you can only pair 16 devices to a coordinator ( See details ). Note There is an alternative firmware allowing for Zigbee routers to create a mesh network and go beyond 16 devices. This is currently not tested nor supported by Zigbee2Tasmota. It may be added later. Flashing options: Flashing with CCLoader and ESP8266 (recommended) Flashing with CCLib and ESP8266 Flash with a dedicated CC Debugger and PC","title":"Flash Zigbee Adapter"},{"location":"CC2530/#flash-tasmota","text":"Once the flashing process completes, you can re-use the ESP82xx and flash Tasmota with Zigbee2Tasmota enabled tasmota-zigbee.bin binary. Otherwise, you can use any ESP82xx device.","title":"Flash Tasmota"},{"location":"CC2530/#connect-cc2530-to-tasmota","text":"If you are using your ESP82xx device to flash the Zigbee adapter as described in tutorials you may want to leave these connections in place in case you ever need to update Zigbee firmware. If not, any of the free GPIOs can be used. It is recommended that hardware serial pins be used (GPIO1/GPIO3 or GPIO13[Rx]/GPIO15[Tx]) Due to ESP82xx GPIO pin constraints, GPIO15 can only be used as serial Tx. The interface between the ESP82xx Wi-Fi device and the Zigbee module uses high speed serial. Tip Tasmota also provides serial communications emulation through software (i.e., software serial). This allows any GPIO to be used. TasmotaSerial version 2.4.x (PR #6377 ) has improved the reliability of software serial making it feasible for use in this application. However, if you have an option to use hardware serial, choose that. Z2T uses software serial by default to allow for serial logging on GPIO1/GPIO3 Use SerialLog 0 to enable hardware serial on GPIO13[Rx]/GPIO15[Tx] . Recommended wiring: ESP Device Tasmota Zigbee Module GPIO13 Zigbee RX (166) CC_TXD (A.K.A. P0_3) GPIO15 Zigbee TX (165) CC_RXD (A.K.A. P0_2) 3V3 VCC GND GND","title":"Connect CC2530 to Tasmota"},{"location":"CC2530/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIO13 to Zigbee RX GPIO15 to Zigbee TX You can quickly configure Tasmota using a custom template instead. Use this one for the recommended wiring scheme: { \"NAME\" : \"Zigbee\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 166 , 0 , 165 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 }","title":"Tasmota Settings"},{"location":"CC2530/#first-run","text":"When the Tasmota device boots, Zigbee2Tasmota will wait for 15 seconds before initializing the CC2530. This time allows for Wi-Fi and MQTT to connect (hopefully). First boot: MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":1,\"Message\":\"CC2530 booted\",\"RestartReason\":\"Watchdog\",\"MajorRel\":2,\"MinorRel\":6}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":50,\"MajorRel\":2,\"MinorRel\":6,\"MaintRel\":3,\"Revision\":20190608}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":2,\"Message\":\"Reseting configuration\"}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":3,\"Message\":\"Configured, starting coordinator\"}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":51,\"IEEEAddr\":\"0x00124B00199DF06F\",\"ShortAddr\":\"0x0000\",\"DeviceType\":7,\"DeviceState\":9,\"NumAssocDevices\":0}} MQT: tele/tasmota/Zigbee_home/RESULT = {\"ZbState\":{\"Status\":0,\"Message\":\"Started\"}} ZIG: Zigbee started ZIG: No zigbee devices data in Flash Zigbee will automatically boot the CC2530 device, configure the device and wait for Zigbee messages. Normal boot looks like: MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":1,\"Message\":\"CC2530 booted\",\"RestartReason\":\"Watchdog\",\"MajorRel\":2,\"MinorRel\":6}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":50,\"MajorRel\":2,\"MinorRel\":6,\"MaintRel\":3,\"Revision\":20190608}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":3,\"Message\":\"Configured, starting coordinator\"}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":51,\"IEEEAddr\":\"0x00124B00199DF06F\",\"ShortAddr\":\"0x0000\",\"DeviceType\":7,\"DeviceState\":9,\"NumAssocDevices\":0}} MQT: tele/%topic%/RESULT = {\"ZbState\":{\"Status\":0,\"Message\":\"Started\"}} ZIG: Zigbee started ZIG: Zigbee devices data in Flash (516 bytes) You can force a factory reset of your CC2530 with ZigbeeReset 1 and reboot","title":"First Run"},{"location":"CCLoader/","text":"CCLoader ~ development version feature This is a port of the CCLoader utility from RedBearLab in form of a driver for Tasmota. The main difference is, that now only one ESP8266 is needed to do all the tasks. As a result OTA-upgrades are possible too. The driver is tested for a CC2531, but should work on every CC25xx-device, that is supported by the original CCLoader. The wiring to the debug pins (= programming pins) of the CC25xx boards stays the same. It is possible to leave all wires connected (VCC,GND,RX,TX). In the current version of the Tasmota driver the pins are hardcoded and could be changed easily in the code: int CCL_RESET = 14; //GPIO14=D5 on NodeMCU/WeMos D1 Mini int CCL_DD = 4; //GPIO4=D2 on NodeMCU/WeMos D1 Mini int CCL_DC = 5; //GPIO5=D1 on NodeMCU/WeMos D1 Mini The driver must be enabled manually for a self compiled Tasmota binary. #define USE_CCLOADER After reboot the connected CC25xx chip will be reported in the console and the WebUI. Then chose Firmware Upgrade in the WebUI. Now download the correct firmware as a .bin-file, if you haven't done already. Do not use a .hex-file. These can be found for various chips here: https://github.com/arendst/Tasmota/tree/development/tools Select Ugprade by file upload , like you would do for a OTA upgrade of the Tasmota firmware. If a CC25xx chip was successfully detected and the selected file passes a (very minimalistic) check, this will trigger the upload to the CC25xx. This will start the upgrade, which will take several seconds. The progress will be printed to the console and after the finish, the device gets rebooted. A power cycle is recommended. That\u2019s it. Now it might be a good time to upload a Zigbee- or HM1x-firmware to your ESP8266.","title":"CCLoader"},{"location":"CCLoader/#ccloader","text":"development version feature This is a port of the CCLoader utility from RedBearLab in form of a driver for Tasmota. The main difference is, that now only one ESP8266 is needed to do all the tasks. As a result OTA-upgrades are possible too. The driver is tested for a CC2531, but should work on every CC25xx-device, that is supported by the original CCLoader. The wiring to the debug pins (= programming pins) of the CC25xx boards stays the same. It is possible to leave all wires connected (VCC,GND,RX,TX). In the current version of the Tasmota driver the pins are hardcoded and could be changed easily in the code: int CCL_RESET = 14; //GPIO14=D5 on NodeMCU/WeMos D1 Mini int CCL_DD = 4; //GPIO4=D2 on NodeMCU/WeMos D1 Mini int CCL_DC = 5; //GPIO5=D1 on NodeMCU/WeMos D1 Mini The driver must be enabled manually for a self compiled Tasmota binary. #define USE_CCLOADER After reboot the connected CC25xx chip will be reported in the console and the WebUI. Then chose Firmware Upgrade in the WebUI. Now download the correct firmware as a .bin-file, if you haven't done already. Do not use a .hex-file. These can be found for various chips here: https://github.com/arendst/Tasmota/tree/development/tools Select Ugprade by file upload , like you would do for a OTA upgrade of the Tasmota firmware. If a CC25xx chip was successfully detected and the selected file passes a (very minimalistic) check, this will trigger the upload to the CC25xx. This will start the upgrade, which will take several seconds. The progress will be printed to the console and after the finish, the device gets rebooted. A power cycle is recommended. That\u2019s it. Now it might be a good time to upload a Zigbee- or HM1x-firmware to your ESP8266.","title":"CCLoader"},{"location":"Codes-for-IR-Remotes/","text":"The IR Codes can be used with any devicewith an IR sender. The codes will also fit other devices from same manufacturer or series. Please try out... Feel free to contribute this list TV's ~ IR Codes TV Panasonic TX65FXW784 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x100BCBD\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x100BCBD} 0x40040100BCBD=\"ON/OFF\" 0x400401004C4D=\"Mute\" 0x400401000405=\"Vol+\" 0x400401008485=\"Vol-\" 0x400401002C2D=\"P+\" 0x40040100ACAD=\"P-\" 0x400401007273=\"Left\" 0x40040100F2F3=\"Right\" 0x400401005253=\"Up\" 0x40040100D2D3=\"Down\" 0x400401009293=\"OK\" 0x400401004A4B=\"Menu\" 0x400401000E0F=\"Red\" 0x400401004E4F=\"Yellow\" 0x400401008E8F=\"Green\" 0x40040100CECF=\"Blue\" 0x40040100ECED=\"Last View\" 0x400401206D4C=\"My App\" 0x400401904FDE=\"Netflix\" 0x40040190F160=\"Apps\" 0x400401900392=\"Play\" 0x400401908312=\"Pause\" 0x4004019043D2=\"Stop\" 0x40040190C352=\"Forward\" 0x4004019023B2=\"Back\" 0x400401000809=\"Key 1\" 0x400401008889=\"Key 2\" 0x400401004849=\"Key 3\" 0x40040100C8C9=\"Key 4\" 0x400401002829=\"Key 5\" 0x40040100A8A9=\"Key 6\" 0x400401006869=\"Key 7\" 0x40040100E8E9=\"Key 8\" 0x400401001819=\"Key 9\" 0x400401009899=\"Key 0\" 0x40040190BB2A=\"Title forward\" 0x400401903BAA=\"Title back\" 0x40040190A332=\"Record\" 0x40040190E170=\"Guide\" 0x40040100CBCA=\"Exit\" 0x400401002B2A=\"Back\" 0x40040190E574=\"Option\" 0x400401009C9D=\"Info\" 0x400401400C4D=\"TV\" 0x40040100A0A1=\"AV\" 0x40040180C041=\"Text\" 0x40040180A021=\"STTL\" 0x400401000A0B=\"Picture\" 0x400401003534=\"Help\" IR Remote Codes Sony KDL-EX540 ~ Common buttons should work across multiple models Input {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA50\"} Power On {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x750\"} Power Off {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xF50\"} Power Toggle {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA90\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Ch + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x090\"} Ch - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x890\"} Theatre Mode {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x03EE\"} Play/Pause {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2CE9\"} Stop {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0CE9\"} Rew {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6CE9\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1CE9\"} Sync Menu {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0D58\"} Prev {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1EE9\"} Next {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5EE9\"} i-Manual {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6F58\"} Scene {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0F58\"} Aspect {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5E25\"} Digital/Analog {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x58EE\"} PIP {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x7725\"} Internet Video {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x4F58\"} Favourite {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x37EE\"} Guide {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D25\"} Info {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x5D0\"} Return {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x62E9\"} Options {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x36E9\"} Home {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x070\"} Up {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2F0\"} Down {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xAF0\"} Left {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2D0\"} Right {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xCD0\"} Enter {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA70\"} Red {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x52E9\"} Green {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x32E9\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x72E9\"} Blue {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x12E9\"} 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x010\"} 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x810\"} 3 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x410\"} 4 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC10\"} 5 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x210\"} 6 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA10\"} 7 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x610\"} 8 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE10\"} 9 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Text {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xFD0\"} 0 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0AE9\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE90\"} HDMI 1 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2D58\"} HDMI 2 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D58\"} HDMI 3 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1D58\"} HDMI 4 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5D58\"} Video 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x030\"} Video 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x830\"} Video 3/Component 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x430\"} PC {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC30\"} Digital TV {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x25EE\"} IR Codes TV LG 55UH8509 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x20DF10EF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x20DF10EF} or with mosquitto_pub: mosquitto_pub -q 2 -t cmnd/sonoffIRBridge_1/IRSend -m '{\"protocol\": \"NEC\",\"bits\": 32, \"data\": 0x20DF10EF}' 0x20DF10EF=\"ON/OFF\" 0x20DF0FF0=\"TV\" 0x20DF9E61=\"Ratio\" 0x20DFD02F=\"Input\" 0x20DFA956=\"Energy\" 0x20DF8877=\"Key 1\" 0x20DF48B7=\"Key 2\" 0x20DFC837=\"Key 3\" 0x20DF28D7=\"Key 4\" 0x20DFA857=\"Key 5\" 0x20DF6897=\"Key 6\" 0x20DFE817=\"Key 7\" 0x20DF18E7=\"Key 8\" 0x20DF9867=\"Key 9\" 0x20DFCA35=\"List\" 0x20DF08F7=\"Key 0\" 0x20DF58A7=\"Q.View\" 0x20DF40BF=\"Vol+\" 0x20DFC03F=\"Vol-\" 0x20DFCE31=\"Vol-\" 0x20DF7887=\"Fav\" 0x20DF3BC4=\"3D\" 0x20DF906F=\"Mute\" 0x20DF00FF=\"P+\" 0x20DF807F=\"P-\" 0x20DFC23D=\"Settings\" 0x20DF55AA=\"Info\" 0x20DFA25D=\"Q.Menu\" 0x20DFE01F=\"Left\" 0x20DF609F=\"Right\" 0x20DF02FD=\"Up\" 0x20DF827D=\"Down\" 0x20DF22DD=\"OK\" 0x20DF14EB=\"Back\" 0x20DFD52A=\"Guide\" 0x20DFDA25=\"Exit\" 0x20DF4EB1=\"Red\" 0x20DF8E71=\"Green\" 0x20DFC639=\"Yellow\" 0x20DF8679=\"Blue\" 0x20DF04FB=\"Text\" 0x20DF847B=\"T.Opt\" 0x20DF9C63=\"Subtitle\" 0x20DF8D72=\"Stop\" 0x20DF0DF2=\"Play\" 0x20DF5DA2=\"Pause\" 0x20DFF10E=\"Backward\" 0x20DF718E=\"Forward\" 0x20DF7E81=\"Simplink\" 0x20DF8976=\"AD\" 0x20DF0CF3=\"AV Mode\" 0x20DF3EC1=\"Live TV\" 0x20DF42BD=\"Live TV\" 0x20DF35CA=\"Status\" 0x20DF50AF=\"Audio Language\" 0x20DF57A8=\"Shortmenu\" 0x20DF5AA5=\"AV\" 0x20DF5EA1=\"online manual\" 0x20DF619E=\"Volume to 50\" 0x20DF21DE=\"Volume to 80\" 0x20DFE11E=\"Volume to 100\" 0x20DF6B94=\"Radio/TV\" 0x20DF708F=\"doze function\" 0x20DFA35C=\"Display off\" 0x20DFD728=\"Standby\" 0x20DF23DC=\"Power on\" 0x20DFB44B=\"Settings of remote\" 0x20DF956A=\"Program guide\" 0x20DFF00F=\"Radio/TV\" 0x20DF738C=\"HDMI 1\" 0x20DF33CC=\"HDMI 2\" 0x20DF9768=\"HDMI 3\" 0x20DFFD02=\"Component\" 0x20DFF50A=\"Live Zoom\" 0x20DFF20D=\"Input info\" 0x20DFB24D=\"Picture mode\" 0x20DF09F6=\"Recordings\" 0x20DF4AB5=\"Audio mode\" 0x20DF7B84=\"Register magic remote\" 0x20DFAE51=\"directly register magic remote\" 0x20DF1CE3=\"Subtitles\" 0x20DFCC33=\"Presentation in shop\" 0x20DFBD42=\"Start recording\" 0x20DFAD52=\"LG TV Plus\" 0x20DFDD22=\"Sports mode\" 0x20DF1EE1=\"Search\" 0x20DFDF20=\"Warning: instart\" 0x20DF7F80=\"Warning: Poweronly\" 0x20DFFF00=\"Warning: Easy adjust\" 0x20DF5FA0=\"Warning: instop\" 0x20DF5FA0=\"Enter Password\" 0x20DF3FC0=\"Warning: Reset to factory\" Generic VEON TV (eg model SRO322016) ~ button code On/Off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEA857\"} Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE6897\"} Sleep {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE38C7\"} Source {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE48B7\"} Info {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE28D7\"} EPG {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEAA55\"} Vol+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FED827\"} Vol- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE58A7\"} Chan+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE9867\"} Chan- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE18E7\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE52AD\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FED22D\"} Rwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEE21D\"} FFd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE629D\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEA25D\"} Skip {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE22DD\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE807F\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE40BF\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEC03F\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE20DF\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEA05F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE609F\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEE01F\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE10EF\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE906F\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE00FF\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE8877\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE30CF\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEB04F\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEF00F\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE708F\"} OK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE08F7\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEC837\"} Set-top Boxes ~ IR Codes for VU+ Duo2 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":\"0x8052900C\"} Example IRsend Command: IRsend {\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":0x8052900C} 0xC8052900C=\"ON/OFF\" 0xC8052100D=\"Mute\" 0xC80529010=\"Vol+\" 0xC80521011=\"Vol-\" 0xC80529020=\"P+\" 0xC80529021=\"P+\" 0xC8052105A=\"Left\" 0xC8052905B=\"Right\" 0xC80529058=\"Up\" 0xC80529059=\"Down\" 0xC8052905C=\"OK\" 0xC80529054=\"Men\" 0xC8052906D=\"Red\" 0xC8052906F=\"Yellow\" 0xC8052906E=\"Green\" 0xC80529070=\"Blue\" 0xC8052902D=\"Play/Pause\" 0xC80529031=\"Stop\" 0xC80529028=\"Forward\" 0xC80529029=\"Back\" 0xC80529001=\"Key 1\" 0xC80529002=\"Key 2\" 0xC80529003=\"Key 3\" 0xC80529004=\"Key 4\" 0xC80529005=\"Key 5\" 0xC80529006=\"Key 6\" 0xC80529007=\"Key 7\" 0xC80529008=\"Key 8\" 0xC80529009=\"Key 9\" 0xC80529000=\"Key 0\" 0xC805290BB=\"Key <\" 0xC805290BC=\"Key >\" 0xC80529037=\"Record\" 0xC805290CC=\"EPG\" 0xC80529055=\"Exit\" 0xC805290E5=\"Audio\" 0xC805290F2=\"Radio\" 0xC805290E4=\"TV\" 0xC80521049=\"Context\" 0xC80529081=\"Help\" IR Remote Codes AppleTV Gen4 ~ Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E15080\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13080\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E19080\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E16080\"} Ok {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13A80\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1C080\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1FA80\"} Home {\"Protocol\":\"NEC\",\"Bits\":0,\"Data\":\"0xFFFFFFFFFFFFFFFF\"} IR Remote Codes Humax HMS-1000T DVB-T2 DVR PAL 4-Tune ~ Power {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000800FF\"} TV Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D22D\"} Text {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087689\"} Wide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008728D\"} Play {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000816E9\"} Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000846B9\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A659\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000826D9\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C639\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088679\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E21D\"} Plus {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000842BD\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00086897\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008827D\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088877\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A857\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000848B7\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000828D7\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C837\"} Vol + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F807\"} Vol - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000802FD\"} Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000818E7\"} Home {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008708F\"} Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D827\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000808F7\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F00F\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000838C7\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B847\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000858A7\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087887\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C03F\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000820DF\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A05F\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008609F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E01F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000810EF\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008906F\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000850AF\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D02F\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000830CF\"} TV/Radio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B04F\"} IR Remote Codes FetchTV Mini(Hybroad H626T) ~ Power Toggle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BA45\"} Keyboard Select {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624CB3\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26627B84\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662DB24\"} TV Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266207F8\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662738C\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662936C\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E31C\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266213EC\"} Info {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26628B74\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26622CD3\"} Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662CC33\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266223DC\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662837C\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C33C\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26621CE3\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662AB54\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266227D8\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BB44\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662B34C\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624BB4\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266240BF\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C03F\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266220DF\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662A05F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662609F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E01F\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266210EF\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662906F\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266250AF\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662D02F\"} Smart Receiver VX/CX ~ button code on/off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\",\"DataLSB\":\"0x00FF0CF3\",\"Repeat\":0} mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\",\"DataLSB\":\"0x00FF0DF2\",\"Repeat\":0} FORMAT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF1CE3\",\"DataLSB\":\"0x00FF38C7\",\"Repeat\":0} 16:9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC13E\",\"DataLSB\":\"0x00FF837C\",\"Repeat\":0} AUDIO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFA05\",\"DataLSB\":\"0x00FF5FA0\",\"Repeat\":0} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\",\"DataLSB\":\"0x00FF01FE\",\"Repeat\":0} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\",\"DataLSB\":\"0x00FF02FD\",\"Repeat\":0} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\",\"DataLSB\":\"0x00FF03FC\",\"Repeat\":0} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\",\"DataLSB\":\"0x00FF04FB\",\"Repeat\":0} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\",\"DataLSB\":\"0x00FF05FA\",\"Repeat\":0} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\",\"DataLSB\":\"0x00FF06F9\",\"Repeat\":0} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\",\"DataLSB\":\"0x00FF07F8\",\"Repeat\":0} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\",\"DataLSB\":\"0x00FF08F7\",\"Repeat\":0} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\",\"DataLSB\":\"0x00FF09F6\",\"Repeat\":0} TV/R {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA25D\",\"DataLSB\":\"0x00FF45BA\",\"Repeat\":0} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\",\"DataLSB\":\"0x00FF00FF\",\"Repeat\":0} RECALL {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF19E6\",\"DataLSB\":\"0x00FF9867\",\"Repeat\":0} volume + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF5AA5\",\"DataLSB\":\"0x00FF5AA5\",\"Repeat\":0} volume - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDA25\",\"DataLSB\":\"0x00FF5BA4\",\"Repeat\":0} P - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFBA45\",\"DataLSB\":\"0x00FF5DA2\",\"Repeat\":0} P + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF3AC5\",\"DataLSB\":\"0x00FF5CA3\",\"Repeat\":0} red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEC13\",\"DataLSB\":\"0x00FF37C8\",\"Repeat\":0} green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF6C93\",\"DataLSB\":\"0x00FF36C9\",\"Repeat\":0} yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4CB3\",\"DataLSB\":\"0x00FF32CD\",\"Repeat\":0} blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF2CD3\",\"DataLSB\":\"0x00FF34CB\",\"Repeat\":0} MENU {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4AB5\",\"DataLSB\":\"0x00FF52AD\",\"Repeat\":0} BACK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF44BB\",\"DataLSB\":\"0x00FF22DD\",\"Repeat\":0} EXIT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB44B\",\"DataLSB\":\"0x00FF2DD2\",\"Repeat\":0} up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF04FB\",\"DataLSB\":\"0x00FF20DF\",\"Repeat\":0} left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8877\",\"DataLSB\":\"0x00FF11EE\",\"Repeat\":0} OK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEA15\",\"DataLSB\":\"0x00FF57A8\",\"Repeat\":0} right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF08F7\",\"DataLSB\":\"0x00FF10EF\",\"Repeat\":0} down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF847B\",\"DataLSB\":\"0x00FF21DE\",\"Repeat\":0} INFO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF34CB\",\"DataLSB\":\"0x00FF2CD3\",\"Repeat\":0} FAV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8679\",\"DataLSB\":\"0x00FF619E\",\"Repeat\":0} TXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF7A85\",\"DataLSB\":\"0x00FF5EA1\",\"Repeat\":0} EPG {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF06F9\",\"DataLSB\":\"0x00FF609F\",\"Repeat\":0} FR {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} REC {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF619E\",\"DataLSB\":\"0x00FF8679\",\"Repeat\":0} FF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF29D6\",\"DataLSB\":\"0x00FF946B\",\"Repeat\":0} PREV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF09F6\",\"DataLSB\":\"0x00FF906F\",\"Repeat\":0} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE916\",\"DataLSB\":\"0x00FF9768\",\"Repeat\":0} NEXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC936\",\"DataLSB\":\"0x00FF936C\",\"Repeat\":0} (none left) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4BB4\",\"DataLSB\":\"0x00FFD22D\",\"Repeat\":0} STOP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF718E\",\"DataLSB\":\"0x00FF8E71\",\"Repeat\":0} (none right) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} USB {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFB04\",\"DataLSB\":\"0x00FFDF20\",\"Repeat\":0} HELP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF54AB\",\"DataLSB\":\"0x00FF2AD5\",\"Repeat\":0} DVD {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDB24\",\"DataLSB\":\"0x00FFDB24\",\"Repeat\":0} BD/DVD players ~ \u00e4 IR Remote Codes Sony BD-S1500 ~ Common buttons should work across multiple models Eject {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x68B47\"} Power {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xA8B47\"} Red {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xE6B47\"} Green {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x16B47\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x96B47\"} Bue {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x66B47\"} Top Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x34B47\"} Popup/Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x94B47\"} Return {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC2B47\"} Options {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xFCB47\"} Home {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x42B47\"} Up {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x9CB47\"} Down {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x5CB47\"} Left {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xDCB47\"} Right {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x3CB47\"} Enter {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Favourites {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Netflix {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD2B47\"} Play {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x58B47\"} Pause {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x98B47\"} Rew {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD8B47\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x38B47\"} Prev {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xEAB47\"} Next {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x6AB47\"} Stop {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x18B47\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC6B47\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x26B47\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Projectors ~ IR Remote Codes Acer K132 ~ IR Remote Codes for Acer K132 projector (and possibly other models using a remote with Model No. M1820) ON/OFF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8E11E\"} * Freeze {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8718E\"} * Hide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8F10E\"} * Ratio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C806F9\"} * Zoom {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8D12E\"} * Mode {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C801FE\"} * Source {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C831CE\"} * Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C832CD\"} * Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C841BE\"} * Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8A15E\"} * Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C13E\"} * Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8817E\"} * Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8B24D\"} * Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C821DE\"} * Vol+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C639\"} * Vol- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C826D9\"} * Sound {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8AD52\"} * Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C88679\"} Soundbars ~ IR Codes Soundbar Panasonic SCALL70T ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x40040500BCB9\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x40040500BCB9} 0x40040500BCB9=\"ON/OFF\" 0x400405004C49=\"Mute\" 0x400405000401=\"Vol+\" 0x400405008481=\"Vol-\" 0x40040538DFE2=\"OK\" 0x400405383F02=\"Up\" 0x40040538BF82=\"Down\" 0x40040538AD90=\"Setup\" 0x400405280D20=\"Sound\" 0x400405380538=\"Bluetooth\" 0x400405006164=\"Input\" IR Codes Soundcore Infini Pro ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0xFD256897\"}} Example IRsend Command: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0xFD256897\"} 0xFD2502FD=\"ON/OFF\" 0xFD2518E7=\"Mute\" 0xFD2508F7=\"Input\" 0xFD259867=\"Bluetooth\" 0xFD2548B7=\"TV\" 0xFD256897=\"Vol+\" 0xFD2558A7=\"Vol-\" 0xFD258A75=\"Previous\" 0xFD250AF5=\"Next\" 0xFD25C837=\"Play/Pause\" 0xFD2554AB=\"Movie\" 0xFD255CA3=\"Music\" 0xFD2552AD=\"Voice\" 0xFD2532CD=\"Bass-\" 0xFD258877=\"Bass+\" 0xFD2538C7=\"Surround\" IR Codes Goodmans GDSBT1000P ~ Example received Code: RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x4FBD02F\",\"DataLSB\":\"0x20DF0BF4\",\"Repeat\":0}} Example IRsend Command: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x4FB30CF\"} 0x4FB30CF=\"ON/OFF\" 0x20DF08F7=\"Mute\" 0x20DF0FF0=\"Mode Bluetooth\" 0x20DF0AF5=\"Mode Optical\" 0x20DF16E9=\"Mode Coaxial\" 0x20DF07F8=\"Mode Line in\" 0x20DF09F6=\"Mode AUX\" 0x20DF06F9=\"Bluetooth Pairing\" 0x20DF10EF=\"Music\" 0x20DF0BF4=\"Movie\" 0x20DF14EB=\"Voice\" 0x20DF00FF=\"Treble +\" 0x20DF03FC=\"Treble -\" 0x20DF01FE=\"Bass +\" 0x20DF04FB=\"Bass -\" 0x20DF02FD=\"Volume +\" 0x20DF05FA=\"Volume -\" 0x20DF11EE=\"Previous\" 0x20DF12ED=\"Play/Pause\" 0x20DF13EC=\"Next\" Vacuum Cleaners ~ IR Codes Vacuum Cleaner Ecovacs Deebot Slim2 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFD02F\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x00FFD02F} 0x00FFD02F=\"Automatic Mode/Pause\" 0x00FF609F=\"Edge Cleaning\" 0x00FF40BF=\"Spot Cleaning\" 0x00FF708F=\"Back to Charging Base\" 0x00FFC837=\"Forward\" 0x00FFE01F=\"Left\" 0x00FFF00F=\"Right\" 0x00FFC03F=\"Back/Turn around\" Ventilation ~ IR Codes Prana 150 energy recovery ventilation ~ See device https://prana.org.ua/models/prana_150 (Ukrainian) Example received Code: MQT: tele/sonoffir/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}=\"Power\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"}=\"Screen/LED Brightness\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\"}=\"Heat OFF\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"}=\"Heat ON\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF50AF\"}=\"Fan\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA857\"}=\"Anti freeze\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\"}=\"Night Mode\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF708F\"}=\"Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF28D7\"}=\"Fan +\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"}=\"Night Mode Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"}=\"Night Mode Fan +\" Christmas candle - Weihnachtsbeleuchtung ~ Krinner Lumix IR Remote ~ Remote control has two buttons and three channels. Button 1 is to switch on Button 0 is to switch off Double click on button 1 is flicker mode No usable protocol found yet, but raw mode does it. Example for HttpGetRequest and irsend sendHttpGetRequest(\"http://192.168.1.234/cm?cmnd=irsend5%200,2000,1000,%20400,1000,%20400,%20400,1000,1000,%20400,1000,%20400,%20400,1000,%20400,1000,%20400,1000,%20400,2000,5600\") off channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600 on channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600 flicker channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600 off channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600 off channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600 Vinkor Flameless Flickering Candles (and clones probably) ~ on {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED00FF\",\"Repeat\":0} off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED40BF\",\"Repeat\":0} dim {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED08F7\",\"Repeat\":0} bright {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED48B7\",\"Repeat\":0} candle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED30CF\",\"Repeat\":0} light {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED708F\",\"Repeat\":0} 2H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED20DF\",\"Repeat\":0} 4H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED609F\",\"Repeat\":0} 6H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED10EF\",\"Repeat\":0} 8H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED50AF\",\"Repeat\":0} LED Candles / LED Kerzen ~ Duni Warm White LED Candle / Duni Warmwei\u00df LED Kerzen ~ ON= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} OFF= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"} 4h= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\"} 8h= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\"} ModeCandle= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\"} ModeLight= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\"} ModeDark= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"} ModeBright= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\"} ModeMoon= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"} ModeNightLight= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"} Duni Multicoloured LED Candle / Duni Mehrfarbige LED Kerzen ~ ON_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F48B7\",\"DataLSB\":\"0x01FE12ED\"} OFF_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F807F\",\"DataLSB\":\"0x01FE01FE\"} ModeSmooth_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F58A7\",\"DataLSB\":\"0x01FE1AE5\"} ModeNightLight_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F7887\",\"DataLSB\":\"0x01FE1EE1\"} ModeCandle_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F40BF\",\"DataLSB\":\"0x01FE02FD\"} ModeLight_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FC03F\",\"DataLSB\":\"0x01FE03FC\"} ModeTimer_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F20DF\",\"DataLSB\":\"0x01FE04FB\"} ModeDark_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FA05F\",\"DataLSB\":\"0x01FE05FA\"} ModeBright_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F609F\",\"DataLSB\":\"0x01FE06F9\"} ColorRed_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FE01F\",\"DataLSB\":\"0x01FE07F8\"} ColorGreen_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F10EF\",\"DataLSB\":\"0x01FE08F7\"} ColorBlue_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F906F\",\"DataLSB\":\"0x01FE09F6\"} ColorOrange_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F50AF\",\"DataLSB\":\"0x01FE0AF5\"} ColorLightGreen_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FD827\",\"DataLSB\":\"0x01FE1BE4\"} ColorLightBlue_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FF807\",\"DataLSB\":\"0x01FE1FE0\"} ColorViolet_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F30CF\",\"DataLSB\":\"0x01FE0CF3\"} ColorYellow_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FB04F\",\"DataLSB\":\"0x01FE0DF2\"} ColorBlueWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F708F\",\"DataLSB\":\"0x01FE0EF1\"} ColorPink_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F00FF\",\"DataLSB\":\"0x01FE00FF\"} ColorYellowWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FF00F\",\"DataLSB\":\"0x01FE0FF0\"} ColorWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F9867\",\"DataLSB\":\"0x01FE19E6\"} Fishtec Bougie / Generic Multicolored Led Candle / Generische mehrfarbige LED Kerzen ~ ON= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE48B7\"} OFF= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE58A7\"} ColorBlue= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE609F\"} ColorRed= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE20DF\"} ColorGreen= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FEA05F\"} ColorWhite= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE30CF\"} ColorTurkis= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE10EF\"} ColorOrange= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE50AF\"} ColorPink= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE708F\"} ColorPurple= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FEF807\"} ColorLightPurple= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE906F\"} ColorLightBlue= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FED827\"} ColorOceanBlue= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FEB04F\"} ModeMultiColor= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FEC03F\"} ModeSwitch= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE7887\"} Edifier R1850DB IR remote ~ *MUTE: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7827D\",\"DataLSB\":\"0x10E741BE\",\"Repeat\":0} *+: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7609F\",\"DataLSB\":\"0x10E706F9\",\"Repeat\":0} *-: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7E21D\",\"DataLSB\":\"0x10E747B8\",\"Repeat\":0} *ON/OFF: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7629D\",\"DataLSB\":\"0x10E746B9\",\"Repeat\":0} *PC: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7E01F\",\"DataLSB\":\"0x10E707F8\",\"Repeat\":0} *AUX: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7906F\",\"DataLSB\":\"0x10E709F6\",\"Repeat\":0} *OPT: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7A25D\",\"DataLSB\":\"0x10E745BA\",\"Repeat\":0} *COX: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7C03F\",\"DataLSB\":\"0x10E703FC\",\"Repeat\":0} *BT: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E73AC5\",\"DataLSB\":\"0x10E75CA3\",\"Repeat\":0} *<<: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E77887\",\"DataLSB\":\"0x10E71EE1\",\"Repeat\":0} *>||: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E77A85\",\"DataLSB\":\"0x10E75EA1\",\"Repeat\":0} *>>: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E740BF\",\"DataLSB\":\"0x10E702FD\",\"Repeat\":0}","title":"Codes for IR Remotes"},{"location":"Codes-for-IR-Remotes/#tvs","text":"","title":"TV's"},{"location":"Codes-for-IR-Remotes/#ir-codes-tv-panasonic-tx65fxw784","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x100BCBD\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x100BCBD} 0x40040100BCBD=\"ON/OFF\" 0x400401004C4D=\"Mute\" 0x400401000405=\"Vol+\" 0x400401008485=\"Vol-\" 0x400401002C2D=\"P+\" 0x40040100ACAD=\"P-\" 0x400401007273=\"Left\" 0x40040100F2F3=\"Right\" 0x400401005253=\"Up\" 0x40040100D2D3=\"Down\" 0x400401009293=\"OK\" 0x400401004A4B=\"Menu\" 0x400401000E0F=\"Red\" 0x400401004E4F=\"Yellow\" 0x400401008E8F=\"Green\" 0x40040100CECF=\"Blue\" 0x40040100ECED=\"Last View\" 0x400401206D4C=\"My App\" 0x400401904FDE=\"Netflix\" 0x40040190F160=\"Apps\" 0x400401900392=\"Play\" 0x400401908312=\"Pause\" 0x4004019043D2=\"Stop\" 0x40040190C352=\"Forward\" 0x4004019023B2=\"Back\" 0x400401000809=\"Key 1\" 0x400401008889=\"Key 2\" 0x400401004849=\"Key 3\" 0x40040100C8C9=\"Key 4\" 0x400401002829=\"Key 5\" 0x40040100A8A9=\"Key 6\" 0x400401006869=\"Key 7\" 0x40040100E8E9=\"Key 8\" 0x400401001819=\"Key 9\" 0x400401009899=\"Key 0\" 0x40040190BB2A=\"Title forward\" 0x400401903BAA=\"Title back\" 0x40040190A332=\"Record\" 0x40040190E170=\"Guide\" 0x40040100CBCA=\"Exit\" 0x400401002B2A=\"Back\" 0x40040190E574=\"Option\" 0x400401009C9D=\"Info\" 0x400401400C4D=\"TV\" 0x40040100A0A1=\"AV\" 0x40040180C041=\"Text\" 0x40040180A021=\"STTL\" 0x400401000A0B=\"Picture\" 0x400401003534=\"Help\"","title":"IR Codes TV Panasonic TX65FXW784"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-sony-kdl-ex540","text":"Common buttons should work across multiple models Input {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA50\"} Power On {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x750\"} Power Off {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xF50\"} Power Toggle {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA90\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Ch + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x090\"} Ch - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x890\"} Theatre Mode {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x03EE\"} Play/Pause {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2CE9\"} Stop {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0CE9\"} Rew {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6CE9\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1CE9\"} Sync Menu {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0D58\"} Prev {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1EE9\"} Next {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5EE9\"} i-Manual {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6F58\"} Scene {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0F58\"} Aspect {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5E25\"} Digital/Analog {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x58EE\"} PIP {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x7725\"} Internet Video {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x4F58\"} Favourite {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x37EE\"} Guide {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D25\"} Info {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x5D0\"} Return {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x62E9\"} Options {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x36E9\"} Home {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x070\"} Up {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2F0\"} Down {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xAF0\"} Left {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2D0\"} Right {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xCD0\"} Enter {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA70\"} Red {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x52E9\"} Green {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x32E9\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x72E9\"} Blue {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x12E9\"} 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x010\"} 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x810\"} 3 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x410\"} 4 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC10\"} 5 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x210\"} 6 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA10\"} 7 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x610\"} 8 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE10\"} 9 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Text {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xFD0\"} 0 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0AE9\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE90\"} HDMI 1 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2D58\"} HDMI 2 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D58\"} HDMI 3 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1D58\"} HDMI 4 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5D58\"} Video 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x030\"} Video 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x830\"} Video 3/Component 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x430\"} PC {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC30\"} Digital TV {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x25EE\"}","title":"IR Remote Codes Sony KDL-EX540"},{"location":"Codes-for-IR-Remotes/#ir-codes-tv-lg-55uh8509","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x20DF10EF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x20DF10EF} or with mosquitto_pub: mosquitto_pub -q 2 -t cmnd/sonoffIRBridge_1/IRSend -m '{\"protocol\": \"NEC\",\"bits\": 32, \"data\": 0x20DF10EF}' 0x20DF10EF=\"ON/OFF\" 0x20DF0FF0=\"TV\" 0x20DF9E61=\"Ratio\" 0x20DFD02F=\"Input\" 0x20DFA956=\"Energy\" 0x20DF8877=\"Key 1\" 0x20DF48B7=\"Key 2\" 0x20DFC837=\"Key 3\" 0x20DF28D7=\"Key 4\" 0x20DFA857=\"Key 5\" 0x20DF6897=\"Key 6\" 0x20DFE817=\"Key 7\" 0x20DF18E7=\"Key 8\" 0x20DF9867=\"Key 9\" 0x20DFCA35=\"List\" 0x20DF08F7=\"Key 0\" 0x20DF58A7=\"Q.View\" 0x20DF40BF=\"Vol+\" 0x20DFC03F=\"Vol-\" 0x20DFCE31=\"Vol-\" 0x20DF7887=\"Fav\" 0x20DF3BC4=\"3D\" 0x20DF906F=\"Mute\" 0x20DF00FF=\"P+\" 0x20DF807F=\"P-\" 0x20DFC23D=\"Settings\" 0x20DF55AA=\"Info\" 0x20DFA25D=\"Q.Menu\" 0x20DFE01F=\"Left\" 0x20DF609F=\"Right\" 0x20DF02FD=\"Up\" 0x20DF827D=\"Down\" 0x20DF22DD=\"OK\" 0x20DF14EB=\"Back\" 0x20DFD52A=\"Guide\" 0x20DFDA25=\"Exit\" 0x20DF4EB1=\"Red\" 0x20DF8E71=\"Green\" 0x20DFC639=\"Yellow\" 0x20DF8679=\"Blue\" 0x20DF04FB=\"Text\" 0x20DF847B=\"T.Opt\" 0x20DF9C63=\"Subtitle\" 0x20DF8D72=\"Stop\" 0x20DF0DF2=\"Play\" 0x20DF5DA2=\"Pause\" 0x20DFF10E=\"Backward\" 0x20DF718E=\"Forward\" 0x20DF7E81=\"Simplink\" 0x20DF8976=\"AD\" 0x20DF0CF3=\"AV Mode\" 0x20DF3EC1=\"Live TV\" 0x20DF42BD=\"Live TV\" 0x20DF35CA=\"Status\" 0x20DF50AF=\"Audio Language\" 0x20DF57A8=\"Shortmenu\" 0x20DF5AA5=\"AV\" 0x20DF5EA1=\"online manual\" 0x20DF619E=\"Volume to 50\" 0x20DF21DE=\"Volume to 80\" 0x20DFE11E=\"Volume to 100\" 0x20DF6B94=\"Radio/TV\" 0x20DF708F=\"doze function\" 0x20DFA35C=\"Display off\" 0x20DFD728=\"Standby\" 0x20DF23DC=\"Power on\" 0x20DFB44B=\"Settings of remote\" 0x20DF956A=\"Program guide\" 0x20DFF00F=\"Radio/TV\" 0x20DF738C=\"HDMI 1\" 0x20DF33CC=\"HDMI 2\" 0x20DF9768=\"HDMI 3\" 0x20DFFD02=\"Component\" 0x20DFF50A=\"Live Zoom\" 0x20DFF20D=\"Input info\" 0x20DFB24D=\"Picture mode\" 0x20DF09F6=\"Recordings\" 0x20DF4AB5=\"Audio mode\" 0x20DF7B84=\"Register magic remote\" 0x20DFAE51=\"directly register magic remote\" 0x20DF1CE3=\"Subtitles\" 0x20DFCC33=\"Presentation in shop\" 0x20DFBD42=\"Start recording\" 0x20DFAD52=\"LG TV Plus\" 0x20DFDD22=\"Sports mode\" 0x20DF1EE1=\"Search\" 0x20DFDF20=\"Warning: instart\" 0x20DF7F80=\"Warning: Poweronly\" 0x20DFFF00=\"Warning: Easy adjust\" 0x20DF5FA0=\"Warning: instop\" 0x20DF5FA0=\"Enter Password\" 0x20DF3FC0=\"Warning: Reset to factory\"","title":"IR Codes TV LG 55UH8509"},{"location":"Codes-for-IR-Remotes/#generic-veon-tv-eg-model-sro322016","text":"button code On/Off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEA857\"} Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE6897\"} Sleep {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE38C7\"} Source {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE48B7\"} Info {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE28D7\"} EPG {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEAA55\"} Vol+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FED827\"} Vol- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE58A7\"} Chan+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE9867\"} Chan- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE18E7\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE52AD\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FED22D\"} Rwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEE21D\"} FFd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE629D\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEA25D\"} Skip {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE22DD\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE807F\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE40BF\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEC03F\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE20DF\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEA05F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE609F\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEE01F\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE10EF\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE906F\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE00FF\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE8877\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE30CF\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEB04F\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEF00F\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE708F\"} OK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FE08F7\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FEC837\"}","title":"Generic VEON TV (eg model SRO322016)"},{"location":"Codes-for-IR-Remotes/#set-top-boxes","text":"","title":"Set-top Boxes"},{"location":"Codes-for-IR-Remotes/#ir-codes-for-vu-duo2","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":\"0x8052900C\"} Example IRsend Command: IRsend {\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":0x8052900C} 0xC8052900C=\"ON/OFF\" 0xC8052100D=\"Mute\" 0xC80529010=\"Vol+\" 0xC80521011=\"Vol-\" 0xC80529020=\"P+\" 0xC80529021=\"P+\" 0xC8052105A=\"Left\" 0xC8052905B=\"Right\" 0xC80529058=\"Up\" 0xC80529059=\"Down\" 0xC8052905C=\"OK\" 0xC80529054=\"Men\" 0xC8052906D=\"Red\" 0xC8052906F=\"Yellow\" 0xC8052906E=\"Green\" 0xC80529070=\"Blue\" 0xC8052902D=\"Play/Pause\" 0xC80529031=\"Stop\" 0xC80529028=\"Forward\" 0xC80529029=\"Back\" 0xC80529001=\"Key 1\" 0xC80529002=\"Key 2\" 0xC80529003=\"Key 3\" 0xC80529004=\"Key 4\" 0xC80529005=\"Key 5\" 0xC80529006=\"Key 6\" 0xC80529007=\"Key 7\" 0xC80529008=\"Key 8\" 0xC80529009=\"Key 9\" 0xC80529000=\"Key 0\" 0xC805290BB=\"Key <\" 0xC805290BC=\"Key >\" 0xC80529037=\"Record\" 0xC805290CC=\"EPG\" 0xC80529055=\"Exit\" 0xC805290E5=\"Audio\" 0xC805290F2=\"Radio\" 0xC805290E4=\"TV\" 0xC80521049=\"Context\" 0xC80529081=\"Help\"","title":"IR Codes for VU+ Duo2"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-appletv-gen4","text":"Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E15080\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13080\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E19080\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E16080\"} Ok {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13A80\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1C080\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1FA80\"} Home {\"Protocol\":\"NEC\",\"Bits\":0,\"Data\":\"0xFFFFFFFFFFFFFFFF\"}","title":"IR Remote Codes AppleTV Gen4"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-humax-hms-1000t-dvb-t2-dvr-pal-4-tune","text":"Power {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000800FF\"} TV Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D22D\"} Text {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087689\"} Wide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008728D\"} Play {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000816E9\"} Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000846B9\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A659\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000826D9\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C639\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088679\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E21D\"} Plus {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000842BD\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00086897\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008827D\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088877\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A857\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000848B7\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000828D7\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C837\"} Vol + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F807\"} Vol - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000802FD\"} Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000818E7\"} Home {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008708F\"} Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D827\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000808F7\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F00F\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000838C7\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B847\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000858A7\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087887\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C03F\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000820DF\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A05F\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008609F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E01F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000810EF\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008906F\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000850AF\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D02F\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000830CF\"} TV/Radio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B04F\"}","title":"IR Remote Codes Humax HMS-1000T DVB-T2 DVR PAL 4-Tune"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-fetchtv-minihybroad-h626t","text":"Power Toggle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BA45\"} Keyboard Select {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624CB3\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26627B84\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662DB24\"} TV Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266207F8\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662738C\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662936C\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E31C\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266213EC\"} Info {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26628B74\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26622CD3\"} Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662CC33\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266223DC\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662837C\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C33C\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26621CE3\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662AB54\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266227D8\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BB44\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662B34C\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624BB4\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266240BF\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C03F\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266220DF\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662A05F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662609F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E01F\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266210EF\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662906F\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266250AF\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662D02F\"}","title":"IR Remote Codes FetchTV Mini(Hybroad H626T)"},{"location":"Codes-for-IR-Remotes/#smart-receiver-vxcx","text":"button code on/off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\",\"DataLSB\":\"0x00FF0CF3\",\"Repeat\":0} mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\",\"DataLSB\":\"0x00FF0DF2\",\"Repeat\":0} FORMAT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF1CE3\",\"DataLSB\":\"0x00FF38C7\",\"Repeat\":0} 16:9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC13E\",\"DataLSB\":\"0x00FF837C\",\"Repeat\":0} AUDIO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFA05\",\"DataLSB\":\"0x00FF5FA0\",\"Repeat\":0} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\",\"DataLSB\":\"0x00FF01FE\",\"Repeat\":0} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\",\"DataLSB\":\"0x00FF02FD\",\"Repeat\":0} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\",\"DataLSB\":\"0x00FF03FC\",\"Repeat\":0} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\",\"DataLSB\":\"0x00FF04FB\",\"Repeat\":0} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\",\"DataLSB\":\"0x00FF05FA\",\"Repeat\":0} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\",\"DataLSB\":\"0x00FF06F9\",\"Repeat\":0} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\",\"DataLSB\":\"0x00FF07F8\",\"Repeat\":0} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\",\"DataLSB\":\"0x00FF08F7\",\"Repeat\":0} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\",\"DataLSB\":\"0x00FF09F6\",\"Repeat\":0} TV/R {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA25D\",\"DataLSB\":\"0x00FF45BA\",\"Repeat\":0} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\",\"DataLSB\":\"0x00FF00FF\",\"Repeat\":0} RECALL {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF19E6\",\"DataLSB\":\"0x00FF9867\",\"Repeat\":0} volume + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF5AA5\",\"DataLSB\":\"0x00FF5AA5\",\"Repeat\":0} volume - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDA25\",\"DataLSB\":\"0x00FF5BA4\",\"Repeat\":0} P - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFBA45\",\"DataLSB\":\"0x00FF5DA2\",\"Repeat\":0} P + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF3AC5\",\"DataLSB\":\"0x00FF5CA3\",\"Repeat\":0} red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEC13\",\"DataLSB\":\"0x00FF37C8\",\"Repeat\":0} green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF6C93\",\"DataLSB\":\"0x00FF36C9\",\"Repeat\":0} yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4CB3\",\"DataLSB\":\"0x00FF32CD\",\"Repeat\":0} blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF2CD3\",\"DataLSB\":\"0x00FF34CB\",\"Repeat\":0} MENU {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4AB5\",\"DataLSB\":\"0x00FF52AD\",\"Repeat\":0} BACK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF44BB\",\"DataLSB\":\"0x00FF22DD\",\"Repeat\":0} EXIT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB44B\",\"DataLSB\":\"0x00FF2DD2\",\"Repeat\":0} up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF04FB\",\"DataLSB\":\"0x00FF20DF\",\"Repeat\":0} left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8877\",\"DataLSB\":\"0x00FF11EE\",\"Repeat\":0} OK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEA15\",\"DataLSB\":\"0x00FF57A8\",\"Repeat\":0} right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF08F7\",\"DataLSB\":\"0x00FF10EF\",\"Repeat\":0} down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF847B\",\"DataLSB\":\"0x00FF21DE\",\"Repeat\":0} INFO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF34CB\",\"DataLSB\":\"0x00FF2CD3\",\"Repeat\":0} FAV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8679\",\"DataLSB\":\"0x00FF619E\",\"Repeat\":0} TXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF7A85\",\"DataLSB\":\"0x00FF5EA1\",\"Repeat\":0} EPG {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF06F9\",\"DataLSB\":\"0x00FF609F\",\"Repeat\":0} FR {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} REC {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF619E\",\"DataLSB\":\"0x00FF8679\",\"Repeat\":0} FF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF29D6\",\"DataLSB\":\"0x00FF946B\",\"Repeat\":0} PREV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF09F6\",\"DataLSB\":\"0x00FF906F\",\"Repeat\":0} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE916\",\"DataLSB\":\"0x00FF9768\",\"Repeat\":0} NEXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC936\",\"DataLSB\":\"0x00FF936C\",\"Repeat\":0} (none left) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4BB4\",\"DataLSB\":\"0x00FFD22D\",\"Repeat\":0} STOP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF718E\",\"DataLSB\":\"0x00FF8E71\",\"Repeat\":0} (none right) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} USB {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFB04\",\"DataLSB\":\"0x00FFDF20\",\"Repeat\":0} HELP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF54AB\",\"DataLSB\":\"0x00FF2AD5\",\"Repeat\":0} DVD {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDB24\",\"DataLSB\":\"0x00FFDB24\",\"Repeat\":0}","title":"Smart Receiver VX/CX"},{"location":"Codes-for-IR-Remotes/#bddvd-players","text":"","title":"BD/DVD players"},{"location":"Codes-for-IR-Remotes/#a-ir-remote-codes-sony-bd-s1500","text":"Common buttons should work across multiple models Eject {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x68B47\"} Power {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xA8B47\"} Red {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xE6B47\"} Green {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x16B47\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x96B47\"} Bue {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x66B47\"} Top Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x34B47\"} Popup/Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x94B47\"} Return {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC2B47\"} Options {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xFCB47\"} Home {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x42B47\"} Up {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x9CB47\"} Down {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x5CB47\"} Left {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xDCB47\"} Right {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x3CB47\"} Enter {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Favourites {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Netflix {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD2B47\"} Play {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x58B47\"} Pause {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x98B47\"} Rew {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD8B47\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x38B47\"} Prev {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xEAB47\"} Next {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x6AB47\"} Stop {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x18B47\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC6B47\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x26B47\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"}","title":"\u00e4 IR Remote Codes Sony BD-S1500"},{"location":"Codes-for-IR-Remotes/#projectors","text":"","title":"Projectors"},{"location":"Codes-for-IR-Remotes/#ir-remote-codes-acer-k132","text":"IR Remote Codes for Acer K132 projector (and possibly other models using a remote with Model No. M1820) ON/OFF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8E11E\"} * Freeze {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8718E\"} * Hide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8F10E\"} * Ratio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C806F9\"} * Zoom {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8D12E\"} * Mode {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C801FE\"} * Source {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C831CE\"} * Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C832CD\"} * Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C841BE\"} * Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8A15E\"} * Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C13E\"} * Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8817E\"} * Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8B24D\"} * Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C821DE\"} * Vol+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C639\"} * Vol- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C826D9\"} * Sound {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8AD52\"} * Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C88679\"}","title":"IR Remote Codes Acer K132"},{"location":"Codes-for-IR-Remotes/#soundbars","text":"","title":"Soundbars"},{"location":"Codes-for-IR-Remotes/#ir-codes-soundbar-panasonic-scall70t","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x40040500BCB9\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x40040500BCB9} 0x40040500BCB9=\"ON/OFF\" 0x400405004C49=\"Mute\" 0x400405000401=\"Vol+\" 0x400405008481=\"Vol-\" 0x40040538DFE2=\"OK\" 0x400405383F02=\"Up\" 0x40040538BF82=\"Down\" 0x40040538AD90=\"Setup\" 0x400405280D20=\"Sound\" 0x400405380538=\"Bluetooth\" 0x400405006164=\"Input\"","title":"IR Codes Soundbar Panasonic SCALL70T"},{"location":"Codes-for-IR-Remotes/#ir-codes-soundcore-infini-pro","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0xFD256897\"}} Example IRsend Command: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0xFD256897\"} 0xFD2502FD=\"ON/OFF\" 0xFD2518E7=\"Mute\" 0xFD2508F7=\"Input\" 0xFD259867=\"Bluetooth\" 0xFD2548B7=\"TV\" 0xFD256897=\"Vol+\" 0xFD2558A7=\"Vol-\" 0xFD258A75=\"Previous\" 0xFD250AF5=\"Next\" 0xFD25C837=\"Play/Pause\" 0xFD2554AB=\"Movie\" 0xFD255CA3=\"Music\" 0xFD2552AD=\"Voice\" 0xFD2532CD=\"Bass-\" 0xFD258877=\"Bass+\" 0xFD2538C7=\"Surround\"","title":"IR Codes Soundcore Infini Pro"},{"location":"Codes-for-IR-Remotes/#ir-codes-goodmans-gdsbt1000p","text":"Example received Code: RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x4FBD02F\",\"DataLSB\":\"0x20DF0BF4\",\"Repeat\":0}} Example IRsend Command: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x4FB30CF\"} 0x4FB30CF=\"ON/OFF\" 0x20DF08F7=\"Mute\" 0x20DF0FF0=\"Mode Bluetooth\" 0x20DF0AF5=\"Mode Optical\" 0x20DF16E9=\"Mode Coaxial\" 0x20DF07F8=\"Mode Line in\" 0x20DF09F6=\"Mode AUX\" 0x20DF06F9=\"Bluetooth Pairing\" 0x20DF10EF=\"Music\" 0x20DF0BF4=\"Movie\" 0x20DF14EB=\"Voice\" 0x20DF00FF=\"Treble +\" 0x20DF03FC=\"Treble -\" 0x20DF01FE=\"Bass +\" 0x20DF04FB=\"Bass -\" 0x20DF02FD=\"Volume +\" 0x20DF05FA=\"Volume -\" 0x20DF11EE=\"Previous\" 0x20DF12ED=\"Play/Pause\" 0x20DF13EC=\"Next\"","title":"IR Codes Goodmans GDSBT1000P"},{"location":"Codes-for-IR-Remotes/#vacuum-cleaners","text":"","title":"Vacuum Cleaners"},{"location":"Codes-for-IR-Remotes/#ir-codes-vacuum-cleaner-ecovacs-deebot-slim2","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFD02F\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x00FFD02F} 0x00FFD02F=\"Automatic Mode/Pause\" 0x00FF609F=\"Edge Cleaning\" 0x00FF40BF=\"Spot Cleaning\" 0x00FF708F=\"Back to Charging Base\" 0x00FFC837=\"Forward\" 0x00FFE01F=\"Left\" 0x00FFF00F=\"Right\" 0x00FFC03F=\"Back/Turn around\"","title":"IR Codes Vacuum Cleaner Ecovacs Deebot Slim2"},{"location":"Codes-for-IR-Remotes/#ventilation","text":"","title":"Ventilation"},{"location":"Codes-for-IR-Remotes/#ir-codes-prana-150-energy-recovery-ventilation","text":"See device https://prana.org.ua/models/prana_150 (Ukrainian) Example received Code: MQT: tele/sonoffir/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}=\"Power\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"}=\"Screen/LED Brightness\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\"}=\"Heat OFF\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"}=\"Heat ON\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF50AF\"}=\"Fan\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA857\"}=\"Anti freeze\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\"}=\"Night Mode\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF708F\"}=\"Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF28D7\"}=\"Fan +\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"}=\"Night Mode Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"}=\"Night Mode Fan +\"","title":"IR Codes Prana 150 energy recovery ventilation"},{"location":"Codes-for-IR-Remotes/#christmas-candle-weihnachtsbeleuchtung","text":"","title":"Christmas candle - Weihnachtsbeleuchtung"},{"location":"Codes-for-IR-Remotes/#krinner-lumix-ir-remote","text":"Remote control has two buttons and three channels. Button 1 is to switch on Button 0 is to switch off Double click on button 1 is flicker mode No usable protocol found yet, but raw mode does it. Example for HttpGetRequest and irsend sendHttpGetRequest(\"http://192.168.1.234/cm?cmnd=irsend5%200,2000,1000,%20400,1000,%20400,%20400,1000,1000,%20400,1000,%20400,%20400,1000,%20400,1000,%20400,1000,%20400,2000,5600\") off channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600 on channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600 flicker channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600 off channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600 off channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600","title":"Krinner Lumix IR Remote"},{"location":"Codes-for-IR-Remotes/#vinkor-flameless-flickering-candles-and-clones-probably","text":"on {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED00FF\",\"Repeat\":0} off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED40BF\",\"Repeat\":0} dim {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED08F7\",\"Repeat\":0} bright {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED48B7\",\"Repeat\":0} candle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED30CF\",\"Repeat\":0} light {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED708F\",\"Repeat\":0} 2H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED20DF\",\"Repeat\":0} 4H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED609F\",\"Repeat\":0} 6H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED10EF\",\"Repeat\":0} 8H {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10ED50AF\",\"Repeat\":0}","title":"Vinkor Flameless Flickering Candles (and clones probably)"},{"location":"Codes-for-IR-Remotes/#led-candles-led-kerzen","text":"","title":"LED Candles / LED Kerzen"},{"location":"Codes-for-IR-Remotes/#duni-warm-white-led-candle-duni-warmwei-led-kerzen","text":"ON= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} OFF= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"} 4h= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\"} 8h= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\"} ModeCandle= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\"} ModeLight= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\"} ModeDark= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"} ModeBright= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\"} ModeMoon= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"} ModeNightLight= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"}","title":"Duni Warm White LED Candle / Duni Warmwei\u00df LED Kerzen"},{"location":"Codes-for-IR-Remotes/#duni-multicoloured-led-candle-duni-mehrfarbige-led-kerzen","text":"ON_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F48B7\",\"DataLSB\":\"0x01FE12ED\"} OFF_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F807F\",\"DataLSB\":\"0x01FE01FE\"} ModeSmooth_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F58A7\",\"DataLSB\":\"0x01FE1AE5\"} ModeNightLight_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F7887\",\"DataLSB\":\"0x01FE1EE1\"} ModeCandle_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F40BF\",\"DataLSB\":\"0x01FE02FD\"} ModeLight_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FC03F\",\"DataLSB\":\"0x01FE03FC\"} ModeTimer_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F20DF\",\"DataLSB\":\"0x01FE04FB\"} ModeDark_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FA05F\",\"DataLSB\":\"0x01FE05FA\"} ModeBright_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F609F\",\"DataLSB\":\"0x01FE06F9\"} ColorRed_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FE01F\",\"DataLSB\":\"0x01FE07F8\"} ColorGreen_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F10EF\",\"DataLSB\":\"0x01FE08F7\"} ColorBlue_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F906F\",\"DataLSB\":\"0x01FE09F6\"} ColorOrange_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F50AF\",\"DataLSB\":\"0x01FE0AF5\"} ColorLightGreen_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FD827\",\"DataLSB\":\"0x01FE1BE4\"} ColorLightBlue_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FF807\",\"DataLSB\":\"0x01FE1FE0\"} ColorViolet_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F30CF\",\"DataLSB\":\"0x01FE0CF3\"} ColorYellow_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FB04F\",\"DataLSB\":\"0x01FE0DF2\"} ColorBlueWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F708F\",\"DataLSB\":\"0x01FE0EF1\"} ColorPink_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F00FF\",\"DataLSB\":\"0x01FE00FF\"} ColorYellowWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807FF00F\",\"DataLSB\":\"0x01FE0FF0\"} ColorWhite_COL= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x807F9867\",\"DataLSB\":\"0x01FE19E6\"}","title":"Duni Multicoloured LED Candle / Duni Mehrfarbige LED Kerzen"},{"location":"Codes-for-IR-Remotes/#fishtec-bougie-generic-multicolored-led-candle-generische-mehrfarbige-led-kerzen","text":"ON= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE48B7\"} OFF= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE58A7\"} ColorBlue= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE609F\"} ColorRed= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE20DF\"} ColorGreen= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FEA05F\"} ColorWhite= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE30CF\"} ColorTurkis= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE10EF\"} ColorOrange= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE50AF\"} ColorPink= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE708F\"} ColorPurple= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FEF807\"} ColorLightPurple= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE906F\"} ColorLightBlue= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FED827\"} ColorOceanBlue= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FEB04F\"} ModeMultiColor= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FEC03F\"} ModeSwitch= {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x1FE7887\"}","title":"Fishtec Bougie / Generic Multicolored Led Candle / Generische mehrfarbige LED Kerzen"},{"location":"Codes-for-IR-Remotes/#edifier-r1850db-ir-remote","text":"*MUTE: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7827D\",\"DataLSB\":\"0x10E741BE\",\"Repeat\":0} *+: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7609F\",\"DataLSB\":\"0x10E706F9\",\"Repeat\":0} *-: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7E21D\",\"DataLSB\":\"0x10E747B8\",\"Repeat\":0} *ON/OFF: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7629D\",\"DataLSB\":\"0x10E746B9\",\"Repeat\":0} *PC: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7E01F\",\"DataLSB\":\"0x10E707F8\",\"Repeat\":0} *AUX: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7906F\",\"DataLSB\":\"0x10E709F6\",\"Repeat\":0} *OPT: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7A25D\",\"DataLSB\":\"0x10E745BA\",\"Repeat\":0} *COX: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E7C03F\",\"DataLSB\":\"0x10E703FC\",\"Repeat\":0} *BT: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E73AC5\",\"DataLSB\":\"0x10E75CA3\",\"Repeat\":0} *<<: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E77887\",\"DataLSB\":\"0x10E71EE1\",\"Repeat\":0} *>||: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E77A85\",\"DataLSB\":\"0x10E75EA1\",\"Repeat\":0} *>>: {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x8E740BF\",\"DataLSB\":\"0x10E702FD\",\"Repeat\":0}","title":"Edifier R1850DB IR remote"},{"location":"Commands/","text":"Tasmota provides a powerful control interface using commands Commands can be issued using MQTT , web requests , webUI console and serial How to use commands ~ Every command used without a parameter (payload) returns the current setting . Power returns the status of first defined power output (usually Relay1) Instead of 0 you can use off or false and instead of 1 you can use on or true . Power ON turns first defined power output (usually Relay1) on Power1 1 also turns first defined power output (usually Relay1) on Power1 True also turns first defined power output (usually Relay1) on Replace <x> in a command with the appropriate index number. Leave it empty to use the first available. Power1 and Power both control first defined power output (usually Relay1) In commands with x..y value parameters use a number from x to y range. When a command mentions resetting to \"firmware default\" it means the setting will revert to the one in the flashed binary file. If you used user_config_override.h at compile time it will revert to those. Note All commands are standard in the form: COMMAND < INDEX > DATA It has only one SPACE between INDEX and DATA . (There is no command in Tasmota that allows the = sign) Example Set networking IP (XXX.XXX.XXX.XXX) addresses using the command IPAddress<x> : IPAddress1 192.168.1.123 The = sign (It can be understood as the sign : ) is used only for meaning explanation reference: IPAddress1 = set device IP address Note Beside results initiated by a command (synchronous) you can get asynchronous results initiated by rule trigger, telemetry event, commands from other source or changed device values. Simply put, other messages may precede messages published as a result of your commands. Example A tele/%topic%/STATUS message (sent every 300 seconds by default) may appear exactly after you issue Power off command and before you receive stat/%topic%/RESULT = {\"POWER\":\"OFF\"} message. with MQTT ~ To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued by using topic cmnd/%topic%/<command> and payload <parameter> where %topic% is the topic of the device you're sending the command to. If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . See MQTT article to find out more. with Web Requests ~ Commands can be executed via web (HTTP) requests, for example: http://<ip>/cm?cmnd=Power%20TOGGLE http://<ip>/cm?cmnd=Power%20On http://<ip>/cm?cmnd=Power%20off http://<ip>/cm?user=admin&password=joker&cmnd=Power%20Toggle Any spaces or special characters must be replaced with their ASCII hex codes . You must precede each hex code with % . Most used codes are: space = %20 and ; = %3B . Tip Use URLencoder.org to easily convert your commands. If you have set a password for web user interface access, this must be included (in plaintext) in the URL of the HTTP request, like so: http://<ip>/cm?user=<username>&password=<password>&cmnd=Power%20On in Console in the Web UI ~ Console menu in the web UI is a convenient place to send commands and it behaves similar to a terminal connection via serial bridge. Warning The GUI controls do not and can not have all the features and commands implemented. For precise and complete control use Console commands! over Serial Bridge ~ If you flashed the device via serial method you can connect to it with a terminal application (e.g. Termite or Arduino IDE Serial Monitor) to issue commands and follow responses. This is a practical way to do a Backlog setup of your new device. Serial interface is set to 115200 bps except for devices that require a different baud rate the Power of Backlog ~ Backlog command allows executing up to 30 consecutive commands with a single command line. Each command is separated by a semicolon (\";\"). Backlog is a useful feature to avoid numerous restarts when setting up a new device. You can use it to: Set up both Wi-Fi AP's Backlog SSID1 < myssid > ; Password1 < mypassword > ; SSID2 < myssid2 > ; Password2 < mypassword2 > Configure MQTT broker address, MQTT credentials, device topic and activate a few custom options Backlog MqttHost < yourhost > ; MqttUser < user > ; MqttPassword < password > ; Topic < customtopic > ; SetOption53 1 ; PowerRetain on For specific power control, using backlog like a script Backlog Status 1 ; Power2 on ; Delay 20 ; Power2 off ; Status 4 When using web requests (Don't forget to encode \"space\" as '%20' and \";\" as '%3B') http://<ip>/cm?user=admin&password=joker&cmnd=Backlog%20Power%20Toggle%3BPower1%20off A Backlog command without an argument clears an possible existing Backlog queue. Example in case of command Backlog Power1 OFF; Delay 600; Power1 ON the usage of an additional Backlog command without any argument within the delay time of 1 minute will delete the whole queue Power1 OFF; Delay 600; Power1 ON . Therefore Power1 ON command will not be executed and the power would remain off. Commands List ~ Warning If you're using Tasmota versions earlier current release some of the commands might not work. Availability of some features and their associated commands depend on the firmware build. Please consult the builds table for a reference of which features are available for each firmware variant. Note Almost all settings using string parameters (except Rule and MqttFingerprint ) share a common area with max 698 chars, i.e. the total length of all these parameters is limited to this size (you will be noted if this limit is exceeded). Control ~ Command Parameters Backlog List of commands to be executed in sequence separated by ; See Using Backlog for examples. Backlog0 List of commands to be executed without any delay in sequence separated by ; See Using Backlog for examples. BlinkCount Number of relay toggles ( blinks ) (does not control the status LED) 0 = blink many times before restoring power state 1..32000 = set number of blinks (default = 10 ) BlinkTime 2..3600 set duration, in 0.1 second increments, to blink aka toggle Power (does not control the status LED) ButtonDebounce User control over button debounce timing 40..1000 = set button debounce time in milliseconds (default = 50 ) Buzzer 0 = stop active buzzer cycle <count>,<beep>,<silence>,<tune> = read more... 2,3 = Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 = Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds -1 = infinite mode -2 = follow LED mode BuzzerActive SetOption67 iFan03 Buzzer control 0 = disable Sonoff iFan03 buzzer (default) 1 = enable Sonoff iFan03 buzzer BuzzerPwm SetOption111 0 = (default) 1 = use frequency output for buzzer pin instead of on/off signal, for piezo buzzers DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group name and restart.\\ If a device group name is not set for a group, the MQTT group topic ( GroupTopic ) is used (with the device group number appended for device group numbers > 1). DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract), ^ (invert), & (bitwise AND) or | (bitwise OR). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. To indicate that an item should not be shared with the group until changed again, prefix the value with N. 3 = Light fade (0 = Off, 1 = On) 4 = Light speed (1..40) 5 = Light brightness (0..255) 6 = Light Scheme 7 = Light fixed color (0 = white (using CT channels), other values according to Color ) 8 = PWM dimmer low preset (0..255) 9 = PWM dimmer high preset (0..255) 10 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 129 = No Status Share - DevGroupShare bitmask indicating which items should not be shared until changed. 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) or hex color value (#RRGGBB, #RRGGBBWW, etc.) Examples: DevGroupSend 5=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 5=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. DevGroupSend 224=NFF0000 - set the color to red locally and inform the group that light channel information is not to be shared until changed. DevGroupSend 129=@\\|18 - do not share light brightness or channel status until changed. DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members. DevGroupTie<x> <relay> = Tie the relay to the device group <x>. Only applies when option 88 is enabled. FanSpeed Fan speed control (iFan02/iFan03 only) 0 = turn fan OFF 1..3 = set fan speed + = increase fan speed - = decrease fan speed Interlock Relay interlock mode and group selection. 0 = disable relay interlock for all relays (i.e., each relay is self-locking) (default) 1 = set interlock mode for selected relays Add up to 8 relays in 1 to 4 interlock groups, each separated by a space. For example 1,2 3,4 = Group Relay1 and Relay2 in group 1 and Relay3 and Relay4 in group 2 ( note the space between the two groups ) 1,2,3 = group Relay1, Relay2 and Relay3 in a single interlock group 1 3 2,4 = Relay1 is in group 1, Relay3 in group 2, Relay2 and Relay4 in group 3 Json Input any command as valid JSON {<Tasmota commands>} example: cmnd/tasmota/json {\"HSBColor\":\"360,100,100\",\"Scheme\": 1,\"Dimmer\": 10,\"CT\": 220} LedMask Set a bitmask specifying which relays control the LED indicator. Read more... <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. LedPower LED power state as on or off 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 8 2 = toggle LED and set LedState 0 (Use Backlog LedPower 0; SetOption31 1 to disable LED even when Wi-Fi or MQTT is not connected) LedPower<x> LED<x> power state control. Enabled only when LedLink(i) is configured 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 0 2 = toggle LED and set LedState 0 LedState Manage LED state 0 = disable use of LED as much as possible 1 = show power state on LED (LED on when power on) (default) (inverted for Sonoff Touch/T1) 2 = show MQTT subscriptions as a LED blink 3 = show power state and MQTT subscriptions as a LED blink 4 = show MQTT publications as a LED blink 5 = show power state and MQTT publications as a LED blink 6 = show all MQTT messages as a LED blink 7 = show power state and MQTT messages as a LED blink 8 = LED on when Wi-Fi and MQTT are connected. Cannot be issued directly and is only activated when LedPower is switched from 0 to 1 due to a software function NoDelay Delay defined by SetOption34 is omitted for any command in a backlog sequence following immediately after NoDelay This must be used with care, and only for simple commands. Example Power0 Control the power state simultaneously for all power outputs on the device 0 / off = turn OFF 1 / on = turn ON 2 / toggle = if relay is ON switch to OFF and vice versa Power<x> Control the corresponding power state ( 1..8 ) (also restarts PulseTime)<x> 0 / off / false = turn OFF 1 / on / true = turn ON 2 / toggle = if power state is ON switch to OFF and vice versa 3 / blink = toggle power for BlinkCount times each BlinkTime duration (at the end of blink , power state is returned to pre-blink state) 4 / blinkoff = stop blink sequence and return power state to pre-blink state PowerOnState Control power state when the device is powered up . More information 0 / OFF = keep power(s) OFF after power up 1 / ON = turn power(s) ON after power up 2 / TOGGLE = toggle power(s) from last saved state 3 = switch power(s) to their last saved state (default) 4 = turn power(s) ON and disable further power control 5 = after a PulseTime period turn power(s) ON (acts as inverted PulseTime mode) PulseTime<x> Display the amount of PulseTime remaining on the corresponding Relay<x>(x = 0..31 ) <value> Set the duration to keep Relay<x> ON when Power<x> ON command is issued. After this amount of time, the power will be turned OFF . 0 / OFF = disable use of PulseTime for Relay<x> 1..111 = set PulseTime for Relay<x> in 0.1 second increments 112..64900 = set PulseTime for Relay<x>, offset by 100, in 1 second increments. Add 100 to desired interval in seconds, e.g., PulseTime 113 = 13 seconds and PulseTime 460 = 6 minutes (i.e., 360 seconds) Note if you have more than 8 relays: Defined PulseTime for relays <1-8> will also be active for correspondent Relay <9-16>. SwitchDebounce User control over switch debounce timing and method 40..1000 = set switch debounce time in milliseconds (default = 50 ) . The granularity is 10 milliseconds, so the normally unnecessary last digit is used by the debouncing code to flag special handling: 0 = no special handling 1 = force_high: only a debounce time long LOW pulse could turn the switch off 2 = force_low: only a debounce time long HIGH pulse could turn the switch on 3 = force_high + force_low 4..8 = unused 9 = AC detection for switches / relays similar to MOES MS-104B / BlitzWolf SS5 etc. If the AC frequency is 50 Hz, SwitchDebounce 69 will turn on the switch after three pulses and off after three missing one. SwitchMode<x> Switch mode 0 = toggle (default) 1 = follow (0 = off, 1 = on) 2 = inverted follow (0 = on, 1 = off) 3 = pushbutton (default 1, 0 = toggle) 4 = inverted pushbutton (default 0, 1 = toggle) 5 = pushbutton with hold (default 1, 0 = toggle, Hold = hold) 6 = inverted pushbutton with hold (default 0, 1 = toggle, hold = hold) 7 = pushbutton toggle (0 = toggle, 1 = toggle) 8 = multi change toggle (0 = toggle, 1 = toggle, 2x change = hold) 9 = multi change follow (0 = off, 1 = on, 2x change = hold) 10 = inverted multi change follow (0 = on, 1 = off, 2x change = hold) 11 = pushbutton with dimmer mode 12 = inverted pushbutton with dimmer mode 13 = pushon mode (1 = on, switch off using PulseTime ) 14 = inverted pushon mode (0 = on, switch off using PulseTime ) 15 = send only MQTT message on switch change (Example tele/tasmota/SENSOR = {\"Time\":\"2021-01-01T00:00:00\",\"Switch1\":\"OFF\"} ) SwitchText<x> Show current JSON label of Switch<x> ( 1..8 ). Only SwitchText shows value for all 8 switches <text> - replace default Switch<x> label in JSON messages with a custom text WebButton<x> Change the name of the toggle buttons of the WEB UI. This command accepts spaces in the name WebQuery<x> Command for GET, POST, PUT, and PATCH HTTP queries, complete with Request Headers and request body (when applicable) <url> GET|POST|PUT|PATCH [<headers>] <body> More information... See also SetOption1 - Set button multipress mode SetOption11 - Swap pushbutton single and double press functionality SetOption13 - Allow immediate action on single button press SetOption26 - Use indexes even when only one relay is present SetOption31 - Disable Wi-Fi LED status blinking SetOption32 - Set hold interval before sending HOLD action SetOption40 - Stop detecting any input change on button GPIO SetOption67 - Enable/Disable Buzzer SetOption73 - Decouple buttons from controlling power outputs Management ~ Command Parameters Delay 2..3600 = set a delay between two backlog commands with 0.1 second increment. Not recommended for precision timing! DeepSleepTime Time to enter deep sleep mode 0 = disable deep sleep mode (default) 11..86400 = set deep sleep mode time period in seconds DeviceName Device name displayed in the webUI and used for HA autodiscovery. <value> = set device name (default = FriendlyName1 value) Emulation 0 = disable emulation (default) 1 = enable Belkin WeMo emulation for Alexa 2 = enable Hue Bridge emulation for Alexa FriendlyName<x> 1 = Reset friendly name to firmware default <value> = set friendly name (32 char limit) Gpios Show list of available components by name and index 255 / All Show list of all components by name and index Gpio Show current component assignments of the Module's configurable GPIO 255 / All Show component assignments for all the devices available GPIO Gpio<x> <component> = assign a component to Gpio<x> I2Cscan Scan I 2 C bus and show addresses for found devices I2CDriver Enable / Disable I 2 C sensor drivers. Read more... LogHost 1 = reset syslog host to firmware default ( SYS_LOG_HOST ) <value> = set syslog host LogPort 1 = reset syslog port to firmware default ( SYS_LOG_PORT ) 2..32766 = set syslog port Modules Show available modules by name and index Module Displays active module by name and index <value> = switch to module <value> and restart 0 = switch to defined template and restart Module2 Displays active fast reboot fallback module by name and index <value> = set fast reboot fallback module to <value> 0 = set fast reboot fallback module to defined template MqttLog 0 = disable logging via MQTT (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messsages NtpServer<x> NTP server setup (x= 1..3 ) 0 = clear NtpServer<x> settings 1 = reset NtpServer<x> settings to firmware defaults <value> = set NtpServer<x> host or IP address (32 char limit) OtaUrl Display current OTA URL 1 = Reset OtaUrl to firmware default url = set address for OTA (100 char limit) Pwm<x> 0..1023 = set PWM value for channel (NOTE see SetOption15 ) PwmFrequency 1 = reset PWM frequency to 223Hz 40..4000 or 40..50000 = set PWM frequency (40Hz to 4kHz on ESP 82xx / 40-50kHz on ESP32) As of v8.3.0 the default frequency changed to 977Hz PwmRange 1 = reset maximum PWM range to 1023 255..1023 = set maximum PWM range Reset 1 = reset device settings to firmware defaults and restart (see warning below) 2 = erase flash, reset device settings to firmware defaults and restart 3 = erase System Parameter Area in flash (Wi-Fi calibration and related data) and restart (see warning below) 4 = reset device settings to firmware defaults but retain Wi-Fi credentials and restart 5 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi settings and restart 6 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi and MQTT settings and restart (Erase of flash can take a few seconds to complete and there is no output during the erase process on the serial or web console) 99 = reset device bootcount to zero For reset 3 and reset 1 , device must be power-cycled in order to load new Wifi System parameters. Restart 1 = restart device with configuration saved to flash 2 = halt system (needs hardware reset or power cycle to restart) 99 = force restart device without configuration save For debug and testing stack trace dumps only: -1 = force an Exception (28) crash -2 = force a Soft WDT reset (after a freeze of 2 seconds) -3 = force an OS watchdog reset (after a freeze of 120 seconds, caution! ) RtcNtpServer<x> Use Tasmota NTP server when enabled by define RTC_NTP_SERVER 0 = disabled 1 = enabled SaveData 0 = save parameter changes only manually, e.g. with Restart 1 1 = save parameter changes every second (default) 2..3600 = save parameter changes every x second SerialLog Disable hardware serial bridge and 0 = disable serial logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages SerialLog will be disabled automatically 10 minutes after the device reboots. SetSensor<x> Enable / Disable individual sensor driver(x= 1..127 ) Sleep 0 = turn sleep off 1..250 = set sleep duration in milliseconds to enable energy saving (default = 50 ) State Display current device state and publish to %prefix%/%topic%/RESULT topic\u2003 Status = show abbreviated status information 0 = show all status information (1 - 11) 1 = show device parameters information 2 = show firmware information 3 = show logging and telemetry information 4 = show memory information 5 = show network information 6 = show MQTT information 7 = show time information 8 = show connected sensor information (retained for backwards compatibility) 9 = show power thresholds (only on modules with power monitoring) 10 = show connected sensor information (replaces 'Status 8') 11 = show information equal to TelePeriod state message 12 = in case of crash to dump the call stack saved in RT memory Status0 0 = show all status information in a single line SysLog 0 = disable syslog logging (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messages Template Show current Template 0 = create template from active module x = create template from a supported module 255 = merge current module and template settings into new template { ... } = store template in a JSON payload Does not activate the template. To activate use Module 0 . Time 0 = enable NTP (default) 1 = format JSON message timestamp in ISO format 2 = format JSON message timestamp in both ISO and Epoch format 3 = format JSON message timestamp in Epoch format 4 = format JSON message timestamp in milliseconds <value> = disable NTP and set UTC time as epoch value if greater than 1451602800 (January 1, 2016) TimeStd TimeDst Set policies for the beginning of daylight saving time (DST) and return back to standard time (STD)\u2003 Use the Tasmota timezone table to find the commands for your time zone. 0 = reset parameters to firmware defaults H , W , M , D , h , T H = hemisphere ( 0 = northern hemisphere / 1 = southern hemisphere) W = week ( 0 = last week of month, 1..4 = first .. fourth) M = month ( 1..12 ) D = day of week ( 1..7 1 = Sunday 7 = Saturday) h = hour ( 0..23 ) in local time T = time zone ( -780..780 ) (offset from UTC in MINUTES - 780min / 60min=13hrs) Example: TIMEDST 1,1,10,1,2,660 _If time zone is NOT 99, DST is not used (even if displayed) see Timezone -13..+13 = set time zone offset from UTC in hours -13:00..+13:00 = set time zone offset from UTC in hours and minutes 99 = use time zone configured with TimeDst and TimeStd Use the Tasmota time zone table to find the commands for your time zone. Ufs Universal File System commands read more... UfsDelete Delete SD card or Flash FS file if only of them available UfsDelete2 Delete only Flash FS file if available UfsFree Filesystem free size in kb UfsRename Rename SD card or Flash FS file if only of them available UfsRename2 Rename only Flash FS file if available UfsRun Run file UfsSize Filesystem size in kb UfsType Get filesystem type 0 = none 1 = SD card 2 = Flash file 3 = LittleFS Upgrade 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if <value> is higher than device version Upload 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if <value> is higher than device version WebGetConfig <url> = pull a configuration .dmp file from a HTTP URL More information... WebLog 0 = disable web logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages WebTime <start_pos>,<end_pos> = show part of date and/or time in WebUI based on \"2017-03-07T11:08:02-07:00\" See also SetOption68 - PWM Channel control SetOption76 - DeepSleep disable bootcount incrementing Wi-Fi ~ Command Parameters AP 0 = switch to other Wi-Fi Access Point 1 = select Wi-Fi Access Point 1 2 = select Wi-Fi Access Point 2 CORS \" = disable CORS (Cross Origin Resource Sharing) (default) * = enable CORS for all locations value = Enable CORS for location. This needs to be complete url ex: http://tasui.shantur.com Hostname 1 = reset hostname to MQTT_TOPIC-<4digits> and restart <value> = set hostname (32 char limit) and restart. If hostname contains % it will be reset to the default instead. See FAQ for allowed characters. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. IPAddress<x> Set networking IP ( XXX.XXX.XXX.XXX ) addresses IPAddress1 to set device IP address 0.0.0.0 to use dynamic IP address (DHCP) XXX.XXX.XXX.XXX to set static IP address IPAddress2 to set gateway IP address IPAddress3 to set subnet mask IPAddress4 to set DNS server IP address IPAddress5 to set Secondary DNS server IP address follow IPAddress commands with restart 1 to apply changes Password<x> <x> = 1..2 <value> = set AP<x> Wi-Fi password and restart 1 = reset AP<x> Wi-Fi password to firmware default ( STA_PASS1 or STA_PASS2 ) and restart Passwords are limited to 64 characters. Do not use special characters or white spaces in the password . Note that Password and Password1 are equivalent commands. Ping<x> <addr> <x> = 0..8 = the number of ICMP packets to send, 0 uses the default (4) <addr> = address to send Ping, either in numerical format 192.168.1.200 or domain name tasmota.com (requires #define USE_PING ) Example Ping4 192.168.1.203 : RSL: tele/tasmota_xxx/RESULT = {\"Ping\":{\"192.168.1.203\":{\"Reachable\":true,\"Success\":4,\"Timeout\":0,\"MinTime\":59,\"MaxTime\":167,\"AvgTime\":116}}} Ssid<x> <x> = 1..2 <value> = set AP<x> Wi-Fi SSID and restart 1 = reset AP<x> Wi-Fi SSID to firmware default ( STA_SSID1 or STA_SSID2 ) and restart SSID are limited to 32 characters. Do not use special characters or white spaces in the SSID TCPBaudRate Requires GPIOs TCP Tx and TCP Rx and can work with hardware or software serial. 1200..115200 = set the baudrate for serial (only 8N1 mode) TCPConnect , <port> = Port used for connection = IP address to connect to TCPConfig <value> = standard 3 characters mode such as 8N1, 7E1, etc ... TCPStart Requires GPIOs TCP Tx and TCP Rx and can work with hardware or software serial. Also works with ModBus Bridge <port>, [<ipaddress>] = Start listening to port. If <ipaddress> is defined only allows connections from the provided IPv4 address 0 = Shut down TCP server and disconnect any existing connection Supports 2 parallel TCP connections, which can be useful if you need a terminal + a specific protocol (like XMODEM). The 3rd connection will disconnect a previous connection. The number of parallel connections is a compile-time option. WebColor<x> Configure Web GUI colors (x = 1..19 ) #RRGGBB = Set color for WebColor<x> 1 = Global text (Black) 2 = Global background (White) 3 = Form background (Greyish) 4 = Input text (Black) 5 = Input background (White) 6 = Console text (Black) 7 = Console background (White) 8 = Warning text (Red) 9 = Success text (Green) 10 = Button text (White) 11 = Button (Blueish) 12 = Button hovered over (Darker blue-ish) 13 = Restart/Reset/Delete button (Red-ish) 14 = Restart/Reset/Delete button hover (Darker red-ish) 15 = Save button (Green-ish) 16 = Save button hover (Darker greenish) 17 = Config timer tab text (White) 18 = Config timer tab background (Light grey) 19 = Module title and FriendlyName text (Whiteish) User themes WebPassword Show current web server password 0 = disable use of password for web UI 1 = reset password to firmware default ( WEB_PASSWORD ) <value> = set web UI password (32 char limit) for user WEB_USERNAME (Default WEB_USERNAME = admin ) WebQuery Send HTTP GET, POST, PUT, and PATCH Requests <url> <method> [<header1Name:header1Value\\|header2Name:header2Value...>]<body> <url> = HTTP URL to query <method> = HTTP Request method. Must be GET , POST , PUT , or PATCH [<header1Name:header1Value\\|header2Name:header2Value...>] (optional) = HTTP Request Headers. <body> (optional) = HTTP Request Body. Ignored for GET requests Examples WebQuery http://www.mysite.com/api/status GET : Simple HTTP GET Request WebQuery http://www.mysite.com/api/update POST [Authorization:Bearer xyz\\|Content-Type:application/json]{\"message\":\"body\"} : Sends POST data with an authorization header and Content-Type WebQuery http://www.mysite.com/api/set PUT {\"message\":\"body\"} : Sends PUT request with a body, but no headers WebRefresh Web page refresh 1000..10000 = set refresh time in milliseconds (default = 2345 ) WebSend Send a command to Tasmota host over http. If a command starts with a / it will be used as a link. [<host>:<port>,<user>:<password>] <command> <host> = hostname or IP address. <port> = port for the device if not the default 80 <user> = enter username of the device you're sending the command to <password> = enter password of the device you're sending the command to <command> = command and payload example 1: [<ip>] POWER1 ON sends http://<ip>/cm?cmnd=POWER1 ON example 2: WebSend [myserver.com] /fancy/data.php?log=1234 sends http://myserver.com/fancy/data.php?log=1234 WebGetConfig <url> Download a configuration (*.dmp) from an http URL. The URL can include %id% which will be substituted by the device's MAC address without the dots. A possible usage for ones that compile their own binary is to include the command in USER_BACKLOG for automatic reconfiguration after a reset 1 command. WebSensor<x> Control display of sensor telemetry in the web UI 0 = Do not display sensor's telemetry 1 = Display sensor's telemetry ( default ) <x> = number corresponding to the sensor - listed in the sns section of the supported sensor spreadsheet <x> = 3 Energy telemetry Issue a Status 4 to obtain a list of sensor types enabled in the firmware loaded on the device. WebServer 0 = stop web server 1 = start web server in user mode 2 = start web server in admin mode Wifi 0 = disable Wi-Fi 1 = enable Wi-Fi (default) ESP8266 only: 2 = Wi-Fi mode 802.11b 3 = Wi-Fi mode 802.11b/g 4 = Wi-Fi mode 802.11b/g/n When wifi is Off it is always returned On after a restart except for a wake-up from deepsleep. WifiConfig 0 = disable Wi-Fi Manager and reboot (used with alternate AP) 2 = set Wi-Fi Manager as the current configuration tool and start Wi-Fi Manager (web server at 192.168.4.1) for 3 minutes, then reboot and try to connect Wi-Fi network 4 = retry other AP without rebooting (default) 5 = wait until selected AP is available again without rebooting 6 = Wi-Fi parameters can only be entered via commands in the serial console 7 = set Wi-Fi Manager (web server at 192.168.4.1) as the current configuration tool restricted to reset settings only. This setting is recommended for devices without an external control/reset button . \u2003 No longer supported 1 = set SmartConfig ( Android /iOS) for 3 minutes 3 = set WPS for 3 minutes WifiPower set Wi-Fi transmit power level in decibel-milliwatts (dBm) (default = 17 ) WifiScan 1 = start a network scan. Results will be sent as a JSON payload. Read more... WifiTest<x> Test whether the Wi-Fi SSId and Password are correct and Tasmota can connect to the network. <x> = 0..2 0 = test credentials, if successful save them in SSID slot 1, restart Tasmota 1 = test credentials, if successful save them in SSID slot 1 without restart 2 = test credentials, if successful save them in SSID slot 2 without restart ssid+password = credentials used for testing, + symbol is the separator since it is not allowed in an SSId name.* Read more... See also SetOption55 - mDNS service control SetOption56 - Wi-Fi network scan to select strongest signal on restart SetOption57 - Wi-Fi network re-scan, alternate AP MQTT ~ Command Parameters ButtonRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on button press ButtonTopic <value> = set MQTT button topic 0 = disable use of MQTT button topic 1 = set MQTT button topic to device %topic% 2 = reset MQTT button topic to firmware default ( MQTT_BUTTON_TOPIC ) (default = 0 ) If using MQTT to issue this command, if it is published to the device GroupTopic , the command will not be executed. FullTopic 1 = reset MQTT fulltopic to firmware default ( MQTT_FULLTOPIC ) and restart <value> = set MQTT fulltopic and restart. Use of optional %prefix%, %topic%, %hostname%, and %id% substitution tokens is allowed. If using MQTT to issue this command, if it is published to the device GroupTopic , you must ensure uniqueness of the resulting fulltopic on each destination device by using one or more of these substitution tokens. GroupTopic<x> 1 = reset MQTT group <x> topic to firmware default ( MQTT_GRPTOPIC ) and restart <value> = set MQTT group <x> topic and restart InfoRetain 0 = disable use of info MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/INFO<x> MqttClient 1 = reset MQTT client to firmware config ( MQTT_CLIENT_ID ) and restart <value> = set MQTT client and restart. You can use the %06X substitution token to replace with last six characters of MAC address. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. MqttFingerprint TLS needs to be enabled in firmware for this command \u2003 <value> = set current fingerprint as 20 space separated bytes (59 chars max) MqttHost 0 = clear MQTT host field and allow mDNS to find MQTT host 1 = reset MQTT host to firmware default ( MQTT_HOST ) and restart <value> = set MQTT host and restart (do NOT use .local ) MqttKeepAlive 1..100 = set MQTT Keep Alive timer (default = 30 ) MqttPassword 0 = clear MQTT password 1 = reset MQTT password to firmware default ( MQTT_PASS ) and restart <value> = set MQTT password and restart (min 5 chars) MqttPort 1 = reset MQTT port to firmware default ( MQTT_PORT ) and restart <value> = set MQTT port between 2 and 32766 and restart MqttRetry 10..32000 = set MQTT connection retry timer in seconds (default = 10 ) MqttTimeout 1..100 = set MQTT socket timeout (default = 4 ) MqttUser 0 = clear MQTT user name 1 = reset MQTT user name to firmware default ( MQTT_USER ) and restart <value> = set MQTT user name and restart MqttWifiTimeout 100..20000 = set MQTT Wi-Fi connection timeout in milliseconds (default = 200 ) PowerRetain MQTT power retain state 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update Prefix1 1 = reset MQTT command subscription prefix to firmware default ( SUB_PREFIX ) and restart <value> = set MQTT command subscription prefix and restart Prefix2 1 = reset MQTT status prefix to firmware default ( PUB_PREFIX ) and restart <value> = set MQTT status prefix and restart Prefix3 1 = Reset MQTT telemetry prefix to firmware default ( PUB_PREFIX2 ) and restart <value> = set MQTT telemetry prefix and restart Publish <topic> <payload> = MQTT publish any topic and optional payload\u2003 Publish2 <topic> <payload> = MQTT publish any topic and optional payload with retain flag SensorRetain 0 = disable use of sensor MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/SENSOR StateRetain 0 = disable use of state MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/STATE StateText<x> <value> = set state text ( <x> = 1..4 ) 1 = OFF state text 2 = ON state text 3 = TOGGLE state text 4 = HOLD state text SwitchRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on switch press Subscribe Subscribes to an MQTT topic without appended /# and assigns an Event name to it. <eventName>, <mqttTopic> [, <key>] = Read more... = list all topics currently subscribed Subscribe2 Subscribes to an MQTT topic and assigns an Event name to it. <eventName>, <mqttTopic> [, <key>] = Read more... = list all topics currently subscribed SwitchTopic <value> = set MQTT switch topic 0 = disable use of MQTT switch topic 1 = set MQTT switch topic to device %topic% 2 = reset MQTT switch topic to firmware default ( MQTT_SWITCH_TOPIC ) (default = 0 ) Read more about this. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. TelePeriod See current value and force publish STATE and SENSOR message 0 = disable telemetry messages 1 = reset telemetry period to firmware default ( TELE_PERIOD ) 10..3600 = set telemetry period in seconds (default = 300 ) Topic 1 = reset MQTT topic to firmware default ( MQTT_TOPIC ) and restart <value> = set MQTT topic and ButtonTopic and restart. When using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. Topic can not be identical to MqttClient Unsubscribe Unsubscribe from topics subscribed to with Subscribe = unsubscribe all topics <eventName> = unsubscribe from a specific MQTT topic See also SetOption3 - Disable//Enable MQTT SetOption4 - Return MQTT response as RESULT or %COMMAND% topic SetOption10 - Main topic change behavior SetOption104 - Disable MQTT retained messages (some brokers don't support them) Rules ~ Command Parameters Add<x> <value> = add value to Var<x> ( example ) CalcRes Current calculation resolution 0..7 = set number of decimal places to be used in Add , Sub , Mult and Scale Event Execute an event to trigger a rule as documented \u2003 Mem<x> Manage up to 16 variables stored on flash (x = 1..16 ) Mem returns all current values. Mem<x> returns the variable's current value. <value> = store a string value in a variable \" = clear stored value in Mem<x> Mult<x> <value> = multiply value to Var<x> ( example ) Rule<x> Rules. Read more... 0 = disable Rule<x> 1 = enable Rule<x> 2 = toggle Rule<x> 4 = disable one-shot detection (perform commands as long as trigger is met) 5 = enable one-shot (e.g., sometimes used for slow changing sensors like temperature) detection 6 = toggle one-shot detection 8 = disable stop-on-error after exception restart 9 = enable stop-on-error after exception restart 10 = toggle stop-on-error after exception restart <value> = define Rule<x> +<value> = append to Rule<x> \" = clear Rule<x> Rule set one-shot: Each rule within the rule set will trigger only once until the trigger condition returns to a false condition. For example, ON Energy#Power<3 : Without one-shot enabled, it will trigger anytime Energy#Power gets an update (i.e., the Power telemetry value changes) and the value is <3 . This can potentially trigger that rule multiple times. With one-shot enabled, the rule will trigger only the on the first transition to <3 and not again until the trigger value goes >=3 . In other words, the rule will trigger again, but it has to cross the conditional \"boundary\" before it will trigger again. Rule0 Same functionality as Rule<x> but affects all rulesets at once RuleTimer<x> Up to eight timers to be used as countdown event (x = 1..8 )\u2003 0..65535 = set countdown rule timer in seconds RuleTimer0 0 = stops and clear all timer simultaneously Scale<x> Scale value from a low and high limit to another low and high limits and save in Var<x> ( example ) v = value: the number to scale fl = fromLow: the lower bound of the value\u2019s current range fh = fromHigh: the upper bound of the value\u2019s current range tl = toLow: the lower bound of the value\u2019s target range th = toHigh: the upper bound of the value\u2019s target range Sub<x> <value> = subtract value to Var<x> ( example ) Var<x> Manage up to 16 variables stored in memory (x = 1..16 ) Var returns all current values. Var<x> returns the variable's current value. <string> = store a string value in a variable \" = clear stored value in Var<x> Timers ~ Command Parameters Latitude <value> = set latitude in decimal degrees format, e.g. -33.893681 Longitude <value> = set longitude in decimal degrees format, e.g. 18.619954 Timers Timers control 0 = disable all timers 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x> 1..16 = copy Timer<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table Information on sensors documented below is transmitted in the Tasmota telemetry message Sensors ~ Command Parameters AdcParam<x> ADC analog input tuning parameters. On ESP32 x is channel 1..8 <sensor>, <param1>, <param2>, <param3>, <param4> complete <sensor> values listed here... Altitude -30000..30000 = altitude in meters AmpRes Current sensor resolution 0..3 = maximum number of decimal places BH1750Resolution<x> BH1750 resolution mode. x = BH1750 sensor number ( 1..2 ) 0..2 = choose sensor resolution ( 0 = high (default) , 1 = high2, 2 = low) BH1750MTime<x> BH1750 Measurement Time value. x = BH1750 sensor number ( 1..2 ) 30..255 = set Measurement Time value. Not persistent after reboot. (default = 69 ) Counter<x> 0 = reset Counter<x> 1..2,147,483,645 = preset Counter<x> -1..-2,147,483,645 = decrease Counter<x> +1..+2,147,483,645 = increase Counter<x> In order to define and use a Counter, * you must configure one of the free device GPIO as Counter<x> . Counter module configuration is using internal pull-up resistor while Counter n does not. * CounterDebounce 0 = turn off counter debounce 1..32000 = set counter debounce time in milliseconds. Counter is increased with every falling edge when CounterType =0 or time between successive falling edges is measured when CounterType =1. When CounterDebounceLow and CounterDebounceHigh are set to zero (default) only falling edges of the counter's GPIO are checked. Any CounterDebounceLow or CounterDebounceHigh unequal zero checks are carried out before CounterDebounce check is done. As an example you can set CounterDebounce 500 to allow a minimum distance between to successive valid falling edges equal to 500ms. CounterDebounceLow 0 = turn off counter debounce low 1..32000 = set counter debounce low time in milliseconds. Allow individual debounce times for low pulse widths to discard non valid falling edges. These are checked before legacy CounterDebounce checks distance between two valid falling edges. When unequal zero tasmota will check falling and rising edges on the counter's GPIO. For CounterDebounceLow any GPIO change from low to high hat happens after the GPIO was not low for at least CounterDebounceLow will be ignored. As an example you can set CounterDebounceLow 50 to allow a valid minimum distance between a falling and rising edge equal to 50ms while having a final CounterDebounce 500 check between to successive valid falling edges equal to 500ms. CounterDebounceHigh 0 = turn off counter debounce high 1..32000 = set counter debounce high time in milliseconds. Allow individual debounce times for high pulse widths to discard non valid falling edges. These are checked before legacy CounterDebounce checks distance between two valid falling edges. When unequal zero tasmota will check falling and rising edges on the counter's GPIO. For CounterDebounceHigh any GPIO change from high to low hat happens after the GPIO was not high for at least CounterDebounceHigh will be ignored. As an example you can set CounterDebounceHigh 100 to allow a valid minimum distance between a rising and falling edge equal to 100ms while having a final CounterDebounce 500 check between to successive valid falling edges equal to 500ms. CounterType<x> 0 = set Counter<x> as pulse Counter 1 = set Counter<x> as pulse Timer GlobalHum 0.0..100.0 = Set global Humidity for some Sensors that uses global Humidity. GlobalHum2 1..250 = select Global Humidity source indexed from teleperiod occurence data. GlobalPress2 1..250 = select Global Pressure source indexed from teleperiod occurence data. GlobalTemp -50.0..100.0 = Set global Temperature for some Sensors that uses global temperature. GlobalTemp2 1..250 = select Global Temperature source indexed from teleperiod occurence data. HumOffset -10.0..10.0 = Set calibration offset value for reported humidity telemetry This setting affects all humidity sensors on the device. HumRes Humidity sensor resolution 0..3 = maximum number of decimal places PressRes Pressure sensor resolution 0..3 = maximum number of decimal places NPCLRes Neopool only <value> = number of digits in results for CL values NPIonRes Neopool only <value> = number of digits in results for ION values NPPHRes Neopool only <value> = number of digits in results for PH values Sensor12 ADS1115 mode selection (default S0 ). Note that Vdd (2.0-5.5v) must be >= analog voltage inputs. D0 .. D5 = differential modes S0 .. S5 = single-ended modes 0 = +/- 6.144v 1 = +/- 4.096v 2 = +/- 2.048v 3 = +/- 1.024v 4 = +/- 0.512v 5 = +/- 0.256v Sensor13 INA219 and ISL28022 low voltage current sensor configuration Predefined modes to use with standard 0.1 ohm resistor: 0 = set INA219 calibration to max 32V and 2A 1 = set INA219 calibration to max 32V and 1A 2 = set INA219 calibration to max 16V and 0.4A In all cases, ISL28022 is set to 60V mode 10 .. 255 : Define custom shunt resistor encoded as a decimal number RRM such that Rshunt = RR * 10^M milliohm Do not forget to choose a resistor adapted for the correct power dissipation and apply a 50% security margin ! Examples: 11 = 1 * 10^1 = 10 milliohm (Imax=32A => Pres=15W) 21 = 2 * 10^1 = 20 milliohm (Imax=16A => Pres=7W) 12 = 1 * 10^2 = 100 milliohm (default, Imax=3.2A => Pres=2W) 13 = 1 * 10^3 = 1000 milliohm = 1 ohm (Imax=0.320A => Pres=0,2W) The driver seamlessly detect INA219/ISL28022 and adapt configuration and readings accordingly. The component label in Web GUI and SENSOR message will automatically match the detected part. It is possible to mix INA219 and ISL28022 as far as addresses do not conflicts. Shunt resistor setting applies to all INA219/ISL28022. Sensor15 Automatic Baseline Correction for MH-Z19B CO 2 sensor 0 = disable 1 = enable (default) 2 = start manual calibration from 400 ppm of CO 2 9 = reset sensor to factory defaults 1000 = sets measurement range to 1000ppm CO 2 2000 = sets measurement range to 2000ppm CO 2 3000 = sets measurement range to 3000ppm CO 2 5000 = sets measurement range to 5000ppm CO 2 10000 = sets measurement range to 10000ppm CO 2 Sensor18 PMSx003 particle dust sensor 0..32000 = control sensor polling interval to extend lifetime Sensor20 Nova Fitness SDS011 dust sensor. 1..255 = number of seconds before TelePeriod to poll the sensor Sensor27 APDS-9960 sensor commands 0 = enable light level and proximity sensor / disable gestures (default) 1 = enable gesture mode/ disable light level and proximity sensor 2 = enable gestures with half gain / disable light and proximity sensor 3..255 = Set ATIME register for different integration times Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration. Read more... Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup|outstate{,repmode}} Continue reading... Sensor34 HX711 load cell sensor calibration 1 = reset display to 0 2 = start calibration 2 <value> = set reference weight in grams and start calibration 3 = show reference weight in grams 3 <value> = set reference weight in grams 4 = show calibrated scale value 4 <value> = set calibrated scale value 5 = show max weight in gram 5 <value> = set max weight in grams 6 = show single item weight in grams 6 <value> = set single item weight in grams. Once the item weight is set, when items are added to the scale, the telemetry message will report Count as the number of items on the scale 7 = save current weight to be used as start weight on restart 8 0/1 \u2003 0 = disable JSON message on weight change over 4 grams \u2003 1 = enable JSON message on weight change (see below) 9 <value> = set minimum delta to trigger JSON message (see above). \u2003 0 = 4 grams (old default) \u2003 1..100 = set delta to 0-99 grams \u2003 101-255 = set delta to 110-1650 grams (10g increments) Sensor50 PAJ7620 gesture sensor 0 = sensor muted, no readings in Tasmota 1 = gesture mode 2 = proximity mode 3 = corner mode 4 = PIN mode 5 = cursor mode Sensor52 iBeacon driver with HM10 or HM17/HM16 1 and 2 = required only once to initialize the module u<x> = sets update interval in seconds (scan tags every <x> seconds) (default = 10) t<x> = set timeout interval in seconds (send RSSI=0 if tag is not detected after <x> seconds) (default = 30) d1 = enable debug mode (shows all serial traffic in console) d0 = disable debug mode_(default = 30)_ c = clears iBeacon list s AT+<command> = send native AT commands Sensor53 Smart Meter Interface r = reset the driver with a new descriptor specified with the Tasmota Scripting language. c<x> <value> = preset counter (x = 1..5 ) to value when the driver is set to counter mode d<x> = disable data decoding and dump meter (x = 1..5 ) data to the Console. This is used to decipher the meter's data format to define the variable encoding in the meter's descriptor. d0 = disable data dump mode and revert to decoding mode. l<x> = monitor the serial activity at a GPIO with a connected LED. x = GPIO of the LED. l255 = disable monitoring (default) m<x> = serial meter number (x = 1..5 ) to be monitored m0 = monitor all serial meters (default) Sensor54 INA226 Current Sensor 1 = rescan for devices and return the number found. 2 = save the configuration and restart 10 = return channel 1 shunt resistance and full scale current 11 <resistance> = set INA226 channel 1 shunt in ohms, floating point 12 <current> = set INA226 channel 1 full scale in amperes, floating point 20 = return channel 2 shunt resistance and full scale current 21 <resistance> = set INA226 channel 2 shunt in ohms, floating point 22 <current> = set INA226 channel 2 full scale in amperes, floating point 30 = return channel 1 shunt resistance and full scale current 31 <resistance> = set INA226 channel 1 shunt in ohms, floating point 32 <current> = set INA226 channel 1 full scale in amperes, floating point 40 = return channel 1 shunt resistance and full scale current 41 <resistance> = set INA226 channel 1 shunt in ohms, floating point 42 <current> = set INA226 channel 1 full scale in amperes, floating point Sensor60 GPS 0 = write to all available sectors, then restart and overwrite the older ones 1 = write to all available sectors, then restart and overwrite the older ones 2 = filter out horizontal drift noise 3 = turn off noise filter 4 = start recording, new data will be appended 5 = start new recording, old data will lost 6 = stop recording, download link will be visible in webUI 7 = send mqtt on new position + TELE (consider to set TELE to a very high value) 8 = only TELE message 9 = start NTP server 10 = deactivate NTP server 11 = force update of Tasmota-system-UTC with every new GPS-time-message 12 = do not update of Tasmota-system-UTC with every new GPS-time-message 13 = set latitude and longitude in settings 14 = open virtual serial port over TCP, usable for u-center 15 = pause virtual serial port over TCP Sensor68 WindMeter sensor - Analog (pulse count) anemometer 1, <value> = set radius length in millimeters (measured from center to the edge of one of the cups) 0..65535 (default = 61 mm) 2, <value> = set number of pulses for a complete turn 1..255 (default = 1 ) 3, <value> = set pulse counter debounce time in milliseconds 1..32000 (default = 10 ) 4, <value> = set speed compensation factor, a multiplication coefficient to adjust resulting speed -32.768..32.767 three decimal places (default = 1.180 ) 5, <value> = set minimum percentage change between current and last reported speed trigger a new tele message 0..100 , 255 = off (default = 255 ) Sensor78 EZO sensors - commands Ascii commands are sent directly to the sensor as-is. See your specific EZO device datasheet for the list of commands available. By default, the specific command is sent to all EZO devices that are found. If using multiple EZO sensors, and the command should be issued to a single device, the index can be specified as part of the command: Sensor78-# where # represent the index of the device (ex: Sensor78-1 i). For more details please see Tasmota's support for EZO devices . Sensor80 Set antenna gain for MFRC522 RFID Reader. Sensor80 1 <0..7> 0 18dB 1 23dB 2 18dB 3 23dB 4 33dB 5 38dB 6 43dB 7 48dB Sensor90 Send commands to Hydreon RG-15 Rain Sensor A Reads accumulation data R Read all available data K Restart the rain sensor P Set to polling only mode (not supported) C Set to continuous mode, where data is sent when accumulation changes (default) H Force high resolution L Force low resolution I Force imperial (not supported) M Force metric (default) S Revert to jumper configured values O Reset the accumulation counter SpeedUnit TX20/TX23 and WindMeter anemometer speed unit 1 = m/s 2 = km/h 3 = kn 4 = mph 5 = ft/s 6 = yd/s TempRes Temperature sensor resolution 0..3 = maximum number of decimal places TempOffset -12.6..12.6 = Set calibration offset value for reported temperature telemetry This setting affects all temperature sensors on the device. VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places WeightRes Load cell sensor resolution 0..3 = maximum number of decimal places Wiper DS3502 contains a single potentiometer whose wiper position is controlled by the value in the Wiper Register (WR) represented by x = 0..3 POTI 0..127 = set POTI for wiper x STATUS = get wiper position for wiper x RESET = reset settings for wiper x See also SetOption8 - Show temperature in Celsius (default) or Fahrenheit SetOption18 - Set status of signal light paired with CO 2 sensor SetOption24 - Set pressure units Power Monitoring ~ Command Parameters AmpRes Current sensor resolution 0..3 = maximum number of decimal places CurrentCal 1000..32000 (default = 3500 ) Set calibration offset value for reported Current telemetry Allows finer calibration for energy monitoring devices CurrentHigh 0 = disable current high threshold (default) <value> = set current high threshold value in milliamps CurrentLow 0 = disable current low threshold (default) <value> = set current low threshold value in milliamps CurrentSet <value> = calibrate current to target value in mA EnergyExport<x> Export energy values <x> = meter number (default is 1 ) EnergyExportActive<x> ADE7880 only! Set/reset energy active values <x> = meter number (default is 1 ) EnergyToday<x> Set Energy Today values, parameters: <x> = meter number (default is 1 ) <value> = set new value in Wh, 0 for reset <time> = 0..4294967295 set StartTotalTime time as epoch value (optional 2nd parameter) EnergyTotal<x> Set or set Energy Total values, parameters: <x> = meter number (default is 1 ) <value> = set new value in Wh, 0 for reset <time> = 0..4294967295 set StartTotalTime time as epoch value (optional 2nd parameter) The new value represents start of day, and output for total includes the today value. EnergyReset<x> x = 1..5 1 <value>{,<time>} = ((p)re)set values 2 <value>{,<time>} = ((p)re)set values for Yesterday 3 <value>{,<time>} = ((p)re)set values for Total <value> = 0..42949672 in watt-hours (Wh) <time> = 0..4294967295 set StartTotalTime time as epoch value 4 <standard> {, <off-peak> } = ((p)re)set tariff period values for Totals 5 <standard> {, <off-peak> } = ((p)re)set tariff period values for Exported With version 10, this command has been replaced, see above. EnergyRes Energy sensor resolution 0..5 = maximum number of decimal places EnergyYesterday<x> Set Energy Yesterday values, parameters: <x> = meter number (default is 1 ) <value> = set new value in Wh, 0 for reset <time> = 0..4294967295 set StartTotalTime time as epoch value (optional 2nd parameter) EnergyUsage Set energy usage values, parameters: <value> = set energy usage value, 0 for reset FreqRes Frequency sensor resolution 0..3 = maximum number of decimal places FrequencySet <value> = calibrate frequency to a target value in Hz MaxPower 0 = disable use maximum power monitoring <value> = set maximum allowed power in watts MaxPowerHold 1 = set default time to 10 seconds to stay over MaxPower before power off <value> = set time in seconds to stay over MaxPower before power off MaxPowerWindow 1 = set default time to 30 seconds to stay power off before re-applying power up to 5 times <value> = set time in seconds to stay power off before re-applying power up to 5 times ModuleAddress Set the address of a PZEM module 1..3 = the last octet of the PZEM-004T serial address <address> = the last octet of the address on MODBUS PZEM energy monitoring modules Prior to setting the module address, the PZEM must be connected to both RX and TX, and AC voltage. Connect one PZEM at a time and issue this command. Repeat for each PZEM to be connected for multi-phase monitoring. The command without an argument cannot be used to read the address of the connected PZEM. PowerCal 1000..32000 (default = 12530 ) Set calibration offset value for reported Power telemetry reading Allows finer calibration for energy monitoring devices PowerDelta<x> Set maximum delta of phase a<x> in energy monitoring devices to report on active power load change while the power is ON. PowerDelta will not report when the power turns off.\u2003 0 = disable reporting on power change 1..100 = set reporting on percentage power change to send an MQTT telemetry message 101..32000 = set reporting on absolute power change to send an MQTT telemetry message (offset by 100, e.g., 101 =1W, 207 =107W) PowerHigh 0 = disable power high threshold (default) <value> = set power high threshold value in watts to send an MQTT telemetry message PowerLow 0 = disable power low threshold (default) <value> = set power low threshold value in watts to send an MQTT telemetry message PowerSet <value> = calibrate power to a target value in watts\u2003 Status 8 = show power usage 9 = show power thresholds Tariff<x> P1 Smart Meter tariff configuration x = 1, 2, 9 1 STD,DST Start times for off-peak tariff 2 STD,DST End times for off-peak tariff 9 0/1 \u2003 0 = use Start/End times also on weekends. \u2003 1 = use off-peak tariff all weekend. STD and DST may be specified as: \u2003 <hour> = 0..23 or \u2003 <time> = 00:00..23:59 or \u2003 <minutes> = 0..1439 (since midnight) If both Tariff1 STD and Tariff2 STD are equal, all tariffs are disabled. VoltageCal Set calibration offset value for reported Voltage telemetry reading 1000..32000 (default = 1950 ) Allows finer calibration for energy monitoring devices VoltageHigh 0 = disable voltage high threshold (default) <value> = set voltage high threshold value in V VoltageLow 0 = disable voltage low threshold (default) <value> = set voltage low threshold value in V VoltageSet <value> = calibrate voltage to a target value in V\u2003 VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places See Also SetOption21 - Energy monitoring when power is off SetOption33 - Configure power monitoring Max_Power_Retry count number SetOption39 - Control handling of invalid power measurements SetOption72 - Set reference used for total energy SetOption129 - Enable separate energy meters Light ~ Command Parameters AlexaCTRange SetOption82 Reduce the CT range from 153..500 to 200..380 to accommodate with Alexa range 0 = CT ranges from 153 to 500 (default) 1 = CT ranges from 200 to 380 (although you can still set in from 153 to 500) Channel<x> 0..100 = set PWM channel dimmer value from 0 to 100%\u2003 + = increase by 10 - = decrease by 10 When SetOption68 is set to 1 Channel<x> will follow Power<x> numbering with Relays first then PWM. Example : 2 Relays and 3 PWM: Relay1 = Power1 ; Relay2 = Power2 ; PWM1 = Power3 and Channel3 ; PWM2 = Power4 and Channel4 ; PWM3 = Power5 and Channel5 ChannelRemap SetOption37 Color remapping for led channels, also provides an option for allowing independent handling of RGB and white channels. Setting changes require a device reboot. 0 = disable 1..119 = according to this table 120..127 = invalid (results in same as 0 ) 128..255 = same as 0..127 but with independent channel handling enabled Color<x> x = 1..6 \u2003 1 = Set color \u2003 2 = Set color adjusted to current Dimmer value \u2003 3 = Set clock seconds hand color ( Scheme 5 only) \u2003 4 = Set clock minutes hand color ( Scheme 5 only) \u2003 5 = Set clock hour hand color ( Scheme 5 only) \u2003 6 = Set clock hour marker color <value> r,g,b = set color by decimal value ( 0..255 ) #CWWW = set hex color value for CT lights #RRGGBB = set hex color value for RGB lights #RRGGBBWW = set hex color value for RGBW lights #RRGGBBCWWW = set hex color value for RGBCCT lights (5 PWM channels) Note : Just append an = instead of the remaining color codes, this way they wont get changed. For example a command like Color #00ff= would update the RGB part to disable red and enable green, but would omit to update blue or any white channel. Set color to 1 = red 2 = green 3 = blue 4 = orange 5 = light green 6 = light blue 7 = amber 8 = cyan 9 = purple 10 = yellow 11 = pink 12 = white (using RGB channels) + = next color - = previous color CT 153..500 = set color temperature from 153 (cold) to 500 (warm) for CT lights + = increase CT value by 10 - = decrease CT value by 10 CTRange Specify CT range of the bulb. The slider will still allow to set CT from 153 to 500, but the rendering will be done within the new range. <ct_min>,<ct_max> = set color temperature from 153 (cold) to 500 (warm) for CT lights default = 153,500 This settings is not persisted in flash Dimmer 0..100 = set dimmer value from 0 to 100% + = increase by DimmerStep value (default = 10 ) - = decrease by DimmerStep value (default = 10 ) Use of these parameters with Fade on enables dimmer level \"move down,\" \"move up,\" and \"stop\" commands ( #11269 ) < = decrease to 1 > = increase to 100 ! = stop any dimmer fade in progress at current dimmer level Dimmer<x> Commands available only when SetOption37 >= 128 ( #6819 ) <value> same as in Dimmer Dimmer0 <value> = set dimming for all channels Dimmer1 <value> = set dimming for RGB channels Dimmer2 <value> = set dimming for white channels Dimmer4 <value> = allow retaining brightness ratio between white and color channels when setting dimmer for linked lights DimmerRange Change dimming range. <dimmerMin>,<dimmerMax> = set the internal dimming range from minimum to maximum value (0..255, 0..255) Does not change Dimmer command behavior DimmerStep 1..50 - set Dimmer +/- step value. (default = 10 ) Fade 0 = do not use fade (default) 1 = use fade See also SetOption91 HsbColor <hue>,<sat>,<bri> = set color by hue, saturation and brightness HsbColor1 0..360 = set hue HsbColor2 0..100 = set saturation HsbColor3 0..100 = set brightness L1MusicSync Only for Sonoff L1 (Lite) and Spider Z LED controllers <power,sensitivity,speed> \u2003 power = 0 - off, 1 - on, 2 - toggle \u2003 sensitivity = 1..10 ( default: 5 ) \u2003 speed = 1..100 ( default: 50 ) Can be used with only power argument Led<x> #RRGGBB = set hex color value where <x> is the pixel number of the LED. A blank-delimited list of colors sets multiple successive pixels. (applies only to addressable LEDs) LedPwmMode<x> Control status LED light mode (x = 0..4 ) 0 = digital on/off mode (default) 1 = PWM mode 2 = toggle between modes LedPwmOff 0..255 = set LED brightness when OFF LedPwmOn 0..255 = set LED brightness when ON LedTable 0 = do not use LED gamma correction (default \u00ab6.5.0.9) 1 = use gamma correction (default \u00bb6.5.0.9) MultiPwm SetOption68 Multi-channel PWM instead of a single light 0 = Treat PWM as a single light (default) 1 = Treat PWM as separate channels. In this mode, use Power<x> to turn lights on and off, and Channel<x> to change the value of each channel. Color still works to set all channels at once. Requires restart after change Palette 0 = Clear color palette [ ...] = Set list of colors used by Color<1,2> and Scheme<2,3,4> commands with each color separated by a space. The palette setting is not saved to flash. Use a boot-time rule such as ON System#Boot DO Palette xxxxx ENDON to set it back at each restart. Pixels 1..512 = set amount of pixels in strip or ring and reset Rotation (applies only to addressable LEDs) PowerOnFade SetOption91 Enable Fade at boot and power on. By default fading is not enabled at boot because of stuttering caused by wi-fi connection 0 = don't Fade at startup (default) 1 = Fade at startup PWMCT SetOption92 Alternative to Module 38 : for Cold/Warm white bulbs, enable the second PWM as CT (Color Temp) instead of Warm White, as required for Philips-Xiaomi bulbs. 0 = normal Cold/Warm PWM (default) 1 = Brightness/CT PWM See PWM CT in Lights RGBWWTable Control light intensity of unbalanced PWM channels PWM1,PWM2,PWM3,PWM4,PWM5 = channel range with values 0..255 (default = 255,255,255,255,255 ) Range adjustment is computed after Gamma correction. Rotation <value> = set amount of pixels to rotate (up to Pixels value) (applies only to addressable LEDs) Scheme Light effects + = next scheme - = previous scheme 0 = single color for LED light (default) 1 = start wake up sequence (same as Wakeup ) 2 = cycle up through colors using Speed option 3 = cycle down through colors using Speed option 4 = random cycle through colors using Speed and Fade Use <value>, <startcolor> if you want to set the starting color of selected scheme Following schemes are usable only with addressable LEDs, e.g. WS281X, Neopixel 5 = clock mode ( example ) 6 = candlelight pattern 7 = RGB pattern 8 = Christmas pattern 9 = Hanukkah pattern 10 = Kwanzaa pattern 11 = rainbow pattern 12 = fire pattern 13 = stairs pattern Speed 1..40 = set fade speed from fast 1 to very slow 40 + = increase speed - = decrease speed The Speed value represents the time in 0.5s to fade from 0 to 100% (or the reverse). Example: Speed 4 takes 2.0s to fade from full brightness to black, or 0.5s to move from 75% to 100%. Speed2 Same as Speed but settings aren't stored. ! = can be used to cancel the use of a preceding Speed2 command. Use example... StepPixels ( Scheme 5 only) <value> = define the number of LEDs in each step VirtualCT Precisely specify color rendering of the bulb for Color Temperature. Needs SetOption106 1 and works for 3, 4 or 5 channel lights {\"<minct>\":\"<color1>\",\"midct\":\"<color2>\",\"maxct\":\"<color3\"} Example: VirtualCT {\"200\":\"FFFFFF0000\",\"400\":\"000000FF00\"} The first and last CT values indicate the min and max CT and are equivalent to CTRange . Read more... This settings is not persisted in flash Wakeup Start wake up sequence from OFF to stored Dimmer value 0..100 = Start wake up sequence from OFF to provided Dimmer value WakeupDuration 1..3000 = set wake up duration in seconds White 1..100 = set white channel brightness in single white channel lights (single W or RGBW lights) WhiteBlend SetOption105 White Blend Mode 0 = disable (default) 1 = enable Width<x> x = 1..4 1 = 0..4 = LED group width ( Scheme 6..12 only) 2 = 0..32 = seconds hand width ( Scheme 5 only) 3 = 0..32 = minutes hand width ( Scheme 5 only) 4 = 0..32 = hour hand width ( Scheme 5 only) See also SetOption15 , SetOption16 , SetOption17 , SetOption20 , SetOption37 , SetOption68 and SetOption107 Device Groups ~ Command Parameters DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group <x> name and restart. Prior to 8.2.0.3, GroupTopic was used to specify the device group name. DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract) or ^ (invert). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. 2 = Light fade (0 = Off, 1 = On) 3 = Light speed (1..40) 4 = Light brightness (0..255) 5 = Light Scheme 6 = Light fixed color (0 = white (using CT channels), other values according to Color ) 7 = PWM dimmer low preset (0..255) 8 = PWM dimmer high preset (0..255) 9 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members. SetOptions ~ Tip Instead of typing SetOption you can use shorter form of SO . so instead of SetOption19 1 you can use SO19 1 Command Parameters SetOption0 Save power state and use after restart (=SaveState) 0 = disable (see note below) 1 = enable (default) Note: Power state means on/off state of eg. relays or lights. Other parameters like color, color temperature, brightness, dimmer, etc. are still saved when changed. To disable saving other parameters see SaveData . SetOption1 Set button multipress mode to 0 = allow all button actions (default) 1 = restrict to single to penta press and hold actions (i.e., disable inadvertent reset due to long press) SetOption2 Set display of global temperature/humidity/pressure info to JSON sensor message 0 = disable (default) 1 = enable SetOption3 MQTT 0 = disable MQTT 1 = enable MQTT (default) SetOption4 Return MQTT response as 0 = RESULT topic (default) 1 = %COMMAND% topic SetOption8 Show temperature in 0 = Celsius (default) 1 = Fahrenheit SetOption10 When the device MQTT topic changes 0 = remove retained message on old topic LWT (default) 1 = send \"Offline\" to old topic LWT SetOption11 Swap button single and double press functionality 0 = disable (default) 1 = enable SetOption12 Configuration saving to flash option 0 = allow dynamic flash save slot rotation (default) 1 = use fixed eeprom flash slot SetOption13 Allow immediate action on single button press 0 = single, multi-press and hold button actions (default) 1 = only single press action for immediate response (i.e., disable multipress detection). Disable by holding for 4 x button hold time (see SetOption32 ). SetOption15 Set PWM control for LED lights 0 = basic PWM control 1 = control with Color or Dimmer commands (default) SetOption16 Set addressable LED Clock scheme parameter 0 = clock-wise mode (default) 1 = counter-clock-wise mode SetOption17 Show Color string as 0 = hex string (default) 1 = comma-separated decimal string SetOption18 Set status of signal light paired with CO 2 sensor 0 = disable light (default) 1 = enable light The light will be green below CO2_LOW and red above CO2_HIGH (transition yellow/orange between). The default levels are: 800ppm for low and 1200ppm for high but these can be set in user_config_override.h . SetOption19 Tasmota discovery protocol used in Home Assistant Tasmota integration 0 = enable Tasmota discovery (default) 1 = use deprecated MQTT discovery (only with #define USE_HOME_ASSISTANT , does not exist in release binaries) SetOption20 Update of Dimmer/Color/CT without turning power on 0 = disable (default) 1 = enable SetOption21 Energy monitoring when power is off 0 = disable (default) 1 = enable SetOption24 Set pressure units 0 = hPa (default) 1 = mmHg SetOption26 Use indexes even when only one relay is present 0 = messages use POWER (default) 1 = messages use POWER1 SetOption28 RF received data format 0 = hex (default) 1 = decimal SetOption29 IR received data format 0 = hex (default) 1 = decimal SetOption30 Enforce Home Assistant auto-discovery as light 0 = relays are announced as a switch and PWM as a light (default) 1 = both relays and PWM are announced as light SetOption31 Set status LED blinking during Wi-Fi and MQTT connection problems. LedPower must be set to 0 for this feature to work 0 = Enabled (default) 1 = Disabled SetOption32 Number of 0.1 seconds to hold button before sending HOLD action message. 1..100 to set button hold time (default = 40 ) . This option also affects the time required to perform a firmware defaults reset (10x HOLD action time). There is no firmware reset on using the HOLD action with shutterbuttons. SetOption33 Number of seconds for which the maximum power limit can be exceeded before the power is turned off 1..250 = set number of seconds (default = 5 ) SetOption34 0..255 = set Backlog inter-command delay in milliseconds (default = 200 ) SetOption36 Boot loop defaults restoration control. 0 = disable boot loop control 1..200 = set number of boot loops (a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME (default 10 seconds) before beginning to restore settings (default = 1 ) . Once this number is reached, subsequent restarts will: 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI 2 nd restart: disable rules causing boot loop 3 rd restart: disable all rules (and autoexec.bat ) 4 th restart: reset user defined GPIOs to disable any attached peripherals 5 th restart: reset module to Sonoff Basic (1) SetOption38 6..255 = set IRReceive protocol detection sensitivity minimizing UNKNOWN protocols SetOption39 Control handling of invalid power measurements. Read more... 0 = reset to default on next restart 1..255 = number of invalid power readings before reporting no load (default = 128 ) . SetOption40 Stop detecting input change on the button GPIO. Solves #5449 Active only when SetOption1 1 and SetOption13 0 . This disables all long press functionality. 0..250 = button hold time in 0.1 seconds after which button functionality is disabled. (default = 1 ) Example: Backlog SetOption1 1; SetOption13 0; SetOption40 10 = discard any button press over 1 second SetOption41 0 = Disable ARP <x> = Force sending gratuitous ARP (Wi-Fi keep alive) every <x> seconds (default = 60 ) If <x> is below 100 it is the number of seconds, if <x> is above 100 , it is the number of minutes after substracting 100. Ex: 105 is every 5 minutes, while 90 is every 90 seconds. SetOption42 0..255 = set over-temperature (Celsius only) threshold resulting in power off on all energy monitoring devices (default = 90 ) SetOption43 0..255 = to control Rotary step. Details #10407 SetOption44 1..100 = set base tolerance percentage for matching incoming IR messages (default = 25 ) SetOption45 1..250 = change bi-stable latching relay pulse length in milliseconds (default = 40 ) SetOption51 Enable GPIO9 and GPIO10 component selections in Module Configuration WARNING Do not use on ESP8266 devices! 0 = disable (default) 1 = enable SetOption52 Control display of optional time offset from UTC in JSON payloads 0 = disable (default) 1 = enable SetOption53 Display hostname and IP address in GUI 0 = disable (default) 1 = enable SetOption54 Apply SetOption20 settings to commands from Tuya device 0 = disable (default) 1 = enable SetOption55 mDNS service 0 = disable (default) 1 = enable SetOption56 Wi-Fi network scan to select strongest signal on restart (network has to be visible) 0 = disable (default) 1 = enable SetOption57 Wi-Fi network re-scan every 44 minutes with alternate to +10dB stronger signal if detected (only visible networks) 0 = disable 1 = enable (default) SetOption58 IR Raw data in JSON payload 0 = disable (default) 1 = enable SetOption59 Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands: State , Power and any command causing a light to be turned on. 0 = disable (default) 1 = enable SetOption60 Set sleep mode 0 = dynamic sleep (default) 1 = normal sleep SetOption61 Force local operation when ButtonTopic or SwitchTopic is set. 0 = disable (default) 1 = enable SetOption62 Set retain on Button or Switch hold messages 0 = disable (default) 1 = don't use retain flag on HOLD messages SetOption63 Set relay state feedback scan at restart ( #5594 , #5663 ) 0 = Scan power state at restart (default) 1 = Disable power state scanning at restart SetOption64 Switch between - or _ as sensor name separator 0 = sensor name index separator is - (hyphen) (default) 1 = sensor name index separator is _ (underscore) Affects DS18X20, DHT, BMP and SHT3X sensor names in tele messages SetOption65 Device recovery using fast power cycle detection 0 = enabled (default) 1 = disabled SetOption66 Set publishing TuyaReceived to MQTT 0 = disable publishing TuyaReceived over MQTT (default) 1 = enable publishing TuyaReceived over MQTT SetOption69 Deprecated in favor of DimmerRange By default Tuya dimmers won't dim below 10% because some don't function very well that way. 0 = disable Tuya dimmer 10% lower limit 1 = enable Tuya dimmer 10% lower limit (default) SetOption71 Set DDS238 Modbus register for active energy 0 = set primary register (default) 1 = set alternate register SetOption72 Set reference used for total energy 0 = use firmware counter (default) 1 = use energy monitor (e.g., PZEM-0xx, SDM120, SDM630, DDS238, DDSU666) hardware counter SetOption73 Detach buttons from relays and send multi-press and hold MQTT messages instead 0 = disable (default) 1 = enable Example message: {\"Button1\":{\"Action\":\"SINGLE\"}} SetOption74 Enable internal pullup for single DS18x20 sensor 0 = disable (default) 1 = internal pullup enabled SetOption75 Set grouptopic behaviour ( #6779 ) 0 = GroupTopic using FullTopic replacing %topic% (default) 1 = GroupTopic is cmnd/%grouptopic%/ SetOption76 Boot count incrementing when DeepSleep is enabled ( #6930 ) 0 = disable boot count incrementing (default) 1 = enable boot count incrementing SetOption77 Do not power off if a slider is moved to far left 0 = disable (default) 1 = enable SetOption78 OTA compatibility check 0 = enabled (default) 1 = disabled SetOption79 Reset counters at TelePeriod time 0 = disable (default) 1 = enable SetOption80 Blinds and shutters support 0 = disable blinds and shutters support (default) 1 = enable blinds and shutters support SetOption81 Set PCF8574 component behavior for all ports 0 = set as regular state (default) 1 = set as inverted state SetOption82 Reduce the CT range from 153..500 to 200.380 to accommodate with Alexa range 0 = CT ranges from 153 to 500 (default) 1 = CT ranges from 200 to 380 (although you can still set in from 153 to 500) SetOption83 Uses Zigbee device friendly name instead of 16 bits short addresses as JSON key when reporting values and commands 0 = JSON key as short address 1 = JSON key as friendly name See ZbName <device>,<name> SetOption84 (Experimental) When using AWS IoT, sends a device shadow update (alternative to retained) 0 = don't update device shadow (default) 1 = update device shadow Note: if the Topic contains '/' they are replaced with '_' SetOption85 Device group support 0 = disable (default) 1 = enable SetOption86 PWM Dimmer only! Turn brightness LED's off 5 seconds after last change 0 = disable (default) 1 = enable SetOption87 PWM Dimmer only! Turn red LED on when powered off 0 = disable (default) 1 = enable SetOption88 Make each relay part of a separate device group. Relay 1 updates are sent to/received from device group 1, relay 2 updates are sent to/received from device group 2, etc. For the PWM Dimmer module, make each button be associated with a different device group. 0 = disable (default) 1 = enable SetOption90 Disable sending MQTT with non-JSON messages 0 = send all MQTT (default) 1 = send only MQTT messages with JSON payloads SetOption93 Control caching of compressed rules 0 = Disable memory caching of uncompressed rules 1 = Keep uncompressed rules in memory to avoid CPU load of uncompressing at each tick (default) SetOption94 Select MAX31855 or MAX6675 thermocouple support 0 = Use MAX31855 protocol (default) 1 = Use simpler MAX6675 protocol instead of MAX31855 SetOption97 Set TuyaMCU serial baudrate 0 = 9600 bps (default) 1 = 115200 bps SetOption98 Provide rotary dimmer rule triggers 0 = disable (default) 1 = enable SetOption99 Enable zero-cross capable AC dimmer 0 = no zero-cross AC dimmer connected (default) 1 = zero-cross AC dimmer attached. Focus on raising edge and sync frequency SetOption101 Add Zigbee source endpoint as suffix to attributes 0 = disable (default) 1 = enable e.g. Power3 instead of Power if sent from endpoint 3 . SetOption103 Set TLS mode 0 = disable TLS 1 = enable TLS SetOption104 Disable MQTT retained messages (some brokers don't support them) 0 = retained messages enabled (default) 1 = retained messages disabled SetOption107 Set virtual CT channel light type (experimental feature) 0 = Warm White 1 = Cold White SetOption108 0 = Teleinfo telemetry only sent into Energy MQTT JSON (default) 1 = Each Teleinfo received frame is also sent by MQTT (mainly to be able to display real time data) SetOption109 0 = (default) 1 = force gen1 Alexa mode, for Echo Dot 2nd gen devices only SetOption113 works only with rotary dial button 0 = (default) 1 = set dimmer low on rotary dial after power off SetOption114 Detach switches from relays and send MQTT messages instead 0 = disable (default) 1 = enable Example result: {\"Switch1\":{\"Action\":\"ON\"}} SetOption115 ESP32 MI32 BLE 0 = disable (default) 1 = enable SetOption116 Auto-query of lights and devices 1 = disable SetOption117 Run fade at fixed duration instead of fixed slew rate 1 = enable SetOption123 Wiegand tag number output in hex format 1 = enable SetOption124 Wiegand key pad stroke format 0 = one tag (ending char # or ) *(default) 1 = one key SetOption125 ZbBridge only Hide bridge topic from zigbee topic (use with SetOption89 ) 1 = enable SetOption126 Enable arithmetic mean over teleperiod for JSON temperature for DS18x20 sensors 1 = enable SetOption127 Force Wi-Fi in no-sleep mode even if Sleep 0 is not enabled 1 = enable SetOption128 Web referrer check for HTTP API commands 0 = disabled 1 = enabled (default) SetOption129 Enable split total energy results #13030 1 = enable SetOption130 Add heap size (and ESP32 fragmentation) to logging timestamp for debugging 1 = enable SetOption131 (Tuya) Allow save dimmer = 0 received by MCU 1 = enable SetOption132 When MQTT TLS is enabled, forces fingerprint validation of server identity instead of checking the identify against a certificate authority (CA) 1 = Fingerprint, 0 = CA SetOption134 PWM force phases to be synced (ESP32 only). On ESP32, PWM phases are by default distributed one after the other to minimize effect on power supply. This is also mandatory for H-Bridge devices. 0 = phases are automatically aligned one after the other, 1 = phases all start at the same time (default behavior for ESP8266). SetOption135 Disables Display Splash screen (for all drivers, universal & LVGL) 1 = Splash screen disabled, 0 = Splash screen displayed SetOption136 1 = Disable single sensor reports from Tuya devices while keeping teleperiod reports 0 = Publish an immediate tele/%topic%/SENSOR TuyaSNS message at each reception of individual value (default) SetOption137 1 = following Tuya responses will not be forwarded to MQTT when SetOption66 is enabled - heartbeat every 10 seconds, TUYA_CMD_HEARTBEAT - the WiFi state during start-up and Wi-Fi events, TUYA_CMD_WIFI_STATE - the local time info query of the MCU every minute, TUYA_CMD_SET_TIME - the received update package info from MCU during firmware update of Tuya MCU, TUYA_CMD_UPGRADE_PACKAGE SetOption138 Align GUI energy multicolumn layout in webUI 0 = left/center (default) 1 = right SetOption139 When SetOption24 1 switch pressure unit to: 0 = mmHg (default) 1 = inHg SetOption140 0 = open clean MQTT session (default) 1 = open persistent MQTT session SetOption141 1 = disable display of model name in webUI header SetOption142 1 = wait 1 second for WiFi connection solving some FRITZ!Box modem issues SetOption143 1 = disables ZigBee auto-probing and configure back attribute reporting SetOption144 1 = include a timestamp in ZbReceived messages TuyaMCU ~ Command Parameters TuyaEnum<x> Send value to an Enum (fnId 61, 62, 63 and 64) where <x> = number of Enum <value> = must be from a range set in TuyaEnumList TuyaEnumList Declare the range an Enum (fnId 61, 62, 63 and 64) must respect (0 is always the first item in range) <enum>,<range> = <enum> is Enum<x> declared using TuyaMCU and <range> can be 0..31 Without payload returns the configuration of all the Enums TuyaMCU Used to map functions in TuyaMCU <fnId>,<dpId> = read more... <fnId>,0 = remove setting for fnId TuyaRGB Set correct format of color reporting by tuyaMCU 0 - Type 1, 12 characters uppercase. Example: 00DF00DC0244 (default) 1 - Type 1, 12 characters lowercase. Example: 008003e8037a 2 - Type 2, 14 characters uppercase. Example: 00FF00FFFF6464 3 - Type 2, 14 characters lowercase. Example: 00e420ffff6464 TuyaSend<x> Send data to MCU with TuyaMCU x = 0..4,8 TuyaSend0 = send a query command to the MCU TuyaSend1 <dpId>,<boolean> = send boolean ( 0 / 1 ) data type to dpId (1 byte max length) TuyaSend2 <dpId>,<int> = send integer data to dpId (4 bytes max length) TuyaSend2 <dpId>,<0xAABBCCDD> = send 4 byte data to dpId (4 bytes max length) TuyaSend3 <dpId>,<value> = send an ASCII string to dpId (unknown max length) TuyaSend4 <dpId>,<enum> = send enumerated ( 0 / 1 / 2 / 3 / 4 / 5 ) data type to dpId (1 byte max length) TuyaSend5 <dpId>,<value> = send an HEX string to dpId - 0x prefix NOT needed - (unknown max length) TuyaSend6 <dpId>,<value> = send an HEX raw value to dpId - 0x prefix NOT needed, but will be processed correctly - (unknown max length) TuyaSend8 = request dpId states if supported TuyaTempSetRes Set resolution only for Tuya Set Temperature sensor (fnId 72). 0..3 = maximum number of decimals shown See also SetOption8 - change temperature display unit SetOption66 - publish TuyaReceived output to MQTT DimmerRange - to adjust dimmer range TempRes - set number of decimals shown for temperature sensors Serial Bridge ~ Hardware Serial Bridge uses GPIO1 (Tx) and GPIO3 (Rx) or GPIO13 (Tx) and GPIO15 (Rx) pins of your device. Software Serial Bridge can use any other GPIO to be configured as components Serial Tx and Serial Rx (or SerBr Tx and SerBr Rx ). If Tx and Rx components are not assigned in the Template or Module, GPIO1 and GPIO3 will be used. Note that changing serial logging ( SerialLog 0) will disable the hardware Serial Bridge. Information received by Tasmota over the serial bridge is captured automatically. Before data will be received, a properly formatted SerialSend<x> or SSerialSend<x> command must be executed. This must be done any time the device restarts (e.g., via a System#Boot triggered rule). This command is required in order to set how the expected serial data will be formatted and interpreted (i.e., which <x> option). A {\"SSerialReceived\":{\"Data\":\"<string>\"}} message will be posted. You can use a rule to process the string which will be contained in SSerialReceived#Data . Expect possible communication errors when additional sensors are configured. Command Parameters Baudrate 1 = set hardware serial bridge to default baud rate of 115200 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SBaudrate 1 = set software serial bridge to default baud rate of 9600 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SerialBuffer 256..520 = set the serial buffer size. This option will not be persisted , use a rule with a trigger like Power1#Boot when you want this to survive a reboot. Sometimes, serial buffer overruns can be mitigated by setting this to a large value such as 520 . SerialConfig value = set serial protocol using data/parity/stop conventional notation (example: 8N1 or 702 ) 0..23 = set serial protocol ( 3 equals 8N1 ) SerialDelimiter <value> = set serial delimiter to escape character code or ASCII character 1..127 = set serial delimiter to decimal ASCII 128 = only allow ASCII characters 32 to 127 in response text 254 = disable serial delimiter & post HEX string 129..253 or 255 = disable serial delimiter (default = 255) SerialSend<x> <string> Disable serial logging and send using hardware serial x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary. Data in serial response messages is encoded as binary strings 5 = send as hex. Data in serial response messages is encoded as hex strings 6 = send as comma-delimited string of decimal numbers SSerialConfig value = set serial protocol using data/parity/stop conventional notation (example: 8N1 or 702 ) 0..23 = set serial protocol ( 3 equals 8N1 ) SSerialSend<x> <string> Send using software serial protocol x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary data. Data in serial response messages is encoded as binary strings 5 = send as hex. Data in serial response messages is encoded as hex strings 6 = send as comma-delimited string of decimal numbers 9 = enable Serial Bridge console Tee for debugging purposes (payload 1 to enable) RF Bridge ~ Command Parameters RfCode Show last sent 24-bit user code 1..8388607 = send 24-bit user code #1..#7FFFFF = send 24-bit hexadecimal user code using RfSync, RfLow and RfHigh timing RfHigh 1 = reset high pulse time to 840 microseconds 2..32767 = set high pulse time in microseconds #2..#7FFF = set high pulse time in hexadecimal microseconds RfHost Show 16-bit host part of user code 1 = reset 16-bit host part of user code to 11802 (#2E1A) 2..32767 = set 16-bit host part of user code #2..7FFF = set 16-bit host part of user code in hexadecimal RfKey<x> Send learned or default RF data for RfKey<x> (x = 1 \u2013 16 ) 1 = send default RF data for RfKey<x> using RfSync, RfLow, RfHigh and RfHost parameters 2 = learn RF data for RfKey<x> 3 = unlearn RF data for RfKey<x> 4 = save RF data using RfSync, RfLow, RfHigh and last RfCode parameters 5 = show default or learned RF data 6 = send learned RF data RfLow 1 = reset low pulse time to 270 microseconds 2..32767 = set low pulse time in microseconds #2..#7FFF = set low pulse time in hexadecimal microseconds RfRaw This command only works when the firmware has been updated with Portisch firmware . Refer to the Portisch wiki for details. Learning and Decoding RF Codes with Portisch Firmware 0 = Set iTead default firmware support and messages (default on restart) 1 = set Portisch firmware support and messages 166 or AAA655 = start sniffing/reading RF signals disabling iTead default RF handling 167 or AAA755 = stop sniffing/reading RF signals enabling iTead default RF handling 168 or AAA855 = transmitting iTead default RF protocols 169 or AAA955 = start sniffing and learning predefined protocols 176 or AAB055 = bucket Transmitting using command 0xB0 177 or AAB155 = start Bucket sniffing using command 0xB1 192 or AAC000C055 = beep ( 00C0 is the length of the sound) 255 or AAFF55 = show Rf firmware version (result AA02FF means Version 02) <value> = hexadecimal data to be sent to RF chip. This must be immediately followed by the RfRaw 0 command (e.g., Backlog RfRaw <value>; RfRaw 0 RfSync 1 = reset start sync pulse time to 8470 microseconds 2..32767 = set start sync pulse time in microseconds #2..#7FFF = set start sync pulse time in hexadecimal microseconds RfTimeout change timeout in RfReceive 100..60000 = disable duplicate RfReceive ( default = 1000 ) See also SetOption28 - Set RF received data format RF Transceiver ~ Command Parameters RFsend <value> = code decimal or JSON. Data value is required and can be decimal or hexadecimal (using the 0x prefix), other values are optional. JSON {\"Data\":\"<value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} \"Data\":\"<value>\" = hexadecimal code \"Bits\":<value> = required number of data bits (default = 24 ) \"Protocol\":<value> = protocol number (default = 1 ) \"Repeat\":<value> = repeat value (default = 10 ) \"Pulse\":<value> = pulse value ( 350 = default for protocol 1) \u2003e.g., RFsend {\"Data\":\"0x7028DC\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238} Decimal data, bits, protocol, repeat, pulse \u2003e.g., RFsend 7350492, 24, 1, 10, 238 or RFsend 0x7028DC, 24, 1, 10, 238 IR Remote ~ The standard Tasmota builds have reduced support for IR protocols: RC5 , RC6 and NEC . Use Tasmota-IR to have access to full protocols. Command Parameters IRsend <x> Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure at least one of the free device GPIOs as IRsend (8) . GPIO01 nor GPIO03 can be used. <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>, \"Channel\":<value>} \"Protocol\" (select one of the following): \"NEC\" \"RC5\" \"RC6\" \"Bits\":1..32 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":1..(2^32)-1 = data frame as 32 bit decimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":2170978686} or \"Data\":0x1..0xFFFFFFFF = data frame as 32 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} \"Channel\":1..16 = IRSend GPIO to be used to send the message. Alternatively, you can send IR remote control codes using RAW command encoding . Read more... Tasmota-IR enabled with all protocols Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E|ARDB1 Panasonic_AC : LKE|NKE|DKE|JKE|CKP|RKR Whirlpool_AC : DG11J13A|DG11J104|DG11J1-04|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds \"StateMode\" : SendOnly (default) StoreOnly SendStore See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload Displays ~ Command Parameters Display Show current display setting as a JSON payload DisplayAddress 0..255 Set display module address DisplayDimmer 0 = Turn the display off 1..100 = Set display luminosity (only on 8x8 Dot-Matrix displays) 13..100 maps to 1..7 levels of brightness for TM1637, TM1638 and MAX7219 seven-segment display modules DisplayInvert 1 - Invert display where implemented. More info... DisplayMode 0..5 Set to display predefined content according to display type 0..3 for TM1637, TM1638 and MAX7219 seven-segment display modules DisplayModel Set display model: 1 = I 2 C LCD Display (default addresses 0x27 , 0x3F ) 2 = SSD1306 OLED 128x32/128x64/68x48 (default I 2 C addresses 0x3C , 0x3D ) 3 = HT16K33 8x8 Dot-Matrix 4 = ILI9341 TFT LCD 5 = 2.9 inch E-Paper Display 296x128 (software 3-wire SPI) 6 = 4.2 inch E-Paper Display 400x300 (software 3-wire SPI) 7 = SH1106 OLED 128x64 (default I 2 C address 0x3c ) 8 = ILI9488 TFT 480x320 (capacitive touch, hardware 3-wire SPI) 9 = SSD1351 color OLED 128x128 (hardware 3-wire SPI) 10 = RA8867 TFT LCD 1024x600 (capacitive touch, hardware 4-wire SPI) 15 = TM1637 7-segment, 4-,6- and 8-digit displays (TM1637, TM1638 and MAX7219), hardware 2- and 3-wire I2C-like interface 16 = LilyGO T5-4.7 E-Paper display board 17 = Universal Display Driver powered displays DisplayRefresh 1..7 Set time in seconds to update predefined content when using DisplayMode \u2260 0 DisplaySize 1..4 Set display scale-up size (SSD1306 and ILI9341 only) DisplayRotate Set rotation angle 0 = 0\u00b0 1 = 90\u00b0 2 = 180\u00b0 3 = 270\u00b0 DisplayText <value> = See DisplayText use For TM1637, TM1638 and MAX7219, see below DisplayText (TM1637, TM1638 and MAX7219) text [, position [, length ]] Clears and then displays basic text on the 7-segment display. length can be 1 to NUM_DIGITS , position can be 0 (left-most) to NUM_DIGITS-1 (right-most) A caret( ^ ) symbol in the text input is displayed as the degrees( \u00b0 ) symbol. This is useful for displaying Temperature (or angle)! See TM163x for details. DisplayTextNC (TM1637, TM1638 and MAX7219) text [, position [, length ]] Clears first, then displays text. Usage is same as above. See TM163x for details. DisplayType Select display sub-modules. More info... For usage of this command with TM163x, see TM163x for details. DisplayCols 1..44 Set number of display columns (for display modes>0) DisplayRows 1..32 Set number of display rows (for display modes>0) DisplayFont Specify the current font 0 use classic GFX font 1 = 12 2 = 24 3 = 8 (opt) 7 use RA8876 internal font DisplayWidth Specify the display width in pixels (SSD1306 only) -or- Specify number of digits in TM163x seven-segment display module DisplayHeight Specify the display height in pixels (SSD1306 only) DisplayClear (TM1637, TM1638 and MAX7219) Clears the display. See TM163x for details. DisplayNumber (TM1637, TM1638 and MAX7219) num [, position [, leading_zeros [, length ]]] Clears and then displays number num without decimal. leading zeros can be 1 or 0 (default), length can be 1 to NUM_DIGITS (4 or 6), position can be 0 (left-most) to NUM_DIGITS (right-most). See TM163x for details. DisplayNumberNC (TM1637, TM1638 and MAX7219) num [, position [, leading_zeros [, length ]]] Display integer number as above, but without clearing first. Usage is same as above. See TM163x for details. DisplayFloat (TM1637, TM1638 and MAX7219) num [, position [, precision [, length ]]] Clears and then displays float (with decimal point). precision can be 0 to NUM_DIGITS (default), length can be 1 to NUM_DIGITS (4 or 6), position can be 0 (left-most) to NUM_DIGITS (right-most). See TM163x for details. DisplayFloatNC (TM1637, TM1638 and MAX7219) num [, position [, precision [, length ]]] Displays float (with decimal point) as above, but without clearing first. Usage same as above. See TM163x for details. DisplayRaw (TM1637, TM1638 and MAX7219) position , length , num1 [, num2 [, num3 [, num4 [, ...upto NUM_DIGITS numbers]]...] Takes upto NUM_DIGITS comma-separated integers (0-255) and displays raw segments. length can be 1 to NUM_DIGITS (4 or 6), position can be 0 (left-most) to NUM_DIGITS (right-most). num1 , num2 , ... are numbers representing a 7-segment digit. Each number represents all segments of one digit. Segment a=1, b=2, c=4, d=8, e=16, f=32, g=64 and h (decimal point)=128. To turn on all segments, the number would be 1+2+4+8+16+32+64+128 = 255. See TM163x for details. DisplayScrollText (TM1637, TM1638 and MAX7219) text [, num_iterations ] Displays scrolling text, upto 50 characters. If num_iterations is not specified, it scrolls indefinitely, until another Display- command is issued. Optionally, specifying num_iterations causes the scrolling to stop after the specified number of iterations. See TM163x for details. DisplayScrollDelay (TM1637, TM1638 and MAX7219) 0..15 Sets the speed of text scroll. Smaller delay implies faster scrolling. See TM163x for details. DisplayLevel (TM1637, TM1638 and MAX7219) 0..100 Display a horizontal bar graph. See TM163x for details. DisplayClock (TM1637, TM1638 and MAX7219) Displays a clock. 1 = displays a clock in 12-hour format. 2 = displays a clock in 24-hour format. 0 = turns off the clock and clears the display See TM163x for details. Shutters ~ Command (x = 1..4 ) Parameters ShutterMode<x> 1..5 (default = 0 ) Defines the mode the shutter will operates the relays, steppers and/or servos. 0=autodetect based on INTERLOCK and GPIO defined. STATUS 13 show the mode. 1=normal two relay up/off down/off. 2=two relay on/off up/down. 3=one relay garage mode. 4=one relay plus stepper motor. 5=one relay and position servo. ShutterButton<x> <button> <func> <mqtt> Assign a button to control the shutter. For more details please refer to Blinds and Shutters support <button> \u2003 0 : disable buttons for this shutter \u2003 1..4 : Button number <func> up / down / updown / toggle : function to assign to the button <mqtt> 1 / 0 : enable/disable MQTT publish for button hold action For example: To control shutter #1 by two buttons: Backlog ShutterButton1 1 up 1; ShutterButton1 2 down 1 assigns button #1 to act as an \"up\" button (1x press open, 2x press 50% position, 3x press 74% position) and button #2 to act as an \"down\" button (1x press close, 2x press 50% position, 3x press 24% position) for shutter #1 including MQTT publish. To control shutter #1 by a single button: ShutterButton1 1 updown 0 assigns button #1 to act as an \"up and down\" button (1x press up, 2x press down). To control shutter #1 by a single button: ShutterButton1 1 toggle 0 assigns button #1 to act as a \"toggle\" button (1x press toggle, 2x press 50% position). ShutterCalibration<x> Granular shutter position calibration. The measured opening position of the shutter at the 30, 50, 70, 90, and 100 percent opened locations. For example: ShutterCalibration<x> 23 38 56 74 82 ShutterChange -100..100 Moves the shutter from the current position relatively in %. If the resulting position is below 0 or above 100 it will be capped. Command can also be executed during movement and will change the target position. ShutterCloseDuration<x> 1.0 ..240.0 (default = 10.0 ) time, in seconds, it takes to fully close the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterClose<x> Engage the relay to close the shutter. This action can be requested at any time. Number of shutter can be the index or the argument ShutterFrequency<x> 0..10,000 Hz (default = 1000 ) the maximum frequency at which the stepper motor can operate reliably. Typically this is up to 2,000Hz with a 12V power supply and up to 5,000Hz with a 24V power supply. ShutterEnableEndStopTime<x> 0 = no additional shutter end stop time (default) 1 = 1 s additional shutter end stop time ShutterInvert<x> 0 = use default shutter positioning ( 0 = Closed, 100 = Open) 1 = invert shutter positioning ( 100 = Closed, 0 = Open) (e.g., if used with KNX) ShutterInvertWebButtons<x> 0 = use default button icons (\u25b2 for open, \u25bc for close) 1 = invert button icons (\u25bc for open, \u25b2 for close) (e.g., if used with horizontal awning: where open means rolling-down fabric material and close rolling-up in a protect position) ShutterLock<x> 0 = unlock shutter positioning (default) 1 = lock shutter positioning ShutterMotorDelay<x> -12.75 .. 12.75 (default = 0 ) time, in seconds, it takes the motor to start moving once power is turned on; i.e., motor lag time. You can use negative numbers if your motor stops to late after power OFF When used with stepper motors, this setting defines the ramp up/down speed (i.e., acceleration/deceleration) before the motor reaches its target speed for gradual starting and stopping. In this case only positive numbers are allowed. ShutterOpenDuration<x> 1.0 ..240.0 (default = 10.0 ) time, in seconds, it takes to fully open the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterOpen<x> Engage the relay to open the shutter. This action can be requested at any time. Number of shutter can be index or the argument ShutterPosition<x> 0..100 , UP , OPEN , DOWN , CLOSE , STOP , TOGGLE , TOGGLEDIR ,, A shutter position change can be requested at any time. The shutter will stop and revert or update to the requested position. The shutter's actual position will be saved after the movement is completed. In this case, the position will be restored during reboot. An interruption during shutter movement (e.g., a device restart) will lose the current position. ShutterPWMRange<x> 0..1023,0..1023 For servo motors the min and max position is defined by the length of the duty cycle signal. Because every servo is different the min and max PWM value must be set for each servo type. The value is also dependant on the PWMfrequency . Servos normally use 50..200 as PWMfrequency . ShutterRelay<x> <value> 0 = disable this and all higher numbered shutters Relay<value> component used to open the shutter. This relay's mate, the next higher numbered relay, closes the shutter. Depending on the shutter mode, the relays may need to be interlocked using the Interlock command. The ShutterRelay command must be executed first before any other shutter commands for Shutter<x> can be executed. ShutterSetClose<x> shutter closed position. ShutterPosition will be reset to fully closed value (e.g., 0 when ShutterInvert = 0 , 100 otherwise). This does not work with Servos. min and max of servos are always defined through ShutterPWMRange . ShutterSetOpen<x> shutter opened position. ShutterPosition will be reset to fully opened value (e.g., 100 when ShutterInvert = 0 , 0 otherwise). This does not work with Servos. min and max of servos are always defined through ShutterPWMRange . ShutterSetHalfway<x> 0..100 (default = 50 ) Define shutter half open position (in percent) ShutterStop<x> Disengage the relays to stop the shutter. Number of shutter can be the index or the argument ShutterStopClose<x> Stop the shutter when currently moving, close it otherwise ShutterStopOpen<x> Stop the shutter when currently moving, open it otherwise ShutterStopPosition<x> Stop the shutter when currently moving, set it to position 0..100 , UP , DOWN , STOP , TOGGLE otherwise ShutterStopToggle<x> Stop the shutter when currently moving, do ShutterToggle otherwise ShutterStopToggleDir<x> Stop the shutter when currently moving, do ShutterToggleDir otherwise ShutterToggle<x> Toggle the shutter - close the shutter when its position is >50, open it otherwise ShutterToggleDir<x> Toggle the shutter - close the shutter when it previously moved to open, open it otherwise ShutterTiltConfig<x> <min> <max> <Tiltduration> <openposition> <closeposition> (default = 0 0 0 0 0 ) Configure the tilt for venetian blinds. Min/man values must be in the range of -90\u00b0 to 90\u00b0. Open and Close position must be part of the defined range between min and max. Tiltduration defines the time the shutter needs to change the tilt from min to max value. This time has to been multiplied by 20. E.g. 1.2sec = 1.2 x 20 = 24. Example defines tilt on shutter 2: shuttertiltconfig2 -90 90 24 0 90 ShutterTilt<x> Set the tilt position <value> (between min and max), OPEN , CLOSE . Definition please see shuttertiltconfig ShutterTiltChange<x> -100..100 Moves the shuttertilt from the current position relatively in %. If the resulting tilt is below min or above max it will be capped. Command can also be executed during movement and will change the tilt at target position. See also SetOption80 - Enable shutter support Zigbee ~ See Zigbee article for more information Command Parameters <device> As <device> in following commands you can use interchangeably: <shortaddr> = short address of the Zigbee device on the network, example: 0x1234 <longaddr> = permanent IEEE address of the Zigbee device (64 bits), example: 0x00158D00041160C5 <index> = number of the device in the internal list (starts at 1), ideal for enumerating devices, example: 3 for third device in the list <name> = friendly name. Only when previously set with ZbName ZbBind Binds one Zigbee device to another device or to a group. This allows one device to directly send commands (f.e. a remote to a bulb) without any action on the coordinator. Command structure: {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } <device> = device sending messages (mandatory) <endpoint> = source endpoint (mandatory) <cluster> = source cluster id (mandatory) <to_device> = target device (optional) <to_endpoint> = target endpoint \u2003(optional if it can be inferred from ZbStatus3 ) <to_group> = target group id (optional) You must specify either \"ToDevice\" or \"ToGroup\" but not both Zigbee2Tasmota must know the IEEE address of target device, see ZbStatus2 to verify and ZbProbe to have Zigbee2Tasmota query the address (EZSP ZBBridge only) If you bind devices to groups you should also use ZbListen to that group, otherwise MQTT messages will not be published ZbBindState<n> Asks the device for its internal binding states <device> the device to query <n> the start index for the request, 1 is the default. This is used to scan through all bindings. ZbCIE Configure on the ZigBee device the CIE address using the IEEE address of the ZigBee Bridge. The ZigBee Bridge will act as the CIE device for the ZigBee Network. See IAS Cluster in the ZigBee specification for more information. Usage: ZbCIE <device>,<endpoint> <device> is the ZigBee device to configure <endpoint> is the endpoint in the ZigBee device where the IAS Cluster is. Example: ZbCIE 1,44 ZbEnroll Enroll the the ZigBee device to the ZigBee Bridge for reporting security sensors data, panels, etc. The ZigBee Bridge will act as the CIE device for the ZigBee Network. Usage: ZbEnroll <device>,<endpoint> <device> is the ZigBee device to configure <endpoint> is the endpoint in the ZigBee device where the IAS Cluster is. Example: ZbEnroll 1,44 ZbConfig display the current Zigbee configuration Example or result: {\"ZbConfig\":{\"Channel\":11,\"PanID\":\"0x1A63\",\"ExtPanID\":\"0xCCCCCCCCCCCCCCCC\",\"KeyL\":\"0x0F0D0B0907050301\",\"KeyH\":\"0x0D0C0A0806040200\"}} ZbConfig <json> change the configuration and restart if any change was applied. Warning: change in configuration causes a reset of the CC2530/ZBBridge and requires devices to be re-paired. \"Channel\":<channel> : Zigbee radio channel (11-26) \"PanID\":<panid> : identifier of the Zigbee Network \"ExtPanID\":<extpanid> : unique identifier of the Zigbee Network (ExtPanID features are not supported in Z2T but this parameter needs to be set) \"KeyL\":<key_l>,\"KeyH\":<key_h> : 128 bits encryption key, split into 2 64 bits values (Low and High) \"TXRadio\":<txradio> : radio power in dBm (1-20) only for ZBBridge All parameters are optional and only the ones specified are changed. The command always displays the complete configuration after the change Example of command: ZbConfig {\"Channel\":22,\"PanID\":\"0x1A69\",\"ExtPanID\":\"0xDDCCCCCCCCCCCCCC\",\"KeyL\":\"0xFF0D0B0907050301\",\"KeyH\":\"0xED0C0A0806040200\"} The following command creates a highly secure Network key based on a hardware random generator: ZbConfig {\"KeyL\":\"\",\"KeyH\":\"\"} ZbData feature in development ZbDeviceTopic SetOption89 Configure MQTT topic for Zigbee devices (also see SensorRetain ) 0 = single tele/%topic%/SENSOR topic (default) 1 = unique device topic based on Zigbee device ShortAddr Example: tele/Zigbee/5ADF/SENSOR = {\"ZbReceived\":{\"0x5ADF\":{\"Dimmer\":254,\"Endpoint\":1,\"LinkQuality\":70}}} EndpointTopic SetOption101 Add Zigbee source endpoint as suffix to attributes 0 = disable (default) 1 = enable e.g. Power3 instead of Power if sent from endpoint 3 . ZbEndpointSuffix SetOption120 Add the Zigbee endpoint as suffix in topic when using SetOption89 1 0 = disable (default) 1 = enable ZbForget Used for devices that are unused but still visible in ZbStatus <device> = Remove a device from the Tasmota flash memory. It does not un-pair the device nor deleting the device information in the CC2530/ZBBridge. ZbLight Sets or reads the light type to be emulated in Zigbee Hue Emulation with Alexa. <device>,<light_type> sets the light type using an integer 0..5 corresponding to the number of channels (from one channel (on/off) to 5 channel (RGBCCT) lights) <device>,-1 removes the device from Philips Hue emulation <device> displays the current status of the Light (Zigbee2Tasmota tracks all changes to the light) ZbListen<x> <group> (EZSP ZBBridge only)Listens to a multicast group address. By default EZSP will not report group messages unless you subscribe to the group. <x> : slot in the array of group addresses, 1..15 <group> : group address to listen to, 0..0xFFFF At start-up, Z2T automatically listens to group 0 in slot 0. CC2530 does not need this command and always report all group messages. ZbLeave <device> = request a device to leave the network. If the device is offline or sleeping, this will have no effect. It is not 100% guaranteed that the device will never connect again ZbInfo <device> = display all information known about a device, equivalent to ZbStatus3 with a simpler JSON output ZbMap<n> Asks the device for its view of the Zigbee topology <device> the device to query <n> the start index for the request, 1 is the default. This is used to scan through all values since devices usually return only 3 values per request. ZbName Sets or reads the Zigbee device friendly name (up to 32 characters). <device>,<name> sets the new friendly name <device>, (empty name) clears the friendly name <device> displays the current friendly name Also see SetOption83 1 to enable friendly names as JSON keys instead of ShortAddr. ZbNameKey SetOption83 Uses Zigbee device friendly name instead of 16 bits short addresses as JSON key when reporting values and commands 0 = JSON key as short address 1 = JSON key as friendly name See ZbName <device>,<name> ZbNameTopic SetOption112 0 = (default) 1 = use friendly name in Zigbee topic (use with ZbDeviceTopic ) ZbNoAutoBind SetOption110 0 = (default) 1 = disable Zigbee auto-binding and auto-attribute reporting when pairing a new device. Use only if you want to manually configure devices ZbNoPrefix SetOption100 remove Zigbee ZbReceived value from {\"ZbReceived\":{xxx:yyy}} JSON message 0 = disable (default) 1 = enable ZbOccupancy Configure the time-out after \"Occupancy\":1 to send a synthetic \"Occupancy\":0 for Zigbee motion sensors <device>,<x> - set occupancy timeout for <device> Possible values for <x> 0 : no time-out, the device actually generates \"Occupancy\":0 n : the number of seconds. The possible values are 15, 30, 45, 60, 75, 90, 105, 120. If the number is different, it is rounded up -1 : apply the default of 90 seconds ZbOmitDevice SetOption119 Remove device addr from JSON payload 0 = disable (default) 1 = enable ZbPermitJoin Sets pairing mode for new device discovery 0 = disable pairing mode 1 = enable pairing mode for 60 seconds 99 = enable pairing until device reboots (CC2530 only) Leaving Zigbee network open to join will allow any Zigbee device to connect and retrieve your network encryption key. This can lead to a compromise of your Zigbee network. ZbPing <device> = test availability of Zigbee device. If the device is connected and not sleeping, you should receive a ZbPing message within the next second. Example: ZbPing 0x5ADF responds with: {\"ZbPing\":{\"Device\":\"0x5ADF\",\"IEEEAddr\":\"0x90FD9FFFFE03B051\"}} ZbReceivedTopic SetOption118 Move ZbReceived from JSON message into the subtopic replacing \"SENSOR\" default 0 = disable (default) 1 = enable ZbSend Command structure: {\"Device\":\"<shortaddr>\", \"Endpoint\":\"<endpoint>\", \"Manuf\":<manuf>, \"Send\":{\"<sendcmd>\":<sendparam>}} <shortaddr> = short address of the Zigbee device on the network <endpoint> = target endpoint on the device ( understanding endpoints ) <manuf> = (optional) forces a specific ManufacturerId in the ZCL frame (required by some Xiaomi devices) \"<sendcmd>\":<sendparam> = command and parameters to send ( Zigbee Device Commands ) _Use ZbZNPSend to send a raw form low-level message on CC253x gateways _ Example: ZbSend { \"Device\":\"0x1234\", \"Endpoint\":\"0x03\", \"Send\":{\"Power\":\"on\"} } ZbScan Do an energy scan on each radio channel ZbStatus<x> Display Zigbee devices seen on the network since boot <device> (optional) = all devices This command provides three levels of increasing detail according to <x> ZbStatus1 Display Short Address, and Friendly Name ZbStatus2 Also include Manufacturer ID and Model ID ZbStatus3 Also include a list of endpoints and the clusterIds supported by each endpoint Example: ZbStatus3 1 requests all details for device number 1 Requested information may exceed maximum result size allowed by Tasmota. In this case, the output will be truncated. To get all of the desired information, request results for a specific device individually. ZbUnbind Unbinds one Zigbee device from another or from a group. {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } <device> = the device sending the messages (mandatory) <endpoint> = the source endpoint (mandatory) <cluster> = the source cluster id (mandatory) <to_device> = the target device (optional) <to_endpoint> = the target endpoint (optional if it can be inferred from ZbStatus3 ) <to_group> = the target group id (optional) You must specify either \"ToDevice\" or \"ToGroup\" but not both Zigbee2Tasmota must know the IEEE address of the target device, use ZbStatus2 to verify and ZbProbe to query the address. See also SetOption83 , SetOption89 , SetOption100 , SetOption101 Zigbee Debug Functions ~ Do not use unless you know exactly what you are doing. Command Parameters ZbModelId Manually force the ModelId field of a Zigbee device. This is used to simulate devices not physically present on the network, for debugging only. <device>,<modelid> = set new ModelId <device>, = (empty ModelId) clear ModelId <device> = display current ModelId (also displayed in ZbStatus2 ) ZbProbe <device> = probe a Zigbee device to get additional information including its IEEEaddress, vendor and model names, endpoints, and supported clusters per endpoint. Device probe is performed automatically when a new Zigbee device connects. Battery powered Zigbee devices can not be probed in general because they are usually in sleep mode. ZbRead Removed in favor of ZbSend with \"Read\" attribute. ZbReset 1 = perform a factory reset and reconfiguration of the CC2530 chip. You will need to re-pair all Zigbee devices ZbRestore Restores a device configuration previously dumped with ZbStatus2 . This command does not pair a device, but lets you get back device configuration like ModelId or IEEEAddress. <json> = json contains the fields dumped with ZbStatus2 . <json> can contain multiple devices (if they fit). ZbSave <hex> Forces saving the Zigbee device information to Flash. Auto-saving happens 10 seconds after a new Device parameter was changed, this command is normally not useful ZbZNPSend <hex> (CC2530 only) Send a raw ZCL message to a Zigbee device. This is a low-level command, and requires to manually build the ZCL parameters. Most common usage will be provided as high-level functions. ZbZNPReceive (CC2530 only) Simulates a received message <hex> = hex string of the simulated message, same format as ZbZNPReceived debug logs ZbEZSPSend<x> <hex> (EZSP only) Send a raw EZSP message. This is a low-level command, and requires to manually build the ZCL parameters. Most common usage will be provided as high-level functions. <x> : 1 =high-level EZSP command, 2 =low-level EZSP frame, 3 =low-level EZSP/ASH frame <hex> = hex string of the message ZbEZSPReceive<x> <hex> (EZSP only) Simulates a received message <x> : 1 =high-level EZSP command, 2 =low-level EZSP frame, 3 =low-level EZSP/ASH frame <hex> = hex string of the simulated message, same format as ZbZNPReceived debug logs Bluetooth ~ Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and time zone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is an active scan and it should be used only if necessary . At the moment that is the case just with MJ_HT_V1. This can change if a future HM-10 firmware starts supporting passive scan. NRFBeacon Set a BLE device as a beacon using the (fixed) MAC-address <value> (1-3 digits) = use beacon from scan list <value> (12 characters) = use beacon given the MAC interpreted as an uppercase string AABBCCDDEEFF NRFIgnore 0 = all known sensor types active_(default)_ <value> = ignore certain sensor type ( 1 = Flora, 2 = MJ_HT_V1, 3 = LYWSD02, 4 = LYWSD03, 5 = CGG1, 6 = CGD1 NRFKey Set a \"bind_key\" for a MAC-address to decrypt (LYWSD03MMC & MHO-C401). The argument is a 44 uppercase characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string NRFMjyd2s Set a \"bind_key\" for a MAC-address to decrypt sensor data of the MJYD2S. The argument is a 44 characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string NRFNlight Set the MAC of an NLIGHT <value> (12 characters) = MAC interpreted as an uppercase string AABBCCDDEEFF NRFPage Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) NRFScan Scan for regular BLE-advertisements and show a list in the console 0 = start a new scan list 1 = append to the scan list 2 = stop running scan Stepper Motors ~ Command Parameters MotorMIS 1,2,4,8,16 Set micro stepping increment - 1/1 (full steps) to 1/16 (default = 1 ) MotorSPR integer Set the number of steps the given motor needs for one revolution (default = 200 ) This is dependent on the type of motor and micro stepping. Most common motors are 1.8\u00b0 per step. MotorRPM 1..300 Set revolutions per minute (default = 30 ) MotorMove integer Move the motor the given number of steps (positive values: clockwise, negative values: counterclockwise) MotorRotate integer Rotate the motor the given number of degrees (positive values: clockwise, negative values: counterclockwise) MotorTurn float Spin the motor the given number of turns (positive values: clockwise, negative values: counterclockwise) MP3 Player ~ The MP3 Player driver is based on the one from DFRobot. They named it DFPlayer mini . All MP3 Players with the identical Serial Control Command structure can be used. Note Player module pin RX should be connected to a GPIO defined as \"MP3 Player\" from the drop-down list. The driver uses a Software Serial and do not requires usage of hardware TX/RX pins. Command Parameters MP3DAC 0 = DAC on (default) 1 = DAC off MP3Device Specify playback device 1 = USB 2 = SD Card (default (also defaults on reset or power cycle)) MP3EQ Set equalizer mode: 0 = normal 1 = pop 2 = rock 3 = jazz 4 = classic 5 = bass) MP3Pause Pause MP3Play Play, works as a normal play on a real MP3 Player, starts at first MP3 file MP3Reset Reset the MP3 player to defaults MP3Stop Stop MP3Track x = play track <x> MP3Volume 0..100 = set Volume Thermostat ~ Command Parameters ThermostatModeSet Sets the thermostat mode 0 = Thermostat Off (controller inactive, default) 1 = Thermostat in automatic mode (controller active) 2 = Thermostat in manual mode (output switch follows the input switch, used to follow an existing wall thermostat) ClimateModeSet Sets the climate mode 0 = Heating mode (default) 1 = Cooling mode ControllerModeSet Sets the controller mode (used for thermostat in automatic mode) 0 = Hybrid controller (Predictive ramp-up controller and PI, default) 1 = PI controller 2 = Predictive ramp-up controller TempFrostProtectSet Sets the frost protection temperature. The controller, if in automatic mode, will never allow the temperature to sink below this value <0..12> = Temperature value in degrees Celsius/Fahrenheit (default 4.0\u00b0 Celsius) InputSwitchSet Sets the number of the input used in case in manual control <1..4> = Number of the input (default 1) InputSwitchUse Switch to decide if the input shall be used to automatically switch to manual mode and assign it to the output (useful if using a serially connected wall thermostat) 0 = Input not used (default) 1 = Input used SensorInputSet Sets the temperature sensor to be used 0 = MQTT (default) 1 = Local sensor (can be changed by define, default DS18B20) OutputRelaySet Sets the output switch to be used for the thermostat <1..8> = Number of the output (default 1) EnableOutputSet Enables or disables the physical output 0 = Output disabled 1 = Output enabled (default) TimeAllowRampupSet Sets the minimum time in minutes since the last control action to be able to switch to the predictive ramp-up controller phase (applicable just in case of Hybrid controller, used normally in case of big deltas between the setpoint and the room temperature) <value> = Minutes (default 300 minutes) TempFormatSet Sets the temperature format 0 = Degrees Celsius (default) 1 = Degrees Fahrenheit TempMeasuredSet Sets the temperature measured by the sensor (for MQTT sensor mode) <TempFrostProtectSet..100> = Temperature (default 18.0\u00b0 Celsius) TempTargetSet Sets the target temperature for the controller (setpoint) <TempFrostProtectSet..100> = Temperature (default 18.0\u00b0 Celsius) TempMeasuredGrdRead Returns the calculated temperature gradient <value> = Temperature gradient in degrees Celsius/Fahrenheit StateEmergencySet Sets the thermostat emergency flag 0 = Emergency flag off (default) 1 = Emergency flag on (thermostat switches to off state) TimeManualToAutoSet Sets the time in manual mode after the last active input action (f.e. last action from serial connected wall thermostat) to switch to automatic mode 0..1440 = time in minutes (default 60 minutes) PropBandSet Sets the value of the proportional band of the PI controller 0..20 = value in degrees Celsius (default 4 degrees Celsius) TimeResetSet Sets the value of the reset time of the PI controller 0..86400 = value in seconds (default 12000 seconds) TimePiProportRead Returns the proportional part of the PI controller calculation in seconds value = value in seconds TimePiIntegrRead Returns the integral part of the PI controller calculation in seconds value = value in seconds TimePiCycleSet Sets the value of the cycle for the PI controller 0..1440 = value in minutes (default 30 minutes) TempAntiWindupResetSet Sets the value of the delta between controlled temperature and setpoint above which the integral part of the PI controller will be set to 0, in degrees Celsius/Fahrenheit 0..10 = value in degrees (default 0.8\u00b0 Celsius) TempHystSet Sets the value of the temperature hysteresis for the PI controller, in degrees Celsius/Fahrenheit -10..10 = value in degrees (default 0.1\u00b0 Celsius) TimeMaxActionSet Sets the maximum duty cycle of the PI controller in minutes 0..1440 = value in minutes (default 20 minutes) TimeMinActionSet Sets the minimum duty cycle of the PI controller in minutes 0..1440 = value in minutes (default 4 minutes) TimeSensLostSet Sets the maximum time without a temperature sensor update to mark it as lost in minutes 0..1440 = value in minutes (default 30 minutes) TimeMinTurnoffActionSet Sets the minimum time in minutes within a cycle for the PI controller to switch off the output, below it, it will stay on 0..1440 = value in minutes (default 3 minutes) TempRupDeltInSet Sets the minimum delta between controlled temperature and setpoint for the controller to switch to ramp-up controller phase (applicable just in Hybrid controller mode) 0..10 = value in degrees Celsius/Fahrenheit (default 0.4\u00b0 Celsius) TempRupDeltOutSet Sets the maximum delta between controlled temperature and setpoint for the controller to switch to the PI controller phase (applicable just in Hybrid controller mode) 0..10 = value in degrees Celsius/Fahrenheit (default 0.2\u00b0 Celsius) TimeRampupMaxSet Sets the maximum time in minutes for the controller to stay in the ramp-up phase (applicable just in Hybrid controller mode 0..1440 = value in minutes (default 960 minutes) TimeRampupCycleSet Sets the value of the cycle for the ramp-up controller 0..1440 = value in minutes (default 30 minutes) TempRampupPiAccErrSet Sets the initial accumulated error when switching from ramp-up to the PI controller phase if the target temperature has not been reached (applicable just in Hybrid controller mode) 0..25 = value in degrees Celsius/Fahrenheit (default 2\u00b0 Celsius) CtrDutyCycleRead Returns the duty cycle of the controller 0..100 = value in % DiagnosticModeSet Enables/disables the diagnostics flag 0 = Diagnostics disabled 1 = Diagnostics enabled (default) Domoticz ~ Command Parameters DzIdx<x> Show Domoticz Relay idx <x> (x = 1..4 ) 0 = disable use of Relay idx <x> (default) <value> = Show Relay idx <x> DzKeyIdx<x> Show Domoticz Key idx <x> (x = 1..4 ) 0 = disable use of Key idx <x> (default) <value> = Show Key idx <x> (to use enable ButtonTopic ) DzSend<type> send values or state to Domoticz <index>,<value1(;value2)|state> DzSensorIdx<x> Show Domoticz Sensor idx <x> (x = 1..5 ) 0 = disable use of Sensor idx <x> (default) <value> = Show Sensor idx <x> DzSwitchIdx<x> Show Domoticz Switch idx <x> (x = 1..4 ) 0 = disable use of Switch idx <x> (default) <value> = Show Switch idx <x> (to use enable SwitchTopic ) DzUpdateTimer Show current update timer value in seconds 0 = disable sending interim Domoticz status (default) 1..3600 = send status to Domoticz in defined intervals InfluxDB ~ Command Parameters Ifx InfluxDB state 0 = off 1 = on IfxHost <value> = set Influxdb host name or IP address IfxPort <value> = set Influxdb port IfxDatabase <value> = set Influxdb V1 and database name IfxUser <value> = set Influxdb V1 and userid IfxPassword <value> = set Influxdb V1 and password IfxBucket <value> = set Influxdb V2 and bucket name IfxOrg <value> = set Influxdb V2 and organization IfxSensor Set Influxdb sensor logging 0 = off 1 = on IfxToken <value> = set Influxdb V2 and token IfxPeriod <value> = 0 = use Teleperiod value as publication interval (default) 10 .. 3600 = set a different publication interval Even when IfxPeriod 0 is used, publication is not necessarily performed at the same time as the telemetry message. IfxRp <value> = set Influxdb retention policy (optional) If blank, default is used as defined by the InfluxDB service. Retention policy must exist in InfluxDB, otherwise http post will fail. KNX ~ Command Parameters KnxTx_Cmnd<x> 0 or 1 = send command using slot <x> set in KNX Menu at KNX_TX KnxTx_Val<x> <value> = send float value using slot <x> set in KNX Menu at KNX_TX KnxTx_Scene <value> = send scene number to the GA set in KNX Menu KNX_ENABLED Status of KNX Communications 0 = set to Disable 1 = set to Enable KNX_ENHANCED Status of Enhanced mode for KNX Communications 0 = set to Disable 1 = set to Enable KNX_PA KNX Physical Address 0.0.0 = address not set x.x.x = set the device address (example 1.1.0 ) KNX_GA Return the amount of Group Address to Send Data/Commands configured KNX_GA<x> Setup Group Address to Send Data/Commands (<x> = KNX Group Address number) 1 = return configuration of GA<x> <option>, <area>, <line>, <member> to set configuration of GA<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Send Data/Commands KNX_CB Return the amount of Group Address to Receive Data/Commands configured KNX_CB<x> Setup Group Address to Receive Data/Commands 1 = return configuration of CB<x> <option>, <area>, <line>, <member> to set configuration of CB<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Receive Data/Commands OPTION OPTION Value OPTION OPTION Value 1 Relay 1 17 TEMPERATURE 2 Relay 2 18 HUMIDITY 3 Relay 3 19 ENERGY_VOLTAGE 4 Relay 4 20 ENERGY_CURRENT 5 Relay 5 21 ENERGY_POWER 6 Relay 6 22 ENERGY_POWERFACTOR 7 Relay 7 23 ENERGY_DAILY 8 Relay 8 24 ENERGY_START 9 Button 1 25 ENERGY_TOTAL 10 Button 2 26 KNX_SLOT1 11 Button 3 27 KNX_SLOT2 12 Button 4 28 KNX_SLOT3 13 Button 5 29 KNX_SLOT4 14 Button 6 30 KNX_SLOT5 15 Button 7 255 EMPTY 16 Button 8 ESP32 ~ BLE ESP32 ~ Command Parameters BLEAddrFilter Set BLE Address type filter. BLEAddrFilter = show filter level BLEAddrFilter n = set BLE address type filter 0..3 - default 3. Ignores BLE address types > filter value. Set 0 to ONLY see public addresses. BLEAlias Set Alias names for devices. A device may be referred to by it's alias in subsequent commands BLEAlias mac=alias mac=alias ... = set one or more aliases from devices. BLEAlias2 = clear all aliases. BLEDebug Set BLE debug level. BLEDebug = show extra debug information BLEDebug0 = suppress extra debug BLEDetails Display details about received adverts BLEDetails0 = disable showing of details. BLEDetails1 mac/alias = show the next advert from device mac/alias BLEDetails2 mac/alias = show all advert from device mac BLEDevices Cause a list of known devices to be sent on MQTT, or Empty the list of known devices. BLEDevices0 = clear the known devices list. BLEDevices = Cause the known devices list to be published on stat/TASName/BLE. BLEMaxAge Set the timeout for device adverts. BLEMaxAge n = set the devices timeout to n seconds. BLEMaxAge = display the device timeout. BLEMode Change the operational mode of the BLE driver. BLEMode0 = disable regular BLE scans. BLEMode1 = BLE scan on command only. BLEMode2 = regular BLE scanning (default). BLEName Read or write the name of a BLE device. BLEName mac|alias = read the name of a device using 1800/2A00. BLEName mac|alias = write the name of a device using 1800/2A00 - many devices are read only. BLEOp Perform a simple active BLE operation (read/write/notify). see separate description in source code BLEPeriod Set the period for publish of BLE data <value> = set interval in seconds BLEScan Cause/Configure BLE a scan BLEScan0 0..1 = enable or disable Active scanning. (an active scan will gather extra data from devices, including name) BLEScan = Trigger a 20s scan now if in BLEMode1 BLEScan n = Trigger a scan now for n seconds if in BLEMode1 iBeacon Show or set enable for the iBeacon driver iBeacon = Display 0 iBeaconClear Clear iBeacon list iBeaconOnlyAliased Show or set OnlyAliased for the iBeacon driver iBeaconOnlyAliased = Display 0 iBeaconPeriod Display or Set the period for publish of iBeacon data iBeaconPeriod = display interval iBeaconPeriod ss = set interval in seconds iBeaconTimeout Display or Set the timeout for iBeacon devices iBeaconTimeout = display timeout iBeaconTimeout ss = set timeout in seconds BLE MI Sensors ~ Command Parameters MI32Battery Trigger an active read of battery values. MI32Battery = request the driver read the battery from all sensors which have active battery read requirements. MI32Block Block or unblock a sensor device. MI32Block = list blocked devices by mac. MI32Block <mac or blealias> = Block one mac/alias. MI32Key Add a decryption key. MI32Key hexkey = add a 44 character decryption key to the keys list. MI32Keys Add one or more decryption keys by mac or alias. MI32Keys = list keys. MI32Keys <mac or blealias>=<bind_key> <mac or blealias>=<bind_key> ... = add keys for MAC or ble_alias. MI32Keys <mac or blealias>= - remove keys for one mac MI32Option<x> n Set driver options at runtime x=0 - 0 -> sends only recently received sensor data, 1 -> aggregates all recent sensors data types x=1 - 0 -> shows full sensor data at TELEPERIOD, 1 -> shows no sensor data at TELEPERIOD x=2 - 0 -> sensor data only at TELEPERIOD (default and \"usual\" Tasmota style), 1 -> direct bridging of BLE-data to mqtt-messages x=5 - 0 -> show all relevant BLE sensors, 1 -> show only sensors with a BLEAlias x=6 (from v 9.0.2.1) 1 -> always use MQTT Topic like tele/tasmota_ble/<name> containing only one sensor MI32Page Display/Set the sensors per page in the web view. MI32page = show sensors per page. MI32page n = Set sensors per page to n. MI32Period Display/Set the active scan and tele period for the MI32 driver. MI32Period = display the period in seconds. MI32Period n = Set the MI driver active read and tele period to n seconds. MI32Time <x> = set the time on the device in slot x . MI32Unit <x> = set the current Tasmota temperature unit as the temp unit for sensor in slot x . Camera ~ Command Parameters Wc Query all camera settings WcBrightness -2..+2 = set picture brightness WcContrast -2..+2 = set picture contrast WcFlip Flip camera image. 0 = disable (default) 1 = enable WcMirror Mirror camera image. 0 = disable (default) 1 = enable WcResolution Set camera resolution. 0 = 96x96 (96x96) 1 = QQVGA2 (128x160) 2 = QCIF (176x144) 3 = HQVGA (240x176) 4 = QVGA (320x240) 5 = CIF (400x296) 6 = VGA (640x480) 7 = SVGA (800x600) 8 = XGA (1024x768) 9 = SXGA (1280x1024) 10 = UXGA (1600x1200) WcSaturation -2..+2 = set picture saturation WcStream Control streaming 0 = stop 1 = start Ethernet ~ Command Parameters Ethernet Only for ESP32 boards with additional LAN chip 0 = disable Ethernet 1 = enable Ethernet (default) EthAddress 0..31 = PHYxx address EthClockMode Ethernet clock mode. 0 = ETH_CLOCK_GPIO0_IN (default) 1 = ETH_CLOCK_GPIO0_OUT 2 = ETH_CLOCK_GPIO16_OUT 3 = ETH_CLOCK_GPIO17_OUT EthType Ethernet type. 0 = ETH_PHY_LAN8720 (default) 1 = ETH_PHY_TLK110 2 = ETH_PHY_IP101 EthIpAddress Set device Ethernet IP address (for Wi-Fi, see IpAddress ) 0.0.0.0 = use dynamic IP address (DHCP) XXX.XXX.XXX.XXX = set static IP address Follow any IP configuration commands with restart 1 to apply changes EthGateway Set gateway IP address EthSubnetmask Set subnet mask EthDnsServer1 EthDnsServer2 Set DNS servers IP address See Also wifi - Enable/Disable Wi-Fi","title":"Commands"},{"location":"Commands/#how-to-use-commands","text":"Every command used without a parameter (payload) returns the current setting . Power returns the status of first defined power output (usually Relay1) Instead of 0 you can use off or false and instead of 1 you can use on or true . Power ON turns first defined power output (usually Relay1) on Power1 1 also turns first defined power output (usually Relay1) on Power1 True also turns first defined power output (usually Relay1) on Replace <x> in a command with the appropriate index number. Leave it empty to use the first available. Power1 and Power both control first defined power output (usually Relay1) In commands with x..y value parameters use a number from x to y range. When a command mentions resetting to \"firmware default\" it means the setting will revert to the one in the flashed binary file. If you used user_config_override.h at compile time it will revert to those. Note All commands are standard in the form: COMMAND < INDEX > DATA It has only one SPACE between INDEX and DATA . (There is no command in Tasmota that allows the = sign) Example Set networking IP (XXX.XXX.XXX.XXX) addresses using the command IPAddress<x> : IPAddress1 192.168.1.123 The = sign (It can be understood as the sign : ) is used only for meaning explanation reference: IPAddress1 = set device IP address Note Beside results initiated by a command (synchronous) you can get asynchronous results initiated by rule trigger, telemetry event, commands from other source or changed device values. Simply put, other messages may precede messages published as a result of your commands. Example A tele/%topic%/STATUS message (sent every 300 seconds by default) may appear exactly after you issue Power off command and before you receive stat/%topic%/RESULT = {\"POWER\":\"OFF\"} message.","title":"How to use commands"},{"location":"Commands/#with-mqtt","text":"To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued by using topic cmnd/%topic%/<command> and payload <parameter> where %topic% is the topic of the device you're sending the command to. If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . See MQTT article to find out more.","title":"with MQTT"},{"location":"Commands/#with-web-requests","text":"Commands can be executed via web (HTTP) requests, for example: http://<ip>/cm?cmnd=Power%20TOGGLE http://<ip>/cm?cmnd=Power%20On http://<ip>/cm?cmnd=Power%20off http://<ip>/cm?user=admin&password=joker&cmnd=Power%20Toggle Any spaces or special characters must be replaced with their ASCII hex codes . You must precede each hex code with % . Most used codes are: space = %20 and ; = %3B . Tip Use URLencoder.org to easily convert your commands. If you have set a password for web user interface access, this must be included (in plaintext) in the URL of the HTTP request, like so: http://<ip>/cm?user=<username>&password=<password>&cmnd=Power%20On","title":"with Web Requests"},{"location":"Commands/#in-console-in-the-web-ui","text":"Console menu in the web UI is a convenient place to send commands and it behaves similar to a terminal connection via serial bridge. Warning The GUI controls do not and can not have all the features and commands implemented. For precise and complete control use Console commands!","title":"in Console in the Web UI"},{"location":"Commands/#over-serial-bridge","text":"If you flashed the device via serial method you can connect to it with a terminal application (e.g. Termite or Arduino IDE Serial Monitor) to issue commands and follow responses. This is a practical way to do a Backlog setup of your new device. Serial interface is set to 115200 bps except for devices that require a different baud rate","title":"over Serial Bridge"},{"location":"Commands/#the-power-of-backlog","text":"Backlog command allows executing up to 30 consecutive commands with a single command line. Each command is separated by a semicolon (\";\"). Backlog is a useful feature to avoid numerous restarts when setting up a new device. You can use it to: Set up both Wi-Fi AP's Backlog SSID1 < myssid > ; Password1 < mypassword > ; SSID2 < myssid2 > ; Password2 < mypassword2 > Configure MQTT broker address, MQTT credentials, device topic and activate a few custom options Backlog MqttHost < yourhost > ; MqttUser < user > ; MqttPassword < password > ; Topic < customtopic > ; SetOption53 1 ; PowerRetain on For specific power control, using backlog like a script Backlog Status 1 ; Power2 on ; Delay 20 ; Power2 off ; Status 4 When using web requests (Don't forget to encode \"space\" as '%20' and \";\" as '%3B') http://<ip>/cm?user=admin&password=joker&cmnd=Backlog%20Power%20Toggle%3BPower1%20off A Backlog command without an argument clears an possible existing Backlog queue. Example in case of command Backlog Power1 OFF; Delay 600; Power1 ON the usage of an additional Backlog command without any argument within the delay time of 1 minute will delete the whole queue Power1 OFF; Delay 600; Power1 ON . Therefore Power1 ON command will not be executed and the power would remain off.","title":"the Power of Backlog"},{"location":"Commands/#commands-list","text":"Warning If you're using Tasmota versions earlier current release some of the commands might not work. Availability of some features and their associated commands depend on the firmware build. Please consult the builds table for a reference of which features are available for each firmware variant. Note Almost all settings using string parameters (except Rule and MqttFingerprint ) share a common area with max 698 chars, i.e. the total length of all these parameters is limited to this size (you will be noted if this limit is exceeded).","title":"Commands List"},{"location":"Commands/#control","text":"Command Parameters Backlog List of commands to be executed in sequence separated by ; See Using Backlog for examples. Backlog0 List of commands to be executed without any delay in sequence separated by ; See Using Backlog for examples. BlinkCount Number of relay toggles ( blinks ) (does not control the status LED) 0 = blink many times before restoring power state 1..32000 = set number of blinks (default = 10 ) BlinkTime 2..3600 set duration, in 0.1 second increments, to blink aka toggle Power (does not control the status LED) ButtonDebounce User control over button debounce timing 40..1000 = set button debounce time in milliseconds (default = 50 ) Buzzer 0 = stop active buzzer cycle <count>,<beep>,<silence>,<tune> = read more... 2,3 = Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 = Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds -1 = infinite mode -2 = follow LED mode BuzzerActive SetOption67 iFan03 Buzzer control 0 = disable Sonoff iFan03 buzzer (default) 1 = enable Sonoff iFan03 buzzer BuzzerPwm SetOption111 0 = (default) 1 = use frequency output for buzzer pin instead of on/off signal, for piezo buzzers DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group name and restart.\\ If a device group name is not set for a group, the MQTT group topic ( GroupTopic ) is used (with the device group number appended for device group numbers > 1). DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract), ^ (invert), & (bitwise AND) or | (bitwise OR). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. To indicate that an item should not be shared with the group until changed again, prefix the value with N. 3 = Light fade (0 = Off, 1 = On) 4 = Light speed (1..40) 5 = Light brightness (0..255) 6 = Light Scheme 7 = Light fixed color (0 = white (using CT channels), other values according to Color ) 8 = PWM dimmer low preset (0..255) 9 = PWM dimmer high preset (0..255) 10 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 129 = No Status Share - DevGroupShare bitmask indicating which items should not be shared until changed. 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) or hex color value (#RRGGBB, #RRGGBBWW, etc.) Examples: DevGroupSend 5=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 5=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. DevGroupSend 224=NFF0000 - set the color to red locally and inform the group that light channel information is not to be shared until changed. DevGroupSend 129=@\\|18 - do not share light brightness or channel status until changed. DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members. DevGroupTie<x> <relay> = Tie the relay to the device group <x>. Only applies when option 88 is enabled. FanSpeed Fan speed control (iFan02/iFan03 only) 0 = turn fan OFF 1..3 = set fan speed + = increase fan speed - = decrease fan speed Interlock Relay interlock mode and group selection. 0 = disable relay interlock for all relays (i.e., each relay is self-locking) (default) 1 = set interlock mode for selected relays Add up to 8 relays in 1 to 4 interlock groups, each separated by a space. For example 1,2 3,4 = Group Relay1 and Relay2 in group 1 and Relay3 and Relay4 in group 2 ( note the space between the two groups ) 1,2,3 = group Relay1, Relay2 and Relay3 in a single interlock group 1 3 2,4 = Relay1 is in group 1, Relay3 in group 2, Relay2 and Relay4 in group 3 Json Input any command as valid JSON {<Tasmota commands>} example: cmnd/tasmota/json {\"HSBColor\":\"360,100,100\",\"Scheme\": 1,\"Dimmer\": 10,\"CT\": 220} LedMask Set a bitmask specifying which relays control the LED indicator. Read more... <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. LedPower LED power state as on or off 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 8 2 = toggle LED and set LedState 0 (Use Backlog LedPower 0; SetOption31 1 to disable LED even when Wi-Fi or MQTT is not connected) LedPower<x> LED<x> power state control. Enabled only when LedLink(i) is configured 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 0 2 = toggle LED and set LedState 0 LedState Manage LED state 0 = disable use of LED as much as possible 1 = show power state on LED (LED on when power on) (default) (inverted for Sonoff Touch/T1) 2 = show MQTT subscriptions as a LED blink 3 = show power state and MQTT subscriptions as a LED blink 4 = show MQTT publications as a LED blink 5 = show power state and MQTT publications as a LED blink 6 = show all MQTT messages as a LED blink 7 = show power state and MQTT messages as a LED blink 8 = LED on when Wi-Fi and MQTT are connected. Cannot be issued directly and is only activated when LedPower is switched from 0 to 1 due to a software function NoDelay Delay defined by SetOption34 is omitted for any command in a backlog sequence following immediately after NoDelay This must be used with care, and only for simple commands. Example Power0 Control the power state simultaneously for all power outputs on the device 0 / off = turn OFF 1 / on = turn ON 2 / toggle = if relay is ON switch to OFF and vice versa Power<x> Control the corresponding power state ( 1..8 ) (also restarts PulseTime)<x> 0 / off / false = turn OFF 1 / on / true = turn ON 2 / toggle = if power state is ON switch to OFF and vice versa 3 / blink = toggle power for BlinkCount times each BlinkTime duration (at the end of blink , power state is returned to pre-blink state) 4 / blinkoff = stop blink sequence and return power state to pre-blink state PowerOnState Control power state when the device is powered up . More information 0 / OFF = keep power(s) OFF after power up 1 / ON = turn power(s) ON after power up 2 / TOGGLE = toggle power(s) from last saved state 3 = switch power(s) to their last saved state (default) 4 = turn power(s) ON and disable further power control 5 = after a PulseTime period turn power(s) ON (acts as inverted PulseTime mode) PulseTime<x> Display the amount of PulseTime remaining on the corresponding Relay<x>(x = 0..31 ) <value> Set the duration to keep Relay<x> ON when Power<x> ON command is issued. After this amount of time, the power will be turned OFF . 0 / OFF = disable use of PulseTime for Relay<x> 1..111 = set PulseTime for Relay<x> in 0.1 second increments 112..64900 = set PulseTime for Relay<x>, offset by 100, in 1 second increments. Add 100 to desired interval in seconds, e.g., PulseTime 113 = 13 seconds and PulseTime 460 = 6 minutes (i.e., 360 seconds) Note if you have more than 8 relays: Defined PulseTime for relays <1-8> will also be active for correspondent Relay <9-16>. SwitchDebounce User control over switch debounce timing and method 40..1000 = set switch debounce time in milliseconds (default = 50 ) . The granularity is 10 milliseconds, so the normally unnecessary last digit is used by the debouncing code to flag special handling: 0 = no special handling 1 = force_high: only a debounce time long LOW pulse could turn the switch off 2 = force_low: only a debounce time long HIGH pulse could turn the switch on 3 = force_high + force_low 4..8 = unused 9 = AC detection for switches / relays similar to MOES MS-104B / BlitzWolf SS5 etc. If the AC frequency is 50 Hz, SwitchDebounce 69 will turn on the switch after three pulses and off after three missing one. SwitchMode<x> Switch mode 0 = toggle (default) 1 = follow (0 = off, 1 = on) 2 = inverted follow (0 = on, 1 = off) 3 = pushbutton (default 1, 0 = toggle) 4 = inverted pushbutton (default 0, 1 = toggle) 5 = pushbutton with hold (default 1, 0 = toggle, Hold = hold) 6 = inverted pushbutton with hold (default 0, 1 = toggle, hold = hold) 7 = pushbutton toggle (0 = toggle, 1 = toggle) 8 = multi change toggle (0 = toggle, 1 = toggle, 2x change = hold) 9 = multi change follow (0 = off, 1 = on, 2x change = hold) 10 = inverted multi change follow (0 = on, 1 = off, 2x change = hold) 11 = pushbutton with dimmer mode 12 = inverted pushbutton with dimmer mode 13 = pushon mode (1 = on, switch off using PulseTime ) 14 = inverted pushon mode (0 = on, switch off using PulseTime ) 15 = send only MQTT message on switch change (Example tele/tasmota/SENSOR = {\"Time\":\"2021-01-01T00:00:00\",\"Switch1\":\"OFF\"} ) SwitchText<x> Show current JSON label of Switch<x> ( 1..8 ). Only SwitchText shows value for all 8 switches <text> - replace default Switch<x> label in JSON messages with a custom text WebButton<x> Change the name of the toggle buttons of the WEB UI. This command accepts spaces in the name WebQuery<x> Command for GET, POST, PUT, and PATCH HTTP queries, complete with Request Headers and request body (when applicable) <url> GET|POST|PUT|PATCH [<headers>] <body> More information... See also SetOption1 - Set button multipress mode SetOption11 - Swap pushbutton single and double press functionality SetOption13 - Allow immediate action on single button press SetOption26 - Use indexes even when only one relay is present SetOption31 - Disable Wi-Fi LED status blinking SetOption32 - Set hold interval before sending HOLD action SetOption40 - Stop detecting any input change on button GPIO SetOption67 - Enable/Disable Buzzer SetOption73 - Decouple buttons from controlling power outputs","title":"Control"},{"location":"Commands/#management","text":"Command Parameters Delay 2..3600 = set a delay between two backlog commands with 0.1 second increment. Not recommended for precision timing! DeepSleepTime Time to enter deep sleep mode 0 = disable deep sleep mode (default) 11..86400 = set deep sleep mode time period in seconds DeviceName Device name displayed in the webUI and used for HA autodiscovery. <value> = set device name (default = FriendlyName1 value) Emulation 0 = disable emulation (default) 1 = enable Belkin WeMo emulation for Alexa 2 = enable Hue Bridge emulation for Alexa FriendlyName<x> 1 = Reset friendly name to firmware default <value> = set friendly name (32 char limit) Gpios Show list of available components by name and index 255 / All Show list of all components by name and index Gpio Show current component assignments of the Module's configurable GPIO 255 / All Show component assignments for all the devices available GPIO Gpio<x> <component> = assign a component to Gpio<x> I2Cscan Scan I 2 C bus and show addresses for found devices I2CDriver Enable / Disable I 2 C sensor drivers. Read more... LogHost 1 = reset syslog host to firmware default ( SYS_LOG_HOST ) <value> = set syslog host LogPort 1 = reset syslog port to firmware default ( SYS_LOG_PORT ) 2..32766 = set syslog port Modules Show available modules by name and index Module Displays active module by name and index <value> = switch to module <value> and restart 0 = switch to defined template and restart Module2 Displays active fast reboot fallback module by name and index <value> = set fast reboot fallback module to <value> 0 = set fast reboot fallback module to defined template MqttLog 0 = disable logging via MQTT (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messsages NtpServer<x> NTP server setup (x= 1..3 ) 0 = clear NtpServer<x> settings 1 = reset NtpServer<x> settings to firmware defaults <value> = set NtpServer<x> host or IP address (32 char limit) OtaUrl Display current OTA URL 1 = Reset OtaUrl to firmware default url = set address for OTA (100 char limit) Pwm<x> 0..1023 = set PWM value for channel (NOTE see SetOption15 ) PwmFrequency 1 = reset PWM frequency to 223Hz 40..4000 or 40..50000 = set PWM frequency (40Hz to 4kHz on ESP 82xx / 40-50kHz on ESP32) As of v8.3.0 the default frequency changed to 977Hz PwmRange 1 = reset maximum PWM range to 1023 255..1023 = set maximum PWM range Reset 1 = reset device settings to firmware defaults and restart (see warning below) 2 = erase flash, reset device settings to firmware defaults and restart 3 = erase System Parameter Area in flash (Wi-Fi calibration and related data) and restart (see warning below) 4 = reset device settings to firmware defaults but retain Wi-Fi credentials and restart 5 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi settings and restart 6 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi and MQTT settings and restart (Erase of flash can take a few seconds to complete and there is no output during the erase process on the serial or web console) 99 = reset device bootcount to zero For reset 3 and reset 1 , device must be power-cycled in order to load new Wifi System parameters. Restart 1 = restart device with configuration saved to flash 2 = halt system (needs hardware reset or power cycle to restart) 99 = force restart device without configuration save For debug and testing stack trace dumps only: -1 = force an Exception (28) crash -2 = force a Soft WDT reset (after a freeze of 2 seconds) -3 = force an OS watchdog reset (after a freeze of 120 seconds, caution! ) RtcNtpServer<x> Use Tasmota NTP server when enabled by define RTC_NTP_SERVER 0 = disabled 1 = enabled SaveData 0 = save parameter changes only manually, e.g. with Restart 1 1 = save parameter changes every second (default) 2..3600 = save parameter changes every x second SerialLog Disable hardware serial bridge and 0 = disable serial logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages SerialLog will be disabled automatically 10 minutes after the device reboots. SetSensor<x> Enable / Disable individual sensor driver(x= 1..127 ) Sleep 0 = turn sleep off 1..250 = set sleep duration in milliseconds to enable energy saving (default = 50 ) State Display current device state and publish to %prefix%/%topic%/RESULT topic\u2003 Status = show abbreviated status information 0 = show all status information (1 - 11) 1 = show device parameters information 2 = show firmware information 3 = show logging and telemetry information 4 = show memory information 5 = show network information 6 = show MQTT information 7 = show time information 8 = show connected sensor information (retained for backwards compatibility) 9 = show power thresholds (only on modules with power monitoring) 10 = show connected sensor information (replaces 'Status 8') 11 = show information equal to TelePeriod state message 12 = in case of crash to dump the call stack saved in RT memory Status0 0 = show all status information in a single line SysLog 0 = disable syslog logging (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messages Template Show current Template 0 = create template from active module x = create template from a supported module 255 = merge current module and template settings into new template { ... } = store template in a JSON payload Does not activate the template. To activate use Module 0 . Time 0 = enable NTP (default) 1 = format JSON message timestamp in ISO format 2 = format JSON message timestamp in both ISO and Epoch format 3 = format JSON message timestamp in Epoch format 4 = format JSON message timestamp in milliseconds <value> = disable NTP and set UTC time as epoch value if greater than 1451602800 (January 1, 2016) TimeStd TimeDst Set policies for the beginning of daylight saving time (DST) and return back to standard time (STD)\u2003 Use the Tasmota timezone table to find the commands for your time zone. 0 = reset parameters to firmware defaults H , W , M , D , h , T H = hemisphere ( 0 = northern hemisphere / 1 = southern hemisphere) W = week ( 0 = last week of month, 1..4 = first .. fourth) M = month ( 1..12 ) D = day of week ( 1..7 1 = Sunday 7 = Saturday) h = hour ( 0..23 ) in local time T = time zone ( -780..780 ) (offset from UTC in MINUTES - 780min / 60min=13hrs) Example: TIMEDST 1,1,10,1,2,660 _If time zone is NOT 99, DST is not used (even if displayed) see Timezone -13..+13 = set time zone offset from UTC in hours -13:00..+13:00 = set time zone offset from UTC in hours and minutes 99 = use time zone configured with TimeDst and TimeStd Use the Tasmota time zone table to find the commands for your time zone. Ufs Universal File System commands read more... UfsDelete Delete SD card or Flash FS file if only of them available UfsDelete2 Delete only Flash FS file if available UfsFree Filesystem free size in kb UfsRename Rename SD card or Flash FS file if only of them available UfsRename2 Rename only Flash FS file if available UfsRun Run file UfsSize Filesystem size in kb UfsType Get filesystem type 0 = none 1 = SD card 2 = Flash file 3 = LittleFS Upgrade 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if <value> is higher than device version Upload 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if <value> is higher than device version WebGetConfig <url> = pull a configuration .dmp file from a HTTP URL More information... WebLog 0 = disable web logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages WebTime <start_pos>,<end_pos> = show part of date and/or time in WebUI based on \"2017-03-07T11:08:02-07:00\" See also SetOption68 - PWM Channel control SetOption76 - DeepSleep disable bootcount incrementing","title":"Management"},{"location":"Commands/#wi-fi","text":"Command Parameters AP 0 = switch to other Wi-Fi Access Point 1 = select Wi-Fi Access Point 1 2 = select Wi-Fi Access Point 2 CORS \" = disable CORS (Cross Origin Resource Sharing) (default) * = enable CORS for all locations value = Enable CORS for location. This needs to be complete url ex: http://tasui.shantur.com Hostname 1 = reset hostname to MQTT_TOPIC-<4digits> and restart <value> = set hostname (32 char limit) and restart. If hostname contains % it will be reset to the default instead. See FAQ for allowed characters. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. IPAddress<x> Set networking IP ( XXX.XXX.XXX.XXX ) addresses IPAddress1 to set device IP address 0.0.0.0 to use dynamic IP address (DHCP) XXX.XXX.XXX.XXX to set static IP address IPAddress2 to set gateway IP address IPAddress3 to set subnet mask IPAddress4 to set DNS server IP address IPAddress5 to set Secondary DNS server IP address follow IPAddress commands with restart 1 to apply changes Password<x> <x> = 1..2 <value> = set AP<x> Wi-Fi password and restart 1 = reset AP<x> Wi-Fi password to firmware default ( STA_PASS1 or STA_PASS2 ) and restart Passwords are limited to 64 characters. Do not use special characters or white spaces in the password . Note that Password and Password1 are equivalent commands. Ping<x> <addr> <x> = 0..8 = the number of ICMP packets to send, 0 uses the default (4) <addr> = address to send Ping, either in numerical format 192.168.1.200 or domain name tasmota.com (requires #define USE_PING ) Example Ping4 192.168.1.203 : RSL: tele/tasmota_xxx/RESULT = {\"Ping\":{\"192.168.1.203\":{\"Reachable\":true,\"Success\":4,\"Timeout\":0,\"MinTime\":59,\"MaxTime\":167,\"AvgTime\":116}}} Ssid<x> <x> = 1..2 <value> = set AP<x> Wi-Fi SSID and restart 1 = reset AP<x> Wi-Fi SSID to firmware default ( STA_SSID1 or STA_SSID2 ) and restart SSID are limited to 32 characters. Do not use special characters or white spaces in the SSID TCPBaudRate Requires GPIOs TCP Tx and TCP Rx and can work with hardware or software serial. 1200..115200 = set the baudrate for serial (only 8N1 mode) TCPConnect , <port> = Port used for connection = IP address to connect to TCPConfig <value> = standard 3 characters mode such as 8N1, 7E1, etc ... TCPStart Requires GPIOs TCP Tx and TCP Rx and can work with hardware or software serial. Also works with ModBus Bridge <port>, [<ipaddress>] = Start listening to port. If <ipaddress> is defined only allows connections from the provided IPv4 address 0 = Shut down TCP server and disconnect any existing connection Supports 2 parallel TCP connections, which can be useful if you need a terminal + a specific protocol (like XMODEM). The 3rd connection will disconnect a previous connection. The number of parallel connections is a compile-time option. WebColor<x> Configure Web GUI colors (x = 1..19 ) #RRGGBB = Set color for WebColor<x> 1 = Global text (Black) 2 = Global background (White) 3 = Form background (Greyish) 4 = Input text (Black) 5 = Input background (White) 6 = Console text (Black) 7 = Console background (White) 8 = Warning text (Red) 9 = Success text (Green) 10 = Button text (White) 11 = Button (Blueish) 12 = Button hovered over (Darker blue-ish) 13 = Restart/Reset/Delete button (Red-ish) 14 = Restart/Reset/Delete button hover (Darker red-ish) 15 = Save button (Green-ish) 16 = Save button hover (Darker greenish) 17 = Config timer tab text (White) 18 = Config timer tab background (Light grey) 19 = Module title and FriendlyName text (Whiteish) User themes WebPassword Show current web server password 0 = disable use of password for web UI 1 = reset password to firmware default ( WEB_PASSWORD ) <value> = set web UI password (32 char limit) for user WEB_USERNAME (Default WEB_USERNAME = admin ) WebQuery Send HTTP GET, POST, PUT, and PATCH Requests <url> <method> [<header1Name:header1Value\\|header2Name:header2Value...>]<body> <url> = HTTP URL to query <method> = HTTP Request method. Must be GET , POST , PUT , or PATCH [<header1Name:header1Value\\|header2Name:header2Value...>] (optional) = HTTP Request Headers. <body> (optional) = HTTP Request Body. Ignored for GET requests Examples WebQuery http://www.mysite.com/api/status GET : Simple HTTP GET Request WebQuery http://www.mysite.com/api/update POST [Authorization:Bearer xyz\\|Content-Type:application/json]{\"message\":\"body\"} : Sends POST data with an authorization header and Content-Type WebQuery http://www.mysite.com/api/set PUT {\"message\":\"body\"} : Sends PUT request with a body, but no headers WebRefresh Web page refresh 1000..10000 = set refresh time in milliseconds (default = 2345 ) WebSend Send a command to Tasmota host over http. If a command starts with a / it will be used as a link. [<host>:<port>,<user>:<password>] <command> <host> = hostname or IP address. <port> = port for the device if not the default 80 <user> = enter username of the device you're sending the command to <password> = enter password of the device you're sending the command to <command> = command and payload example 1: [<ip>] POWER1 ON sends http://<ip>/cm?cmnd=POWER1 ON example 2: WebSend [myserver.com] /fancy/data.php?log=1234 sends http://myserver.com/fancy/data.php?log=1234 WebGetConfig <url> Download a configuration (*.dmp) from an http URL. The URL can include %id% which will be substituted by the device's MAC address without the dots. A possible usage for ones that compile their own binary is to include the command in USER_BACKLOG for automatic reconfiguration after a reset 1 command. WebSensor<x> Control display of sensor telemetry in the web UI 0 = Do not display sensor's telemetry 1 = Display sensor's telemetry ( default ) <x> = number corresponding to the sensor - listed in the sns section of the supported sensor spreadsheet <x> = 3 Energy telemetry Issue a Status 4 to obtain a list of sensor types enabled in the firmware loaded on the device. WebServer 0 = stop web server 1 = start web server in user mode 2 = start web server in admin mode Wifi 0 = disable Wi-Fi 1 = enable Wi-Fi (default) ESP8266 only: 2 = Wi-Fi mode 802.11b 3 = Wi-Fi mode 802.11b/g 4 = Wi-Fi mode 802.11b/g/n When wifi is Off it is always returned On after a restart except for a wake-up from deepsleep. WifiConfig 0 = disable Wi-Fi Manager and reboot (used with alternate AP) 2 = set Wi-Fi Manager as the current configuration tool and start Wi-Fi Manager (web server at 192.168.4.1) for 3 minutes, then reboot and try to connect Wi-Fi network 4 = retry other AP without rebooting (default) 5 = wait until selected AP is available again without rebooting 6 = Wi-Fi parameters can only be entered via commands in the serial console 7 = set Wi-Fi Manager (web server at 192.168.4.1) as the current configuration tool restricted to reset settings only. This setting is recommended for devices without an external control/reset button . \u2003 No longer supported 1 = set SmartConfig ( Android /iOS) for 3 minutes 3 = set WPS for 3 minutes WifiPower set Wi-Fi transmit power level in decibel-milliwatts (dBm) (default = 17 ) WifiScan 1 = start a network scan. Results will be sent as a JSON payload. Read more... WifiTest<x> Test whether the Wi-Fi SSId and Password are correct and Tasmota can connect to the network. <x> = 0..2 0 = test credentials, if successful save them in SSID slot 1, restart Tasmota 1 = test credentials, if successful save them in SSID slot 1 without restart 2 = test credentials, if successful save them in SSID slot 2 without restart ssid+password = credentials used for testing, + symbol is the separator since it is not allowed in an SSId name.* Read more... See also SetOption55 - mDNS service control SetOption56 - Wi-Fi network scan to select strongest signal on restart SetOption57 - Wi-Fi network re-scan, alternate AP","title":"Wi-Fi"},{"location":"Commands/#mqtt","text":"Command Parameters ButtonRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on button press ButtonTopic <value> = set MQTT button topic 0 = disable use of MQTT button topic 1 = set MQTT button topic to device %topic% 2 = reset MQTT button topic to firmware default ( MQTT_BUTTON_TOPIC ) (default = 0 ) If using MQTT to issue this command, if it is published to the device GroupTopic , the command will not be executed. FullTopic 1 = reset MQTT fulltopic to firmware default ( MQTT_FULLTOPIC ) and restart <value> = set MQTT fulltopic and restart. Use of optional %prefix%, %topic%, %hostname%, and %id% substitution tokens is allowed. If using MQTT to issue this command, if it is published to the device GroupTopic , you must ensure uniqueness of the resulting fulltopic on each destination device by using one or more of these substitution tokens. GroupTopic<x> 1 = reset MQTT group <x> topic to firmware default ( MQTT_GRPTOPIC ) and restart <value> = set MQTT group <x> topic and restart InfoRetain 0 = disable use of info MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/INFO<x> MqttClient 1 = reset MQTT client to firmware config ( MQTT_CLIENT_ID ) and restart <value> = set MQTT client and restart. You can use the %06X substitution token to replace with last six characters of MAC address. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. MqttFingerprint TLS needs to be enabled in firmware for this command \u2003 <value> = set current fingerprint as 20 space separated bytes (59 chars max) MqttHost 0 = clear MQTT host field and allow mDNS to find MQTT host 1 = reset MQTT host to firmware default ( MQTT_HOST ) and restart <value> = set MQTT host and restart (do NOT use .local ) MqttKeepAlive 1..100 = set MQTT Keep Alive timer (default = 30 ) MqttPassword 0 = clear MQTT password 1 = reset MQTT password to firmware default ( MQTT_PASS ) and restart <value> = set MQTT password and restart (min 5 chars) MqttPort 1 = reset MQTT port to firmware default ( MQTT_PORT ) and restart <value> = set MQTT port between 2 and 32766 and restart MqttRetry 10..32000 = set MQTT connection retry timer in seconds (default = 10 ) MqttTimeout 1..100 = set MQTT socket timeout (default = 4 ) MqttUser 0 = clear MQTT user name 1 = reset MQTT user name to firmware default ( MQTT_USER ) and restart <value> = set MQTT user name and restart MqttWifiTimeout 100..20000 = set MQTT Wi-Fi connection timeout in milliseconds (default = 200 ) PowerRetain MQTT power retain state 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update Prefix1 1 = reset MQTT command subscription prefix to firmware default ( SUB_PREFIX ) and restart <value> = set MQTT command subscription prefix and restart Prefix2 1 = reset MQTT status prefix to firmware default ( PUB_PREFIX ) and restart <value> = set MQTT status prefix and restart Prefix3 1 = Reset MQTT telemetry prefix to firmware default ( PUB_PREFIX2 ) and restart <value> = set MQTT telemetry prefix and restart Publish <topic> <payload> = MQTT publish any topic and optional payload\u2003 Publish2 <topic> <payload> = MQTT publish any topic and optional payload with retain flag SensorRetain 0 = disable use of sensor MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/SENSOR StateRetain 0 = disable use of state MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/STATE StateText<x> <value> = set state text ( <x> = 1..4 ) 1 = OFF state text 2 = ON state text 3 = TOGGLE state text 4 = HOLD state text SwitchRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on switch press Subscribe Subscribes to an MQTT topic without appended /# and assigns an Event name to it. <eventName>, <mqttTopic> [, <key>] = Read more... = list all topics currently subscribed Subscribe2 Subscribes to an MQTT topic and assigns an Event name to it. <eventName>, <mqttTopic> [, <key>] = Read more... = list all topics currently subscribed SwitchTopic <value> = set MQTT switch topic 0 = disable use of MQTT switch topic 1 = set MQTT switch topic to device %topic% 2 = reset MQTT switch topic to firmware default ( MQTT_SWITCH_TOPIC ) (default = 0 ) Read more about this. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. TelePeriod See current value and force publish STATE and SENSOR message 0 = disable telemetry messages 1 = reset telemetry period to firmware default ( TELE_PERIOD ) 10..3600 = set telemetry period in seconds (default = 300 ) Topic 1 = reset MQTT topic to firmware default ( MQTT_TOPIC ) and restart <value> = set MQTT topic and ButtonTopic and restart. When using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. Topic can not be identical to MqttClient Unsubscribe Unsubscribe from topics subscribed to with Subscribe = unsubscribe all topics <eventName> = unsubscribe from a specific MQTT topic See also SetOption3 - Disable//Enable MQTT SetOption4 - Return MQTT response as RESULT or %COMMAND% topic SetOption10 - Main topic change behavior SetOption104 - Disable MQTT retained messages (some brokers don't support them)","title":"MQTT"},{"location":"Commands/#rules","text":"Command Parameters Add<x> <value> = add value to Var<x> ( example ) CalcRes Current calculation resolution 0..7 = set number of decimal places to be used in Add , Sub , Mult and Scale Event Execute an event to trigger a rule as documented \u2003 Mem<x> Manage up to 16 variables stored on flash (x = 1..16 ) Mem returns all current values. Mem<x> returns the variable's current value. <value> = store a string value in a variable \" = clear stored value in Mem<x> Mult<x> <value> = multiply value to Var<x> ( example ) Rule<x> Rules. Read more... 0 = disable Rule<x> 1 = enable Rule<x> 2 = toggle Rule<x> 4 = disable one-shot detection (perform commands as long as trigger is met) 5 = enable one-shot (e.g., sometimes used for slow changing sensors like temperature) detection 6 = toggle one-shot detection 8 = disable stop-on-error after exception restart 9 = enable stop-on-error after exception restart 10 = toggle stop-on-error after exception restart <value> = define Rule<x> +<value> = append to Rule<x> \" = clear Rule<x> Rule set one-shot: Each rule within the rule set will trigger only once until the trigger condition returns to a false condition. For example, ON Energy#Power<3 : Without one-shot enabled, it will trigger anytime Energy#Power gets an update (i.e., the Power telemetry value changes) and the value is <3 . This can potentially trigger that rule multiple times. With one-shot enabled, the rule will trigger only the on the first transition to <3 and not again until the trigger value goes >=3 . In other words, the rule will trigger again, but it has to cross the conditional \"boundary\" before it will trigger again. Rule0 Same functionality as Rule<x> but affects all rulesets at once RuleTimer<x> Up to eight timers to be used as countdown event (x = 1..8 )\u2003 0..65535 = set countdown rule timer in seconds RuleTimer0 0 = stops and clear all timer simultaneously Scale<x> Scale value from a low and high limit to another low and high limits and save in Var<x> ( example ) v = value: the number to scale fl = fromLow: the lower bound of the value\u2019s current range fh = fromHigh: the upper bound of the value\u2019s current range tl = toLow: the lower bound of the value\u2019s target range th = toHigh: the upper bound of the value\u2019s target range Sub<x> <value> = subtract value to Var<x> ( example ) Var<x> Manage up to 16 variables stored in memory (x = 1..16 ) Var returns all current values. Var<x> returns the variable's current value. <string> = store a string value in a variable \" = clear stored value in Var<x>","title":"Rules"},{"location":"Commands/#timers","text":"Command Parameters Latitude <value> = set latitude in decimal degrees format, e.g. -33.893681 Longitude <value> = set longitude in decimal degrees format, e.g. 18.619954 Timers Timers control 0 = disable all timers 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x> 1..16 = copy Timer<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table Information on sensors documented below is transmitted in the Tasmota telemetry message","title":"Timers"},{"location":"Commands/#sensors","text":"Command Parameters AdcParam<x> ADC analog input tuning parameters. On ESP32 x is channel 1..8 <sensor>, <param1>, <param2>, <param3>, <param4> complete <sensor> values listed here... Altitude -30000..30000 = altitude in meters AmpRes Current sensor resolution 0..3 = maximum number of decimal places BH1750Resolution<x> BH1750 resolution mode. x = BH1750 sensor number ( 1..2 ) 0..2 = choose sensor resolution ( 0 = high (default) , 1 = high2, 2 = low) BH1750MTime<x> BH1750 Measurement Time value. x = BH1750 sensor number ( 1..2 ) 30..255 = set Measurement Time value. Not persistent after reboot. (default = 69 ) Counter<x> 0 = reset Counter<x> 1..2,147,483,645 = preset Counter<x> -1..-2,147,483,645 = decrease Counter<x> +1..+2,147,483,645 = increase Counter<x> In order to define and use a Counter, * you must configure one of the free device GPIO as Counter<x> . Counter module configuration is using internal pull-up resistor while Counter n does not. * CounterDebounce 0 = turn off counter debounce 1..32000 = set counter debounce time in milliseconds. Counter is increased with every falling edge when CounterType =0 or time between successive falling edges is measured when CounterType =1. When CounterDebounceLow and CounterDebounceHigh are set to zero (default) only falling edges of the counter's GPIO are checked. Any CounterDebounceLow or CounterDebounceHigh unequal zero checks are carried out before CounterDebounce check is done. As an example you can set CounterDebounce 500 to allow a minimum distance between to successive valid falling edges equal to 500ms. CounterDebounceLow 0 = turn off counter debounce low 1..32000 = set counter debounce low time in milliseconds. Allow individual debounce times for low pulse widths to discard non valid falling edges. These are checked before legacy CounterDebounce checks distance between two valid falling edges. When unequal zero tasmota will check falling and rising edges on the counter's GPIO. For CounterDebounceLow any GPIO change from low to high hat happens after the GPIO was not low for at least CounterDebounceLow will be ignored. As an example you can set CounterDebounceLow 50 to allow a valid minimum distance between a falling and rising edge equal to 50ms while having a final CounterDebounce 500 check between to successive valid falling edges equal to 500ms. CounterDebounceHigh 0 = turn off counter debounce high 1..32000 = set counter debounce high time in milliseconds. Allow individual debounce times for high pulse widths to discard non valid falling edges. These are checked before legacy CounterDebounce checks distance between two valid falling edges. When unequal zero tasmota will check falling and rising edges on the counter's GPIO. For CounterDebounceHigh any GPIO change from high to low hat happens after the GPIO was not high for at least CounterDebounceHigh will be ignored. As an example you can set CounterDebounceHigh 100 to allow a valid minimum distance between a rising and falling edge equal to 100ms while having a final CounterDebounce 500 check between to successive valid falling edges equal to 500ms. CounterType<x> 0 = set Counter<x> as pulse Counter 1 = set Counter<x> as pulse Timer GlobalHum 0.0..100.0 = Set global Humidity for some Sensors that uses global Humidity. GlobalHum2 1..250 = select Global Humidity source indexed from teleperiod occurence data. GlobalPress2 1..250 = select Global Pressure source indexed from teleperiod occurence data. GlobalTemp -50.0..100.0 = Set global Temperature for some Sensors that uses global temperature. GlobalTemp2 1..250 = select Global Temperature source indexed from teleperiod occurence data. HumOffset -10.0..10.0 = Set calibration offset value for reported humidity telemetry This setting affects all humidity sensors on the device. HumRes Humidity sensor resolution 0..3 = maximum number of decimal places PressRes Pressure sensor resolution 0..3 = maximum number of decimal places NPCLRes Neopool only <value> = number of digits in results for CL values NPIonRes Neopool only <value> = number of digits in results for ION values NPPHRes Neopool only <value> = number of digits in results for PH values Sensor12 ADS1115 mode selection (default S0 ). Note that Vdd (2.0-5.5v) must be >= analog voltage inputs. D0 .. D5 = differential modes S0 .. S5 = single-ended modes 0 = +/- 6.144v 1 = +/- 4.096v 2 = +/- 2.048v 3 = +/- 1.024v 4 = +/- 0.512v 5 = +/- 0.256v Sensor13 INA219 and ISL28022 low voltage current sensor configuration Predefined modes to use with standard 0.1 ohm resistor: 0 = set INA219 calibration to max 32V and 2A 1 = set INA219 calibration to max 32V and 1A 2 = set INA219 calibration to max 16V and 0.4A In all cases, ISL28022 is set to 60V mode 10 .. 255 : Define custom shunt resistor encoded as a decimal number RRM such that Rshunt = RR * 10^M milliohm Do not forget to choose a resistor adapted for the correct power dissipation and apply a 50% security margin ! Examples: 11 = 1 * 10^1 = 10 milliohm (Imax=32A => Pres=15W) 21 = 2 * 10^1 = 20 milliohm (Imax=16A => Pres=7W) 12 = 1 * 10^2 = 100 milliohm (default, Imax=3.2A => Pres=2W) 13 = 1 * 10^3 = 1000 milliohm = 1 ohm (Imax=0.320A => Pres=0,2W) The driver seamlessly detect INA219/ISL28022 and adapt configuration and readings accordingly. The component label in Web GUI and SENSOR message will automatically match the detected part. It is possible to mix INA219 and ISL28022 as far as addresses do not conflicts. Shunt resistor setting applies to all INA219/ISL28022. Sensor15 Automatic Baseline Correction for MH-Z19B CO 2 sensor 0 = disable 1 = enable (default) 2 = start manual calibration from 400 ppm of CO 2 9 = reset sensor to factory defaults 1000 = sets measurement range to 1000ppm CO 2 2000 = sets measurement range to 2000ppm CO 2 3000 = sets measurement range to 3000ppm CO 2 5000 = sets measurement range to 5000ppm CO 2 10000 = sets measurement range to 10000ppm CO 2 Sensor18 PMSx003 particle dust sensor 0..32000 = control sensor polling interval to extend lifetime Sensor20 Nova Fitness SDS011 dust sensor. 1..255 = number of seconds before TelePeriod to poll the sensor Sensor27 APDS-9960 sensor commands 0 = enable light level and proximity sensor / disable gestures (default) 1 = enable gesture mode/ disable light level and proximity sensor 2 = enable gestures with half gain / disable light and proximity sensor 3..255 = Set ATIME register for different integration times Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration. Read more... Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup|outstate{,repmode}} Continue reading... Sensor34 HX711 load cell sensor calibration 1 = reset display to 0 2 = start calibration 2 <value> = set reference weight in grams and start calibration 3 = show reference weight in grams 3 <value> = set reference weight in grams 4 = show calibrated scale value 4 <value> = set calibrated scale value 5 = show max weight in gram 5 <value> = set max weight in grams 6 = show single item weight in grams 6 <value> = set single item weight in grams. Once the item weight is set, when items are added to the scale, the telemetry message will report Count as the number of items on the scale 7 = save current weight to be used as start weight on restart 8 0/1 \u2003 0 = disable JSON message on weight change over 4 grams \u2003 1 = enable JSON message on weight change (see below) 9 <value> = set minimum delta to trigger JSON message (see above). \u2003 0 = 4 grams (old default) \u2003 1..100 = set delta to 0-99 grams \u2003 101-255 = set delta to 110-1650 grams (10g increments) Sensor50 PAJ7620 gesture sensor 0 = sensor muted, no readings in Tasmota 1 = gesture mode 2 = proximity mode 3 = corner mode 4 = PIN mode 5 = cursor mode Sensor52 iBeacon driver with HM10 or HM17/HM16 1 and 2 = required only once to initialize the module u<x> = sets update interval in seconds (scan tags every <x> seconds) (default = 10) t<x> = set timeout interval in seconds (send RSSI=0 if tag is not detected after <x> seconds) (default = 30) d1 = enable debug mode (shows all serial traffic in console) d0 = disable debug mode_(default = 30)_ c = clears iBeacon list s AT+<command> = send native AT commands Sensor53 Smart Meter Interface r = reset the driver with a new descriptor specified with the Tasmota Scripting language. c<x> <value> = preset counter (x = 1..5 ) to value when the driver is set to counter mode d<x> = disable data decoding and dump meter (x = 1..5 ) data to the Console. This is used to decipher the meter's data format to define the variable encoding in the meter's descriptor. d0 = disable data dump mode and revert to decoding mode. l<x> = monitor the serial activity at a GPIO with a connected LED. x = GPIO of the LED. l255 = disable monitoring (default) m<x> = serial meter number (x = 1..5 ) to be monitored m0 = monitor all serial meters (default) Sensor54 INA226 Current Sensor 1 = rescan for devices and return the number found. 2 = save the configuration and restart 10 = return channel 1 shunt resistance and full scale current 11 <resistance> = set INA226 channel 1 shunt in ohms, floating point 12 <current> = set INA226 channel 1 full scale in amperes, floating point 20 = return channel 2 shunt resistance and full scale current 21 <resistance> = set INA226 channel 2 shunt in ohms, floating point 22 <current> = set INA226 channel 2 full scale in amperes, floating point 30 = return channel 1 shunt resistance and full scale current 31 <resistance> = set INA226 channel 1 shunt in ohms, floating point 32 <current> = set INA226 channel 1 full scale in amperes, floating point 40 = return channel 1 shunt resistance and full scale current 41 <resistance> = set INA226 channel 1 shunt in ohms, floating point 42 <current> = set INA226 channel 1 full scale in amperes, floating point Sensor60 GPS 0 = write to all available sectors, then restart and overwrite the older ones 1 = write to all available sectors, then restart and overwrite the older ones 2 = filter out horizontal drift noise 3 = turn off noise filter 4 = start recording, new data will be appended 5 = start new recording, old data will lost 6 = stop recording, download link will be visible in webUI 7 = send mqtt on new position + TELE (consider to set TELE to a very high value) 8 = only TELE message 9 = start NTP server 10 = deactivate NTP server 11 = force update of Tasmota-system-UTC with every new GPS-time-message 12 = do not update of Tasmota-system-UTC with every new GPS-time-message 13 = set latitude and longitude in settings 14 = open virtual serial port over TCP, usable for u-center 15 = pause virtual serial port over TCP Sensor68 WindMeter sensor - Analog (pulse count) anemometer 1, <value> = set radius length in millimeters (measured from center to the edge of one of the cups) 0..65535 (default = 61 mm) 2, <value> = set number of pulses for a complete turn 1..255 (default = 1 ) 3, <value> = set pulse counter debounce time in milliseconds 1..32000 (default = 10 ) 4, <value> = set speed compensation factor, a multiplication coefficient to adjust resulting speed -32.768..32.767 three decimal places (default = 1.180 ) 5, <value> = set minimum percentage change between current and last reported speed trigger a new tele message 0..100 , 255 = off (default = 255 ) Sensor78 EZO sensors - commands Ascii commands are sent directly to the sensor as-is. See your specific EZO device datasheet for the list of commands available. By default, the specific command is sent to all EZO devices that are found. If using multiple EZO sensors, and the command should be issued to a single device, the index can be specified as part of the command: Sensor78-# where # represent the index of the device (ex: Sensor78-1 i). For more details please see Tasmota's support for EZO devices . Sensor80 Set antenna gain for MFRC522 RFID Reader. Sensor80 1 <0..7> 0 18dB 1 23dB 2 18dB 3 23dB 4 33dB 5 38dB 6 43dB 7 48dB Sensor90 Send commands to Hydreon RG-15 Rain Sensor A Reads accumulation data R Read all available data K Restart the rain sensor P Set to polling only mode (not supported) C Set to continuous mode, where data is sent when accumulation changes (default) H Force high resolution L Force low resolution I Force imperial (not supported) M Force metric (default) S Revert to jumper configured values O Reset the accumulation counter SpeedUnit TX20/TX23 and WindMeter anemometer speed unit 1 = m/s 2 = km/h 3 = kn 4 = mph 5 = ft/s 6 = yd/s TempRes Temperature sensor resolution 0..3 = maximum number of decimal places TempOffset -12.6..12.6 = Set calibration offset value for reported temperature telemetry This setting affects all temperature sensors on the device. VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places WeightRes Load cell sensor resolution 0..3 = maximum number of decimal places Wiper DS3502 contains a single potentiometer whose wiper position is controlled by the value in the Wiper Register (WR) represented by x = 0..3 POTI 0..127 = set POTI for wiper x STATUS = get wiper position for wiper x RESET = reset settings for wiper x See also SetOption8 - Show temperature in Celsius (default) or Fahrenheit SetOption18 - Set status of signal light paired with CO 2 sensor SetOption24 - Set pressure units","title":"Sensors"},{"location":"Commands/#power-monitoring","text":"Command Parameters AmpRes Current sensor resolution 0..3 = maximum number of decimal places CurrentCal 1000..32000 (default = 3500 ) Set calibration offset value for reported Current telemetry Allows finer calibration for energy monitoring devices CurrentHigh 0 = disable current high threshold (default) <value> = set current high threshold value in milliamps CurrentLow 0 = disable current low threshold (default) <value> = set current low threshold value in milliamps CurrentSet <value> = calibrate current to target value in mA EnergyExport<x> Export energy values <x> = meter number (default is 1 ) EnergyExportActive<x> ADE7880 only! Set/reset energy active values <x> = meter number (default is 1 ) EnergyToday<x> Set Energy Today values, parameters: <x> = meter number (default is 1 ) <value> = set new value in Wh, 0 for reset <time> = 0..4294967295 set StartTotalTime time as epoch value (optional 2nd parameter) EnergyTotal<x> Set or set Energy Total values, parameters: <x> = meter number (default is 1 ) <value> = set new value in Wh, 0 for reset <time> = 0..4294967295 set StartTotalTime time as epoch value (optional 2nd parameter) The new value represents start of day, and output for total includes the today value. EnergyReset<x> x = 1..5 1 <value>{,<time>} = ((p)re)set values 2 <value>{,<time>} = ((p)re)set values for Yesterday 3 <value>{,<time>} = ((p)re)set values for Total <value> = 0..42949672 in watt-hours (Wh) <time> = 0..4294967295 set StartTotalTime time as epoch value 4 <standard> {, <off-peak> } = ((p)re)set tariff period values for Totals 5 <standard> {, <off-peak> } = ((p)re)set tariff period values for Exported With version 10, this command has been replaced, see above. EnergyRes Energy sensor resolution 0..5 = maximum number of decimal places EnergyYesterday<x> Set Energy Yesterday values, parameters: <x> = meter number (default is 1 ) <value> = set new value in Wh, 0 for reset <time> = 0..4294967295 set StartTotalTime time as epoch value (optional 2nd parameter) EnergyUsage Set energy usage values, parameters: <value> = set energy usage value, 0 for reset FreqRes Frequency sensor resolution 0..3 = maximum number of decimal places FrequencySet <value> = calibrate frequency to a target value in Hz MaxPower 0 = disable use maximum power monitoring <value> = set maximum allowed power in watts MaxPowerHold 1 = set default time to 10 seconds to stay over MaxPower before power off <value> = set time in seconds to stay over MaxPower before power off MaxPowerWindow 1 = set default time to 30 seconds to stay power off before re-applying power up to 5 times <value> = set time in seconds to stay power off before re-applying power up to 5 times ModuleAddress Set the address of a PZEM module 1..3 = the last octet of the PZEM-004T serial address <address> = the last octet of the address on MODBUS PZEM energy monitoring modules Prior to setting the module address, the PZEM must be connected to both RX and TX, and AC voltage. Connect one PZEM at a time and issue this command. Repeat for each PZEM to be connected for multi-phase monitoring. The command without an argument cannot be used to read the address of the connected PZEM. PowerCal 1000..32000 (default = 12530 ) Set calibration offset value for reported Power telemetry reading Allows finer calibration for energy monitoring devices PowerDelta<x> Set maximum delta of phase a<x> in energy monitoring devices to report on active power load change while the power is ON. PowerDelta will not report when the power turns off.\u2003 0 = disable reporting on power change 1..100 = set reporting on percentage power change to send an MQTT telemetry message 101..32000 = set reporting on absolute power change to send an MQTT telemetry message (offset by 100, e.g., 101 =1W, 207 =107W) PowerHigh 0 = disable power high threshold (default) <value> = set power high threshold value in watts to send an MQTT telemetry message PowerLow 0 = disable power low threshold (default) <value> = set power low threshold value in watts to send an MQTT telemetry message PowerSet <value> = calibrate power to a target value in watts\u2003 Status 8 = show power usage 9 = show power thresholds Tariff<x> P1 Smart Meter tariff configuration x = 1, 2, 9 1 STD,DST Start times for off-peak tariff 2 STD,DST End times for off-peak tariff 9 0/1 \u2003 0 = use Start/End times also on weekends. \u2003 1 = use off-peak tariff all weekend. STD and DST may be specified as: \u2003 <hour> = 0..23 or \u2003 <time> = 00:00..23:59 or \u2003 <minutes> = 0..1439 (since midnight) If both Tariff1 STD and Tariff2 STD are equal, all tariffs are disabled. VoltageCal Set calibration offset value for reported Voltage telemetry reading 1000..32000 (default = 1950 ) Allows finer calibration for energy monitoring devices VoltageHigh 0 = disable voltage high threshold (default) <value> = set voltage high threshold value in V VoltageLow 0 = disable voltage low threshold (default) <value> = set voltage low threshold value in V VoltageSet <value> = calibrate voltage to a target value in V\u2003 VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places See Also SetOption21 - Energy monitoring when power is off SetOption33 - Configure power monitoring Max_Power_Retry count number SetOption39 - Control handling of invalid power measurements SetOption72 - Set reference used for total energy SetOption129 - Enable separate energy meters","title":"Power Monitoring"},{"location":"Commands/#light","text":"Command Parameters AlexaCTRange SetOption82 Reduce the CT range from 153..500 to 200..380 to accommodate with Alexa range 0 = CT ranges from 153 to 500 (default) 1 = CT ranges from 200 to 380 (although you can still set in from 153 to 500) Channel<x> 0..100 = set PWM channel dimmer value from 0 to 100%\u2003 + = increase by 10 - = decrease by 10 When SetOption68 is set to 1 Channel<x> will follow Power<x> numbering with Relays first then PWM. Example : 2 Relays and 3 PWM: Relay1 = Power1 ; Relay2 = Power2 ; PWM1 = Power3 and Channel3 ; PWM2 = Power4 and Channel4 ; PWM3 = Power5 and Channel5 ChannelRemap SetOption37 Color remapping for led channels, also provides an option for allowing independent handling of RGB and white channels. Setting changes require a device reboot. 0 = disable 1..119 = according to this table 120..127 = invalid (results in same as 0 ) 128..255 = same as 0..127 but with independent channel handling enabled Color<x> x = 1..6 \u2003 1 = Set color \u2003 2 = Set color adjusted to current Dimmer value \u2003 3 = Set clock seconds hand color ( Scheme 5 only) \u2003 4 = Set clock minutes hand color ( Scheme 5 only) \u2003 5 = Set clock hour hand color ( Scheme 5 only) \u2003 6 = Set clock hour marker color <value> r,g,b = set color by decimal value ( 0..255 ) #CWWW = set hex color value for CT lights #RRGGBB = set hex color value for RGB lights #RRGGBBWW = set hex color value for RGBW lights #RRGGBBCWWW = set hex color value for RGBCCT lights (5 PWM channels) Note : Just append an = instead of the remaining color codes, this way they wont get changed. For example a command like Color #00ff= would update the RGB part to disable red and enable green, but would omit to update blue or any white channel. Set color to 1 = red 2 = green 3 = blue 4 = orange 5 = light green 6 = light blue 7 = amber 8 = cyan 9 = purple 10 = yellow 11 = pink 12 = white (using RGB channels) + = next color - = previous color CT 153..500 = set color temperature from 153 (cold) to 500 (warm) for CT lights + = increase CT value by 10 - = decrease CT value by 10 CTRange Specify CT range of the bulb. The slider will still allow to set CT from 153 to 500, but the rendering will be done within the new range. <ct_min>,<ct_max> = set color temperature from 153 (cold) to 500 (warm) for CT lights default = 153,500 This settings is not persisted in flash Dimmer 0..100 = set dimmer value from 0 to 100% + = increase by DimmerStep value (default = 10 ) - = decrease by DimmerStep value (default = 10 ) Use of these parameters with Fade on enables dimmer level \"move down,\" \"move up,\" and \"stop\" commands ( #11269 ) < = decrease to 1 > = increase to 100 ! = stop any dimmer fade in progress at current dimmer level Dimmer<x> Commands available only when SetOption37 >= 128 ( #6819 ) <value> same as in Dimmer Dimmer0 <value> = set dimming for all channels Dimmer1 <value> = set dimming for RGB channels Dimmer2 <value> = set dimming for white channels Dimmer4 <value> = allow retaining brightness ratio between white and color channels when setting dimmer for linked lights DimmerRange Change dimming range. <dimmerMin>,<dimmerMax> = set the internal dimming range from minimum to maximum value (0..255, 0..255) Does not change Dimmer command behavior DimmerStep 1..50 - set Dimmer +/- step value. (default = 10 ) Fade 0 = do not use fade (default) 1 = use fade See also SetOption91 HsbColor <hue>,<sat>,<bri> = set color by hue, saturation and brightness HsbColor1 0..360 = set hue HsbColor2 0..100 = set saturation HsbColor3 0..100 = set brightness L1MusicSync Only for Sonoff L1 (Lite) and Spider Z LED controllers <power,sensitivity,speed> \u2003 power = 0 - off, 1 - on, 2 - toggle \u2003 sensitivity = 1..10 ( default: 5 ) \u2003 speed = 1..100 ( default: 50 ) Can be used with only power argument Led<x> #RRGGBB = set hex color value where <x> is the pixel number of the LED. A blank-delimited list of colors sets multiple successive pixels. (applies only to addressable LEDs) LedPwmMode<x> Control status LED light mode (x = 0..4 ) 0 = digital on/off mode (default) 1 = PWM mode 2 = toggle between modes LedPwmOff 0..255 = set LED brightness when OFF LedPwmOn 0..255 = set LED brightness when ON LedTable 0 = do not use LED gamma correction (default \u00ab6.5.0.9) 1 = use gamma correction (default \u00bb6.5.0.9) MultiPwm SetOption68 Multi-channel PWM instead of a single light 0 = Treat PWM as a single light (default) 1 = Treat PWM as separate channels. In this mode, use Power<x> to turn lights on and off, and Channel<x> to change the value of each channel. Color still works to set all channels at once. Requires restart after change Palette 0 = Clear color palette [ ...] = Set list of colors used by Color<1,2> and Scheme<2,3,4> commands with each color separated by a space. The palette setting is not saved to flash. Use a boot-time rule such as ON System#Boot DO Palette xxxxx ENDON to set it back at each restart. Pixels 1..512 = set amount of pixels in strip or ring and reset Rotation (applies only to addressable LEDs) PowerOnFade SetOption91 Enable Fade at boot and power on. By default fading is not enabled at boot because of stuttering caused by wi-fi connection 0 = don't Fade at startup (default) 1 = Fade at startup PWMCT SetOption92 Alternative to Module 38 : for Cold/Warm white bulbs, enable the second PWM as CT (Color Temp) instead of Warm White, as required for Philips-Xiaomi bulbs. 0 = normal Cold/Warm PWM (default) 1 = Brightness/CT PWM See PWM CT in Lights RGBWWTable Control light intensity of unbalanced PWM channels PWM1,PWM2,PWM3,PWM4,PWM5 = channel range with values 0..255 (default = 255,255,255,255,255 ) Range adjustment is computed after Gamma correction. Rotation <value> = set amount of pixels to rotate (up to Pixels value) (applies only to addressable LEDs) Scheme Light effects + = next scheme - = previous scheme 0 = single color for LED light (default) 1 = start wake up sequence (same as Wakeup ) 2 = cycle up through colors using Speed option 3 = cycle down through colors using Speed option 4 = random cycle through colors using Speed and Fade Use <value>, <startcolor> if you want to set the starting color of selected scheme Following schemes are usable only with addressable LEDs, e.g. WS281X, Neopixel 5 = clock mode ( example ) 6 = candlelight pattern 7 = RGB pattern 8 = Christmas pattern 9 = Hanukkah pattern 10 = Kwanzaa pattern 11 = rainbow pattern 12 = fire pattern 13 = stairs pattern Speed 1..40 = set fade speed from fast 1 to very slow 40 + = increase speed - = decrease speed The Speed value represents the time in 0.5s to fade from 0 to 100% (or the reverse). Example: Speed 4 takes 2.0s to fade from full brightness to black, or 0.5s to move from 75% to 100%. Speed2 Same as Speed but settings aren't stored. ! = can be used to cancel the use of a preceding Speed2 command. Use example... StepPixels ( Scheme 5 only) <value> = define the number of LEDs in each step VirtualCT Precisely specify color rendering of the bulb for Color Temperature. Needs SetOption106 1 and works for 3, 4 or 5 channel lights {\"<minct>\":\"<color1>\",\"midct\":\"<color2>\",\"maxct\":\"<color3\"} Example: VirtualCT {\"200\":\"FFFFFF0000\",\"400\":\"000000FF00\"} The first and last CT values indicate the min and max CT and are equivalent to CTRange . Read more... This settings is not persisted in flash Wakeup Start wake up sequence from OFF to stored Dimmer value 0..100 = Start wake up sequence from OFF to provided Dimmer value WakeupDuration 1..3000 = set wake up duration in seconds White 1..100 = set white channel brightness in single white channel lights (single W or RGBW lights) WhiteBlend SetOption105 White Blend Mode 0 = disable (default) 1 = enable Width<x> x = 1..4 1 = 0..4 = LED group width ( Scheme 6..12 only) 2 = 0..32 = seconds hand width ( Scheme 5 only) 3 = 0..32 = minutes hand width ( Scheme 5 only) 4 = 0..32 = hour hand width ( Scheme 5 only) See also SetOption15 , SetOption16 , SetOption17 , SetOption20 , SetOption37 , SetOption68 and SetOption107","title":"Light"},{"location":"Commands/#device-groups","text":"Command Parameters DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group <x> name and restart. Prior to 8.2.0.3, GroupTopic was used to specify the device group name. DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract) or ^ (invert). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=^ - toggle all the relays. 2 = Light fade (0 = Off, 1 = On) 3 = Light speed (1..40) 4 = Light brightness (0..255) 5 = Light Scheme 6 = Light fixed color (0 = white (using CT channels), other values according to Color ) 7 = PWM dimmer low preset (0..255) 8 = PWM dimmer high preset (0..255) 9 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members.","title":"Device Groups"},{"location":"Commands/#setoptions","text":"Tip Instead of typing SetOption you can use shorter form of SO . so instead of SetOption19 1 you can use SO19 1 Command Parameters SetOption0 Save power state and use after restart (=SaveState) 0 = disable (see note below) 1 = enable (default) Note: Power state means on/off state of eg. relays or lights. Other parameters like color, color temperature, brightness, dimmer, etc. are still saved when changed. To disable saving other parameters see SaveData . SetOption1 Set button multipress mode to 0 = allow all button actions (default) 1 = restrict to single to penta press and hold actions (i.e., disable inadvertent reset due to long press) SetOption2 Set display of global temperature/humidity/pressure info to JSON sensor message 0 = disable (default) 1 = enable SetOption3 MQTT 0 = disable MQTT 1 = enable MQTT (default) SetOption4 Return MQTT response as 0 = RESULT topic (default) 1 = %COMMAND% topic SetOption8 Show temperature in 0 = Celsius (default) 1 = Fahrenheit SetOption10 When the device MQTT topic changes 0 = remove retained message on old topic LWT (default) 1 = send \"Offline\" to old topic LWT SetOption11 Swap button single and double press functionality 0 = disable (default) 1 = enable SetOption12 Configuration saving to flash option 0 = allow dynamic flash save slot rotation (default) 1 = use fixed eeprom flash slot SetOption13 Allow immediate action on single button press 0 = single, multi-press and hold button actions (default) 1 = only single press action for immediate response (i.e., disable multipress detection). Disable by holding for 4 x button hold time (see SetOption32 ). SetOption15 Set PWM control for LED lights 0 = basic PWM control 1 = control with Color or Dimmer commands (default) SetOption16 Set addressable LED Clock scheme parameter 0 = clock-wise mode (default) 1 = counter-clock-wise mode SetOption17 Show Color string as 0 = hex string (default) 1 = comma-separated decimal string SetOption18 Set status of signal light paired with CO 2 sensor 0 = disable light (default) 1 = enable light The light will be green below CO2_LOW and red above CO2_HIGH (transition yellow/orange between). The default levels are: 800ppm for low and 1200ppm for high but these can be set in user_config_override.h . SetOption19 Tasmota discovery protocol used in Home Assistant Tasmota integration 0 = enable Tasmota discovery (default) 1 = use deprecated MQTT discovery (only with #define USE_HOME_ASSISTANT , does not exist in release binaries) SetOption20 Update of Dimmer/Color/CT without turning power on 0 = disable (default) 1 = enable SetOption21 Energy monitoring when power is off 0 = disable (default) 1 = enable SetOption24 Set pressure units 0 = hPa (default) 1 = mmHg SetOption26 Use indexes even when only one relay is present 0 = messages use POWER (default) 1 = messages use POWER1 SetOption28 RF received data format 0 = hex (default) 1 = decimal SetOption29 IR received data format 0 = hex (default) 1 = decimal SetOption30 Enforce Home Assistant auto-discovery as light 0 = relays are announced as a switch and PWM as a light (default) 1 = both relays and PWM are announced as light SetOption31 Set status LED blinking during Wi-Fi and MQTT connection problems. LedPower must be set to 0 for this feature to work 0 = Enabled (default) 1 = Disabled SetOption32 Number of 0.1 seconds to hold button before sending HOLD action message. 1..100 to set button hold time (default = 40 ) . This option also affects the time required to perform a firmware defaults reset (10x HOLD action time). There is no firmware reset on using the HOLD action with shutterbuttons. SetOption33 Number of seconds for which the maximum power limit can be exceeded before the power is turned off 1..250 = set number of seconds (default = 5 ) SetOption34 0..255 = set Backlog inter-command delay in milliseconds (default = 200 ) SetOption36 Boot loop defaults restoration control. 0 = disable boot loop control 1..200 = set number of boot loops (a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME (default 10 seconds) before beginning to restore settings (default = 1 ) . Once this number is reached, subsequent restarts will: 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI 2 nd restart: disable rules causing boot loop 3 rd restart: disable all rules (and autoexec.bat ) 4 th restart: reset user defined GPIOs to disable any attached peripherals 5 th restart: reset module to Sonoff Basic (1) SetOption38 6..255 = set IRReceive protocol detection sensitivity minimizing UNKNOWN protocols SetOption39 Control handling of invalid power measurements. Read more... 0 = reset to default on next restart 1..255 = number of invalid power readings before reporting no load (default = 128 ) . SetOption40 Stop detecting input change on the button GPIO. Solves #5449 Active only when SetOption1 1 and SetOption13 0 . This disables all long press functionality. 0..250 = button hold time in 0.1 seconds after which button functionality is disabled. (default = 1 ) Example: Backlog SetOption1 1; SetOption13 0; SetOption40 10 = discard any button press over 1 second SetOption41 0 = Disable ARP <x> = Force sending gratuitous ARP (Wi-Fi keep alive) every <x> seconds (default = 60 ) If <x> is below 100 it is the number of seconds, if <x> is above 100 , it is the number of minutes after substracting 100. Ex: 105 is every 5 minutes, while 90 is every 90 seconds. SetOption42 0..255 = set over-temperature (Celsius only) threshold resulting in power off on all energy monitoring devices (default = 90 ) SetOption43 0..255 = to control Rotary step. Details #10407 SetOption44 1..100 = set base tolerance percentage for matching incoming IR messages (default = 25 ) SetOption45 1..250 = change bi-stable latching relay pulse length in milliseconds (default = 40 ) SetOption51 Enable GPIO9 and GPIO10 component selections in Module Configuration WARNING Do not use on ESP8266 devices! 0 = disable (default) 1 = enable SetOption52 Control display of optional time offset from UTC in JSON payloads 0 = disable (default) 1 = enable SetOption53 Display hostname and IP address in GUI 0 = disable (default) 1 = enable SetOption54 Apply SetOption20 settings to commands from Tuya device 0 = disable (default) 1 = enable SetOption55 mDNS service 0 = disable (default) 1 = enable SetOption56 Wi-Fi network scan to select strongest signal on restart (network has to be visible) 0 = disable (default) 1 = enable SetOption57 Wi-Fi network re-scan every 44 minutes with alternate to +10dB stronger signal if detected (only visible networks) 0 = disable 1 = enable (default) SetOption58 IR Raw data in JSON payload 0 = disable (default) 1 = enable SetOption59 Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands: State , Power and any command causing a light to be turned on. 0 = disable (default) 1 = enable SetOption60 Set sleep mode 0 = dynamic sleep (default) 1 = normal sleep SetOption61 Force local operation when ButtonTopic or SwitchTopic is set. 0 = disable (default) 1 = enable SetOption62 Set retain on Button or Switch hold messages 0 = disable (default) 1 = don't use retain flag on HOLD messages SetOption63 Set relay state feedback scan at restart ( #5594 , #5663 ) 0 = Scan power state at restart (default) 1 = Disable power state scanning at restart SetOption64 Switch between - or _ as sensor name separator 0 = sensor name index separator is - (hyphen) (default) 1 = sensor name index separator is _ (underscore) Affects DS18X20, DHT, BMP and SHT3X sensor names in tele messages SetOption65 Device recovery using fast power cycle detection 0 = enabled (default) 1 = disabled SetOption66 Set publishing TuyaReceived to MQTT 0 = disable publishing TuyaReceived over MQTT (default) 1 = enable publishing TuyaReceived over MQTT SetOption69 Deprecated in favor of DimmerRange By default Tuya dimmers won't dim below 10% because some don't function very well that way. 0 = disable Tuya dimmer 10% lower limit 1 = enable Tuya dimmer 10% lower limit (default) SetOption71 Set DDS238 Modbus register for active energy 0 = set primary register (default) 1 = set alternate register SetOption72 Set reference used for total energy 0 = use firmware counter (default) 1 = use energy monitor (e.g., PZEM-0xx, SDM120, SDM630, DDS238, DDSU666) hardware counter SetOption73 Detach buttons from relays and send multi-press and hold MQTT messages instead 0 = disable (default) 1 = enable Example message: {\"Button1\":{\"Action\":\"SINGLE\"}} SetOption74 Enable internal pullup for single DS18x20 sensor 0 = disable (default) 1 = internal pullup enabled SetOption75 Set grouptopic behaviour ( #6779 ) 0 = GroupTopic using FullTopic replacing %topic% (default) 1 = GroupTopic is cmnd/%grouptopic%/ SetOption76 Boot count incrementing when DeepSleep is enabled ( #6930 ) 0 = disable boot count incrementing (default) 1 = enable boot count incrementing SetOption77 Do not power off if a slider is moved to far left 0 = disable (default) 1 = enable SetOption78 OTA compatibility check 0 = enabled (default) 1 = disabled SetOption79 Reset counters at TelePeriod time 0 = disable (default) 1 = enable SetOption80 Blinds and shutters support 0 = disable blinds and shutters support (default) 1 = enable blinds and shutters support SetOption81 Set PCF8574 component behavior for all ports 0 = set as regular state (default) 1 = set as inverted state SetOption82 Reduce the CT range from 153..500 to 200.380 to accommodate with Alexa range 0 = CT ranges from 153 to 500 (default) 1 = CT ranges from 200 to 380 (although you can still set in from 153 to 500) SetOption83 Uses Zigbee device friendly name instead of 16 bits short addresses as JSON key when reporting values and commands 0 = JSON key as short address 1 = JSON key as friendly name See ZbName <device>,<name> SetOption84 (Experimental) When using AWS IoT, sends a device shadow update (alternative to retained) 0 = don't update device shadow (default) 1 = update device shadow Note: if the Topic contains '/' they are replaced with '_' SetOption85 Device group support 0 = disable (default) 1 = enable SetOption86 PWM Dimmer only! Turn brightness LED's off 5 seconds after last change 0 = disable (default) 1 = enable SetOption87 PWM Dimmer only! Turn red LED on when powered off 0 = disable (default) 1 = enable SetOption88 Make each relay part of a separate device group. Relay 1 updates are sent to/received from device group 1, relay 2 updates are sent to/received from device group 2, etc. For the PWM Dimmer module, make each button be associated with a different device group. 0 = disable (default) 1 = enable SetOption90 Disable sending MQTT with non-JSON messages 0 = send all MQTT (default) 1 = send only MQTT messages with JSON payloads SetOption93 Control caching of compressed rules 0 = Disable memory caching of uncompressed rules 1 = Keep uncompressed rules in memory to avoid CPU load of uncompressing at each tick (default) SetOption94 Select MAX31855 or MAX6675 thermocouple support 0 = Use MAX31855 protocol (default) 1 = Use simpler MAX6675 protocol instead of MAX31855 SetOption97 Set TuyaMCU serial baudrate 0 = 9600 bps (default) 1 = 115200 bps SetOption98 Provide rotary dimmer rule triggers 0 = disable (default) 1 = enable SetOption99 Enable zero-cross capable AC dimmer 0 = no zero-cross AC dimmer connected (default) 1 = zero-cross AC dimmer attached. Focus on raising edge and sync frequency SetOption101 Add Zigbee source endpoint as suffix to attributes 0 = disable (default) 1 = enable e.g. Power3 instead of Power if sent from endpoint 3 . SetOption103 Set TLS mode 0 = disable TLS 1 = enable TLS SetOption104 Disable MQTT retained messages (some brokers don't support them) 0 = retained messages enabled (default) 1 = retained messages disabled SetOption107 Set virtual CT channel light type (experimental feature) 0 = Warm White 1 = Cold White SetOption108 0 = Teleinfo telemetry only sent into Energy MQTT JSON (default) 1 = Each Teleinfo received frame is also sent by MQTT (mainly to be able to display real time data) SetOption109 0 = (default) 1 = force gen1 Alexa mode, for Echo Dot 2nd gen devices only SetOption113 works only with rotary dial button 0 = (default) 1 = set dimmer low on rotary dial after power off SetOption114 Detach switches from relays and send MQTT messages instead 0 = disable (default) 1 = enable Example result: {\"Switch1\":{\"Action\":\"ON\"}} SetOption115 ESP32 MI32 BLE 0 = disable (default) 1 = enable SetOption116 Auto-query of lights and devices 1 = disable SetOption117 Run fade at fixed duration instead of fixed slew rate 1 = enable SetOption123 Wiegand tag number output in hex format 1 = enable SetOption124 Wiegand key pad stroke format 0 = one tag (ending char # or ) *(default) 1 = one key SetOption125 ZbBridge only Hide bridge topic from zigbee topic (use with SetOption89 ) 1 = enable SetOption126 Enable arithmetic mean over teleperiod for JSON temperature for DS18x20 sensors 1 = enable SetOption127 Force Wi-Fi in no-sleep mode even if Sleep 0 is not enabled 1 = enable SetOption128 Web referrer check for HTTP API commands 0 = disabled 1 = enabled (default) SetOption129 Enable split total energy results #13030 1 = enable SetOption130 Add heap size (and ESP32 fragmentation) to logging timestamp for debugging 1 = enable SetOption131 (Tuya) Allow save dimmer = 0 received by MCU 1 = enable SetOption132 When MQTT TLS is enabled, forces fingerprint validation of server identity instead of checking the identify against a certificate authority (CA) 1 = Fingerprint, 0 = CA SetOption134 PWM force phases to be synced (ESP32 only). On ESP32, PWM phases are by default distributed one after the other to minimize effect on power supply. This is also mandatory for H-Bridge devices. 0 = phases are automatically aligned one after the other, 1 = phases all start at the same time (default behavior for ESP8266). SetOption135 Disables Display Splash screen (for all drivers, universal & LVGL) 1 = Splash screen disabled, 0 = Splash screen displayed SetOption136 1 = Disable single sensor reports from Tuya devices while keeping teleperiod reports 0 = Publish an immediate tele/%topic%/SENSOR TuyaSNS message at each reception of individual value (default) SetOption137 1 = following Tuya responses will not be forwarded to MQTT when SetOption66 is enabled - heartbeat every 10 seconds, TUYA_CMD_HEARTBEAT - the WiFi state during start-up and Wi-Fi events, TUYA_CMD_WIFI_STATE - the local time info query of the MCU every minute, TUYA_CMD_SET_TIME - the received update package info from MCU during firmware update of Tuya MCU, TUYA_CMD_UPGRADE_PACKAGE SetOption138 Align GUI energy multicolumn layout in webUI 0 = left/center (default) 1 = right SetOption139 When SetOption24 1 switch pressure unit to: 0 = mmHg (default) 1 = inHg SetOption140 0 = open clean MQTT session (default) 1 = open persistent MQTT session SetOption141 1 = disable display of model name in webUI header SetOption142 1 = wait 1 second for WiFi connection solving some FRITZ!Box modem issues SetOption143 1 = disables ZigBee auto-probing and configure back attribute reporting SetOption144 1 = include a timestamp in ZbReceived messages","title":"SetOptions"},{"location":"Commands/#tuyamcu","text":"Command Parameters TuyaEnum<x> Send value to an Enum (fnId 61, 62, 63 and 64) where <x> = number of Enum <value> = must be from a range set in TuyaEnumList TuyaEnumList Declare the range an Enum (fnId 61, 62, 63 and 64) must respect (0 is always the first item in range) <enum>,<range> = <enum> is Enum<x> declared using TuyaMCU and <range> can be 0..31 Without payload returns the configuration of all the Enums TuyaMCU Used to map functions in TuyaMCU <fnId>,<dpId> = read more... <fnId>,0 = remove setting for fnId TuyaRGB Set correct format of color reporting by tuyaMCU 0 - Type 1, 12 characters uppercase. Example: 00DF00DC0244 (default) 1 - Type 1, 12 characters lowercase. Example: 008003e8037a 2 - Type 2, 14 characters uppercase. Example: 00FF00FFFF6464 3 - Type 2, 14 characters lowercase. Example: 00e420ffff6464 TuyaSend<x> Send data to MCU with TuyaMCU x = 0..4,8 TuyaSend0 = send a query command to the MCU TuyaSend1 <dpId>,<boolean> = send boolean ( 0 / 1 ) data type to dpId (1 byte max length) TuyaSend2 <dpId>,<int> = send integer data to dpId (4 bytes max length) TuyaSend2 <dpId>,<0xAABBCCDD> = send 4 byte data to dpId (4 bytes max length) TuyaSend3 <dpId>,<value> = send an ASCII string to dpId (unknown max length) TuyaSend4 <dpId>,<enum> = send enumerated ( 0 / 1 / 2 / 3 / 4 / 5 ) data type to dpId (1 byte max length) TuyaSend5 <dpId>,<value> = send an HEX string to dpId - 0x prefix NOT needed - (unknown max length) TuyaSend6 <dpId>,<value> = send an HEX raw value to dpId - 0x prefix NOT needed, but will be processed correctly - (unknown max length) TuyaSend8 = request dpId states if supported TuyaTempSetRes Set resolution only for Tuya Set Temperature sensor (fnId 72). 0..3 = maximum number of decimals shown See also SetOption8 - change temperature display unit SetOption66 - publish TuyaReceived output to MQTT DimmerRange - to adjust dimmer range TempRes - set number of decimals shown for temperature sensors","title":"TuyaMCU"},{"location":"Commands/#serial-bridge","text":"Hardware Serial Bridge uses GPIO1 (Tx) and GPIO3 (Rx) or GPIO13 (Tx) and GPIO15 (Rx) pins of your device. Software Serial Bridge can use any other GPIO to be configured as components Serial Tx and Serial Rx (or SerBr Tx and SerBr Rx ). If Tx and Rx components are not assigned in the Template or Module, GPIO1 and GPIO3 will be used. Note that changing serial logging ( SerialLog 0) will disable the hardware Serial Bridge. Information received by Tasmota over the serial bridge is captured automatically. Before data will be received, a properly formatted SerialSend<x> or SSerialSend<x> command must be executed. This must be done any time the device restarts (e.g., via a System#Boot triggered rule). This command is required in order to set how the expected serial data will be formatted and interpreted (i.e., which <x> option). A {\"SSerialReceived\":{\"Data\":\"<string>\"}} message will be posted. You can use a rule to process the string which will be contained in SSerialReceived#Data . Expect possible communication errors when additional sensors are configured. Command Parameters Baudrate 1 = set hardware serial bridge to default baud rate of 115200 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SBaudrate 1 = set software serial bridge to default baud rate of 9600 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SerialBuffer 256..520 = set the serial buffer size. This option will not be persisted , use a rule with a trigger like Power1#Boot when you want this to survive a reboot. Sometimes, serial buffer overruns can be mitigated by setting this to a large value such as 520 . SerialConfig value = set serial protocol using data/parity/stop conventional notation (example: 8N1 or 702 ) 0..23 = set serial protocol ( 3 equals 8N1 ) SerialDelimiter <value> = set serial delimiter to escape character code or ASCII character 1..127 = set serial delimiter to decimal ASCII 128 = only allow ASCII characters 32 to 127 in response text 254 = disable serial delimiter & post HEX string 129..253 or 255 = disable serial delimiter (default = 255) SerialSend<x> <string> Disable serial logging and send using hardware serial x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary. Data in serial response messages is encoded as binary strings 5 = send as hex. Data in serial response messages is encoded as hex strings 6 = send as comma-delimited string of decimal numbers SSerialConfig value = set serial protocol using data/parity/stop conventional notation (example: 8N1 or 702 ) 0..23 = set serial protocol ( 3 equals 8N1 ) SSerialSend<x> <string> Send using software serial protocol x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary data. Data in serial response messages is encoded as binary strings 5 = send as hex. Data in serial response messages is encoded as hex strings 6 = send as comma-delimited string of decimal numbers 9 = enable Serial Bridge console Tee for debugging purposes (payload 1 to enable)","title":"Serial Bridge"},{"location":"Commands/#rf-bridge","text":"Command Parameters RfCode Show last sent 24-bit user code 1..8388607 = send 24-bit user code #1..#7FFFFF = send 24-bit hexadecimal user code using RfSync, RfLow and RfHigh timing RfHigh 1 = reset high pulse time to 840 microseconds 2..32767 = set high pulse time in microseconds #2..#7FFF = set high pulse time in hexadecimal microseconds RfHost Show 16-bit host part of user code 1 = reset 16-bit host part of user code to 11802 (#2E1A) 2..32767 = set 16-bit host part of user code #2..7FFF = set 16-bit host part of user code in hexadecimal RfKey<x> Send learned or default RF data for RfKey<x> (x = 1 \u2013 16 ) 1 = send default RF data for RfKey<x> using RfSync, RfLow, RfHigh and RfHost parameters 2 = learn RF data for RfKey<x> 3 = unlearn RF data for RfKey<x> 4 = save RF data using RfSync, RfLow, RfHigh and last RfCode parameters 5 = show default or learned RF data 6 = send learned RF data RfLow 1 = reset low pulse time to 270 microseconds 2..32767 = set low pulse time in microseconds #2..#7FFF = set low pulse time in hexadecimal microseconds RfRaw This command only works when the firmware has been updated with Portisch firmware . Refer to the Portisch wiki for details. Learning and Decoding RF Codes with Portisch Firmware 0 = Set iTead default firmware support and messages (default on restart) 1 = set Portisch firmware support and messages 166 or AAA655 = start sniffing/reading RF signals disabling iTead default RF handling 167 or AAA755 = stop sniffing/reading RF signals enabling iTead default RF handling 168 or AAA855 = transmitting iTead default RF protocols 169 or AAA955 = start sniffing and learning predefined protocols 176 or AAB055 = bucket Transmitting using command 0xB0 177 or AAB155 = start Bucket sniffing using command 0xB1 192 or AAC000C055 = beep ( 00C0 is the length of the sound) 255 or AAFF55 = show Rf firmware version (result AA02FF means Version 02) <value> = hexadecimal data to be sent to RF chip. This must be immediately followed by the RfRaw 0 command (e.g., Backlog RfRaw <value>; RfRaw 0 RfSync 1 = reset start sync pulse time to 8470 microseconds 2..32767 = set start sync pulse time in microseconds #2..#7FFF = set start sync pulse time in hexadecimal microseconds RfTimeout change timeout in RfReceive 100..60000 = disable duplicate RfReceive ( default = 1000 ) See also SetOption28 - Set RF received data format","title":"RF Bridge"},{"location":"Commands/#rf-transceiver","text":"Command Parameters RFsend <value> = code decimal or JSON. Data value is required and can be decimal or hexadecimal (using the 0x prefix), other values are optional. JSON {\"Data\":\"<value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} \"Data\":\"<value>\" = hexadecimal code \"Bits\":<value> = required number of data bits (default = 24 ) \"Protocol\":<value> = protocol number (default = 1 ) \"Repeat\":<value> = repeat value (default = 10 ) \"Pulse\":<value> = pulse value ( 350 = default for protocol 1) \u2003e.g., RFsend {\"Data\":\"0x7028DC\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238} Decimal data, bits, protocol, repeat, pulse \u2003e.g., RFsend 7350492, 24, 1, 10, 238 or RFsend 0x7028DC, 24, 1, 10, 238","title":"RF Transceiver"},{"location":"Commands/#ir-remote","text":"The standard Tasmota builds have reduced support for IR protocols: RC5 , RC6 and NEC . Use Tasmota-IR to have access to full protocols. Command Parameters IRsend <x> Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure at least one of the free device GPIOs as IRsend (8) . GPIO01 nor GPIO03 can be used. <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>, \"Channel\":<value>} \"Protocol\" (select one of the following): \"NEC\" \"RC5\" \"RC6\" \"Bits\":1..32 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":1..(2^32)-1 = data frame as 32 bit decimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":2170978686} or \"Data\":0x1..0xFFFFFFFF = data frame as 32 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} \"Channel\":1..16 = IRSend GPIO to be used to send the message. Alternatively, you can send IR remote control codes using RAW command encoding . Read more... Tasmota-IR enabled with all protocols Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E|ARDB1 Panasonic_AC : LKE|NKE|DKE|JKE|CKP|RKR Whirlpool_AC : DG11J13A|DG11J104|DG11J1-04|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds \"StateMode\" : SendOnly (default) StoreOnly SendStore See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload","title":"IR Remote"},{"location":"Commands/#displays","text":"Command Parameters Display Show current display setting as a JSON payload DisplayAddress 0..255 Set display module address DisplayDimmer 0 = Turn the display off 1..100 = Set display luminosity (only on 8x8 Dot-Matrix displays) 13..100 maps to 1..7 levels of brightness for TM1637, TM1638 and MAX7219 seven-segment display modules DisplayInvert 1 - Invert display where implemented. More info... DisplayMode 0..5 Set to display predefined content according to display type 0..3 for TM1637, TM1638 and MAX7219 seven-segment display modules DisplayModel Set display model: 1 = I 2 C LCD Display (default addresses 0x27 , 0x3F ) 2 = SSD1306 OLED 128x32/128x64/68x48 (default I 2 C addresses 0x3C , 0x3D ) 3 = HT16K33 8x8 Dot-Matrix 4 = ILI9341 TFT LCD 5 = 2.9 inch E-Paper Display 296x128 (software 3-wire SPI) 6 = 4.2 inch E-Paper Display 400x300 (software 3-wire SPI) 7 = SH1106 OLED 128x64 (default I 2 C address 0x3c ) 8 = ILI9488 TFT 480x320 (capacitive touch, hardware 3-wire SPI) 9 = SSD1351 color OLED 128x128 (hardware 3-wire SPI) 10 = RA8867 TFT LCD 1024x600 (capacitive touch, hardware 4-wire SPI) 15 = TM1637 7-segment, 4-,6- and 8-digit displays (TM1637, TM1638 and MAX7219), hardware 2- and 3-wire I2C-like interface 16 = LilyGO T5-4.7 E-Paper display board 17 = Universal Display Driver powered displays DisplayRefresh 1..7 Set time in seconds to update predefined content when using DisplayMode \u2260 0 DisplaySize 1..4 Set display scale-up size (SSD1306 and ILI9341 only) DisplayRotate Set rotation angle 0 = 0\u00b0 1 = 90\u00b0 2 = 180\u00b0 3 = 270\u00b0 DisplayText <value> = See DisplayText use For TM1637, TM1638 and MAX7219, see below DisplayText (TM1637, TM1638 and MAX7219) text [, position [, length ]] Clears and then displays basic text on the 7-segment display. length can be 1 to NUM_DIGITS , position can be 0 (left-most) to NUM_DIGITS-1 (right-most) A caret( ^ ) symbol in the text input is displayed as the degrees( \u00b0 ) symbol. This is useful for displaying Temperature (or angle)! See TM163x for details. DisplayTextNC (TM1637, TM1638 and MAX7219) text [, position [, length ]] Clears first, then displays text. Usage is same as above. See TM163x for details. DisplayType Select display sub-modules. More info... For usage of this command with TM163x, see TM163x for details. DisplayCols 1..44 Set number of display columns (for display modes>0) DisplayRows 1..32 Set number of display rows (for display modes>0) DisplayFont Specify the current font 0 use classic GFX font 1 = 12 2 = 24 3 = 8 (opt) 7 use RA8876 internal font DisplayWidth Specify the display width in pixels (SSD1306 only) -or- Specify number of digits in TM163x seven-segment display module DisplayHeight Specify the display height in pixels (SSD1306 only) DisplayClear (TM1637, TM1638 and MAX7219) Clears the display. See TM163x for details. DisplayNumber (TM1637, TM1638 and MAX7219) num [, position [, leading_zeros [, length ]]] Clears and then displays number num without decimal. leading zeros can be 1 or 0 (default), length can be 1 to NUM_DIGITS (4 or 6), position can be 0 (left-most) to NUM_DIGITS (right-most). See TM163x for details. DisplayNumberNC (TM1637, TM1638 and MAX7219) num [, position [, leading_zeros [, length ]]] Display integer number as above, but without clearing first. Usage is same as above. See TM163x for details. DisplayFloat (TM1637, TM1638 and MAX7219) num [, position [, precision [, length ]]] Clears and then displays float (with decimal point). precision can be 0 to NUM_DIGITS (default), length can be 1 to NUM_DIGITS (4 or 6), position can be 0 (left-most) to NUM_DIGITS (right-most). See TM163x for details. DisplayFloatNC (TM1637, TM1638 and MAX7219) num [, position [, precision [, length ]]] Displays float (with decimal point) as above, but without clearing first. Usage same as above. See TM163x for details. DisplayRaw (TM1637, TM1638 and MAX7219) position , length , num1 [, num2 [, num3 [, num4 [, ...upto NUM_DIGITS numbers]]...] Takes upto NUM_DIGITS comma-separated integers (0-255) and displays raw segments. length can be 1 to NUM_DIGITS (4 or 6), position can be 0 (left-most) to NUM_DIGITS (right-most). num1 , num2 , ... are numbers representing a 7-segment digit. Each number represents all segments of one digit. Segment a=1, b=2, c=4, d=8, e=16, f=32, g=64 and h (decimal point)=128. To turn on all segments, the number would be 1+2+4+8+16+32+64+128 = 255. See TM163x for details. DisplayScrollText (TM1637, TM1638 and MAX7219) text [, num_iterations ] Displays scrolling text, upto 50 characters. If num_iterations is not specified, it scrolls indefinitely, until another Display- command is issued. Optionally, specifying num_iterations causes the scrolling to stop after the specified number of iterations. See TM163x for details. DisplayScrollDelay (TM1637, TM1638 and MAX7219) 0..15 Sets the speed of text scroll. Smaller delay implies faster scrolling. See TM163x for details. DisplayLevel (TM1637, TM1638 and MAX7219) 0..100 Display a horizontal bar graph. See TM163x for details. DisplayClock (TM1637, TM1638 and MAX7219) Displays a clock. 1 = displays a clock in 12-hour format. 2 = displays a clock in 24-hour format. 0 = turns off the clock and clears the display See TM163x for details.","title":"Displays"},{"location":"Commands/#shutters","text":"Command (x = 1..4 ) Parameters ShutterMode<x> 1..5 (default = 0 ) Defines the mode the shutter will operates the relays, steppers and/or servos. 0=autodetect based on INTERLOCK and GPIO defined. STATUS 13 show the mode. 1=normal two relay up/off down/off. 2=two relay on/off up/down. 3=one relay garage mode. 4=one relay plus stepper motor. 5=one relay and position servo. ShutterButton<x> <button> <func> <mqtt> Assign a button to control the shutter. For more details please refer to Blinds and Shutters support <button> \u2003 0 : disable buttons for this shutter \u2003 1..4 : Button number <func> up / down / updown / toggle : function to assign to the button <mqtt> 1 / 0 : enable/disable MQTT publish for button hold action For example: To control shutter #1 by two buttons: Backlog ShutterButton1 1 up 1; ShutterButton1 2 down 1 assigns button #1 to act as an \"up\" button (1x press open, 2x press 50% position, 3x press 74% position) and button #2 to act as an \"down\" button (1x press close, 2x press 50% position, 3x press 24% position) for shutter #1 including MQTT publish. To control shutter #1 by a single button: ShutterButton1 1 updown 0 assigns button #1 to act as an \"up and down\" button (1x press up, 2x press down). To control shutter #1 by a single button: ShutterButton1 1 toggle 0 assigns button #1 to act as a \"toggle\" button (1x press toggle, 2x press 50% position). ShutterCalibration<x> Granular shutter position calibration. The measured opening position of the shutter at the 30, 50, 70, 90, and 100 percent opened locations. For example: ShutterCalibration<x> 23 38 56 74 82 ShutterChange -100..100 Moves the shutter from the current position relatively in %. If the resulting position is below 0 or above 100 it will be capped. Command can also be executed during movement and will change the target position. ShutterCloseDuration<x> 1.0 ..240.0 (default = 10.0 ) time, in seconds, it takes to fully close the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterClose<x> Engage the relay to close the shutter. This action can be requested at any time. Number of shutter can be the index or the argument ShutterFrequency<x> 0..10,000 Hz (default = 1000 ) the maximum frequency at which the stepper motor can operate reliably. Typically this is up to 2,000Hz with a 12V power supply and up to 5,000Hz with a 24V power supply. ShutterEnableEndStopTime<x> 0 = no additional shutter end stop time (default) 1 = 1 s additional shutter end stop time ShutterInvert<x> 0 = use default shutter positioning ( 0 = Closed, 100 = Open) 1 = invert shutter positioning ( 100 = Closed, 0 = Open) (e.g., if used with KNX) ShutterInvertWebButtons<x> 0 = use default button icons (\u25b2 for open, \u25bc for close) 1 = invert button icons (\u25bc for open, \u25b2 for close) (e.g., if used with horizontal awning: where open means rolling-down fabric material and close rolling-up in a protect position) ShutterLock<x> 0 = unlock shutter positioning (default) 1 = lock shutter positioning ShutterMotorDelay<x> -12.75 .. 12.75 (default = 0 ) time, in seconds, it takes the motor to start moving once power is turned on; i.e., motor lag time. You can use negative numbers if your motor stops to late after power OFF When used with stepper motors, this setting defines the ramp up/down speed (i.e., acceleration/deceleration) before the motor reaches its target speed for gradual starting and stopping. In this case only positive numbers are allowed. ShutterOpenDuration<x> 1.0 ..240.0 (default = 10.0 ) time, in seconds, it takes to fully open the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterOpen<x> Engage the relay to open the shutter. This action can be requested at any time. Number of shutter can be index or the argument ShutterPosition<x> 0..100 , UP , OPEN , DOWN , CLOSE , STOP , TOGGLE , TOGGLEDIR ,, A shutter position change can be requested at any time. The shutter will stop and revert or update to the requested position. The shutter's actual position will be saved after the movement is completed. In this case, the position will be restored during reboot. An interruption during shutter movement (e.g., a device restart) will lose the current position. ShutterPWMRange<x> 0..1023,0..1023 For servo motors the min and max position is defined by the length of the duty cycle signal. Because every servo is different the min and max PWM value must be set for each servo type. The value is also dependant on the PWMfrequency . Servos normally use 50..200 as PWMfrequency . ShutterRelay<x> <value> 0 = disable this and all higher numbered shutters Relay<value> component used to open the shutter. This relay's mate, the next higher numbered relay, closes the shutter. Depending on the shutter mode, the relays may need to be interlocked using the Interlock command. The ShutterRelay command must be executed first before any other shutter commands for Shutter<x> can be executed. ShutterSetClose<x> shutter closed position. ShutterPosition will be reset to fully closed value (e.g., 0 when ShutterInvert = 0 , 100 otherwise). This does not work with Servos. min and max of servos are always defined through ShutterPWMRange . ShutterSetOpen<x> shutter opened position. ShutterPosition will be reset to fully opened value (e.g., 100 when ShutterInvert = 0 , 0 otherwise). This does not work with Servos. min and max of servos are always defined through ShutterPWMRange . ShutterSetHalfway<x> 0..100 (default = 50 ) Define shutter half open position (in percent) ShutterStop<x> Disengage the relays to stop the shutter. Number of shutter can be the index or the argument ShutterStopClose<x> Stop the shutter when currently moving, close it otherwise ShutterStopOpen<x> Stop the shutter when currently moving, open it otherwise ShutterStopPosition<x> Stop the shutter when currently moving, set it to position 0..100 , UP , DOWN , STOP , TOGGLE otherwise ShutterStopToggle<x> Stop the shutter when currently moving, do ShutterToggle otherwise ShutterStopToggleDir<x> Stop the shutter when currently moving, do ShutterToggleDir otherwise ShutterToggle<x> Toggle the shutter - close the shutter when its position is >50, open it otherwise ShutterToggleDir<x> Toggle the shutter - close the shutter when it previously moved to open, open it otherwise ShutterTiltConfig<x> <min> <max> <Tiltduration> <openposition> <closeposition> (default = 0 0 0 0 0 ) Configure the tilt for venetian blinds. Min/man values must be in the range of -90\u00b0 to 90\u00b0. Open and Close position must be part of the defined range between min and max. Tiltduration defines the time the shutter needs to change the tilt from min to max value. This time has to been multiplied by 20. E.g. 1.2sec = 1.2 x 20 = 24. Example defines tilt on shutter 2: shuttertiltconfig2 -90 90 24 0 90 ShutterTilt<x> Set the tilt position <value> (between min and max), OPEN , CLOSE . Definition please see shuttertiltconfig ShutterTiltChange<x> -100..100 Moves the shuttertilt from the current position relatively in %. If the resulting tilt is below min or above max it will be capped. Command can also be executed during movement and will change the tilt at target position. See also SetOption80 - Enable shutter support","title":"Shutters"},{"location":"Commands/#zigbee","text":"See Zigbee article for more information Command Parameters <device> As <device> in following commands you can use interchangeably: <shortaddr> = short address of the Zigbee device on the network, example: 0x1234 <longaddr> = permanent IEEE address of the Zigbee device (64 bits), example: 0x00158D00041160C5 <index> = number of the device in the internal list (starts at 1), ideal for enumerating devices, example: 3 for third device in the list <name> = friendly name. Only when previously set with ZbName ZbBind Binds one Zigbee device to another device or to a group. This allows one device to directly send commands (f.e. a remote to a bulb) without any action on the coordinator. Command structure: {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } <device> = device sending messages (mandatory) <endpoint> = source endpoint (mandatory) <cluster> = source cluster id (mandatory) <to_device> = target device (optional) <to_endpoint> = target endpoint \u2003(optional if it can be inferred from ZbStatus3 ) <to_group> = target group id (optional) You must specify either \"ToDevice\" or \"ToGroup\" but not both Zigbee2Tasmota must know the IEEE address of target device, see ZbStatus2 to verify and ZbProbe to have Zigbee2Tasmota query the address (EZSP ZBBridge only) If you bind devices to groups you should also use ZbListen to that group, otherwise MQTT messages will not be published ZbBindState<n> Asks the device for its internal binding states <device> the device to query <n> the start index for the request, 1 is the default. This is used to scan through all bindings. ZbCIE Configure on the ZigBee device the CIE address using the IEEE address of the ZigBee Bridge. The ZigBee Bridge will act as the CIE device for the ZigBee Network. See IAS Cluster in the ZigBee specification for more information. Usage: ZbCIE <device>,<endpoint> <device> is the ZigBee device to configure <endpoint> is the endpoint in the ZigBee device where the IAS Cluster is. Example: ZbCIE 1,44 ZbEnroll Enroll the the ZigBee device to the ZigBee Bridge for reporting security sensors data, panels, etc. The ZigBee Bridge will act as the CIE device for the ZigBee Network. Usage: ZbEnroll <device>,<endpoint> <device> is the ZigBee device to configure <endpoint> is the endpoint in the ZigBee device where the IAS Cluster is. Example: ZbEnroll 1,44 ZbConfig display the current Zigbee configuration Example or result: {\"ZbConfig\":{\"Channel\":11,\"PanID\":\"0x1A63\",\"ExtPanID\":\"0xCCCCCCCCCCCCCCCC\",\"KeyL\":\"0x0F0D0B0907050301\",\"KeyH\":\"0x0D0C0A0806040200\"}} ZbConfig <json> change the configuration and restart if any change was applied. Warning: change in configuration causes a reset of the CC2530/ZBBridge and requires devices to be re-paired. \"Channel\":<channel> : Zigbee radio channel (11-26) \"PanID\":<panid> : identifier of the Zigbee Network \"ExtPanID\":<extpanid> : unique identifier of the Zigbee Network (ExtPanID features are not supported in Z2T but this parameter needs to be set) \"KeyL\":<key_l>,\"KeyH\":<key_h> : 128 bits encryption key, split into 2 64 bits values (Low and High) \"TXRadio\":<txradio> : radio power in dBm (1-20) only for ZBBridge All parameters are optional and only the ones specified are changed. The command always displays the complete configuration after the change Example of command: ZbConfig {\"Channel\":22,\"PanID\":\"0x1A69\",\"ExtPanID\":\"0xDDCCCCCCCCCCCCCC\",\"KeyL\":\"0xFF0D0B0907050301\",\"KeyH\":\"0xED0C0A0806040200\"} The following command creates a highly secure Network key based on a hardware random generator: ZbConfig {\"KeyL\":\"\",\"KeyH\":\"\"} ZbData feature in development ZbDeviceTopic SetOption89 Configure MQTT topic for Zigbee devices (also see SensorRetain ) 0 = single tele/%topic%/SENSOR topic (default) 1 = unique device topic based on Zigbee device ShortAddr Example: tele/Zigbee/5ADF/SENSOR = {\"ZbReceived\":{\"0x5ADF\":{\"Dimmer\":254,\"Endpoint\":1,\"LinkQuality\":70}}} EndpointTopic SetOption101 Add Zigbee source endpoint as suffix to attributes 0 = disable (default) 1 = enable e.g. Power3 instead of Power if sent from endpoint 3 . ZbEndpointSuffix SetOption120 Add the Zigbee endpoint as suffix in topic when using SetOption89 1 0 = disable (default) 1 = enable ZbForget Used for devices that are unused but still visible in ZbStatus <device> = Remove a device from the Tasmota flash memory. It does not un-pair the device nor deleting the device information in the CC2530/ZBBridge. ZbLight Sets or reads the light type to be emulated in Zigbee Hue Emulation with Alexa. <device>,<light_type> sets the light type using an integer 0..5 corresponding to the number of channels (from one channel (on/off) to 5 channel (RGBCCT) lights) <device>,-1 removes the device from Philips Hue emulation <device> displays the current status of the Light (Zigbee2Tasmota tracks all changes to the light) ZbListen<x> <group> (EZSP ZBBridge only)Listens to a multicast group address. By default EZSP will not report group messages unless you subscribe to the group. <x> : slot in the array of group addresses, 1..15 <group> : group address to listen to, 0..0xFFFF At start-up, Z2T automatically listens to group 0 in slot 0. CC2530 does not need this command and always report all group messages. ZbLeave <device> = request a device to leave the network. If the device is offline or sleeping, this will have no effect. It is not 100% guaranteed that the device will never connect again ZbInfo <device> = display all information known about a device, equivalent to ZbStatus3 with a simpler JSON output ZbMap<n> Asks the device for its view of the Zigbee topology <device> the device to query <n> the start index for the request, 1 is the default. This is used to scan through all values since devices usually return only 3 values per request. ZbName Sets or reads the Zigbee device friendly name (up to 32 characters). <device>,<name> sets the new friendly name <device>, (empty name) clears the friendly name <device> displays the current friendly name Also see SetOption83 1 to enable friendly names as JSON keys instead of ShortAddr. ZbNameKey SetOption83 Uses Zigbee device friendly name instead of 16 bits short addresses as JSON key when reporting values and commands 0 = JSON key as short address 1 = JSON key as friendly name See ZbName <device>,<name> ZbNameTopic SetOption112 0 = (default) 1 = use friendly name in Zigbee topic (use with ZbDeviceTopic ) ZbNoAutoBind SetOption110 0 = (default) 1 = disable Zigbee auto-binding and auto-attribute reporting when pairing a new device. Use only if you want to manually configure devices ZbNoPrefix SetOption100 remove Zigbee ZbReceived value from {\"ZbReceived\":{xxx:yyy}} JSON message 0 = disable (default) 1 = enable ZbOccupancy Configure the time-out after \"Occupancy\":1 to send a synthetic \"Occupancy\":0 for Zigbee motion sensors <device>,<x> - set occupancy timeout for <device> Possible values for <x> 0 : no time-out, the device actually generates \"Occupancy\":0 n : the number of seconds. The possible values are 15, 30, 45, 60, 75, 90, 105, 120. If the number is different, it is rounded up -1 : apply the default of 90 seconds ZbOmitDevice SetOption119 Remove device addr from JSON payload 0 = disable (default) 1 = enable ZbPermitJoin Sets pairing mode for new device discovery 0 = disable pairing mode 1 = enable pairing mode for 60 seconds 99 = enable pairing until device reboots (CC2530 only) Leaving Zigbee network open to join will allow any Zigbee device to connect and retrieve your network encryption key. This can lead to a compromise of your Zigbee network. ZbPing <device> = test availability of Zigbee device. If the device is connected and not sleeping, you should receive a ZbPing message within the next second. Example: ZbPing 0x5ADF responds with: {\"ZbPing\":{\"Device\":\"0x5ADF\",\"IEEEAddr\":\"0x90FD9FFFFE03B051\"}} ZbReceivedTopic SetOption118 Move ZbReceived from JSON message into the subtopic replacing \"SENSOR\" default 0 = disable (default) 1 = enable ZbSend Command structure: {\"Device\":\"<shortaddr>\", \"Endpoint\":\"<endpoint>\", \"Manuf\":<manuf>, \"Send\":{\"<sendcmd>\":<sendparam>}} <shortaddr> = short address of the Zigbee device on the network <endpoint> = target endpoint on the device ( understanding endpoints ) <manuf> = (optional) forces a specific ManufacturerId in the ZCL frame (required by some Xiaomi devices) \"<sendcmd>\":<sendparam> = command and parameters to send ( Zigbee Device Commands ) _Use ZbZNPSend to send a raw form low-level message on CC253x gateways _ Example: ZbSend { \"Device\":\"0x1234\", \"Endpoint\":\"0x03\", \"Send\":{\"Power\":\"on\"} } ZbScan Do an energy scan on each radio channel ZbStatus<x> Display Zigbee devices seen on the network since boot <device> (optional) = all devices This command provides three levels of increasing detail according to <x> ZbStatus1 Display Short Address, and Friendly Name ZbStatus2 Also include Manufacturer ID and Model ID ZbStatus3 Also include a list of endpoints and the clusterIds supported by each endpoint Example: ZbStatus3 1 requests all details for device number 1 Requested information may exceed maximum result size allowed by Tasmota. In this case, the output will be truncated. To get all of the desired information, request results for a specific device individually. ZbUnbind Unbinds one Zigbee device from another or from a group. {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } <device> = the device sending the messages (mandatory) <endpoint> = the source endpoint (mandatory) <cluster> = the source cluster id (mandatory) <to_device> = the target device (optional) <to_endpoint> = the target endpoint (optional if it can be inferred from ZbStatus3 ) <to_group> = the target group id (optional) You must specify either \"ToDevice\" or \"ToGroup\" but not both Zigbee2Tasmota must know the IEEE address of the target device, use ZbStatus2 to verify and ZbProbe to query the address. See also SetOption83 , SetOption89 , SetOption100 , SetOption101","title":"Zigbee"},{"location":"Commands/#bluetooth","text":"Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and time zone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is an active scan and it should be used only if necessary . At the moment that is the case just with MJ_HT_V1. This can change if a future HM-10 firmware starts supporting passive scan. NRFBeacon Set a BLE device as a beacon using the (fixed) MAC-address <value> (1-3 digits) = use beacon from scan list <value> (12 characters) = use beacon given the MAC interpreted as an uppercase string AABBCCDDEEFF NRFIgnore 0 = all known sensor types active_(default)_ <value> = ignore certain sensor type ( 1 = Flora, 2 = MJ_HT_V1, 3 = LYWSD02, 4 = LYWSD03, 5 = CGG1, 6 = CGD1 NRFKey Set a \"bind_key\" for a MAC-address to decrypt (LYWSD03MMC & MHO-C401). The argument is a 44 uppercase characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string NRFMjyd2s Set a \"bind_key\" for a MAC-address to decrypt sensor data of the MJYD2S. The argument is a 44 characters long string, which is the concatenation of the bind_key and the corresponding MAC. <00112233445566778899AABBCCDDEEFF> (32 characters) = bind_key <112233445566> (12 characters) = MAC of the sensor <00112233445566778899AABBCCDDEEFF112233445566> (44 characters)= final string NRFNlight Set the MAC of an NLIGHT <value> (12 characters) = MAC interpreted as an uppercase string AABBCCDDEEFF NRFPage Show the maximum number of sensors shown per page in the webUI list. <value> = set number of sensors (default = 4) NRFScan Scan for regular BLE-advertisements and show a list in the console 0 = start a new scan list 1 = append to the scan list 2 = stop running scan","title":"Bluetooth"},{"location":"Commands/#stepper-motors","text":"Command Parameters MotorMIS 1,2,4,8,16 Set micro stepping increment - 1/1 (full steps) to 1/16 (default = 1 ) MotorSPR integer Set the number of steps the given motor needs for one revolution (default = 200 ) This is dependent on the type of motor and micro stepping. Most common motors are 1.8\u00b0 per step. MotorRPM 1..300 Set revolutions per minute (default = 30 ) MotorMove integer Move the motor the given number of steps (positive values: clockwise, negative values: counterclockwise) MotorRotate integer Rotate the motor the given number of degrees (positive values: clockwise, negative values: counterclockwise) MotorTurn float Spin the motor the given number of turns (positive values: clockwise, negative values: counterclockwise)","title":"Stepper Motors"},{"location":"Commands/#mp3-player","text":"The MP3 Player driver is based on the one from DFRobot. They named it DFPlayer mini . All MP3 Players with the identical Serial Control Command structure can be used. Note Player module pin RX should be connected to a GPIO defined as \"MP3 Player\" from the drop-down list. The driver uses a Software Serial and do not requires usage of hardware TX/RX pins. Command Parameters MP3DAC 0 = DAC on (default) 1 = DAC off MP3Device Specify playback device 1 = USB 2 = SD Card (default (also defaults on reset or power cycle)) MP3EQ Set equalizer mode: 0 = normal 1 = pop 2 = rock 3 = jazz 4 = classic 5 = bass) MP3Pause Pause MP3Play Play, works as a normal play on a real MP3 Player, starts at first MP3 file MP3Reset Reset the MP3 player to defaults MP3Stop Stop MP3Track x = play track <x> MP3Volume 0..100 = set Volume","title":"MP3 Player"},{"location":"Commands/#thermostat","text":"Command Parameters ThermostatModeSet Sets the thermostat mode 0 = Thermostat Off (controller inactive, default) 1 = Thermostat in automatic mode (controller active) 2 = Thermostat in manual mode (output switch follows the input switch, used to follow an existing wall thermostat) ClimateModeSet Sets the climate mode 0 = Heating mode (default) 1 = Cooling mode ControllerModeSet Sets the controller mode (used for thermostat in automatic mode) 0 = Hybrid controller (Predictive ramp-up controller and PI, default) 1 = PI controller 2 = Predictive ramp-up controller TempFrostProtectSet Sets the frost protection temperature. The controller, if in automatic mode, will never allow the temperature to sink below this value <0..12> = Temperature value in degrees Celsius/Fahrenheit (default 4.0\u00b0 Celsius) InputSwitchSet Sets the number of the input used in case in manual control <1..4> = Number of the input (default 1) InputSwitchUse Switch to decide if the input shall be used to automatically switch to manual mode and assign it to the output (useful if using a serially connected wall thermostat) 0 = Input not used (default) 1 = Input used SensorInputSet Sets the temperature sensor to be used 0 = MQTT (default) 1 = Local sensor (can be changed by define, default DS18B20) OutputRelaySet Sets the output switch to be used for the thermostat <1..8> = Number of the output (default 1) EnableOutputSet Enables or disables the physical output 0 = Output disabled 1 = Output enabled (default) TimeAllowRampupSet Sets the minimum time in minutes since the last control action to be able to switch to the predictive ramp-up controller phase (applicable just in case of Hybrid controller, used normally in case of big deltas between the setpoint and the room temperature) <value> = Minutes (default 300 minutes) TempFormatSet Sets the temperature format 0 = Degrees Celsius (default) 1 = Degrees Fahrenheit TempMeasuredSet Sets the temperature measured by the sensor (for MQTT sensor mode) <TempFrostProtectSet..100> = Temperature (default 18.0\u00b0 Celsius) TempTargetSet Sets the target temperature for the controller (setpoint) <TempFrostProtectSet..100> = Temperature (default 18.0\u00b0 Celsius) TempMeasuredGrdRead Returns the calculated temperature gradient <value> = Temperature gradient in degrees Celsius/Fahrenheit StateEmergencySet Sets the thermostat emergency flag 0 = Emergency flag off (default) 1 = Emergency flag on (thermostat switches to off state) TimeManualToAutoSet Sets the time in manual mode after the last active input action (f.e. last action from serial connected wall thermostat) to switch to automatic mode 0..1440 = time in minutes (default 60 minutes) PropBandSet Sets the value of the proportional band of the PI controller 0..20 = value in degrees Celsius (default 4 degrees Celsius) TimeResetSet Sets the value of the reset time of the PI controller 0..86400 = value in seconds (default 12000 seconds) TimePiProportRead Returns the proportional part of the PI controller calculation in seconds value = value in seconds TimePiIntegrRead Returns the integral part of the PI controller calculation in seconds value = value in seconds TimePiCycleSet Sets the value of the cycle for the PI controller 0..1440 = value in minutes (default 30 minutes) TempAntiWindupResetSet Sets the value of the delta between controlled temperature and setpoint above which the integral part of the PI controller will be set to 0, in degrees Celsius/Fahrenheit 0..10 = value in degrees (default 0.8\u00b0 Celsius) TempHystSet Sets the value of the temperature hysteresis for the PI controller, in degrees Celsius/Fahrenheit -10..10 = value in degrees (default 0.1\u00b0 Celsius) TimeMaxActionSet Sets the maximum duty cycle of the PI controller in minutes 0..1440 = value in minutes (default 20 minutes) TimeMinActionSet Sets the minimum duty cycle of the PI controller in minutes 0..1440 = value in minutes (default 4 minutes) TimeSensLostSet Sets the maximum time without a temperature sensor update to mark it as lost in minutes 0..1440 = value in minutes (default 30 minutes) TimeMinTurnoffActionSet Sets the minimum time in minutes within a cycle for the PI controller to switch off the output, below it, it will stay on 0..1440 = value in minutes (default 3 minutes) TempRupDeltInSet Sets the minimum delta between controlled temperature and setpoint for the controller to switch to ramp-up controller phase (applicable just in Hybrid controller mode) 0..10 = value in degrees Celsius/Fahrenheit (default 0.4\u00b0 Celsius) TempRupDeltOutSet Sets the maximum delta between controlled temperature and setpoint for the controller to switch to the PI controller phase (applicable just in Hybrid controller mode) 0..10 = value in degrees Celsius/Fahrenheit (default 0.2\u00b0 Celsius) TimeRampupMaxSet Sets the maximum time in minutes for the controller to stay in the ramp-up phase (applicable just in Hybrid controller mode 0..1440 = value in minutes (default 960 minutes) TimeRampupCycleSet Sets the value of the cycle for the ramp-up controller 0..1440 = value in minutes (default 30 minutes) TempRampupPiAccErrSet Sets the initial accumulated error when switching from ramp-up to the PI controller phase if the target temperature has not been reached (applicable just in Hybrid controller mode) 0..25 = value in degrees Celsius/Fahrenheit (default 2\u00b0 Celsius) CtrDutyCycleRead Returns the duty cycle of the controller 0..100 = value in % DiagnosticModeSet Enables/disables the diagnostics flag 0 = Diagnostics disabled 1 = Diagnostics enabled (default)","title":"Thermostat"},{"location":"Commands/#domoticz","text":"Command Parameters DzIdx<x> Show Domoticz Relay idx <x> (x = 1..4 ) 0 = disable use of Relay idx <x> (default) <value> = Show Relay idx <x> DzKeyIdx<x> Show Domoticz Key idx <x> (x = 1..4 ) 0 = disable use of Key idx <x> (default) <value> = Show Key idx <x> (to use enable ButtonTopic ) DzSend<type> send values or state to Domoticz <index>,<value1(;value2)|state> DzSensorIdx<x> Show Domoticz Sensor idx <x> (x = 1..5 ) 0 = disable use of Sensor idx <x> (default) <value> = Show Sensor idx <x> DzSwitchIdx<x> Show Domoticz Switch idx <x> (x = 1..4 ) 0 = disable use of Switch idx <x> (default) <value> = Show Switch idx <x> (to use enable SwitchTopic ) DzUpdateTimer Show current update timer value in seconds 0 = disable sending interim Domoticz status (default) 1..3600 = send status to Domoticz in defined intervals","title":"Domoticz"},{"location":"Commands/#influxdb","text":"Command Parameters Ifx InfluxDB state 0 = off 1 = on IfxHost <value> = set Influxdb host name or IP address IfxPort <value> = set Influxdb port IfxDatabase <value> = set Influxdb V1 and database name IfxUser <value> = set Influxdb V1 and userid IfxPassword <value> = set Influxdb V1 and password IfxBucket <value> = set Influxdb V2 and bucket name IfxOrg <value> = set Influxdb V2 and organization IfxSensor Set Influxdb sensor logging 0 = off 1 = on IfxToken <value> = set Influxdb V2 and token IfxPeriod <value> = 0 = use Teleperiod value as publication interval (default) 10 .. 3600 = set a different publication interval Even when IfxPeriod 0 is used, publication is not necessarily performed at the same time as the telemetry message. IfxRp <value> = set Influxdb retention policy (optional) If blank, default is used as defined by the InfluxDB service. Retention policy must exist in InfluxDB, otherwise http post will fail.","title":"InfluxDB"},{"location":"Commands/#knx","text":"Command Parameters KnxTx_Cmnd<x> 0 or 1 = send command using slot <x> set in KNX Menu at KNX_TX KnxTx_Val<x> <value> = send float value using slot <x> set in KNX Menu at KNX_TX KnxTx_Scene <value> = send scene number to the GA set in KNX Menu KNX_ENABLED Status of KNX Communications 0 = set to Disable 1 = set to Enable KNX_ENHANCED Status of Enhanced mode for KNX Communications 0 = set to Disable 1 = set to Enable KNX_PA KNX Physical Address 0.0.0 = address not set x.x.x = set the device address (example 1.1.0 ) KNX_GA Return the amount of Group Address to Send Data/Commands configured KNX_GA<x> Setup Group Address to Send Data/Commands (<x> = KNX Group Address number) 1 = return configuration of GA<x> <option>, <area>, <line>, <member> to set configuration of GA<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Send Data/Commands KNX_CB Return the amount of Group Address to Receive Data/Commands configured KNX_CB<x> Setup Group Address to Receive Data/Commands 1 = return configuration of CB<x> <option>, <area>, <line>, <member> to set configuration of CB<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Receive Data/Commands OPTION OPTION Value OPTION OPTION Value 1 Relay 1 17 TEMPERATURE 2 Relay 2 18 HUMIDITY 3 Relay 3 19 ENERGY_VOLTAGE 4 Relay 4 20 ENERGY_CURRENT 5 Relay 5 21 ENERGY_POWER 6 Relay 6 22 ENERGY_POWERFACTOR 7 Relay 7 23 ENERGY_DAILY 8 Relay 8 24 ENERGY_START 9 Button 1 25 ENERGY_TOTAL 10 Button 2 26 KNX_SLOT1 11 Button 3 27 KNX_SLOT2 12 Button 4 28 KNX_SLOT3 13 Button 5 29 KNX_SLOT4 14 Button 6 30 KNX_SLOT5 15 Button 7 255 EMPTY 16 Button 8","title":"KNX"},{"location":"Commands/#esp32","text":"","title":"ESP32"},{"location":"Commands/#ble-esp32","text":"Command Parameters BLEAddrFilter Set BLE Address type filter. BLEAddrFilter = show filter level BLEAddrFilter n = set BLE address type filter 0..3 - default 3. Ignores BLE address types > filter value. Set 0 to ONLY see public addresses. BLEAlias Set Alias names for devices. A device may be referred to by it's alias in subsequent commands BLEAlias mac=alias mac=alias ... = set one or more aliases from devices. BLEAlias2 = clear all aliases. BLEDebug Set BLE debug level. BLEDebug = show extra debug information BLEDebug0 = suppress extra debug BLEDetails Display details about received adverts BLEDetails0 = disable showing of details. BLEDetails1 mac/alias = show the next advert from device mac/alias BLEDetails2 mac/alias = show all advert from device mac BLEDevices Cause a list of known devices to be sent on MQTT, or Empty the list of known devices. BLEDevices0 = clear the known devices list. BLEDevices = Cause the known devices list to be published on stat/TASName/BLE. BLEMaxAge Set the timeout for device adverts. BLEMaxAge n = set the devices timeout to n seconds. BLEMaxAge = display the device timeout. BLEMode Change the operational mode of the BLE driver. BLEMode0 = disable regular BLE scans. BLEMode1 = BLE scan on command only. BLEMode2 = regular BLE scanning (default). BLEName Read or write the name of a BLE device. BLEName mac|alias = read the name of a device using 1800/2A00. BLEName mac|alias = write the name of a device using 1800/2A00 - many devices are read only. BLEOp Perform a simple active BLE operation (read/write/notify). see separate description in source code BLEPeriod Set the period for publish of BLE data <value> = set interval in seconds BLEScan Cause/Configure BLE a scan BLEScan0 0..1 = enable or disable Active scanning. (an active scan will gather extra data from devices, including name) BLEScan = Trigger a 20s scan now if in BLEMode1 BLEScan n = Trigger a scan now for n seconds if in BLEMode1 iBeacon Show or set enable for the iBeacon driver iBeacon = Display 0 iBeaconClear Clear iBeacon list iBeaconOnlyAliased Show or set OnlyAliased for the iBeacon driver iBeaconOnlyAliased = Display 0 iBeaconPeriod Display or Set the period for publish of iBeacon data iBeaconPeriod = display interval iBeaconPeriod ss = set interval in seconds iBeaconTimeout Display or Set the timeout for iBeacon devices iBeaconTimeout = display timeout iBeaconTimeout ss = set timeout in seconds","title":"BLE ESP32"},{"location":"Commands/#ble-mi-sensors","text":"Command Parameters MI32Battery Trigger an active read of battery values. MI32Battery = request the driver read the battery from all sensors which have active battery read requirements. MI32Block Block or unblock a sensor device. MI32Block = list blocked devices by mac. MI32Block <mac or blealias> = Block one mac/alias. MI32Key Add a decryption key. MI32Key hexkey = add a 44 character decryption key to the keys list. MI32Keys Add one or more decryption keys by mac or alias. MI32Keys = list keys. MI32Keys <mac or blealias>=<bind_key> <mac or blealias>=<bind_key> ... = add keys for MAC or ble_alias. MI32Keys <mac or blealias>= - remove keys for one mac MI32Option<x> n Set driver options at runtime x=0 - 0 -> sends only recently received sensor data, 1 -> aggregates all recent sensors data types x=1 - 0 -> shows full sensor data at TELEPERIOD, 1 -> shows no sensor data at TELEPERIOD x=2 - 0 -> sensor data only at TELEPERIOD (default and \"usual\" Tasmota style), 1 -> direct bridging of BLE-data to mqtt-messages x=5 - 0 -> show all relevant BLE sensors, 1 -> show only sensors with a BLEAlias x=6 (from v 9.0.2.1) 1 -> always use MQTT Topic like tele/tasmota_ble/<name> containing only one sensor MI32Page Display/Set the sensors per page in the web view. MI32page = show sensors per page. MI32page n = Set sensors per page to n. MI32Period Display/Set the active scan and tele period for the MI32 driver. MI32Period = display the period in seconds. MI32Period n = Set the MI driver active read and tele period to n seconds. MI32Time <x> = set the time on the device in slot x . MI32Unit <x> = set the current Tasmota temperature unit as the temp unit for sensor in slot x .","title":"BLE MI Sensors"},{"location":"Commands/#camera","text":"Command Parameters Wc Query all camera settings WcBrightness -2..+2 = set picture brightness WcContrast -2..+2 = set picture contrast WcFlip Flip camera image. 0 = disable (default) 1 = enable WcMirror Mirror camera image. 0 = disable (default) 1 = enable WcResolution Set camera resolution. 0 = 96x96 (96x96) 1 = QQVGA2 (128x160) 2 = QCIF (176x144) 3 = HQVGA (240x176) 4 = QVGA (320x240) 5 = CIF (400x296) 6 = VGA (640x480) 7 = SVGA (800x600) 8 = XGA (1024x768) 9 = SXGA (1280x1024) 10 = UXGA (1600x1200) WcSaturation -2..+2 = set picture saturation WcStream Control streaming 0 = stop 1 = start","title":"Camera"},{"location":"Commands/#ethernet","text":"Command Parameters Ethernet Only for ESP32 boards with additional LAN chip 0 = disable Ethernet 1 = enable Ethernet (default) EthAddress 0..31 = PHYxx address EthClockMode Ethernet clock mode. 0 = ETH_CLOCK_GPIO0_IN (default) 1 = ETH_CLOCK_GPIO0_OUT 2 = ETH_CLOCK_GPIO16_OUT 3 = ETH_CLOCK_GPIO17_OUT EthType Ethernet type. 0 = ETH_PHY_LAN8720 (default) 1 = ETH_PHY_TLK110 2 = ETH_PHY_IP101 EthIpAddress Set device Ethernet IP address (for Wi-Fi, see IpAddress ) 0.0.0.0 = use dynamic IP address (DHCP) XXX.XXX.XXX.XXX = set static IP address Follow any IP configuration commands with restart 1 to apply changes EthGateway Set gateway IP address EthSubnetmask Set subnet mask EthDnsServer1 EthDnsServer2 Set DNS servers IP address See Also wifi - Enable/Disable Wi-Fi","title":"Ethernet"},{"location":"Compile-your-build/","text":"Flash and memory space on an ESP82XX chip is limited and very valuable. Because of that our precompiled binaries include the most popular features of Tasmota but no build can include all of them. To include a feature you need (or build completely customized Tasmota) you will have to configure and compile your own version. First you will need Tasmota's source code (either development or master branch) and a compiling tool. Compiling Tools ~ If you want to modify the code or default settings you can use: PlatformIO - setup and configure PlatformIO for Tasmota compilation and upload PlatformIO CLI - how to flash Tasmota using the PlatformIO command line interface on Linux PlatformIO-Core - automate firmware builds using PlatformIO-Core and flash with esptool Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota Docker Tasmota - compile from a Docker container using PlatformIO Online Compilers ~ Can only create a firmware binary. Use one of the tools to flash it to your device. Gitpod - compile your own binary in the cloud using Gitpod . TasmoCompiler - simple web GUI to compile Tasmota with your own settings Simplest way to compile is with GitPod , requires only a web browser. Once you have set up the development environment, unzip the source code into a folder. Customize your build ~ There are mainly 2 type of possible customization: Changing default settings that will be used by Tasmota when running for the first time on a blank device (no previous existing configutrion in flash or flash erased). This can be done on any variant as it doesn't change the code base, memory footprint or required libraries. Such customization include: default Wi-Fi settings, default MQTT settings, default values for a setting including SetOption<x> . Adding or removing features. This is essentially supported only on the base tasmota/tasmota32 environment). Other variants have been fine tuned and trying to add/remove features to them is most likely to fail and Tasmota development team will provide no support. The typical failure is trying to add sensors to tasmota-display or adding displays to tasmota-sensors . The proper way is to add both sensors and displays to tasmota . Do not try to add or remove features to a variant, only to tasmota or tasmota32 General customization principle ~ Create a new file in /tasmota folder called user_config_override.h . You can copy the sample file user_config_override_sample.h that is already there and which include some sample definition for coding your own Wifi SSID and pasword inside the Tasmota firmware. Open the file in chosen development environment for editing. Do not modify my_user_config.h It is strongly recommended to NOT customize your build by making changes in my_user_config.h because the changes you made there will be overwritten if you download/clone a newer version of Tasmota code-base. At least this would make any merge complicated. Add your custom configurations ONLY in user_config_override.h . The file my_user_config.h is a great reference for available settings and features. Changing default settings ~ Most default settings are defined in my_user_config.h along with an explanation and the command used to change it dynamically. For example: #define WIFI_CONFIG_TOOL WIFI_RETRY // [WifiConfig] Default tool if Wi-Fi fails to connect (default option: 4 - WIFI_RETRY) // (WIFI_RESTART, WIFI_MANAGER, WIFI_RETRY, WIFI_WAIT, WIFI_SERIAL, WIFI_MANAGER_RESET_ONLY) // The configuration can be changed after first setup using WifiConfig 0, 2, 4, 5, 6 and 7. #define WIFI_SCAN_AT_RESTART false // [SetOption56] Scan Wi-Fi network at restart for configured AP's The first line shows that WIFI_CONFIG_TOOL is the macro matching the command WifiConfig . The default value, as stated in WifiConfig 's documentation is WIFI_RETRY (value 4 ). The other line shows the default value for SetOption56 which is by default false ( OFF or 0 ). If you want to override any of these in your own binary, add the following in user_config_override.h : #ifdef %identifier% #undef %identifier% #endif #define %identifier% %the_new_value% Example: #ifdef WIFI_CONFIG_TOOL #undef WIFI_CONFIG_TOOL #endif #define WIFI_CONFIG_TOOL WIFI_WAIT // Change WifiConfig to wait (5) Enabling a feature in tasmota ~ A feature can be enabled by #defining the matching USE_featurename macro. It can be disabled by #undefining the same macro. All features and their identifier can be found in my_user_config.h . Best practice to enable a feature is to use #ifndef %identifier% #define %identifier% #endif Best practice to disable a feature is to use #ifdef %identifier% #undef %identifier% #endif If the feature you want to customize have a value like for example: #define WIFI_CONFIG_TOOL WIFI_WAIT , the best practice to modify it is to use #ifdef %identifier% #undef %identifier% #endif #define %identifier% %value% Directives Description #define %identifier% enables the feature #undef %identifier% disables the feature #ifdef %identifier% checks if the feature is defined in code #ifndef %identifier% checks if the feature is not defined #endif closes #if statement Example: enable blinds and shutters support #ifndef USE_SHUTTER #define USE_SHUTTER // Add Shutter support for up to 4 shutter with different motortypes (+6k code) #endif identifier = USE_SHUTTER check whether USE_SHUTTER is already defined and proceed if it is not this line copied from my_user_config.h then uncommented, tells the compiler to include (#define) shutter support close the IF statement from line 1 Example: disable Domoticz support #ifdef USE_DOMOTICZ #undef USE_DOMOTICZ #endif identifier = USE_DOMOTICZ check whether USE_DOMOTICZ is already defined and proceed if it is tell the compiler to remove (#undef) Domoticz support close the IF statement from line 1 It is not recommended to change my_user_config.h , use it only for reference Save file, compile the custom binary and flash it Note There are limits to how many features can be included! If you go overboard code might not compile due to features conflicting or might not be able to be flashed if it exceeds ESP8266 limits . Advanced customization ~ USER_BACKLOG ~ USER_BACKLOG allows a set of commands to be automatically executed when the binary is ran for the first time on blank device (no settings in flash) or after a settings reset using reset 1 / reset 2 . It should be defined as a list of commands separated by a ; . No Backlog command is required. It can be used for example for settings which do not have a changeable default. An interesting usage is to automatically reconfigure a device from a saved configuration file right after a reset 1 / reset 2 . Example: #define USER_BACKLOG \"WebGetConfig http: //myserver/tasmota/conf/%id%.dmp\" Will automatically load a configuration backup (*.dmp) file based on the MAC address of the device. USER_RULE ~ If you need some rules to be automatically populated in your binary, you can define USER_RULE<x> . #define USER_RULE1 \"On Switch1#state DO publish cmnd/otherdevice/POWER %value% ENDON\" Defining multiple custom firmwares ~ You may want to generate multiple custom firmwares such as one for switches/relays, one for sensors, in a similar way as Tasmota provides different binaries. This can be achieved very simply. Rename the file platformio_override_sample.ini as platformio_override.ini . Do not change anything inside. Create a file platformio_tasmota_cenv.ini like the sample below. This will allow you to define your own binaries. cenv stands for Custom ENVironment where an environment is a specific binary to generate. In your user_config_override.h you can create sections with specific settings for each type of firmware. SSID and MQTT can be outside of the section so they apply to every binary. Sample platformio_tasmota_cenv.ini ~ ; ********************************************************************* [platformio] ; For best Gitpod performance remove the \";\" in the next line. Needed ; Platformio files are cached and installed at first run ;core_dir = .platformio ; *** Build/upload environment default_envs = ; *** Uncomment the line(s) below to select version(s) that will be build ; by default. Commented versions can still be build individually from ; VSCode or command line tasmota-foo tasmota-bar tasmota32-foo tasmota32-grizzly ; ********************************************************************* ; Common section can override global parameters for all builds [common] ; *** Upload Serial reset method for Wemos and NodeMCU upload_port = COM4 ; ********************************************************************* ; This section show how to create 2 alternative binaries : tasmota-foo.bin ; and tasmota-bar.bin. Those binaries are derived form tasmota.bin and ; customization is defined in user_config_override.h ; Those binaries are for ESP8266 ; The name after the env: tag will give its name to the binary [env:tasmota-foo] build_flags = ${env.build_flags} -DFIRMWARE_FOO [env:tasmota-bar] build_flags = ${env.build_flags} -DFIRMWARE_BAR ; ********************************************************************* ; Similar exemple for ESP32 ; Note that you must explicitly state that they derive from `tasmota32` [env:tasmota32-foo] extends = env:tasmota32_base build_flags = ${env:tasmota32_base.build_flags} -DFIRMWARE_FOO [env:tasmota32-grizzly] extends = env:tasmota32_base build_flags = ${env:tasmota32_base.build_flags} -DFIRMWARE_GRIZZLY Sample user_config_override.h ~ #ifndef _USER_CONFIG_OVERRIDE_H_ #define _USER_CONFIG_OVERRIDE_H_ // force the compiler to show a warning to confirm that this file is included #warning **** user_config_override.h: Using Settings from this File **** // *********************************************** // ** Global settings for all binaries *********** // -- Setup your own Wifi settings --------------- #undef STA_SSID1 #define STA_SSID1 \"YourSSID\" // [Ssid1] Wifi SSID #undef STA_PASS1 #define STA_PASS1 \"YourWifiPassword\" // [Password1] Wifi password // You can also define your IP settings or your MQTT settings // *********************************************** // ** Firmare specific settings ****************** // -- Options for firmware tasmota-foo and tasmota32-foo ------ #ifdef FIRMWARE_FOO // This line will issue a warning during the build (yellow in // VSCode) so you see which section is used #warning **** Build: FOO **** // -- CODE_IMAGE_STR is the name shown between brackets on the // Information page or in INFO MQTT messages #undef CODE_IMAGE_STR #define CODE_IMAGE_STR \"foo\" // Put here your override for firmware tasmota-foo #define USE_I2C #define USE_SENSOR_FOO // Beware this doesn't exist !!! #endif // -- Options for firmware tasmota-bar ------ #ifdef FIRMWARE_BAR #warning **** Build: BAR **** #undef CODE_IMAGE_STR #define CODE_IMAGE_STR \"bar\" // Put here your override for firmware tasmota-bar #endif // -- Options for firmware tasmota32-grizzly ------ #ifdef FIRMWARE_GRIZZLY // If these settings are only for ESP32, you can check these // are used only when building for ESP32 #ifndef ESP32 #error *** This setup of for tasmota32 only *** #endif #warning **** Build: GRIZZLY **** #undef CODE_IMAGE_STR #define CODE_IMAGE_STR \"grizzly\" // Put here your override for firmware tasmota32-grizzly #endif #endif // _USER_CONFIG_OVERRIDE_H_","title":"Compiling"},{"location":"Compile-your-build/#compiling-tools","text":"If you want to modify the code or default settings you can use: PlatformIO - setup and configure PlatformIO for Tasmota compilation and upload PlatformIO CLI - how to flash Tasmota using the PlatformIO command line interface on Linux PlatformIO-Core - automate firmware builds using PlatformIO-Core and flash with esptool Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota Docker Tasmota - compile from a Docker container using PlatformIO","title":"Compiling Tools"},{"location":"Compile-your-build/#customize-your-build","text":"There are mainly 2 type of possible customization: Changing default settings that will be used by Tasmota when running for the first time on a blank device (no previous existing configutrion in flash or flash erased). This can be done on any variant as it doesn't change the code base, memory footprint or required libraries. Such customization include: default Wi-Fi settings, default MQTT settings, default values for a setting including SetOption<x> . Adding or removing features. This is essentially supported only on the base tasmota/tasmota32 environment). Other variants have been fine tuned and trying to add/remove features to them is most likely to fail and Tasmota development team will provide no support. The typical failure is trying to add sensors to tasmota-display or adding displays to tasmota-sensors . The proper way is to add both sensors and displays to tasmota . Do not try to add or remove features to a variant, only to tasmota or tasmota32","title":"Customize your build"},{"location":"Compile-your-build/#general-customization-principle","text":"Create a new file in /tasmota folder called user_config_override.h . You can copy the sample file user_config_override_sample.h that is already there and which include some sample definition for coding your own Wifi SSID and pasword inside the Tasmota firmware. Open the file in chosen development environment for editing. Do not modify my_user_config.h It is strongly recommended to NOT customize your build by making changes in my_user_config.h because the changes you made there will be overwritten if you download/clone a newer version of Tasmota code-base. At least this would make any merge complicated. Add your custom configurations ONLY in user_config_override.h . The file my_user_config.h is a great reference for available settings and features.","title":"General customization principle"},{"location":"Compile-your-build/#changing-default-settings","text":"Most default settings are defined in my_user_config.h along with an explanation and the command used to change it dynamically. For example: #define WIFI_CONFIG_TOOL WIFI_RETRY // [WifiConfig] Default tool if Wi-Fi fails to connect (default option: 4 - WIFI_RETRY) // (WIFI_RESTART, WIFI_MANAGER, WIFI_RETRY, WIFI_WAIT, WIFI_SERIAL, WIFI_MANAGER_RESET_ONLY) // The configuration can be changed after first setup using WifiConfig 0, 2, 4, 5, 6 and 7. #define WIFI_SCAN_AT_RESTART false // [SetOption56] Scan Wi-Fi network at restart for configured AP's The first line shows that WIFI_CONFIG_TOOL is the macro matching the command WifiConfig . The default value, as stated in WifiConfig 's documentation is WIFI_RETRY (value 4 ). The other line shows the default value for SetOption56 which is by default false ( OFF or 0 ). If you want to override any of these in your own binary, add the following in user_config_override.h : #ifdef %identifier% #undef %identifier% #endif #define %identifier% %the_new_value% Example: #ifdef WIFI_CONFIG_TOOL #undef WIFI_CONFIG_TOOL #endif #define WIFI_CONFIG_TOOL WIFI_WAIT // Change WifiConfig to wait (5)","title":"Changing default settings"},{"location":"Compile-your-build/#enabling-a-feature-in-tasmota","text":"A feature can be enabled by #defining the matching USE_featurename macro. It can be disabled by #undefining the same macro. All features and their identifier can be found in my_user_config.h . Best practice to enable a feature is to use #ifndef %identifier% #define %identifier% #endif Best practice to disable a feature is to use #ifdef %identifier% #undef %identifier% #endif If the feature you want to customize have a value like for example: #define WIFI_CONFIG_TOOL WIFI_WAIT , the best practice to modify it is to use #ifdef %identifier% #undef %identifier% #endif #define %identifier% %value% Directives Description #define %identifier% enables the feature #undef %identifier% disables the feature #ifdef %identifier% checks if the feature is defined in code #ifndef %identifier% checks if the feature is not defined #endif closes #if statement Example: enable blinds and shutters support #ifndef USE_SHUTTER #define USE_SHUTTER // Add Shutter support for up to 4 shutter with different motortypes (+6k code) #endif identifier = USE_SHUTTER check whether USE_SHUTTER is already defined and proceed if it is not this line copied from my_user_config.h then uncommented, tells the compiler to include (#define) shutter support close the IF statement from line 1 Example: disable Domoticz support #ifdef USE_DOMOTICZ #undef USE_DOMOTICZ #endif identifier = USE_DOMOTICZ check whether USE_DOMOTICZ is already defined and proceed if it is tell the compiler to remove (#undef) Domoticz support close the IF statement from line 1 It is not recommended to change my_user_config.h , use it only for reference Save file, compile the custom binary and flash it Note There are limits to how many features can be included! If you go overboard code might not compile due to features conflicting or might not be able to be flashed if it exceeds ESP8266 limits .","title":"Enabling a feature in tasmota"},{"location":"Compile-your-build/#advanced-customization","text":"","title":"Advanced customization"},{"location":"Compile-your-build/#user_backlog","text":"USER_BACKLOG allows a set of commands to be automatically executed when the binary is ran for the first time on blank device (no settings in flash) or after a settings reset using reset 1 / reset 2 . It should be defined as a list of commands separated by a ; . No Backlog command is required. It can be used for example for settings which do not have a changeable default. An interesting usage is to automatically reconfigure a device from a saved configuration file right after a reset 1 / reset 2 . Example: #define USER_BACKLOG \"WebGetConfig http: //myserver/tasmota/conf/%id%.dmp\" Will automatically load a configuration backup (*.dmp) file based on the MAC address of the device.","title":"USER_BACKLOG"},{"location":"Compile-your-build/#user_rule","text":"If you need some rules to be automatically populated in your binary, you can define USER_RULE<x> . #define USER_RULE1 \"On Switch1#state DO publish cmnd/otherdevice/POWER %value% ENDON\"","title":"USER_RULE"},{"location":"Compile-your-build/#defining-multiple-custom-firmwares","text":"You may want to generate multiple custom firmwares such as one for switches/relays, one for sensors, in a similar way as Tasmota provides different binaries. This can be achieved very simply. Rename the file platformio_override_sample.ini as platformio_override.ini . Do not change anything inside. Create a file platformio_tasmota_cenv.ini like the sample below. This will allow you to define your own binaries. cenv stands for Custom ENVironment where an environment is a specific binary to generate. In your user_config_override.h you can create sections with specific settings for each type of firmware. SSID and MQTT can be outside of the section so they apply to every binary.","title":"Defining multiple custom firmwares"},{"location":"Components-old/","text":"Component is anything wired to the ESP8266/ESP8255 chip to be controlled by or send data to it. Components can be: buttons, switches, relays, LEDs, sensors, displays, MCU units, etc. Every component is assigned in the device template to the GPIO it is wired (connected) to. Every Tasmota device has some components configured by default. Most often there is a relay, a button and a LED configured as is the case for a Sonoff Basic in the following image. Bug Tasmota 9.1 completely redesigned GPIO mapping to allow for future expansion. Read more about the GPIO Conversion Assigning Components ~ If you wish to expand a device with a peripheral component, after properly wiring everything, you need to assign it to a free GPIO in Configure Module page or use command GPIO<x> . Read more about peripherals . Tip GPIOs configured as User (1) are the GPIOs that can be assigned to components in the Configure Module page. GPIO Conversion ~ Old GPIO New GPIO Name Description 255 1 User User 0 0 None Not used 1 1184 DHT11 DHT11 sensor 2 1216 AM2301 AM230X, DHT21 and DHT22 sensor 3 1248 SI7021 Only for Sonoff Si7021, not the i2c version 4 1312 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 608 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 640 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 1376 WS2812 Addressable LEDs such as WS281X or Neopixel 8 1056 IRsend IR Transmitter LED 9 160 Switch 1 Switch 10 161 Switch 2 Switch 11 162 Switch 3 Switch 12 163 Switch 4 Switch 13 164 Switch 5 Switch 14 165 Switch 6 Switch 15 166 Switch 7 Switch 16 167 Switch 8 Switch 17 32 Button 1 Button active low, internal pull-up resistor 18 33 Button 2 Button active low, internal pull-up resistor 19 34 Button 3 Button active low, internal pull-up resistor 20 35 Button 4 Button active low, internal pull-up resistor 21 224 Relay 1 Relay 22 225 Relay 2 Relay 23 226 Relay 3 Relay 24 227 Relay 4 Relay 25 228 Relay 5 Relay 26 229 Relay 6 Relay 27 230 Relay 7 Relay 28 231 Relay 8 Relay 29 256 Relay_i 1 Relay inverted 30 257 Relay_i 2 Relay inverted 31 258 Relay_i 3 Relay inverted 32 259 Relay_i 4 Relay inverted 33 260 Relay_i 5 Relay inverted 34 261 Relay_i 6 Relay inverted 35 262 Relay_i 7 Relay inverted 36 263 Relay_i 8 Relay inverted 37 416 PWM 1 Pulse Width Modulated Output 38 417 PWM 2 Pulse Width Modulated Output 39 418 PWM 3 Pulse Width Modulated Output 40 419 PWM 4 Pulse Width Modulated Output 41 420 PWM 5 Pulse Width Modulated Output 42 352 Counter 1 Counter Input 43 353 Counter 2 Counter Input 44 354 Counter 3 Counter Input 45 355 Counter 4 Counter Input 46 448 PWM_i 1 Pulse Width Modulated inverted Output 47 449 PWM_i 2 Pulse Width Modulated inverted Output 48 450 PWM_i 3 Pulse Width Modulated inverted Output 49 451 PWM_i 4 Pulse Width Modulated inverted Output 50 452 PWM_i 5 Pulse Width Modulated inverted Output 51 1088 IRrecv IR Receiver Input (for example TSOP1838) 52 288 Led 1 LED 53 289 Led 2 LED 54 290 Led 3 LED 55 291 Led 4 LED 56 320 Led_i 1 Inverted LED - default state ON 57 321 Led_i 2 Inverted LED - default state ON 58 322 Led_i 3 Inverted LED - default state ON 59 323 Led_i 4 Inverted LED - default state ON 60 1408 MHZ Rx MHZ 19 CO2 Sensor 61 1440 MHZ Tx MHZ 19 CO2 Sensor 62 1472 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 1504 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 1600 SAir Rx Sensor Senseair 65 1632 SAir Tx Sensor Senseair 66 768 SPI CS SPI Interface (ePaper Display) 67 800 SPI DC SPI Interface (ePaper Display) 68 992 BkLight Backlight (Display) 69 1696 PMS5003 PMS5003 Air Quality Sensor 70 1760 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 1792 SerBr Rx Serial Bridge Receive 72 1824 SerBr Tx Serial Bridge Transmit 73 1856 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 1888 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 1920 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 1952 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 1984 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 2016 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 2048 TM16 CLK TM1638 Switch Module 80 2080 TM16 DIO TM1638 Switch Module 81 2112 TM16 STB TM1638 Switch Module 82 192 Switch_n 1 Switch, no pull-up resistor 83 193 Switch_n 2 Switch, no pull-up resistor 84 194 Switch_n 3 Switch, no pull-up resistor 85 195 Switch_n 4 Switch, no pull-up resistor 86 196 Switch_n 5 Switch, no pull-up resistor 87 197 Switch_n 6 Switch, no pull-up resistor 88 198 Switch_n 7 Switch, no pull-up resistor 89 199 Switch_n 8 Switch, no pull-up resistor 90 64 Button_n 1 Button, active low, no internal pull-up resistor 91 65 Button_n 2 Button, active low, no internal pull-up resistor 92 66 Button_n 3 Button, active low, no internal pull-up resistor 93 67 Button_n 4 Button, active low, no internal pull-up resistor 94 384 Counter_n 1 Counter sensor, no pull-up resistor 95 385 Counter_n 2 Counter sensor, no pull-up resistor 96 386 Counter_n 3 Counter sensor, no pull-up resistor 97 387 Counter_n 4 Counter sensor, no pull-up resistor 98 1536 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 1568 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 2144 MP3 Player DF MP3 Player mini (Input) 101 1728 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 2176 HX711 SCK HX711 weight sensor serial clock input 103 2208 HX711 DAT HX711 weight sensor data output 104 2240 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 1120 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 1152 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 2272 Tuya Tx Tuya Transfer pin 108 2304 Tuya Rx Tuya Receive pin 109 2336 MGC3130 Xfr MGC3130 E-field Xfr pin 110 2368 MGC3130 Rst MGC3130 E-field Reset pin 111 832 SSPI MISO Software SPI MISO (Display) 112 864 SSPI MOSI Software SPI MOSI (Display) 113 896 SSPI SCLK Software SPI SCLK (Display) 114 928 SSPI CS Software SPI CS (Display) 115 960 SSPI DC Software SPI DC (Display) 116 2400 RF Sensor Theo Arendst RF433 Sensor 117 2432 AZ Rx AZ 7798 CO2 datalogger 118 2464 AZ Tx AZ 7798 CO2 datalogger 119 2496 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 2528 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 2560 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 96 Button_i 1 Button inverted, active high with internal pull-up resistor 123 97 Button_i 2 Button inverted, active high with internal pull-up resistor 124 98 Button_i 3 Button inverted, active high with internal pull-up resistor 125 99 Button_i 4 Button inverted, active high with internal pull-up resistor 126 128 Button_in 1 Button inverted, active high no internal pull-up resistor 127 129 Button_in 2 Button inverted, active high no internal pull-up resistor 128 130 Button_in 3 Button inverted, active high no internal pull-up resistor 129 131 Button_in 4 Button inverted, active high no internal pull-up resistor 130 2592 HLWBL SEL Energy Monitoring (for example Pow) 131 2624 HLWBL SELi Energy Monitoring (for example Pow) 132 2656 HLWBL CF1 Energy Monitoring (for example Pow) 133 2688 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 2720 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 2752 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 2784 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 2816 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 2848 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 2880 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 2912 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 2944 SM16716 DAT SM16716 Pixel LED Data pin 142 2976 SM16716 PWR SM16716 Pixel LED Power pin 143 3008 MY92x1 DI Light Bulb with MY92x controller 144 3040 MY92x1 DCKI Light Bulb with MY92x controller 145 3072 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 3104 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 3136 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 3200 Serial Tx Serial Transfer pin 149 3232 Serial Rx Serial Receive pin 150 3264 Rotary A 1 Rotary Encoder (Mi Desk Lamp) 151 3296 Rotary B 1 Rotary Encoder (Mi Desk Lamp) 152 3265 Rotary A 2 Rotary Encoder (Mi Desk Lamp) 153 3297 Rotary B 2 Rotary Encoder (Mi Desk Lamp) 154 3392 HRE CLOCK Clock/Power line for HR-E Water Meter 155 3424 HRE DATA Data line for HR-E Water Meter 156 3456 ADE7953_IRQ ADE7953 IRQ 157 544 LedLink Device Status LED 158 576 LedLinki Device Status LED, inverted 159 3168 ALux IrSel For AriLux devices - switches between IR/RF mode 160 480 Buzzer Sonoff iFan03 Buzzer 161 512 Buzzeri Sonoff iFan03 Buzzer inverted 162 1024 OLED Reset OLED Display Reset 163 3488 SolaxX1 Tx Solax Inverter Tx pin 164 3520 SolaxX1 Rx Solax Inverter Rx pin 165 3552 Zigbee Tx Zigbee Serial interface Tx 166 3584 Zigbee Rx Zigbee Serial interface Rx 167 3616 RDM6300 Rx RDM6300 RX 168 3648 iBeacon Tx HM17 iBeacon Tx 169 3680 iBeacon Rx HM17 iBeacon Rx 170 3712 A4988 DIR A4988 Motor Direction 171 3744 A4988 STP A4988 Step motor 172 3776 A4988 ENA A4988 Enable motor 173 3808 A4988 MS1 A4988 Microstep increment select pin1 174 3809 A4988 MS2 A4988 Microstep increment select pin2 175 3810 A4988 MS3 A4988 Microstep increment select pin3 176 3904 DDS238-2 Tx DDS2382 Serial interface Tx 177 3936 DDS238-2 Rx DDS2382 Serial interface Rx 178 3968 DDSU666 Tx DDSU666 Serial interface Tx 179 4000 DDSU666 Rx DDSU666 Serial interface Rx 180 4032 SM2135 CLK SM2135 Clk 181 4064 SM2135 DAT SM2135 Dat 182 4096 DeepSleep DeepSleep wake switch 183 4128 EXS Enable EXS Dimmer MCU Enable 184 4160 Client TX TasmotaClient TX 185 4192 Client RX TasmotaClient RX 186 4224 Client RST TasmotaClient Reset Pin 187 4256 Client RSTi TasmotaClient Reset Inverted 188 4288 HPMA RX Honeywell HPMA115S0 Serial Rx 189 4320 HPMA TX Honeywell HPMA115S0 Serial Tx 190 4352 GPS RX GPS Serial Tx 191 4384 GPS TX GPS Serial Tx 192 1344 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 1280 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 4416 HM10 RX HM10-BLE-Mijia-bridge Serial 195 4448 HM10 TX HM10-BLE-Mijia-bridge Serial 196 4480 LE01MR RX F&F LE-01MR Energy Meter Serial 197 4512 LE01MR TX F&F LE-01MR Energy Meter Serial 198 4544 CC1101 GDO0 CC1101 RX Pin 199 4576 CC1101 GDO2 CC1101 TX Pin 200 4608 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 4640 MOODL TX ElectriQ iQ-wifiMOODL Serial TX 202 4672 AS3935 Lightning Detector Interrupt Pin 203 1664 PMS5003 TX Plantower PMS5003 Serial interface 204 4928 Boiler OT Rx OpenTherm Boiler RX pin 205 4960 Boiler OT Tx OpenTherm Boiler TX pin 206 4992 Windmeter Speed WindMeter speed counter pin 207 5056 BL0940 RX BL0940 serial interface 208 5088 TCP TX TCP Serial bridge 209 5120 TCP RX TCP Serial bridge 210 5152 TELEINFO RX Teleinfo serial interface 211 5184 TELEINFO Enable Teleinfo Enable PIN 212 5216 LMT01 LMT01 input counting pin 213 5248 IEM3000 TX IEM3000 Serial interface 214 5280 IEM3000 RX IEM3000 Serial interface 215 5312 Zigbee RST Zigbee reset 216 5344 DYP Rx DYP-ME007 Rx pin 5728 Option a 1 Enable PWM2 high impedance if powered off as used by Wyze bulbs 5729 Option a 2 Enable dummy energy monitor 5730 Option a 3 Enable UDisplay universal display driver Rotary A_n Rotary Encoder Rotary B_n Rotary Encoder Button_d 1 Button, active low with internal pull-down resistor Button_d 2 Button, active low with internal pull-down resistor Button_d 3 Button, active low with internal pull-down resistor Button_d 4 Button, active low with internal pull-down resistor Button_id 1 Button inverted, active high with internal pull-down resistor Button_id 2 Button inverted, active high with internal pull-down resistor Button_id 3 Button inverted, active high with internal pull-down resistor Button_id 4 Button inverted, active high with internal pull-down resistor Switch_d 1 Switch, with pull-down resistor Switch_d 2 Switch, with pull-down resistor Switch_d 3 Switch, with pull-down resistor Switch_d 4 Switch, with pull-down resistor Switch_d 5 Switch, with pull-down resistor Switch_d 6 Switch, with pull-down resistor Switch_d 7 Switch, with pull-down resistor Switch_d 8 Switch, with pull-down resistor ADC Conversion ~ Old ADC New ADC Option WebUI display MQTT mesage 0 0 None none none 1 4704 Analog Analog0 %value% {\"A0\":%value%} 2 4736 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 4768 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 4800 Button none none 5 4832 Buttoni none none 6 4864 Range Range %value% {\"Range\":%value%} 7 4896 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\": %value ,\"Power\": %value ,\"Voltage\":230,\"Current\": %value } 8 3328 Joystick none {\"ANALOG\":{\"Joy1\":%value%}","title":"Components old"},{"location":"Components-old/#assigning-components","text":"If you wish to expand a device with a peripheral component, after properly wiring everything, you need to assign it to a free GPIO in Configure Module page or use command GPIO<x> . Read more about peripherals . Tip GPIOs configured as User (1) are the GPIOs that can be assigned to components in the Configure Module page.","title":"Assigning Components"},{"location":"Components-old/#gpio-conversion","text":"Old GPIO New GPIO Name Description 255 1 User User 0 0 None Not used 1 1184 DHT11 DHT11 sensor 2 1216 AM2301 AM230X, DHT21 and DHT22 sensor 3 1248 SI7021 Only for Sonoff Si7021, not the i2c version 4 1312 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 608 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 640 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 1376 WS2812 Addressable LEDs such as WS281X or Neopixel 8 1056 IRsend IR Transmitter LED 9 160 Switch 1 Switch 10 161 Switch 2 Switch 11 162 Switch 3 Switch 12 163 Switch 4 Switch 13 164 Switch 5 Switch 14 165 Switch 6 Switch 15 166 Switch 7 Switch 16 167 Switch 8 Switch 17 32 Button 1 Button active low, internal pull-up resistor 18 33 Button 2 Button active low, internal pull-up resistor 19 34 Button 3 Button active low, internal pull-up resistor 20 35 Button 4 Button active low, internal pull-up resistor 21 224 Relay 1 Relay 22 225 Relay 2 Relay 23 226 Relay 3 Relay 24 227 Relay 4 Relay 25 228 Relay 5 Relay 26 229 Relay 6 Relay 27 230 Relay 7 Relay 28 231 Relay 8 Relay 29 256 Relay_i 1 Relay inverted 30 257 Relay_i 2 Relay inverted 31 258 Relay_i 3 Relay inverted 32 259 Relay_i 4 Relay inverted 33 260 Relay_i 5 Relay inverted 34 261 Relay_i 6 Relay inverted 35 262 Relay_i 7 Relay inverted 36 263 Relay_i 8 Relay inverted 37 416 PWM 1 Pulse Width Modulated Output 38 417 PWM 2 Pulse Width Modulated Output 39 418 PWM 3 Pulse Width Modulated Output 40 419 PWM 4 Pulse Width Modulated Output 41 420 PWM 5 Pulse Width Modulated Output 42 352 Counter 1 Counter Input 43 353 Counter 2 Counter Input 44 354 Counter 3 Counter Input 45 355 Counter 4 Counter Input 46 448 PWM_i 1 Pulse Width Modulated inverted Output 47 449 PWM_i 2 Pulse Width Modulated inverted Output 48 450 PWM_i 3 Pulse Width Modulated inverted Output 49 451 PWM_i 4 Pulse Width Modulated inverted Output 50 452 PWM_i 5 Pulse Width Modulated inverted Output 51 1088 IRrecv IR Receiver Input (for example TSOP1838) 52 288 Led 1 LED 53 289 Led 2 LED 54 290 Led 3 LED 55 291 Led 4 LED 56 320 Led_i 1 Inverted LED - default state ON 57 321 Led_i 2 Inverted LED - default state ON 58 322 Led_i 3 Inverted LED - default state ON 59 323 Led_i 4 Inverted LED - default state ON 60 1408 MHZ Rx MHZ 19 CO2 Sensor 61 1440 MHZ Tx MHZ 19 CO2 Sensor 62 1472 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 1504 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 1600 SAir Rx Sensor Senseair 65 1632 SAir Tx Sensor Senseair 66 768 SPI CS SPI Interface (ePaper Display) 67 800 SPI DC SPI Interface (ePaper Display) 68 992 BkLight Backlight (Display) 69 1696 PMS5003 PMS5003 Air Quality Sensor 70 1760 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 1792 SerBr Rx Serial Bridge Receive 72 1824 SerBr Tx Serial Bridge Transmit 73 1856 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 1888 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 1920 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 1952 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 1984 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 2016 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 2048 TM16 CLK TM1638 Switch Module 80 2080 TM16 DIO TM1638 Switch Module 81 2112 TM16 STB TM1638 Switch Module 82 192 Switch_n 1 Switch, no pull-up resistor 83 193 Switch_n 2 Switch, no pull-up resistor 84 194 Switch_n 3 Switch, no pull-up resistor 85 195 Switch_n 4 Switch, no pull-up resistor 86 196 Switch_n 5 Switch, no pull-up resistor 87 197 Switch_n 6 Switch, no pull-up resistor 88 198 Switch_n 7 Switch, no pull-up resistor 89 199 Switch_n 8 Switch, no pull-up resistor 90 64 Button_n 1 Button, active low, no internal pull-up resistor 91 65 Button_n 2 Button, active low, no internal pull-up resistor 92 66 Button_n 3 Button, active low, no internal pull-up resistor 93 67 Button_n 4 Button, active low, no internal pull-up resistor 94 384 Counter_n 1 Counter sensor, no pull-up resistor 95 385 Counter_n 2 Counter sensor, no pull-up resistor 96 386 Counter_n 3 Counter sensor, no pull-up resistor 97 387 Counter_n 4 Counter sensor, no pull-up resistor 98 1536 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 1568 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 2144 MP3 Player DF MP3 Player mini (Input) 101 1728 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 2176 HX711 SCK HX711 weight sensor serial clock input 103 2208 HX711 DAT HX711 weight sensor data output 104 2240 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 1120 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 1152 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 2272 Tuya Tx Tuya Transfer pin 108 2304 Tuya Rx Tuya Receive pin 109 2336 MGC3130 Xfr MGC3130 E-field Xfr pin 110 2368 MGC3130 Rst MGC3130 E-field Reset pin 111 832 SSPI MISO Software SPI MISO (Display) 112 864 SSPI MOSI Software SPI MOSI (Display) 113 896 SSPI SCLK Software SPI SCLK (Display) 114 928 SSPI CS Software SPI CS (Display) 115 960 SSPI DC Software SPI DC (Display) 116 2400 RF Sensor Theo Arendst RF433 Sensor 117 2432 AZ Rx AZ 7798 CO2 datalogger 118 2464 AZ Tx AZ 7798 CO2 datalogger 119 2496 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 2528 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 2560 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 96 Button_i 1 Button inverted, active high with internal pull-up resistor 123 97 Button_i 2 Button inverted, active high with internal pull-up resistor 124 98 Button_i 3 Button inverted, active high with internal pull-up resistor 125 99 Button_i 4 Button inverted, active high with internal pull-up resistor 126 128 Button_in 1 Button inverted, active high no internal pull-up resistor 127 129 Button_in 2 Button inverted, active high no internal pull-up resistor 128 130 Button_in 3 Button inverted, active high no internal pull-up resistor 129 131 Button_in 4 Button inverted, active high no internal pull-up resistor 130 2592 HLWBL SEL Energy Monitoring (for example Pow) 131 2624 HLWBL SELi Energy Monitoring (for example Pow) 132 2656 HLWBL CF1 Energy Monitoring (for example Pow) 133 2688 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 2720 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 2752 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 2784 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 2816 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 2848 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 2880 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 2912 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 2944 SM16716 DAT SM16716 Pixel LED Data pin 142 2976 SM16716 PWR SM16716 Pixel LED Power pin 143 3008 MY92x1 DI Light Bulb with MY92x controller 144 3040 MY92x1 DCKI Light Bulb with MY92x controller 145 3072 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 3104 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 3136 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 3200 Serial Tx Serial Transfer pin 149 3232 Serial Rx Serial Receive pin 150 3264 Rotary A 1 Rotary Encoder (Mi Desk Lamp) 151 3296 Rotary B 1 Rotary Encoder (Mi Desk Lamp) 152 3265 Rotary A 2 Rotary Encoder (Mi Desk Lamp) 153 3297 Rotary B 2 Rotary Encoder (Mi Desk Lamp) 154 3392 HRE CLOCK Clock/Power line for HR-E Water Meter 155 3424 HRE DATA Data line for HR-E Water Meter 156 3456 ADE7953_IRQ ADE7953 IRQ 157 544 LedLink Device Status LED 158 576 LedLinki Device Status LED, inverted 159 3168 ALux IrSel For AriLux devices - switches between IR/RF mode 160 480 Buzzer Sonoff iFan03 Buzzer 161 512 Buzzeri Sonoff iFan03 Buzzer inverted 162 1024 OLED Reset OLED Display Reset 163 3488 SolaxX1 Tx Solax Inverter Tx pin 164 3520 SolaxX1 Rx Solax Inverter Rx pin 165 3552 Zigbee Tx Zigbee Serial interface Tx 166 3584 Zigbee Rx Zigbee Serial interface Rx 167 3616 RDM6300 Rx RDM6300 RX 168 3648 iBeacon Tx HM17 iBeacon Tx 169 3680 iBeacon Rx HM17 iBeacon Rx 170 3712 A4988 DIR A4988 Motor Direction 171 3744 A4988 STP A4988 Step motor 172 3776 A4988 ENA A4988 Enable motor 173 3808 A4988 MS1 A4988 Microstep increment select pin1 174 3809 A4988 MS2 A4988 Microstep increment select pin2 175 3810 A4988 MS3 A4988 Microstep increment select pin3 176 3904 DDS238-2 Tx DDS2382 Serial interface Tx 177 3936 DDS238-2 Rx DDS2382 Serial interface Rx 178 3968 DDSU666 Tx DDSU666 Serial interface Tx 179 4000 DDSU666 Rx DDSU666 Serial interface Rx 180 4032 SM2135 CLK SM2135 Clk 181 4064 SM2135 DAT SM2135 Dat 182 4096 DeepSleep DeepSleep wake switch 183 4128 EXS Enable EXS Dimmer MCU Enable 184 4160 Client TX TasmotaClient TX 185 4192 Client RX TasmotaClient RX 186 4224 Client RST TasmotaClient Reset Pin 187 4256 Client RSTi TasmotaClient Reset Inverted 188 4288 HPMA RX Honeywell HPMA115S0 Serial Rx 189 4320 HPMA TX Honeywell HPMA115S0 Serial Tx 190 4352 GPS RX GPS Serial Tx 191 4384 GPS TX GPS Serial Tx 192 1344 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 1280 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 4416 HM10 RX HM10-BLE-Mijia-bridge Serial 195 4448 HM10 TX HM10-BLE-Mijia-bridge Serial 196 4480 LE01MR RX F&F LE-01MR Energy Meter Serial 197 4512 LE01MR TX F&F LE-01MR Energy Meter Serial 198 4544 CC1101 GDO0 CC1101 RX Pin 199 4576 CC1101 GDO2 CC1101 TX Pin 200 4608 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 4640 MOODL TX ElectriQ iQ-wifiMOODL Serial TX 202 4672 AS3935 Lightning Detector Interrupt Pin 203 1664 PMS5003 TX Plantower PMS5003 Serial interface 204 4928 Boiler OT Rx OpenTherm Boiler RX pin 205 4960 Boiler OT Tx OpenTherm Boiler TX pin 206 4992 Windmeter Speed WindMeter speed counter pin 207 5056 BL0940 RX BL0940 serial interface 208 5088 TCP TX TCP Serial bridge 209 5120 TCP RX TCP Serial bridge 210 5152 TELEINFO RX Teleinfo serial interface 211 5184 TELEINFO Enable Teleinfo Enable PIN 212 5216 LMT01 LMT01 input counting pin 213 5248 IEM3000 TX IEM3000 Serial interface 214 5280 IEM3000 RX IEM3000 Serial interface 215 5312 Zigbee RST Zigbee reset 216 5344 DYP Rx DYP-ME007 Rx pin 5728 Option a 1 Enable PWM2 high impedance if powered off as used by Wyze bulbs 5729 Option a 2 Enable dummy energy monitor 5730 Option a 3 Enable UDisplay universal display driver Rotary A_n Rotary Encoder Rotary B_n Rotary Encoder Button_d 1 Button, active low with internal pull-down resistor Button_d 2 Button, active low with internal pull-down resistor Button_d 3 Button, active low with internal pull-down resistor Button_d 4 Button, active low with internal pull-down resistor Button_id 1 Button inverted, active high with internal pull-down resistor Button_id 2 Button inverted, active high with internal pull-down resistor Button_id 3 Button inverted, active high with internal pull-down resistor Button_id 4 Button inverted, active high with internal pull-down resistor Switch_d 1 Switch, with pull-down resistor Switch_d 2 Switch, with pull-down resistor Switch_d 3 Switch, with pull-down resistor Switch_d 4 Switch, with pull-down resistor Switch_d 5 Switch, with pull-down resistor Switch_d 6 Switch, with pull-down resistor Switch_d 7 Switch, with pull-down resistor Switch_d 8 Switch, with pull-down resistor","title":"GPIO Conversion"},{"location":"Components-old/#adc-conversion","text":"Old ADC New ADC Option WebUI display MQTT mesage 0 0 None none none 1 4704 Analog Analog0 %value% {\"A0\":%value%} 2 4736 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 4768 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 4800 Button none none 5 4832 Buttoni none none 6 4864 Range Range %value% {\"Range\":%value%} 7 4896 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\": %value ,\"Power\": %value ,\"Voltage\":230,\"Current\": %value } 8 3328 Joystick none {\"ANALOG\":{\"Joy1\":%value%}","title":"ADC Conversion"},{"location":"Components/","text":"Component is anything wired to the ESP8266/ESP8285 chip to be controlled by or send data to it. Components can be: buttons, switches, relays, LEDs, sensors, displays, MCU units, etc. Every component is assigned in the device template to the GPIO it is wired (connected) to. Every Tasmota device has some components configured by default. Most often there is a relay, a button and a LED configured as is the case for a Sonoff Basic in the following image. Bug Tasmota 9.1 completely redesigned GPIO mapping to allow for future expansion. Read more about the GPIO Conversion Assigning Components ~ If you wish to expand a device with a peripheral component, after properly wiring everything, you need to assign it to a free GPIO in Configure Module page or use command GPIO<x> . Read more about peripherals . Tip GPIOs configured as User (1) are the GPIOs that can be assigned to components in the Configure Module page. GPIO Overview ~ Tasmota ~ # UI Label Comment 0 None Not used 32 Button1 Button active low, internal pull-up resistor 33 Button2 Button active low, internal pull-up resistor 34 Button3 Button active low, internal pull-up resistor 35 Button4 Button active low, internal pull-up resistor 36 Button5 Button active low, internal pull-up resistor 37 Button6 Button active low, internal pull-up resistor 38 Button7 Button active low, internal pull-up resistor 39 Button8 Button active low, internal pull-up resistor 64 Button_n1 Button active low, no internal pull-up resistor 65 Button_n2 Button active low, no internal pull-up resistor 66 Button_n3 Button active low, no internal pull-up resistor 67 Button_n4 Button active low, no internal pull-up resistor 68 Button_n5 Button active low, no internal pull-up resistor 69 Button_n6 Button active low, no internal pull-up resistor 70 Button_n7 Button active low, no internal pull-up resistor 71 Button_n8 Button active low, no internal pull-up resistor 96 Button_i1 Button inverted, active high with internal pull-up resistor 97 Button_i2 Button inverted, active high with internal pull-up resistor 98 Button_i3 Button inverted, active high with internal pull-up resistor 99 Button_i4 Button inverted, active high with internal pull-up resistor 100 Button_i5 Button inverted, active high with internal pull-up resistor 101 Button_i6 Button inverted, active high with internal pull-up resistor 102 Button_i7 Button inverted, active high with internal pull-up resistor 103 Button_i8 Button inverted, active high with internal pull-up resistor 128 Button_in1 Button inverted, active high no internal pull-up resistor 129 Button_in2 Button inverted, active high no internal pull-up resistor 130 Button_in3 Button inverted, active high no internal pull-up resistor 131 Button_in4 Button inverted, active high no internal pull-up resistor 132 Button_in5 Button inverted, active high no internal pull-up resistor 133 Button_in6 Button inverted, active high no internal pull-up resistor 134 Button_in7 Button inverted, active high no internal pull-up resistor 135 Button_in8 Button inverted, active high no internal pull-up resistor 160 Switch1 Switch, internal pull-up resistor 161 Switch2 Switch, internal pull-up resistor 162 Switch3 Switch, internal pull-up resistor 163 Switch4 Switch, internal pull-up resistor 164 Switch5 Switch, internal pull-up resistor 165 Switch6 Switch, internal pull-up resistor 166 Switch7 Switch, internal pull-up resistor 167 Switch8 Switch, internal pull-up resistor 192 Switch_n1 Switch, no pull-up resistor 193 Switch_n2 Switch, no pull-up resistor 194 Switch_n3 Switch, no pull-up resistor 195 Switch_n4 Switch, no pull-up resistor 196 Switch_n5 Switch, no pull-up resistor 197 Switch_n6 Switch, no pull-up resistor 198 Switch_n7 Switch, no pull-up resistor 199 Switch_n8 Switch, no pull-up resistor 224 Relay1 Relay 225 Relay2 Relay 226 Relay3 Relay 227 Relay4 Relay 228 Relay5 Relay 229 Relay6 Relay 230 Relay7 Relay 231 Relay8 Relay 255 User User pin 256 Relay_i1 Relay inverted 257 Relay_i2 Relay inverted 258 Relay_i3 Relay inverted 259 Relay_i4 Relay inverted 260 Relay_i5 Relay inverted 261 Relay_i6 Relay inverted 262 Relay_i7 Relay inverted 263 Relay_i8 Relay inverted 288 Led1 4 x Leds 289 Led2 4 x Leds 290 Led3 4 x Leds 291 Led4 4 x Leds 320 Led_i1 4 x Leds 321 Led_i2 4 x Leds 322 Led_i3 4 x Leds 323 Led_i4 4 x Leds 352 Counter1 4 x Counter 353 Counter2 4 x Counter 354 Counter3 4 x Counter 355 Counter4 4 x Counter 384 Counter_n1 4 x Counter 385 Counter_n2 4 x Counter 386 Counter_n3 4 x Counter 387 Counter_n4 4 x Counter 416 PWM1 5 x PWM 417 PWM2 5 x PWM 418 PWM3 5 x PWM 419 PWM4 5 x PWM 420 PWM5 5 x PWM 448 PWM_i1 5 x PWM 449 PWM_i2 5 x PWM 450 PWM_i3 5 x PWM 451 PWM_i4 5 x PWM 452 PWM_i5 5 x PWM 480 Buzzer Buzzer 512 Buzzer_i Buzzer 544 LedLink Link led 576 LedLink_i Link led 608 I2C SCL1 Software I2C 640 I2C SDA1 Software I2C 672 SPI MISO1 Hardware SPI 704 SPI MOSI1 Hardware SPI 736 SPI CLK1 Hardware SPI 768 SPI CS1 Hardware SPI 800 SPI DC1 Hardware SPI 832 SSPI MISO Software SPI 864 SSPI MOSI Software SPI 896 SSPI SCLK Software SPI 928 SSPI CS Software SPI 960 SSPI DC Software SPI 992 Backlight Display backlight control 1024 Display Rst OLED Display Reset 1056 IRsend IR interface 1088 IRrecv IR interface 1120 RFSend RF interface 1152 RFrecv RF interface 1184 DHT11 DHT11 1216 AM2301 DHT21 DHT22 AM2301 AM2302 AM2321 1248 SI7021 SI7021 1280 DHT11_o DHT11 1312 DS18x20 DS18B20 or DS18S20 1344 DS18x20_o DS18B20 or DS18S20 1376 WS2812 WS2812 Led string 1408 MHZ Tx MH-Z19 Serial interface 1440 MHZ Rx MH-Z19 Serial interface 1472 PZEM0XX Tx PZEM Serial Modbus interface 1504 PZEM004 Rx PZEM Serial Modbus interface 1536 PZEM016 Rx PZEM Serial Modbus interface 1568 PZEM017 Rx PZEM Serial Modbus interface 1600 SAir Tx SenseAir Serial interface 1632 SAir Rx SenseAir Serial interface 1664 PMS5003 Tx Plantower PMS5003 Serial interface 1696 PMS5003 Rx Plantower PMS5003 Serial interface 1728 SDS0X1 Tx Nova Fitness SDS011 Serial interface 1760 SDS0X1 Rx Nova Fitness SDS011 Serial interface 1792 SerBr Tx Serial Bridge Serial interface 1824 SerBr Rx Serial Bridge Serial interface 1856 SR04 Tri/TX SR04 interface 1888 SR04 Ech/RX SR04 interface 1920 SDMx20 Tx SDM120 Serial interface 1952 SDMx20 Rx SDM120 Serial interface 1984 SDM630 Tx SDM630 Serial interface 2016 SDM630 Rx SDM630 Serial interface 2048 TM1638 CLK TM1638 interface 2080 TM1638 DIO TM1638 interface 2112 TM1638 STB TM1638 interface 2144 MP3 Player RB-DFR-562 DFPlayer Mini MP3 Player 2176 HX711 SCK HX711 Load Cell interface 2208 HX711 DAT HX711 Load Cell interface 2240 TX2x TX20/TX23 Transmission Pin 2272 Tuya Tx Tuya Serial interface 2304 Tuya Rx Tuya Serial interface 2336 MGC3130 Xfr MGC3130 interface 2368 MGC3130 Rst MGC3130 interface 2400 RF Sensor Rf receiver with sensor decoding 2432 AZ Tx AZ-Instrument 7798 Serial interface 2464 AZ Rx AZ-Instrument 7798 Serial interface 2496 MX31855 CS MAX31855 Serial interface 2528 MX31855 CLK MAX31855 Serial interface 2560 MX31855 DO MAX31855 Serial interface 2592 HLWBL SEL HLW8012/HJL-01/BL0937 energy monitoring 2624 HLWBL SEL_i HLW8012/HJL-01/BL0937 energy monitoring 2656 HLWBL CF1 HLW8012/HJL-01/BL0937 energy monitoring 2688 HLW8012 CF HLW8012/HJL-01/BL0937 energy monitoring 2720 BL0937 CF HLW8012/HJL-01/BL0937 energy monitoring 2752 MCP39F5 Tx MCP39F501 Energy monitoring (Shelly2) 2784 MCP39F5 Rx MCP39F501 Energy monitoring (Shelly2) 2816 MCP39F5 Rst MCP39F501 Energy monitoring (Shelly2) 2848 PN532 Tx PN532 NFC Serial interface 2880 PN532 Rx PN532 NFC Serial interface 2912 SM16716 CLK SM16716 SELECT 2944 SM16716 DAT SM16716 SELECT 2976 SM16716 PWR SM16716 SELECT 3008 MY92x1 DI my92x1 PWM controller 3040 MY92x1 DCKI my92x1 PWM controller 3072 CSE7766 Tx CSE7766 Serial interface (S31 and Pow R2) 3104 CSE7766 Rx CSE7766 Serial interface (S31 and Pow R2) 3136 ALux IrRcv Arilux RF Receive input 3168 ALux IrSel Arilux RF Receive input 3200 Serial Tx Serial interface 3232 Serial Rx Serial interface 3264 RotaryA1 Rotary switch 3265 RotaryA2 Rotary switch 3296 RotaryB1 Rotary switch 3297 RotaryB2 Rotary switch 3328 ADC Joystick Analog joystick 3360 MX31865 CS1 MAX31865 Chip Select 3361 MX31865 CS2 MAX31865 Chip Select 3362 MX31865 CS3 MAX31865 Chip Select 3363 MX31865 CS4 MAX31865 Chip Select 3364 MX31865 CS5 MAX31865 Chip Select 3365 MX31865 CS6 MAX31865 Chip Select 3392 HRE Clock HR-E Water Meter 3424 HRE Data HR-E Water Meter 3456 ADE7953 IRQ1 ADE7953 IRQ 3457 ADE7953 IRQ2 ADE7953 IRQ 3488 SolaxX1 Tx Solax Inverter Serial interface 3520 SolaxX1 Rx Solax Inverter Serial interface 3552 Zigbee Tx Zigbee Serial interface 3584 Zigbee Rx Zigbee Serial interface 3616 RDM6300 RX RDM6300 RX 3648 iBeacon TX HM17 IBEACON Serial interface 3680 iBeacon RX HM17 IBEACON Serial interface 3712 A4988 DIR A4988 interface 3744 A4988 STP A4988 interface 3776 A4988 ENA A4988 interface 3808 A4988 MS11 A4988 interface 3809 A4988 MS12 A4988 interface 3810 A4988 MS13 A4988 interface 3840 Output Hi Fixed output state 3872 Output Lo Fixed output state 3904 DDS238-2 Tx DDS2382 Serial interface 3936 DDS238-2 Rx DDS2382 Serial interface 3968 DDSU666 Tx DDSU666 Serial interface 4000 DDSU666 Rx DDSU666 Serial interface 4032 SM2135 Clk SM2135 PWM controller 4064 SM2135 Dat1 SM2135 PWM controller 4065 SM2135 Dat2 SM2135 PWM controller 4066 SM2135 Dat3 SM2135 PWM controller 4067 SM2135 Dat4 SM2135 PWM controller 4068 SM2135 Dat5 SM2135 PWM controller 4069 SM2135 Dat6 SM2135 PWM controller 4070 SM2135 Dat7 SM2135 PWM controller 4096 DeepSleep Kill switch for deepsleep 4128 EXS Enable EXS MCU Enable 4160 Client TX Client Serial interface 4192 Client RX Client Serial interface 4224 Client RST Client Reset 4256 Client RST_i Client Reset 4288 HPMA Rx Honeywell HPMA115S0 Serial interface 4320 HPMA Tx Honeywell HPMA115S0 Serial interface 4352 GPS RX GPS Serial interface 4384 GPS TX GPS Serial interface 4416 HM10 RX HM10-BLE-Mijia-bridge Serial interface 4448 HM10 TX HM10-BLE-Mijia-bridge Serial interface 4480 LE-01MR Rx F&F LE-01MR energy meter 4512 LE-01MR Tx F&F LE-01MR energy meter 4544 CC1101 GDO0 CC1101 Serial interface 4576 CC1101 GDO2 CC1101 Serial interface 4608 HRXL Rx Data from MaxBotix HRXL sonar range sensor 4640 MOODL Tx ElectriQ iQ-wifiMOODL Serial TX 4672 AS3935 Franklin Lightning Sensor 4704 ADC Input Analog input 4736 ADC Temp Analog Thermistor 4768 ADC Light Analog Light sensor 4800 ADC Button Analog Button 4832 ADC Button_i Analog Button 4864 ADC Range Analog Range 4896 ADC CT Power ANalog Current 4928 OpenTherm RX OpenTherm Boiler TX pin 4960 OpenTherm TX OpenTherm Boiler TX pin 4992 WindMeter Spd WindMeter speed counter pin 5024 Button_tc Touch pin as button 5056 BL0940 Rx BL0940 serial interface 5088 TCP Tx TCP to serial bridge 5120 TCP Rx TCP to serial bridge 5152 TInfo Rx Teleinfo telemetry data receive pin 5184 TInfo EN Teleinfo Enable Receive Pin 5216 LMT01 Pulse LMT01 input counting pin 5248 iEM3000 TX IEM3000 Serial interface 5280 iEM3000 RX IEM3000 Serial interface 5312 Zigbee Rst1 Zigbee reset 5313 Zigbee Rst2 Zigbee reset 5344 DYP Rx 5376 MiEl HVAC Tx Mitsubishi Electric HVAC 5408 MiEl HVAC Rx Mitsubishi Electric HVAC 5440 WE517 Tx ORNO WE517 Serial interface 5472 WE517 Rx ORNO WE517 Serial interface 5504 AS608 Tx Serial interface AS608 / R503 5536 AS608 Rx Serial interface AS608 / R503 5568 SHD Boot 0 5600 SHD Reset 5632 RC522 Rst RC522 reset 5664 P9813 Clk P9813 Clock and Data 5696 P9813 Dat P9813 Clock and Data 5728 OptionA1 Specific device options to be served in code 5729 OptionA2 Specific device options to be served in code 5730 OptionA3 Specific device options to be served in code 5731 OptionA4 Specific device options to be served in code 5732 OptionA5 Specific device options to be served in code 5733 OptionA6 Specific device options to be served in code 5760 FTC532 FTC532 touch ctrlr serial input 5792 RC522 CS 5824 NRF24 CS 5856 NRF24 DC 5888 ILI9341 CS 5920 ILI9341 DC 5952 ILI9488 CS 5984 EPaper29 CS 6016 EPaper42 CS 6048 SSD1351 CS 6080 RA8876 CS 6112 ST7789 CS 6144 ST7789 DC 6176 SSD1331 CS 6208 SSD1331 DC 6240 SDCard CS 6272 RotaryA_n1 Rotary switch 6273 RotaryA_n2 Rotary switch 6304 RotaryB_n1 Rotary switch 6305 RotaryB_n2 Rotary switch 6336 ADC pH Analog PH Sensor 6368 BS814 CLK Holtek BS814A2 touch ctrlr 6400 BS814 DAT Holtek BS814A2 touch ctrlr 6432 Wiegand D0 Wiegand Data lines 6464 Wiegand D1 Wiegand Data lines 6496 NeoPool Tx Sugar Valley RS485 interface 6528 NeoPool Rx Sugar Valley RS485 interface 6560 SDM72 Tx SDM72 Serial interface 6592 SDM72 Rx SDM72 Serial interface 6624 TM1637 CLK TM1637 interface 6656 TM1637 DIO TM1637 interface 6688 DLP Tx LCD/DLP Projector Serial Control 6720 DLP Rx LCD/DLP Projector Serial Control 6752 SSD1351 DC 6784 XPT2046 CS XPT2046 SPI Chip Select 6816 CSE7761 Tx CSE7761 Serial interface (Dual R3) 6848 CSE7761 Rx CSE7761 Serial interface (Dual R3) 6880 VL53LXX XSHUT1 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6881 VL53LXX XSHUT2 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6882 VL53LXX XSHUT3 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6883 VL53LXX XSHUT4 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6884 VL53LXX XSHUT5 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6885 VL53LXX XSHUT6 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6886 VL53LXX XSHUT7 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6887 VL53LXX XSHUT8 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6912 MAX7219 CLK MAX7219 interface 6944 MAX7219 DIN MAX7219 interface 6976 MAX7219 CS MAX7219 interface 7008 TFmini+ TX TFmini Plus ToF sensor 7040 TFmini+ RX TFmini Plus ToF sensor 7072 ZC Pulse 7104 Input1 7105 Input2 7106 Input3 7107 Input4 7108 Input5 7109 Input6 7110 Input7 7111 Input8 7136 I2S Out Data1 7168 I2S Out Clk1 7200 I2S Out Slct1 7232 I2S In Data1 7264 I2S In Clk1 7296 I2S In Slct1 7328 Interrupt1 7329 Interrupt2 7330 Interrupt3 7331 Interrupt4 7332 Interrupt5 7333 Interrupt6 7334 Interrupt7 7335 Interrupt8 7360 MCP2515 CS MCP2515 Chip Select 7392 HRG15 Tx Hydreon RG-15 rain sensor serial interface 7424 HRG15 Rx Hydreon RG-15 rain sensor serial interface 7456 VINDRIKTNING IKEA VINDRIKTNING Serial interface 7488 BL0939 Rx BL0939 Serial interface (Dual R3 v2) 7520 BL0942 Rx BL0942 Serial interface 7552 HM330X SET HM330X SET pin (sleep when low) 7584 Heartbeat 7616 Heartbeat_i 7648 74x595 SRCLK 74x595 Shift register 7680 74x595 RCLK 74x595 Shift register 7712 74x595 OE 74x595 Shift register 7744 74x595 SER 74x595 Shift register 7776 SolaxX1 RTS Solax Inverter Serial interface 7808 OptionE Emulated module 7840 SDM230 Tx SDM230 Serial interface 7872 SDM230 Rx SDM230 Serial interface 7904 ADC MQ Analog MQ Sensor 7936 CM110x TX CM11 Serial interface 7968 CM110x RX CM11 Serial interface 8000 BL6523 Tx BL6523 based Watt meter Serial interface 8032 BL6523 Rx BL6523 based Watt meter Serial interface 8064 ADE7880 IRQ1 ADE7880 IRQ 8065 ADE7880 IRQ2 ADE7880 IRQ 8096 Reset Generic reset 8128 MS01 Sonoff MS01 Moisture Sensor 1wire interface 8160 SDIO CMD SD Card SDIO interface including 1-bit and 4-bit modes 8192 SDIO CLK SD Card SDIO interface including 1-bit and 4-bit modes 8224 SDIO D0 SD Card SDIO interface including 1-bit and 4-bit modes 8256 SDIO D1 SD Card SDIO interface including 1-bit and 4-bit modes 8288 SDIO D2 SD Card SDIO interface including 1-bit and 4-bit modes 8320 SDIO D3 SD Card SDIO interface including 1-bit and 4-bit modes Tasmota32 ~ # UI Label Comment 0 None Not used 1 User User pin 32 Button1 4 x Button 33 Button2 4 x Button 34 Button3 4 x Button 35 Button4 4 x Button 36 Button5 4 x Button 37 Button6 4 x Button 38 Button7 4 x Button 39 Button8 4 x Button 64 Button_n1 4 x Button 65 Button_n2 4 x Button 66 Button_n3 4 x Button 67 Button_n4 4 x Button 68 Button_n5 4 x Button 69 Button_n6 4 x Button 70 Button_n7 4 x Button 71 Button_n8 4 x Button 96 Button_i1 4 x Button 97 Button_i2 4 x Button 98 Button_i3 4 x Button 99 Button_i4 4 x Button 100 Button_i5 4 x Button 101 Button_i6 4 x Button 102 Button_i7 4 x Button 103 Button_i8 4 x Button 128 Button_in1 4 x Button 129 Button_in2 4 x Button 130 Button_in3 4 x Button 131 Button_in4 4 x Button 132 Button_in5 4 x Button 133 Button_in6 4 x Button 134 Button_in7 4 x Button 135 Button_in8 4 x Button 160 Switch1 8 x User connected external switches 161 Switch2 8 x User connected external switches 162 Switch3 8 x User connected external switches 163 Switch4 8 x User connected external switches 164 Switch5 8 x User connected external switches 165 Switch6 8 x User connected external switches 166 Switch7 8 x User connected external switches 167 Switch8 8 x User connected external switches 168 Switch9 8 x User connected external switches 169 Switch10 8 x User connected external switches 170 Switch11 8 x User connected external switches 171 Switch12 8 x User connected external switches 172 Switch13 8 x User connected external switches 173 Switch14 8 x User connected external switches 174 Switch15 8 x User connected external switches 175 Switch16 8 x User connected external switches 176 Switch17 8 x User connected external switches 177 Switch18 8 x User connected external switches 178 Switch19 8 x User connected external switches 179 Switch20 8 x User connected external switches 180 Switch21 8 x User connected external switches 181 Switch22 8 x User connected external switches 182 Switch23 8 x User connected external switches 183 Switch24 8 x User connected external switches 184 Switch25 8 x User connected external switches 185 Switch26 8 x User connected external switches 186 Switch27 8 x User connected external switches 187 Switch28 8 x User connected external switches 192 Switch_n1 8 x User connected external switches 193 Switch_n2 8 x User connected external switches 194 Switch_n3 8 x User connected external switches 195 Switch_n4 8 x User connected external switches 196 Switch_n5 8 x User connected external switches 197 Switch_n6 8 x User connected external switches 198 Switch_n7 8 x User connected external switches 199 Switch_n8 8 x User connected external switches 200 Switch_n9 8 x User connected external switches 201 Switch_n10 8 x User connected external switches 202 Switch_n11 8 x User connected external switches 203 Switch_n12 8 x User connected external switches 204 Switch_n13 8 x User connected external switches 205 Switch_n14 8 x User connected external switches 206 Switch_n15 8 x User connected external switches 207 Switch_n16 8 x User connected external switches 208 Switch_n17 8 x User connected external switches 209 Switch_n18 8 x User connected external switches 210 Switch_n19 8 x User connected external switches 211 Switch_n20 8 x User connected external switches 212 Switch_n21 8 x User connected external switches 213 Switch_n22 8 x User connected external switches 214 Switch_n23 8 x User connected external switches 215 Switch_n24 8 x User connected external switches 216 Switch_n25 8 x User connected external switches 217 Switch_n26 8 x User connected external switches 218 Switch_n27 8 x User connected external switches 219 Switch_n28 8 x User connected external switches 224 Relay1 8 x Relays 225 Relay2 8 x Relays 226 Relay3 8 x Relays 227 Relay4 8 x Relays 228 Relay5 8 x Relays 229 Relay6 8 x Relays 230 Relay7 8 x Relays 231 Relay8 8 x Relays 232 Relay9 8 x Relays 233 Relay10 8 x Relays 234 Relay11 8 x Relays 235 Relay12 8 x Relays 236 Relay13 8 x Relays 237 Relay14 8 x Relays 238 Relay15 8 x Relays 239 Relay16 8 x Relays 240 Relay17 8 x Relays 241 Relay18 8 x Relays 242 Relay19 8 x Relays 243 Relay20 8 x Relays 244 Relay21 8 x Relays 245 Relay22 8 x Relays 246 Relay23 8 x Relays 247 Relay24 8 x Relays 248 Relay25 8 x Relays 249 Relay26 8 x Relays 250 Relay27 8 x Relays 251 Relay28 8 x Relays 256 Relay_i1 8 x Relays 257 Relay_i2 8 x Relays 258 Relay_i3 8 x Relays 259 Relay_i4 8 x Relays 260 Relay_i5 8 x Relays 261 Relay_i6 8 x Relays 262 Relay_i7 8 x Relays 263 Relay_i8 8 x Relays 264 Relay_i9 8 x Relays 265 Relay_i10 8 x Relays 266 Relay_i11 8 x Relays 267 Relay_i12 8 x Relays 268 Relay_i13 8 x Relays 269 Relay_i14 8 x Relays 270 Relay_i15 8 x Relays 271 Relay_i16 8 x Relays 272 Relay_i17 8 x Relays 273 Relay_i18 8 x Relays 274 Relay_i19 8 x Relays 275 Relay_i20 8 x Relays 276 Relay_i21 8 x Relays 277 Relay_i22 8 x Relays 278 Relay_i23 8 x Relays 279 Relay_i24 8 x Relays 280 Relay_i25 8 x Relays 281 Relay_i26 8 x Relays 282 Relay_i27 8 x Relays 283 Relay_i28 8 x Relays 288 Led1 4 x Leds 289 Led2 4 x Leds 290 Led3 4 x Leds 291 Led4 4 x Leds 320 Led_i1 4 x Leds 321 Led_i2 4 x Leds 322 Led_i3 4 x Leds 323 Led_i4 4 x Leds 352 Counter1 4 x Counter 353 Counter2 4 x Counter 354 Counter3 4 x Counter 355 Counter4 4 x Counter 384 Counter_n1 4 x Counter 385 Counter_n2 4 x Counter 386 Counter_n3 4 x Counter 387 Counter_n4 4 x Counter 416 PWM1 5 x PWM 417 PWM2 5 x PWM 418 PWM3 5 x PWM 419 PWM4 5 x PWM 420 PWM5 5 x PWM 448 PWM_i1 5 x PWM 449 PWM_i2 5 x PWM 450 PWM_i3 5 x PWM 451 PWM_i4 5 x PWM 452 PWM_i5 5 x PWM 480 Buzzer Buzzer 512 Buzzer_i Buzzer 544 LedLink Link led 576 LedLink_i Link led 608 I2C SCL1 Software I2C 609 I2C SCL2 Software I2C 640 I2C SDA1 Software I2C 641 I2C SDA2 Software I2C 672 SPI MISO1 Hardware SPI 673 SPI MISO2 Hardware SPI 704 SPI MOSI1 Hardware SPI 705 SPI MOSI2 Hardware SPI 736 SPI CLK1 Hardware SPI 737 SPI CLK2 Hardware SPI 768 SPI CS1 Hardware SPI 769 SPI CS2 Hardware SPI 800 SPI DC1 Hardware SPI 801 SPI DC2 Hardware SPI 832 SSPI MISO Software SPI 864 SSPI MOSI Software SPI 896 SSPI SCLK Software SPI 928 SSPI CS Software SPI 960 SSPI DC Software SPI 992 Backlight Display backlight control 1024 Display Rst OLED Display Reset 1056 IRsend IR interface 1088 IRrecv IR interface 1120 RFSend RF interface 1152 RFrecv RF interface 1184 DHT11 DHT11 DHT21 DHT22 AM2301 AM2302 AM2321 1216 AM2301 DHT11 DHT21 DHT22 AM2301 AM2302 AM2321 1248 SI7021 DHT11 DHT21 DHT22 AM2301 AM2302 AM2321 1280 DHT11_o DHT11 DHT21 DHT22 AM2301 AM2302 AM2321 1312 DS18x20 DS18B20 or DS18S20 1344 DS18x20_o DS18B20 or DS18S20 1376 WS2812 WS2812 Led string 1408 MHZ Tx MH-Z19 Serial interface 1440 MHZ Rx MH-Z19 Serial interface 1472 PZEM0XX Tx PZEM Serial Modbus interface 1504 PZEM004 Rx PZEM Serial Modbus interface 1536 PZEM016 Rx PZEM Serial Modbus interface 1568 PZEM017 Rx PZEM Serial Modbus interface 1600 SAir Tx SenseAir Serial interface 1632 SAir Rx SenseAir Serial interface 1664 PMS5003 Tx Plantower PMS5003 Serial interface 1696 PMS5003 Rx Plantower PMS5003 Serial interface 1728 SDS0X1 Tx Nova Fitness SDS011 Serial interface 1760 SDS0X1 Rx Nova Fitness SDS011 Serial interface 1792 SerBr Tx Serial Bridge Serial interface 1824 SerBr Rx Serial Bridge Serial interface 1856 SR04 Tri/TX SR04 interface 1888 SR04 Ech/RX SR04 interface 1920 SDMx20 Tx SDM120 Serial interface 1952 SDMx20 Rx SDM120 Serial interface 1984 SDM630 Tx SDM630 Serial interface 2016 SDM630 Rx SDM630 Serial interface 2048 TM1638 CLK TM1638 interface 2080 TM1638 DIO TM1638 interface 2112 TM1638 STB TM1638 interface 2144 MP3 Player RB-DFR-562 DFPlayer Mini MP3 Player 2176 HX711 SCK HX711 Load Cell interface 2208 HX711 DAT HX711 Load Cell interface 2240 TX2x TX20/TX23 Transmission Pin 2272 Tuya Tx Tuya Serial interface 2304 Tuya Rx Tuya Serial interface 2336 MGC3130 Xfr MGC3130 interface 2368 MGC3130 Rst MGC3130 interface 2400 RF Sensor Rf receiver with sensor decoding 2432 AZ Tx AZ-Instrument 7798 Serial interface 2464 AZ Rx AZ-Instrument 7798 Serial interface 2496 MX31855 CS MAX31855 Serial interface 2528 MX31855 CLK MAX31855 Serial interface 2560 MX31855 DO MAX31855 Serial interface 2592 HLWBL SEL HLW8012/HJL-01/BL0937 energy monitoring 2624 HLWBL SEL_i HLW8012/HJL-01/BL0937 energy monitoring 2656 HLWBL CF1 HLW8012/HJL-01/BL0937 energy monitoring 2688 HLW8012 CF HLW8012/HJL-01/BL0937 energy monitoring 2720 BL0937 CF HLW8012/HJL-01/BL0937 energy monitoring 2752 MCP39F5 Tx MCP39F501 Energy monitoring (Shelly2) 2784 MCP39F5 Rx MCP39F501 Energy monitoring (Shelly2) 2816 MCP39F5 Rst MCP39F501 Energy monitoring (Shelly2) 2848 PN532 Tx PN532 NFC Serial interface 2880 PN532 Rx PN532 NFC Serial interface 2912 SM16716 CLK SM16716 SELECT 2944 SM16716 DAT SM16716 SELECT 2976 SM16716 PWR SM16716 SELECT 3008 MY92x1 DI my92x1 PWM controller 3040 MY92x1 DCKI my92x1 PWM controller 3072 CSE7766 Tx CSE7766 Serial interface (S31 and Pow R2) 3104 CSE7766 Rx CSE7766 Serial interface (S31 and Pow R2) 3136 ALux IrRcv Arilux RF Receive input 3168 ALux IrSel Arilux RF Receive input 3200 Serial Tx Serial interface 3232 Serial Rx Serial interface 3264 RotaryA1 Rotary switch 3265 RotaryA2 Rotary switch 3296 RotaryB1 Rotary switch 3297 RotaryB2 Rotary switch 3328 ADC Joystick1 Analog joystick 3329 ADC Joystick2 Analog joystick 3330 ADC Joystick3 Analog joystick 3331 ADC Joystick4 Analog joystick 3332 ADC Joystick5 Analog joystick 3333 ADC Joystick6 Analog joystick 3334 ADC Joystick7 Analog joystick 3335 ADC Joystick8 Analog joystick 3360 MX31865 CS1 MAX31865 Chip Select 3361 MX31865 CS2 MAX31865 Chip Select 3362 MX31865 CS3 MAX31865 Chip Select 3363 MX31865 CS4 MAX31865 Chip Select 3364 MX31865 CS5 MAX31865 Chip Select 3365 MX31865 CS6 MAX31865 Chip Select 3392 HRE Clock HR-E Water Meter 3424 HRE Data HR-E Water Meter 3456 ADE7953 IRQ1 ADE7953 IRQ 3457 ADE7953 IRQ2 ADE7953 IRQ 3488 SolaxX1 Tx Solax Inverter Serial interface 3520 SolaxX1 Rx Solax Inverter Serial interface 3552 Zigbee Tx Zigbee Serial interface 3584 Zigbee Rx Zigbee Serial interface 3616 RDM6300 RX RDM6300 RX 3648 iBeacon TX HM17 IBEACON Serial interface 3680 iBeacon RX HM17 IBEACON Serial interface 3712 A4988 DIR A4988 interface 3744 A4988 STP A4988 interface 3776 A4988 ENA A4988 interface 3808 A4988 MS11 A4988 interface 3809 A4988 MS12 A4988 interface 3810 A4988 MS13 A4988 interface 3840 Output Hi Fixed output state 3872 Output Lo Fixed output state 3904 DDS238-2 Tx DDS2382 Serial interface 3936 DDS238-2 Rx DDS2382 Serial interface 3968 DDSU666 Tx DDSU666 Serial interface 4000 DDSU666 Rx DDSU666 Serial interface 4032 SM2135 Clk SM2135 PWM controller 4064 SM2135 Dat1 SM2135 PWM controller 4065 SM2135 Dat2 SM2135 PWM controller 4066 SM2135 Dat3 SM2135 PWM controller 4067 SM2135 Dat4 SM2135 PWM controller 4068 SM2135 Dat5 SM2135 PWM controller 4069 SM2135 Dat6 SM2135 PWM controller 4070 SM2135 Dat7 SM2135 PWM controller 4096 DeepSleep Kill switch for deepsleep 4128 EXS Enable EXS MCU Enable 4160 Client TX Client Serial interface 4192 Client RX Client Serial interface 4224 Client RST Client Reset 4256 Client RST_i Client Reset 4288 HPMA Rx Honeywell HPMA115S0 Serial interface 4320 HPMA Tx Honeywell HPMA115S0 Serial interface 4352 GPS RX GPS Serial interface 4384 GPS TX GPS Serial interface 4416 HM10 RX HM10-BLE-Mijia-bridge Serial interface 4448 HM10 TX HM10-BLE-Mijia-bridge Serial interface 4480 LE-01MR Rx F&F LE-01MR energy meter 4512 LE-01MR Tx F&F LE-01MR energy meter 4544 CC1101 GDO0 CC1101 Serial interface 4576 CC1101 GDO2 CC1101 Serial interface 4608 HRXL Rx Data from MaxBotix HRXL sonar range sensor 4640 MOODL Tx ElectriQ iQ-wifiMOODL Serial TX 4672 AS3935 Franklin Lightning Sensor 4704 ADC Input1 Analog input 4705 ADC Input2 Analog input 4706 ADC Input3 Analog input 4707 ADC Input4 Analog input 4708 ADC Input5 Analog input 4709 ADC Input6 Analog input 4710 ADC Input7 Analog input 4711 ADC Input8 Analog input 4736 ADC Temp1 Analog Thermistor 4737 ADC Temp2 Analog Thermistor 4738 ADC Temp3 Analog Thermistor 4739 ADC Temp4 Analog Thermistor 4740 ADC Temp5 Analog Thermistor 4741 ADC Temp6 Analog Thermistor 4742 ADC Temp7 Analog Thermistor 4743 ADC Temp8 Analog Thermistor 4768 ADC Light1 Analog Light sensor 4769 ADC Light2 Analog Light sensor 4770 ADC Light3 Analog Light sensor 4771 ADC Light4 Analog Light sensor 4772 ADC Light5 Analog Light sensor 4773 ADC Light6 Analog Light sensor 4774 ADC Light7 Analog Light sensor 4775 ADC Light8 Analog Light sensor 4800 ADC Button1 Analog Button 4801 ADC Button2 Analog Button 4802 ADC Button3 Analog Button 4803 ADC Button4 Analog Button 4804 ADC Button5 Analog Button 4805 ADC Button6 Analog Button 4806 ADC Button7 Analog Button 4807 ADC Button8 Analog Button 4832 ADC Button_i1 Analog Button 4833 ADC Button_i2 Analog Button 4834 ADC Button_i3 Analog Button 4835 ADC Button_i4 Analog Button 4836 ADC Button_i5 Analog Button 4837 ADC Button_i6 Analog Button 4838 ADC Button_i7 Analog Button 4839 ADC Button_i8 Analog Button 4864 ADC Range1 Analog Range 4865 ADC Range2 Analog Range 4866 ADC Range3 Analog Range 4867 ADC Range4 Analog Range 4868 ADC Range5 Analog Range 4869 ADC Range6 Analog Range 4870 ADC Range7 Analog Range 4871 ADC Range8 Analog Range 4896 ADC CT Power1 ANalog Current 4897 ADC CT Power2 ANalog Current 4898 ADC CT Power3 ANalog Current 4899 ADC CT Power4 ANalog Current 4900 ADC CT Power5 ANalog Current 4901 ADC CT Power6 ANalog Current 4902 ADC CT Power7 ANalog Current 4903 ADC CT Power8 ANalog Current 4928 CAM_PWDN Webcam 4960 CAM_RESET Webcam 4992 CAM_XCLK Webcam 5024 CAM_SIOD Webcam I2C 5056 CAM_SIOC Webcam I2C 5088 CAM_DATA1 5089 CAM_DATA2 5090 CAM_DATA3 5091 CAM_DATA4 5092 CAM_DATA5 5093 CAM_DATA6 5094 CAM_DATA7 5095 CAM_DATA8 5120 CAM_VSYNC 5152 CAM_HREF 5184 CAM_PCLK 5216 CAM_PSCLK 5248 CAM_HSD1 5249 CAM_HSD2 5250 CAM_HSD3 5280 CAM_PSRCS 5312 OpenTherm RX OpenTherm Boiler TX pin 5344 OpenTherm TX OpenTherm Boiler TX pin 5376 WindMeter Spd WindMeter speed counter pin 5408 Button_tc1 Touch pin as button 5409 Button_tc2 Touch pin as button 5410 Button_tc3 Touch pin as button 5411 Button_tc4 Touch pin as button 5412 Button_tc5 Touch pin as button 5413 Button_tc6 Touch pin as button 5414 Button_tc7 Touch pin as button 5415 Button_tc8 Touch pin as button 5440 BL0940 Rx BL0940 serial interface 5472 TCP Tx TCP to serial bridge 5504 TCP Rx TCP to serial bridge 5536 ETH POWER Ethernet 5568 ETH MDC Ethernet 5600 ETH MDIO Ethernet 5632 TInfo Rx Teleinfo telemetry data receive pin 5664 TInfo EN Teleinfo Enable Receive Pin 5696 LMT01 Pulse LMT01 input counting pin 5728 iEM3000 TX IEM3000 Serial interface 5760 iEM3000 RX IEM3000 Serial interface 5792 Zigbee Rst1 Zigbee reset 5793 Zigbee Rst2 Zigbee reset 5824 DYP Rx 5856 MiEl HVAC Tx Mitsubishi Electric HVAC 5888 MiEl HVAC Rx Mitsubishi Electric HVAC 5920 WE517 Tx ORNO WE517 Serial interface 5952 WE517 Rx ORNO WE517 Serial interface 5984 AS608 Tx Serial interface AS608 / R503 6016 AS608 Rx Serial interface AS608 / R503 6048 SHD Boot 0 6080 SHD Reset 6112 RC522 Rst RC522 reset 6144 P9813 Clk P9813 Clock and Data 6176 P9813 Dat P9813 Clock and Data 6208 OptionA1 Specific device options to be served in code 6209 OptionA2 Specific device options to be served in code 6210 OptionA3 Specific device options to be served in code 6211 OptionA4 Specific device options to be served in code 6212 OptionA5 Specific device options to be served in code 6213 OptionA6 Specific device options to be served in code 6240 FTC532 FTC532 touch ctrlr serial input 6272 RC522 CS 6304 NRF24 CS 6336 NRF24 DC 6368 ILI9341 CS 6400 ILI9341 DC 6432 ILI9488 CS 6464 EPaper29 CS 6496 EPaper42 CS 6528 SSD1351 CS 6560 RA8876 CS 6592 ST7789 CS 6624 ST7789 DC 6656 SSD1331 CS 6688 SSD1331 DC 6720 SDCard CS 6752 RotaryA_n1 Rotary switch 6753 RotaryA_n2 Rotary switch 6784 RotaryB_n1 Rotary switch 6785 RotaryB_n2 Rotary switch 6816 ADC pH1 Analog PH Sensor 6817 ADC pH2 Analog PH Sensor 6818 ADC pH3 Analog PH Sensor 6819 ADC pH4 Analog PH Sensor 6820 ADC pH5 Analog PH Sensor 6821 ADC pH6 Analog PH Sensor 6822 ADC pH7 Analog PH Sensor 6823 ADC pH8 Analog PH Sensor 6848 BS814 CLK Holtek BS814A2 touch ctrlr 6880 BS814 DAT Holtek BS814A2 touch ctrlr 6912 Wiegand D0 Wiegand Data lines 6944 Wiegand D1 Wiegand Data lines 6976 NeoPool Tx Sugar Valley RS485 interface 7008 NeoPool Rx Sugar Valley RS485 interface 7040 SDM72 Tx SDM72 Serial interface 7072 SDM72 Rx SDM72 Serial interface 7104 TM1637 CLK TM1637 interface 7136 TM1637 DIO TM1637 interface 7168 DLP Tx LCD/DLP Projector Serial Control 7200 DLP Rx LCD/DLP Projector Serial Control 7232 SSD1351 DC 7264 XPT2046 CS XPT2046 SPI Chip Select 7296 CSE7761 Tx CSE7761 Serial interface (Dual R3) 7328 CSE7761 Rx CSE7761 Serial interface (Dual R3) 7360 VL53LXX XSHUT1 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7361 VL53LXX XSHUT2 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7362 VL53LXX XSHUT3 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7363 VL53LXX XSHUT4 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7364 VL53LXX XSHUT5 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7365 VL53LXX XSHUT6 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7366 VL53LXX XSHUT7 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7367 VL53LXX XSHUT8 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7392 MAX7219 CLK MAX7219 interface 7424 MAX7219 DIN MAX7219 interface 7456 MAX7219 CS MAX7219 interface 7488 TFmini+ TX TFmini Plus ToF sensor 7520 TFmini+ RX TFmini Plus ToF sensor 7552 ZC Pulse 7584 HallEffect1 7585 HallEffect2 7616 EPD Data Base connection EPD driver 7648 Input1 7649 Input2 7650 Input3 7651 Input4 7652 Input5 7653 Input6 7654 Input7 7655 Input8 7656 Input9 7657 Input10 7658 Input11 7659 Input12 7660 Input13 7661 Input14 7662 Input15 7663 Input16 7664 Input17 7665 Input18 7666 Input19 7667 Input20 7668 Input21 7669 Input22 7670 Input23 7671 Input24 7672 Input25 7673 Input26 7674 Input27 7675 Input28 7680 Button_d1 7681 Button_d2 7682 Button_d3 7683 Button_d4 7684 Button_d5 7685 Button_d6 7686 Button_d7 7687 Button_d8 7712 Button_id1 7713 Button_id2 7714 Button_id3 7715 Button_id4 7716 Button_id5 7717 Button_id6 7718 Button_id7 7719 Button_id8 7744 Switch_d1 7745 Switch_d2 7746 Switch_d3 7747 Switch_d4 7748 Switch_d5 7749 Switch_d6 7750 Switch_d7 7751 Switch_d8 7752 Switch_d9 7753 Switch_d10 7754 Switch_d11 7755 Switch_d12 7756 Switch_d13 7757 Switch_d14 7758 Switch_d15 7759 Switch_d16 7760 Switch_d17 7761 Switch_d18 7762 Switch_d19 7763 Switch_d20 7764 Switch_d21 7765 Switch_d22 7766 Switch_d23 7767 Switch_d24 7768 Switch_d25 7769 Switch_d26 7770 Switch_d27 7771 Switch_d28 7776 I2S Out Data1 7777 I2S Out Data2 7808 I2S Out Clk1 7809 I2S Out Clk2 7840 I2S Out Slct1 7841 I2S Out Slct2 7872 I2S In Data1 7873 I2S In Data2 7904 I2S In Clk1 7905 I2S In Clk2 7936 I2S In Slct1 7937 I2S In Slct2 7968 Interrupt1 7969 Interrupt2 7970 Interrupt3 7971 Interrupt4 7972 Interrupt5 7973 Interrupt6 7974 Interrupt7 7975 Interrupt8 7976 Interrupt9 7977 Interrupt10 7978 Interrupt11 7979 Interrupt12 7980 Interrupt13 7981 Interrupt14 7982 Interrupt15 7983 Interrupt16 7984 Interrupt17 7985 Interrupt18 7986 Interrupt19 7987 Interrupt20 7988 Interrupt21 7989 Interrupt22 7990 Interrupt23 7991 Interrupt24 7992 Interrupt25 7993 Interrupt26 7994 Interrupt27 7995 Interrupt28 8000 MCP2515 CS MCP2515 Chip Select 8032 HRG15 Tx Hydreon RG-15 rain sensor serial interface 8064 HRG15 Rx Hydreon RG-15 rain sensor serial interface 8096 VINDRIKTNING IKEA VINDRIKTNING Serial interface 8128 BL0939 Rx BL0939 Serial interface (Dual R3 v2) 8160 BL0942 Rx BL0942 Serial interface 8192 HM330X SET HM330X SET pin (sleep when low) 8224 Heartbeat 8256 Heartbeat_i 8288 74x595 SRCLK 74x595 Shift register 8320 74x595 RCLK 74x595 Shift register 8352 74x595 OE 74x595 Shift register 8384 74x595 SER 74x595 Shift register 8416 SolaxX1 RTS Solax Inverter Serial interface 8448 OptionE1 Emulated module 8480 SDM230 Tx SDM230 Serial interface 8512 SDM230 Rx SDM230 Serial interface 8544 ADC MQ1 Analog MQ Sensor 8545 ADC MQ2 Analog MQ Sensor 8546 ADC MQ3 Analog MQ Sensor 8547 ADC MQ4 Analog MQ Sensor 8548 ADC MQ5 Analog MQ Sensor 8549 ADC MQ6 Analog MQ Sensor 8550 ADC MQ7 Analog MQ Sensor 8551 ADC MQ8 Analog MQ Sensor 8576 CM110x TX CM11 Serial interface 8608 CM110x RX CM11 Serial interface 8640 BL6523 Tx BL6523 based Watt meter Serial interface 8672 BL6523 Rx BL6523 based Watt meter Serial interface 8704 ADE7880 IRQ1 ADE7880 IRQ 8705 ADE7880 IRQ2 ADE7880 IRQ 8736 Reset Generic reset 8768 MS01 Sonoff MS01 Moisture Sensor 1wire interface 8800 SDIO CMD SD Card SDIO interface including 1-bit and 4-bit modes 8832 SDIO CLK SD Card SDIO interface including 1-bit and 4-bit modes 8864 SDIO D0 SD Card SDIO interface including 1-bit and 4-bit modes 8896 SDIO D1 SD Card SDIO interface including 1-bit and 4-bit modes 8928 SDIO D2 SD Card SDIO interface including 1-bit and 4-bit modes 8960 SDIO D3 SD Card SDIO interface including 1-bit and 4-bit modes","title":"Components"},{"location":"Components/#assigning-components","text":"If you wish to expand a device with a peripheral component, after properly wiring everything, you need to assign it to a free GPIO in Configure Module page or use command GPIO<x> . Read more about peripherals . Tip GPIOs configured as User (1) are the GPIOs that can be assigned to components in the Configure Module page.","title":"Assigning Components"},{"location":"Components/#gpio-overview","text":"","title":"GPIO Overview"},{"location":"Components/#tasmota","text":"# UI Label Comment 0 None Not used 32 Button1 Button active low, internal pull-up resistor 33 Button2 Button active low, internal pull-up resistor 34 Button3 Button active low, internal pull-up resistor 35 Button4 Button active low, internal pull-up resistor 36 Button5 Button active low, internal pull-up resistor 37 Button6 Button active low, internal pull-up resistor 38 Button7 Button active low, internal pull-up resistor 39 Button8 Button active low, internal pull-up resistor 64 Button_n1 Button active low, no internal pull-up resistor 65 Button_n2 Button active low, no internal pull-up resistor 66 Button_n3 Button active low, no internal pull-up resistor 67 Button_n4 Button active low, no internal pull-up resistor 68 Button_n5 Button active low, no internal pull-up resistor 69 Button_n6 Button active low, no internal pull-up resistor 70 Button_n7 Button active low, no internal pull-up resistor 71 Button_n8 Button active low, no internal pull-up resistor 96 Button_i1 Button inverted, active high with internal pull-up resistor 97 Button_i2 Button inverted, active high with internal pull-up resistor 98 Button_i3 Button inverted, active high with internal pull-up resistor 99 Button_i4 Button inverted, active high with internal pull-up resistor 100 Button_i5 Button inverted, active high with internal pull-up resistor 101 Button_i6 Button inverted, active high with internal pull-up resistor 102 Button_i7 Button inverted, active high with internal pull-up resistor 103 Button_i8 Button inverted, active high with internal pull-up resistor 128 Button_in1 Button inverted, active high no internal pull-up resistor 129 Button_in2 Button inverted, active high no internal pull-up resistor 130 Button_in3 Button inverted, active high no internal pull-up resistor 131 Button_in4 Button inverted, active high no internal pull-up resistor 132 Button_in5 Button inverted, active high no internal pull-up resistor 133 Button_in6 Button inverted, active high no internal pull-up resistor 134 Button_in7 Button inverted, active high no internal pull-up resistor 135 Button_in8 Button inverted, active high no internal pull-up resistor 160 Switch1 Switch, internal pull-up resistor 161 Switch2 Switch, internal pull-up resistor 162 Switch3 Switch, internal pull-up resistor 163 Switch4 Switch, internal pull-up resistor 164 Switch5 Switch, internal pull-up resistor 165 Switch6 Switch, internal pull-up resistor 166 Switch7 Switch, internal pull-up resistor 167 Switch8 Switch, internal pull-up resistor 192 Switch_n1 Switch, no pull-up resistor 193 Switch_n2 Switch, no pull-up resistor 194 Switch_n3 Switch, no pull-up resistor 195 Switch_n4 Switch, no pull-up resistor 196 Switch_n5 Switch, no pull-up resistor 197 Switch_n6 Switch, no pull-up resistor 198 Switch_n7 Switch, no pull-up resistor 199 Switch_n8 Switch, no pull-up resistor 224 Relay1 Relay 225 Relay2 Relay 226 Relay3 Relay 227 Relay4 Relay 228 Relay5 Relay 229 Relay6 Relay 230 Relay7 Relay 231 Relay8 Relay 255 User User pin 256 Relay_i1 Relay inverted 257 Relay_i2 Relay inverted 258 Relay_i3 Relay inverted 259 Relay_i4 Relay inverted 260 Relay_i5 Relay inverted 261 Relay_i6 Relay inverted 262 Relay_i7 Relay inverted 263 Relay_i8 Relay inverted 288 Led1 4 x Leds 289 Led2 4 x Leds 290 Led3 4 x Leds 291 Led4 4 x Leds 320 Led_i1 4 x Leds 321 Led_i2 4 x Leds 322 Led_i3 4 x Leds 323 Led_i4 4 x Leds 352 Counter1 4 x Counter 353 Counter2 4 x Counter 354 Counter3 4 x Counter 355 Counter4 4 x Counter 384 Counter_n1 4 x Counter 385 Counter_n2 4 x Counter 386 Counter_n3 4 x Counter 387 Counter_n4 4 x Counter 416 PWM1 5 x PWM 417 PWM2 5 x PWM 418 PWM3 5 x PWM 419 PWM4 5 x PWM 420 PWM5 5 x PWM 448 PWM_i1 5 x PWM 449 PWM_i2 5 x PWM 450 PWM_i3 5 x PWM 451 PWM_i4 5 x PWM 452 PWM_i5 5 x PWM 480 Buzzer Buzzer 512 Buzzer_i Buzzer 544 LedLink Link led 576 LedLink_i Link led 608 I2C SCL1 Software I2C 640 I2C SDA1 Software I2C 672 SPI MISO1 Hardware SPI 704 SPI MOSI1 Hardware SPI 736 SPI CLK1 Hardware SPI 768 SPI CS1 Hardware SPI 800 SPI DC1 Hardware SPI 832 SSPI MISO Software SPI 864 SSPI MOSI Software SPI 896 SSPI SCLK Software SPI 928 SSPI CS Software SPI 960 SSPI DC Software SPI 992 Backlight Display backlight control 1024 Display Rst OLED Display Reset 1056 IRsend IR interface 1088 IRrecv IR interface 1120 RFSend RF interface 1152 RFrecv RF interface 1184 DHT11 DHT11 1216 AM2301 DHT21 DHT22 AM2301 AM2302 AM2321 1248 SI7021 SI7021 1280 DHT11_o DHT11 1312 DS18x20 DS18B20 or DS18S20 1344 DS18x20_o DS18B20 or DS18S20 1376 WS2812 WS2812 Led string 1408 MHZ Tx MH-Z19 Serial interface 1440 MHZ Rx MH-Z19 Serial interface 1472 PZEM0XX Tx PZEM Serial Modbus interface 1504 PZEM004 Rx PZEM Serial Modbus interface 1536 PZEM016 Rx PZEM Serial Modbus interface 1568 PZEM017 Rx PZEM Serial Modbus interface 1600 SAir Tx SenseAir Serial interface 1632 SAir Rx SenseAir Serial interface 1664 PMS5003 Tx Plantower PMS5003 Serial interface 1696 PMS5003 Rx Plantower PMS5003 Serial interface 1728 SDS0X1 Tx Nova Fitness SDS011 Serial interface 1760 SDS0X1 Rx Nova Fitness SDS011 Serial interface 1792 SerBr Tx Serial Bridge Serial interface 1824 SerBr Rx Serial Bridge Serial interface 1856 SR04 Tri/TX SR04 interface 1888 SR04 Ech/RX SR04 interface 1920 SDMx20 Tx SDM120 Serial interface 1952 SDMx20 Rx SDM120 Serial interface 1984 SDM630 Tx SDM630 Serial interface 2016 SDM630 Rx SDM630 Serial interface 2048 TM1638 CLK TM1638 interface 2080 TM1638 DIO TM1638 interface 2112 TM1638 STB TM1638 interface 2144 MP3 Player RB-DFR-562 DFPlayer Mini MP3 Player 2176 HX711 SCK HX711 Load Cell interface 2208 HX711 DAT HX711 Load Cell interface 2240 TX2x TX20/TX23 Transmission Pin 2272 Tuya Tx Tuya Serial interface 2304 Tuya Rx Tuya Serial interface 2336 MGC3130 Xfr MGC3130 interface 2368 MGC3130 Rst MGC3130 interface 2400 RF Sensor Rf receiver with sensor decoding 2432 AZ Tx AZ-Instrument 7798 Serial interface 2464 AZ Rx AZ-Instrument 7798 Serial interface 2496 MX31855 CS MAX31855 Serial interface 2528 MX31855 CLK MAX31855 Serial interface 2560 MX31855 DO MAX31855 Serial interface 2592 HLWBL SEL HLW8012/HJL-01/BL0937 energy monitoring 2624 HLWBL SEL_i HLW8012/HJL-01/BL0937 energy monitoring 2656 HLWBL CF1 HLW8012/HJL-01/BL0937 energy monitoring 2688 HLW8012 CF HLW8012/HJL-01/BL0937 energy monitoring 2720 BL0937 CF HLW8012/HJL-01/BL0937 energy monitoring 2752 MCP39F5 Tx MCP39F501 Energy monitoring (Shelly2) 2784 MCP39F5 Rx MCP39F501 Energy monitoring (Shelly2) 2816 MCP39F5 Rst MCP39F501 Energy monitoring (Shelly2) 2848 PN532 Tx PN532 NFC Serial interface 2880 PN532 Rx PN532 NFC Serial interface 2912 SM16716 CLK SM16716 SELECT 2944 SM16716 DAT SM16716 SELECT 2976 SM16716 PWR SM16716 SELECT 3008 MY92x1 DI my92x1 PWM controller 3040 MY92x1 DCKI my92x1 PWM controller 3072 CSE7766 Tx CSE7766 Serial interface (S31 and Pow R2) 3104 CSE7766 Rx CSE7766 Serial interface (S31 and Pow R2) 3136 ALux IrRcv Arilux RF Receive input 3168 ALux IrSel Arilux RF Receive input 3200 Serial Tx Serial interface 3232 Serial Rx Serial interface 3264 RotaryA1 Rotary switch 3265 RotaryA2 Rotary switch 3296 RotaryB1 Rotary switch 3297 RotaryB2 Rotary switch 3328 ADC Joystick Analog joystick 3360 MX31865 CS1 MAX31865 Chip Select 3361 MX31865 CS2 MAX31865 Chip Select 3362 MX31865 CS3 MAX31865 Chip Select 3363 MX31865 CS4 MAX31865 Chip Select 3364 MX31865 CS5 MAX31865 Chip Select 3365 MX31865 CS6 MAX31865 Chip Select 3392 HRE Clock HR-E Water Meter 3424 HRE Data HR-E Water Meter 3456 ADE7953 IRQ1 ADE7953 IRQ 3457 ADE7953 IRQ2 ADE7953 IRQ 3488 SolaxX1 Tx Solax Inverter Serial interface 3520 SolaxX1 Rx Solax Inverter Serial interface 3552 Zigbee Tx Zigbee Serial interface 3584 Zigbee Rx Zigbee Serial interface 3616 RDM6300 RX RDM6300 RX 3648 iBeacon TX HM17 IBEACON Serial interface 3680 iBeacon RX HM17 IBEACON Serial interface 3712 A4988 DIR A4988 interface 3744 A4988 STP A4988 interface 3776 A4988 ENA A4988 interface 3808 A4988 MS11 A4988 interface 3809 A4988 MS12 A4988 interface 3810 A4988 MS13 A4988 interface 3840 Output Hi Fixed output state 3872 Output Lo Fixed output state 3904 DDS238-2 Tx DDS2382 Serial interface 3936 DDS238-2 Rx DDS2382 Serial interface 3968 DDSU666 Tx DDSU666 Serial interface 4000 DDSU666 Rx DDSU666 Serial interface 4032 SM2135 Clk SM2135 PWM controller 4064 SM2135 Dat1 SM2135 PWM controller 4065 SM2135 Dat2 SM2135 PWM controller 4066 SM2135 Dat3 SM2135 PWM controller 4067 SM2135 Dat4 SM2135 PWM controller 4068 SM2135 Dat5 SM2135 PWM controller 4069 SM2135 Dat6 SM2135 PWM controller 4070 SM2135 Dat7 SM2135 PWM controller 4096 DeepSleep Kill switch for deepsleep 4128 EXS Enable EXS MCU Enable 4160 Client TX Client Serial interface 4192 Client RX Client Serial interface 4224 Client RST Client Reset 4256 Client RST_i Client Reset 4288 HPMA Rx Honeywell HPMA115S0 Serial interface 4320 HPMA Tx Honeywell HPMA115S0 Serial interface 4352 GPS RX GPS Serial interface 4384 GPS TX GPS Serial interface 4416 HM10 RX HM10-BLE-Mijia-bridge Serial interface 4448 HM10 TX HM10-BLE-Mijia-bridge Serial interface 4480 LE-01MR Rx F&F LE-01MR energy meter 4512 LE-01MR Tx F&F LE-01MR energy meter 4544 CC1101 GDO0 CC1101 Serial interface 4576 CC1101 GDO2 CC1101 Serial interface 4608 HRXL Rx Data from MaxBotix HRXL sonar range sensor 4640 MOODL Tx ElectriQ iQ-wifiMOODL Serial TX 4672 AS3935 Franklin Lightning Sensor 4704 ADC Input Analog input 4736 ADC Temp Analog Thermistor 4768 ADC Light Analog Light sensor 4800 ADC Button Analog Button 4832 ADC Button_i Analog Button 4864 ADC Range Analog Range 4896 ADC CT Power ANalog Current 4928 OpenTherm RX OpenTherm Boiler TX pin 4960 OpenTherm TX OpenTherm Boiler TX pin 4992 WindMeter Spd WindMeter speed counter pin 5024 Button_tc Touch pin as button 5056 BL0940 Rx BL0940 serial interface 5088 TCP Tx TCP to serial bridge 5120 TCP Rx TCP to serial bridge 5152 TInfo Rx Teleinfo telemetry data receive pin 5184 TInfo EN Teleinfo Enable Receive Pin 5216 LMT01 Pulse LMT01 input counting pin 5248 iEM3000 TX IEM3000 Serial interface 5280 iEM3000 RX IEM3000 Serial interface 5312 Zigbee Rst1 Zigbee reset 5313 Zigbee Rst2 Zigbee reset 5344 DYP Rx 5376 MiEl HVAC Tx Mitsubishi Electric HVAC 5408 MiEl HVAC Rx Mitsubishi Electric HVAC 5440 WE517 Tx ORNO WE517 Serial interface 5472 WE517 Rx ORNO WE517 Serial interface 5504 AS608 Tx Serial interface AS608 / R503 5536 AS608 Rx Serial interface AS608 / R503 5568 SHD Boot 0 5600 SHD Reset 5632 RC522 Rst RC522 reset 5664 P9813 Clk P9813 Clock and Data 5696 P9813 Dat P9813 Clock and Data 5728 OptionA1 Specific device options to be served in code 5729 OptionA2 Specific device options to be served in code 5730 OptionA3 Specific device options to be served in code 5731 OptionA4 Specific device options to be served in code 5732 OptionA5 Specific device options to be served in code 5733 OptionA6 Specific device options to be served in code 5760 FTC532 FTC532 touch ctrlr serial input 5792 RC522 CS 5824 NRF24 CS 5856 NRF24 DC 5888 ILI9341 CS 5920 ILI9341 DC 5952 ILI9488 CS 5984 EPaper29 CS 6016 EPaper42 CS 6048 SSD1351 CS 6080 RA8876 CS 6112 ST7789 CS 6144 ST7789 DC 6176 SSD1331 CS 6208 SSD1331 DC 6240 SDCard CS 6272 RotaryA_n1 Rotary switch 6273 RotaryA_n2 Rotary switch 6304 RotaryB_n1 Rotary switch 6305 RotaryB_n2 Rotary switch 6336 ADC pH Analog PH Sensor 6368 BS814 CLK Holtek BS814A2 touch ctrlr 6400 BS814 DAT Holtek BS814A2 touch ctrlr 6432 Wiegand D0 Wiegand Data lines 6464 Wiegand D1 Wiegand Data lines 6496 NeoPool Tx Sugar Valley RS485 interface 6528 NeoPool Rx Sugar Valley RS485 interface 6560 SDM72 Tx SDM72 Serial interface 6592 SDM72 Rx SDM72 Serial interface 6624 TM1637 CLK TM1637 interface 6656 TM1637 DIO TM1637 interface 6688 DLP Tx LCD/DLP Projector Serial Control 6720 DLP Rx LCD/DLP Projector Serial Control 6752 SSD1351 DC 6784 XPT2046 CS XPT2046 SPI Chip Select 6816 CSE7761 Tx CSE7761 Serial interface (Dual R3) 6848 CSE7761 Rx CSE7761 Serial interface (Dual R3) 6880 VL53LXX XSHUT1 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6881 VL53LXX XSHUT2 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6882 VL53LXX XSHUT3 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6883 VL53LXX XSHUT4 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6884 VL53LXX XSHUT5 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6885 VL53LXX XSHUT6 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6886 VL53LXX XSHUT7 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6887 VL53LXX XSHUT8 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 6912 MAX7219 CLK MAX7219 interface 6944 MAX7219 DIN MAX7219 interface 6976 MAX7219 CS MAX7219 interface 7008 TFmini+ TX TFmini Plus ToF sensor 7040 TFmini+ RX TFmini Plus ToF sensor 7072 ZC Pulse 7104 Input1 7105 Input2 7106 Input3 7107 Input4 7108 Input5 7109 Input6 7110 Input7 7111 Input8 7136 I2S Out Data1 7168 I2S Out Clk1 7200 I2S Out Slct1 7232 I2S In Data1 7264 I2S In Clk1 7296 I2S In Slct1 7328 Interrupt1 7329 Interrupt2 7330 Interrupt3 7331 Interrupt4 7332 Interrupt5 7333 Interrupt6 7334 Interrupt7 7335 Interrupt8 7360 MCP2515 CS MCP2515 Chip Select 7392 HRG15 Tx Hydreon RG-15 rain sensor serial interface 7424 HRG15 Rx Hydreon RG-15 rain sensor serial interface 7456 VINDRIKTNING IKEA VINDRIKTNING Serial interface 7488 BL0939 Rx BL0939 Serial interface (Dual R3 v2) 7520 BL0942 Rx BL0942 Serial interface 7552 HM330X SET HM330X SET pin (sleep when low) 7584 Heartbeat 7616 Heartbeat_i 7648 74x595 SRCLK 74x595 Shift register 7680 74x595 RCLK 74x595 Shift register 7712 74x595 OE 74x595 Shift register 7744 74x595 SER 74x595 Shift register 7776 SolaxX1 RTS Solax Inverter Serial interface 7808 OptionE Emulated module 7840 SDM230 Tx SDM230 Serial interface 7872 SDM230 Rx SDM230 Serial interface 7904 ADC MQ Analog MQ Sensor 7936 CM110x TX CM11 Serial interface 7968 CM110x RX CM11 Serial interface 8000 BL6523 Tx BL6523 based Watt meter Serial interface 8032 BL6523 Rx BL6523 based Watt meter Serial interface 8064 ADE7880 IRQ1 ADE7880 IRQ 8065 ADE7880 IRQ2 ADE7880 IRQ 8096 Reset Generic reset 8128 MS01 Sonoff MS01 Moisture Sensor 1wire interface 8160 SDIO CMD SD Card SDIO interface including 1-bit and 4-bit modes 8192 SDIO CLK SD Card SDIO interface including 1-bit and 4-bit modes 8224 SDIO D0 SD Card SDIO interface including 1-bit and 4-bit modes 8256 SDIO D1 SD Card SDIO interface including 1-bit and 4-bit modes 8288 SDIO D2 SD Card SDIO interface including 1-bit and 4-bit modes 8320 SDIO D3 SD Card SDIO interface including 1-bit and 4-bit modes","title":"Tasmota"},{"location":"Components/#tasmota32","text":"# UI Label Comment 0 None Not used 1 User User pin 32 Button1 4 x Button 33 Button2 4 x Button 34 Button3 4 x Button 35 Button4 4 x Button 36 Button5 4 x Button 37 Button6 4 x Button 38 Button7 4 x Button 39 Button8 4 x Button 64 Button_n1 4 x Button 65 Button_n2 4 x Button 66 Button_n3 4 x Button 67 Button_n4 4 x Button 68 Button_n5 4 x Button 69 Button_n6 4 x Button 70 Button_n7 4 x Button 71 Button_n8 4 x Button 96 Button_i1 4 x Button 97 Button_i2 4 x Button 98 Button_i3 4 x Button 99 Button_i4 4 x Button 100 Button_i5 4 x Button 101 Button_i6 4 x Button 102 Button_i7 4 x Button 103 Button_i8 4 x Button 128 Button_in1 4 x Button 129 Button_in2 4 x Button 130 Button_in3 4 x Button 131 Button_in4 4 x Button 132 Button_in5 4 x Button 133 Button_in6 4 x Button 134 Button_in7 4 x Button 135 Button_in8 4 x Button 160 Switch1 8 x User connected external switches 161 Switch2 8 x User connected external switches 162 Switch3 8 x User connected external switches 163 Switch4 8 x User connected external switches 164 Switch5 8 x User connected external switches 165 Switch6 8 x User connected external switches 166 Switch7 8 x User connected external switches 167 Switch8 8 x User connected external switches 168 Switch9 8 x User connected external switches 169 Switch10 8 x User connected external switches 170 Switch11 8 x User connected external switches 171 Switch12 8 x User connected external switches 172 Switch13 8 x User connected external switches 173 Switch14 8 x User connected external switches 174 Switch15 8 x User connected external switches 175 Switch16 8 x User connected external switches 176 Switch17 8 x User connected external switches 177 Switch18 8 x User connected external switches 178 Switch19 8 x User connected external switches 179 Switch20 8 x User connected external switches 180 Switch21 8 x User connected external switches 181 Switch22 8 x User connected external switches 182 Switch23 8 x User connected external switches 183 Switch24 8 x User connected external switches 184 Switch25 8 x User connected external switches 185 Switch26 8 x User connected external switches 186 Switch27 8 x User connected external switches 187 Switch28 8 x User connected external switches 192 Switch_n1 8 x User connected external switches 193 Switch_n2 8 x User connected external switches 194 Switch_n3 8 x User connected external switches 195 Switch_n4 8 x User connected external switches 196 Switch_n5 8 x User connected external switches 197 Switch_n6 8 x User connected external switches 198 Switch_n7 8 x User connected external switches 199 Switch_n8 8 x User connected external switches 200 Switch_n9 8 x User connected external switches 201 Switch_n10 8 x User connected external switches 202 Switch_n11 8 x User connected external switches 203 Switch_n12 8 x User connected external switches 204 Switch_n13 8 x User connected external switches 205 Switch_n14 8 x User connected external switches 206 Switch_n15 8 x User connected external switches 207 Switch_n16 8 x User connected external switches 208 Switch_n17 8 x User connected external switches 209 Switch_n18 8 x User connected external switches 210 Switch_n19 8 x User connected external switches 211 Switch_n20 8 x User connected external switches 212 Switch_n21 8 x User connected external switches 213 Switch_n22 8 x User connected external switches 214 Switch_n23 8 x User connected external switches 215 Switch_n24 8 x User connected external switches 216 Switch_n25 8 x User connected external switches 217 Switch_n26 8 x User connected external switches 218 Switch_n27 8 x User connected external switches 219 Switch_n28 8 x User connected external switches 224 Relay1 8 x Relays 225 Relay2 8 x Relays 226 Relay3 8 x Relays 227 Relay4 8 x Relays 228 Relay5 8 x Relays 229 Relay6 8 x Relays 230 Relay7 8 x Relays 231 Relay8 8 x Relays 232 Relay9 8 x Relays 233 Relay10 8 x Relays 234 Relay11 8 x Relays 235 Relay12 8 x Relays 236 Relay13 8 x Relays 237 Relay14 8 x Relays 238 Relay15 8 x Relays 239 Relay16 8 x Relays 240 Relay17 8 x Relays 241 Relay18 8 x Relays 242 Relay19 8 x Relays 243 Relay20 8 x Relays 244 Relay21 8 x Relays 245 Relay22 8 x Relays 246 Relay23 8 x Relays 247 Relay24 8 x Relays 248 Relay25 8 x Relays 249 Relay26 8 x Relays 250 Relay27 8 x Relays 251 Relay28 8 x Relays 256 Relay_i1 8 x Relays 257 Relay_i2 8 x Relays 258 Relay_i3 8 x Relays 259 Relay_i4 8 x Relays 260 Relay_i5 8 x Relays 261 Relay_i6 8 x Relays 262 Relay_i7 8 x Relays 263 Relay_i8 8 x Relays 264 Relay_i9 8 x Relays 265 Relay_i10 8 x Relays 266 Relay_i11 8 x Relays 267 Relay_i12 8 x Relays 268 Relay_i13 8 x Relays 269 Relay_i14 8 x Relays 270 Relay_i15 8 x Relays 271 Relay_i16 8 x Relays 272 Relay_i17 8 x Relays 273 Relay_i18 8 x Relays 274 Relay_i19 8 x Relays 275 Relay_i20 8 x Relays 276 Relay_i21 8 x Relays 277 Relay_i22 8 x Relays 278 Relay_i23 8 x Relays 279 Relay_i24 8 x Relays 280 Relay_i25 8 x Relays 281 Relay_i26 8 x Relays 282 Relay_i27 8 x Relays 283 Relay_i28 8 x Relays 288 Led1 4 x Leds 289 Led2 4 x Leds 290 Led3 4 x Leds 291 Led4 4 x Leds 320 Led_i1 4 x Leds 321 Led_i2 4 x Leds 322 Led_i3 4 x Leds 323 Led_i4 4 x Leds 352 Counter1 4 x Counter 353 Counter2 4 x Counter 354 Counter3 4 x Counter 355 Counter4 4 x Counter 384 Counter_n1 4 x Counter 385 Counter_n2 4 x Counter 386 Counter_n3 4 x Counter 387 Counter_n4 4 x Counter 416 PWM1 5 x PWM 417 PWM2 5 x PWM 418 PWM3 5 x PWM 419 PWM4 5 x PWM 420 PWM5 5 x PWM 448 PWM_i1 5 x PWM 449 PWM_i2 5 x PWM 450 PWM_i3 5 x PWM 451 PWM_i4 5 x PWM 452 PWM_i5 5 x PWM 480 Buzzer Buzzer 512 Buzzer_i Buzzer 544 LedLink Link led 576 LedLink_i Link led 608 I2C SCL1 Software I2C 609 I2C SCL2 Software I2C 640 I2C SDA1 Software I2C 641 I2C SDA2 Software I2C 672 SPI MISO1 Hardware SPI 673 SPI MISO2 Hardware SPI 704 SPI MOSI1 Hardware SPI 705 SPI MOSI2 Hardware SPI 736 SPI CLK1 Hardware SPI 737 SPI CLK2 Hardware SPI 768 SPI CS1 Hardware SPI 769 SPI CS2 Hardware SPI 800 SPI DC1 Hardware SPI 801 SPI DC2 Hardware SPI 832 SSPI MISO Software SPI 864 SSPI MOSI Software SPI 896 SSPI SCLK Software SPI 928 SSPI CS Software SPI 960 SSPI DC Software SPI 992 Backlight Display backlight control 1024 Display Rst OLED Display Reset 1056 IRsend IR interface 1088 IRrecv IR interface 1120 RFSend RF interface 1152 RFrecv RF interface 1184 DHT11 DHT11 DHT21 DHT22 AM2301 AM2302 AM2321 1216 AM2301 DHT11 DHT21 DHT22 AM2301 AM2302 AM2321 1248 SI7021 DHT11 DHT21 DHT22 AM2301 AM2302 AM2321 1280 DHT11_o DHT11 DHT21 DHT22 AM2301 AM2302 AM2321 1312 DS18x20 DS18B20 or DS18S20 1344 DS18x20_o DS18B20 or DS18S20 1376 WS2812 WS2812 Led string 1408 MHZ Tx MH-Z19 Serial interface 1440 MHZ Rx MH-Z19 Serial interface 1472 PZEM0XX Tx PZEM Serial Modbus interface 1504 PZEM004 Rx PZEM Serial Modbus interface 1536 PZEM016 Rx PZEM Serial Modbus interface 1568 PZEM017 Rx PZEM Serial Modbus interface 1600 SAir Tx SenseAir Serial interface 1632 SAir Rx SenseAir Serial interface 1664 PMS5003 Tx Plantower PMS5003 Serial interface 1696 PMS5003 Rx Plantower PMS5003 Serial interface 1728 SDS0X1 Tx Nova Fitness SDS011 Serial interface 1760 SDS0X1 Rx Nova Fitness SDS011 Serial interface 1792 SerBr Tx Serial Bridge Serial interface 1824 SerBr Rx Serial Bridge Serial interface 1856 SR04 Tri/TX SR04 interface 1888 SR04 Ech/RX SR04 interface 1920 SDMx20 Tx SDM120 Serial interface 1952 SDMx20 Rx SDM120 Serial interface 1984 SDM630 Tx SDM630 Serial interface 2016 SDM630 Rx SDM630 Serial interface 2048 TM1638 CLK TM1638 interface 2080 TM1638 DIO TM1638 interface 2112 TM1638 STB TM1638 interface 2144 MP3 Player RB-DFR-562 DFPlayer Mini MP3 Player 2176 HX711 SCK HX711 Load Cell interface 2208 HX711 DAT HX711 Load Cell interface 2240 TX2x TX20/TX23 Transmission Pin 2272 Tuya Tx Tuya Serial interface 2304 Tuya Rx Tuya Serial interface 2336 MGC3130 Xfr MGC3130 interface 2368 MGC3130 Rst MGC3130 interface 2400 RF Sensor Rf receiver with sensor decoding 2432 AZ Tx AZ-Instrument 7798 Serial interface 2464 AZ Rx AZ-Instrument 7798 Serial interface 2496 MX31855 CS MAX31855 Serial interface 2528 MX31855 CLK MAX31855 Serial interface 2560 MX31855 DO MAX31855 Serial interface 2592 HLWBL SEL HLW8012/HJL-01/BL0937 energy monitoring 2624 HLWBL SEL_i HLW8012/HJL-01/BL0937 energy monitoring 2656 HLWBL CF1 HLW8012/HJL-01/BL0937 energy monitoring 2688 HLW8012 CF HLW8012/HJL-01/BL0937 energy monitoring 2720 BL0937 CF HLW8012/HJL-01/BL0937 energy monitoring 2752 MCP39F5 Tx MCP39F501 Energy monitoring (Shelly2) 2784 MCP39F5 Rx MCP39F501 Energy monitoring (Shelly2) 2816 MCP39F5 Rst MCP39F501 Energy monitoring (Shelly2) 2848 PN532 Tx PN532 NFC Serial interface 2880 PN532 Rx PN532 NFC Serial interface 2912 SM16716 CLK SM16716 SELECT 2944 SM16716 DAT SM16716 SELECT 2976 SM16716 PWR SM16716 SELECT 3008 MY92x1 DI my92x1 PWM controller 3040 MY92x1 DCKI my92x1 PWM controller 3072 CSE7766 Tx CSE7766 Serial interface (S31 and Pow R2) 3104 CSE7766 Rx CSE7766 Serial interface (S31 and Pow R2) 3136 ALux IrRcv Arilux RF Receive input 3168 ALux IrSel Arilux RF Receive input 3200 Serial Tx Serial interface 3232 Serial Rx Serial interface 3264 RotaryA1 Rotary switch 3265 RotaryA2 Rotary switch 3296 RotaryB1 Rotary switch 3297 RotaryB2 Rotary switch 3328 ADC Joystick1 Analog joystick 3329 ADC Joystick2 Analog joystick 3330 ADC Joystick3 Analog joystick 3331 ADC Joystick4 Analog joystick 3332 ADC Joystick5 Analog joystick 3333 ADC Joystick6 Analog joystick 3334 ADC Joystick7 Analog joystick 3335 ADC Joystick8 Analog joystick 3360 MX31865 CS1 MAX31865 Chip Select 3361 MX31865 CS2 MAX31865 Chip Select 3362 MX31865 CS3 MAX31865 Chip Select 3363 MX31865 CS4 MAX31865 Chip Select 3364 MX31865 CS5 MAX31865 Chip Select 3365 MX31865 CS6 MAX31865 Chip Select 3392 HRE Clock HR-E Water Meter 3424 HRE Data HR-E Water Meter 3456 ADE7953 IRQ1 ADE7953 IRQ 3457 ADE7953 IRQ2 ADE7953 IRQ 3488 SolaxX1 Tx Solax Inverter Serial interface 3520 SolaxX1 Rx Solax Inverter Serial interface 3552 Zigbee Tx Zigbee Serial interface 3584 Zigbee Rx Zigbee Serial interface 3616 RDM6300 RX RDM6300 RX 3648 iBeacon TX HM17 IBEACON Serial interface 3680 iBeacon RX HM17 IBEACON Serial interface 3712 A4988 DIR A4988 interface 3744 A4988 STP A4988 interface 3776 A4988 ENA A4988 interface 3808 A4988 MS11 A4988 interface 3809 A4988 MS12 A4988 interface 3810 A4988 MS13 A4988 interface 3840 Output Hi Fixed output state 3872 Output Lo Fixed output state 3904 DDS238-2 Tx DDS2382 Serial interface 3936 DDS238-2 Rx DDS2382 Serial interface 3968 DDSU666 Tx DDSU666 Serial interface 4000 DDSU666 Rx DDSU666 Serial interface 4032 SM2135 Clk SM2135 PWM controller 4064 SM2135 Dat1 SM2135 PWM controller 4065 SM2135 Dat2 SM2135 PWM controller 4066 SM2135 Dat3 SM2135 PWM controller 4067 SM2135 Dat4 SM2135 PWM controller 4068 SM2135 Dat5 SM2135 PWM controller 4069 SM2135 Dat6 SM2135 PWM controller 4070 SM2135 Dat7 SM2135 PWM controller 4096 DeepSleep Kill switch for deepsleep 4128 EXS Enable EXS MCU Enable 4160 Client TX Client Serial interface 4192 Client RX Client Serial interface 4224 Client RST Client Reset 4256 Client RST_i Client Reset 4288 HPMA Rx Honeywell HPMA115S0 Serial interface 4320 HPMA Tx Honeywell HPMA115S0 Serial interface 4352 GPS RX GPS Serial interface 4384 GPS TX GPS Serial interface 4416 HM10 RX HM10-BLE-Mijia-bridge Serial interface 4448 HM10 TX HM10-BLE-Mijia-bridge Serial interface 4480 LE-01MR Rx F&F LE-01MR energy meter 4512 LE-01MR Tx F&F LE-01MR energy meter 4544 CC1101 GDO0 CC1101 Serial interface 4576 CC1101 GDO2 CC1101 Serial interface 4608 HRXL Rx Data from MaxBotix HRXL sonar range sensor 4640 MOODL Tx ElectriQ iQ-wifiMOODL Serial TX 4672 AS3935 Franklin Lightning Sensor 4704 ADC Input1 Analog input 4705 ADC Input2 Analog input 4706 ADC Input3 Analog input 4707 ADC Input4 Analog input 4708 ADC Input5 Analog input 4709 ADC Input6 Analog input 4710 ADC Input7 Analog input 4711 ADC Input8 Analog input 4736 ADC Temp1 Analog Thermistor 4737 ADC Temp2 Analog Thermistor 4738 ADC Temp3 Analog Thermistor 4739 ADC Temp4 Analog Thermistor 4740 ADC Temp5 Analog Thermistor 4741 ADC Temp6 Analog Thermistor 4742 ADC Temp7 Analog Thermistor 4743 ADC Temp8 Analog Thermistor 4768 ADC Light1 Analog Light sensor 4769 ADC Light2 Analog Light sensor 4770 ADC Light3 Analog Light sensor 4771 ADC Light4 Analog Light sensor 4772 ADC Light5 Analog Light sensor 4773 ADC Light6 Analog Light sensor 4774 ADC Light7 Analog Light sensor 4775 ADC Light8 Analog Light sensor 4800 ADC Button1 Analog Button 4801 ADC Button2 Analog Button 4802 ADC Button3 Analog Button 4803 ADC Button4 Analog Button 4804 ADC Button5 Analog Button 4805 ADC Button6 Analog Button 4806 ADC Button7 Analog Button 4807 ADC Button8 Analog Button 4832 ADC Button_i1 Analog Button 4833 ADC Button_i2 Analog Button 4834 ADC Button_i3 Analog Button 4835 ADC Button_i4 Analog Button 4836 ADC Button_i5 Analog Button 4837 ADC Button_i6 Analog Button 4838 ADC Button_i7 Analog Button 4839 ADC Button_i8 Analog Button 4864 ADC Range1 Analog Range 4865 ADC Range2 Analog Range 4866 ADC Range3 Analog Range 4867 ADC Range4 Analog Range 4868 ADC Range5 Analog Range 4869 ADC Range6 Analog Range 4870 ADC Range7 Analog Range 4871 ADC Range8 Analog Range 4896 ADC CT Power1 ANalog Current 4897 ADC CT Power2 ANalog Current 4898 ADC CT Power3 ANalog Current 4899 ADC CT Power4 ANalog Current 4900 ADC CT Power5 ANalog Current 4901 ADC CT Power6 ANalog Current 4902 ADC CT Power7 ANalog Current 4903 ADC CT Power8 ANalog Current 4928 CAM_PWDN Webcam 4960 CAM_RESET Webcam 4992 CAM_XCLK Webcam 5024 CAM_SIOD Webcam I2C 5056 CAM_SIOC Webcam I2C 5088 CAM_DATA1 5089 CAM_DATA2 5090 CAM_DATA3 5091 CAM_DATA4 5092 CAM_DATA5 5093 CAM_DATA6 5094 CAM_DATA7 5095 CAM_DATA8 5120 CAM_VSYNC 5152 CAM_HREF 5184 CAM_PCLK 5216 CAM_PSCLK 5248 CAM_HSD1 5249 CAM_HSD2 5250 CAM_HSD3 5280 CAM_PSRCS 5312 OpenTherm RX OpenTherm Boiler TX pin 5344 OpenTherm TX OpenTherm Boiler TX pin 5376 WindMeter Spd WindMeter speed counter pin 5408 Button_tc1 Touch pin as button 5409 Button_tc2 Touch pin as button 5410 Button_tc3 Touch pin as button 5411 Button_tc4 Touch pin as button 5412 Button_tc5 Touch pin as button 5413 Button_tc6 Touch pin as button 5414 Button_tc7 Touch pin as button 5415 Button_tc8 Touch pin as button 5440 BL0940 Rx BL0940 serial interface 5472 TCP Tx TCP to serial bridge 5504 TCP Rx TCP to serial bridge 5536 ETH POWER Ethernet 5568 ETH MDC Ethernet 5600 ETH MDIO Ethernet 5632 TInfo Rx Teleinfo telemetry data receive pin 5664 TInfo EN Teleinfo Enable Receive Pin 5696 LMT01 Pulse LMT01 input counting pin 5728 iEM3000 TX IEM3000 Serial interface 5760 iEM3000 RX IEM3000 Serial interface 5792 Zigbee Rst1 Zigbee reset 5793 Zigbee Rst2 Zigbee reset 5824 DYP Rx 5856 MiEl HVAC Tx Mitsubishi Electric HVAC 5888 MiEl HVAC Rx Mitsubishi Electric HVAC 5920 WE517 Tx ORNO WE517 Serial interface 5952 WE517 Rx ORNO WE517 Serial interface 5984 AS608 Tx Serial interface AS608 / R503 6016 AS608 Rx Serial interface AS608 / R503 6048 SHD Boot 0 6080 SHD Reset 6112 RC522 Rst RC522 reset 6144 P9813 Clk P9813 Clock and Data 6176 P9813 Dat P9813 Clock and Data 6208 OptionA1 Specific device options to be served in code 6209 OptionA2 Specific device options to be served in code 6210 OptionA3 Specific device options to be served in code 6211 OptionA4 Specific device options to be served in code 6212 OptionA5 Specific device options to be served in code 6213 OptionA6 Specific device options to be served in code 6240 FTC532 FTC532 touch ctrlr serial input 6272 RC522 CS 6304 NRF24 CS 6336 NRF24 DC 6368 ILI9341 CS 6400 ILI9341 DC 6432 ILI9488 CS 6464 EPaper29 CS 6496 EPaper42 CS 6528 SSD1351 CS 6560 RA8876 CS 6592 ST7789 CS 6624 ST7789 DC 6656 SSD1331 CS 6688 SSD1331 DC 6720 SDCard CS 6752 RotaryA_n1 Rotary switch 6753 RotaryA_n2 Rotary switch 6784 RotaryB_n1 Rotary switch 6785 RotaryB_n2 Rotary switch 6816 ADC pH1 Analog PH Sensor 6817 ADC pH2 Analog PH Sensor 6818 ADC pH3 Analog PH Sensor 6819 ADC pH4 Analog PH Sensor 6820 ADC pH5 Analog PH Sensor 6821 ADC pH6 Analog PH Sensor 6822 ADC pH7 Analog PH Sensor 6823 ADC pH8 Analog PH Sensor 6848 BS814 CLK Holtek BS814A2 touch ctrlr 6880 BS814 DAT Holtek BS814A2 touch ctrlr 6912 Wiegand D0 Wiegand Data lines 6944 Wiegand D1 Wiegand Data lines 6976 NeoPool Tx Sugar Valley RS485 interface 7008 NeoPool Rx Sugar Valley RS485 interface 7040 SDM72 Tx SDM72 Serial interface 7072 SDM72 Rx SDM72 Serial interface 7104 TM1637 CLK TM1637 interface 7136 TM1637 DIO TM1637 interface 7168 DLP Tx LCD/DLP Projector Serial Control 7200 DLP Rx LCD/DLP Projector Serial Control 7232 SSD1351 DC 7264 XPT2046 CS XPT2046 SPI Chip Select 7296 CSE7761 Tx CSE7761 Serial interface (Dual R3) 7328 CSE7761 Rx CSE7761 Serial interface (Dual R3) 7360 VL53LXX XSHUT1 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7361 VL53LXX XSHUT2 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7362 VL53LXX XSHUT3 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7363 VL53LXX XSHUT4 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7364 VL53LXX XSHUT5 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7365 VL53LXX XSHUT6 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7366 VL53LXX XSHUT7 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7367 VL53LXX XSHUT8 VL53LXX_XSHUT (the max number of sensors is VL53LXX_MAX_SENSORS)- Used when connecting multiple VL53LXX 7392 MAX7219 CLK MAX7219 interface 7424 MAX7219 DIN MAX7219 interface 7456 MAX7219 CS MAX7219 interface 7488 TFmini+ TX TFmini Plus ToF sensor 7520 TFmini+ RX TFmini Plus ToF sensor 7552 ZC Pulse 7584 HallEffect1 7585 HallEffect2 7616 EPD Data Base connection EPD driver 7648 Input1 7649 Input2 7650 Input3 7651 Input4 7652 Input5 7653 Input6 7654 Input7 7655 Input8 7656 Input9 7657 Input10 7658 Input11 7659 Input12 7660 Input13 7661 Input14 7662 Input15 7663 Input16 7664 Input17 7665 Input18 7666 Input19 7667 Input20 7668 Input21 7669 Input22 7670 Input23 7671 Input24 7672 Input25 7673 Input26 7674 Input27 7675 Input28 7680 Button_d1 7681 Button_d2 7682 Button_d3 7683 Button_d4 7684 Button_d5 7685 Button_d6 7686 Button_d7 7687 Button_d8 7712 Button_id1 7713 Button_id2 7714 Button_id3 7715 Button_id4 7716 Button_id5 7717 Button_id6 7718 Button_id7 7719 Button_id8 7744 Switch_d1 7745 Switch_d2 7746 Switch_d3 7747 Switch_d4 7748 Switch_d5 7749 Switch_d6 7750 Switch_d7 7751 Switch_d8 7752 Switch_d9 7753 Switch_d10 7754 Switch_d11 7755 Switch_d12 7756 Switch_d13 7757 Switch_d14 7758 Switch_d15 7759 Switch_d16 7760 Switch_d17 7761 Switch_d18 7762 Switch_d19 7763 Switch_d20 7764 Switch_d21 7765 Switch_d22 7766 Switch_d23 7767 Switch_d24 7768 Switch_d25 7769 Switch_d26 7770 Switch_d27 7771 Switch_d28 7776 I2S Out Data1 7777 I2S Out Data2 7808 I2S Out Clk1 7809 I2S Out Clk2 7840 I2S Out Slct1 7841 I2S Out Slct2 7872 I2S In Data1 7873 I2S In Data2 7904 I2S In Clk1 7905 I2S In Clk2 7936 I2S In Slct1 7937 I2S In Slct2 7968 Interrupt1 7969 Interrupt2 7970 Interrupt3 7971 Interrupt4 7972 Interrupt5 7973 Interrupt6 7974 Interrupt7 7975 Interrupt8 7976 Interrupt9 7977 Interrupt10 7978 Interrupt11 7979 Interrupt12 7980 Interrupt13 7981 Interrupt14 7982 Interrupt15 7983 Interrupt16 7984 Interrupt17 7985 Interrupt18 7986 Interrupt19 7987 Interrupt20 7988 Interrupt21 7989 Interrupt22 7990 Interrupt23 7991 Interrupt24 7992 Interrupt25 7993 Interrupt26 7994 Interrupt27 7995 Interrupt28 8000 MCP2515 CS MCP2515 Chip Select 8032 HRG15 Tx Hydreon RG-15 rain sensor serial interface 8064 HRG15 Rx Hydreon RG-15 rain sensor serial interface 8096 VINDRIKTNING IKEA VINDRIKTNING Serial interface 8128 BL0939 Rx BL0939 Serial interface (Dual R3 v2) 8160 BL0942 Rx BL0942 Serial interface 8192 HM330X SET HM330X SET pin (sleep when low) 8224 Heartbeat 8256 Heartbeat_i 8288 74x595 SRCLK 74x595 Shift register 8320 74x595 RCLK 74x595 Shift register 8352 74x595 OE 74x595 Shift register 8384 74x595 SER 74x595 Shift register 8416 SolaxX1 RTS Solax Inverter Serial interface 8448 OptionE1 Emulated module 8480 SDM230 Tx SDM230 Serial interface 8512 SDM230 Rx SDM230 Serial interface 8544 ADC MQ1 Analog MQ Sensor 8545 ADC MQ2 Analog MQ Sensor 8546 ADC MQ3 Analog MQ Sensor 8547 ADC MQ4 Analog MQ Sensor 8548 ADC MQ5 Analog MQ Sensor 8549 ADC MQ6 Analog MQ Sensor 8550 ADC MQ7 Analog MQ Sensor 8551 ADC MQ8 Analog MQ Sensor 8576 CM110x TX CM11 Serial interface 8608 CM110x RX CM11 Serial interface 8640 BL6523 Tx BL6523 based Watt meter Serial interface 8672 BL6523 Rx BL6523 based Watt meter Serial interface 8704 ADE7880 IRQ1 ADE7880 IRQ 8705 ADE7880 IRQ2 ADE7880 IRQ 8736 Reset Generic reset 8768 MS01 Sonoff MS01 Moisture Sensor 1wire interface 8800 SDIO CMD SD Card SDIO interface including 1-bit and 4-bit modes 8832 SDIO CLK SD Card SDIO interface including 1-bit and 4-bit modes 8864 SDIO D0 SD Card SDIO interface including 1-bit and 4-bit modes 8896 SDIO D1 SD Card SDIO interface including 1-bit and 4-bit modes 8928 SDIO D2 SD Card SDIO interface including 1-bit and 4-bit modes 8960 SDIO D3 SD Card SDIO interface including 1-bit and 4-bit modes","title":"Tasmota32"},{"location":"Configuration-Procedure-for-New-Devices/","text":"Configuration procedure for new devices ~ If your device is not a built-in module listed in the module configuration menu, a user contributed device template ( explanation ) may be available. Otherwise, follow this procedure for configuring the ESP chip pins used by your device. Some smart devices have additional functionality which may be handled by codes sent to a separate MCU in the device. Devices with functions offloaded to a separate MCU require additional coding in the software or via rules. Certain supported Tasmota BASE devices have built-in code to handle MCU controlled devices. Using a template with an appropriate BASE device may have the programming logic required to manage the MCU commands for your device. If an existing BASE device with the logic for your device is not available, a modified device driver will be required. This case is outside of the scope of this article. If your device is similar to the existing built-in module (e.g., a particular MCU or power monitoring algorithm) it is best to use that as a starting point. When you are not sure which module is suitable for your device, use Generic module (18) . ESP8266 ESP32 Finding Relays and Lights ~ Step 1. ~ Begin this procedure by disabling power state saves. Some improper GPIO assignments can cause device reboots. Disabling this setting avoids repeated flash writes. Also, it is best to allow Tasmota to return to a fail safe state in case of a bad configuration. Ensure that boot loop control is not disabled. Backlog SetOption0 0 ; SetOption36 1 Step 2. ~ Assign every available GPIO to successive Relay<x> components. For the initial GPIO probe, exclude \"dedicated\" GPIO such as GPIO0/GPIO2 and Tx/Rx, etc. You can use a Template to easily perform these assignments: { \"NAME\" : \"ID Relays\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 224 , 225 , 0 , 0 , 226 , 227 , 228 , 229 , 230 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } Save the configuration. Once the device reboots, use the virtual buttons on the web UI to find which of the assigned GPIO actually control the physical relays and LEDs on the device. Make note of which GPIO act on which device peripheral. Step 2a. ~ If you are unable to control some of the relays or LEDs on the device, they may be attached to the \"dedicated\" GPIO skipped in the initial probe. Now assign those GPIOs and repeat step 2a : { \"NAME\" : \"ID Relays 2\" , \"GPIO\" :[ 224 , 225 , 226 , 227 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } If your device is based on the ESP8285 and you are still unable to control some of the relays or LEDs on the device, they may be attached to GPIO9 or GPIO10. Now assign those remaining GPIO and repeat step 2a : { \"NAME\" : \"ID Relays 3\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 0 , 0 , 224 , 225 , 0 , 0 , 0 , 0 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } Step 2b. ~ Once you have found which GPIOs control the relays and LEDs, set these \"active\" GPIO to associate them with the corresponding Relay<x> , LED<x> , or LEDLink or PWM<x> (Some may require the use of inverted (i.e., Relay<x>i / LED<x>i / LEDLinki ) component). Bulbs have mainly PWM . For proper operation, in the final device configuration, assignment of like components must begin from 1 and be assigned sequentially! Regular and inverted components can be intermixed (e.g., Relay1 , then Relay2 ; Led1 , then Led2i and so on). Buttons, Switches, nonPWM Lights or Power Monitoring ~ Step 1. ~ Now assign every remaining GPIO (excluding, once again, remaining \"dedicated\" GPIO like GPIO0/GPIO2 and Tx/Rx, etc.) to successive Switch1 .. Switch8 components ( 9 .. 16 ). (If you have remaining GPIOs assign them as Counter ) { \"NAME\" : \"ID Other\" , \"GPIO\" :[ 160 , 352 , 353 , 354 , 161 , 163 , 0 , 0 , 163 , 164 , 165 , 166 , 167 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } Step 2. ~ Save the configuration. Once the device reboots, use the web UI Console to run the Status 8 (sensors) command. This will display the current state of each GPIO. If you have a bulb, GPIOs which are in state ON will probably be SM16716 CLK or SM16716 DAT component. Step 3. ~ Run SetOption114 1 to show switch activations in console. If you have a power monitoring device, when under load the power monitoring chip should trigger switches or counters. Then its just a matter of finding the right power monitoring components and their combination. Step 4. ~ Once you have found which GPIO are connected to each input, change the GPIO setting in the configuration to your input component or use case (f.e. Button<x> or Switch<x> ). Proper operation may dictate the use of regular or inverted (i.e., Switch<x>i / Button<x>i ) settings. For buttons, you may need to determine whether the internal pull-up is used or not. If so, select Button<x> n , where n indicates no pull-up. Step 1. ~ Begin this procedure by disabling power state saves. Some improper GPIO assignments can cause device reboots. Disabling this setting avoids repeated flash writes. Also, it is best to allow Tasmota to return to a fail safe state in case of a bad configuration. Ensure that boot loop control is not disabled. Backlog SetOption0 0 ; SetOption36 1 Step 2. ~ Assign every available GPIO to successive Relay<x> components. For the initial GPIO probe, exclude \"dedicated\" GPIO such as Tx/Rx, etc. You can use a Template to easily perform these assignments: { \"NAME\" : \"Find Relays\" , \"GPIO\" :[ 224 , 0 , 225 , 0 , 226 , 227 , 1 , 1 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 0 , 0 , 0 , 0 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 ], \"FLAG\" : 0 , \"BASE\" : 1 } Save the configuration. Once the device reboots, use the virtual buttons on the web UI to find which of the assigned GPIO actually control the physical relays and LEDs on the device. Make note of which GPIO act on which device peripheral. Buttons, Switches, nonPWM Lights or Power Monitoring ~ Step 1. ~ Now assign every remaining available GPIO to successive Switch<x> components. For the initial GPIO probe, exclude \"dedicated\" GPIO such as Tx/Rx, etc. You can use a Template to easily perform these assignments: { \"NAME\" : \"Find Switches\" , \"GPIO\" :[ 160 , 0 , 161 , 0 , 162 , 163 , 1 , 1 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 176 , 177 , 178 , 179 , 0 , 0 , 0 , 0 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 ], \"FLAG\" : 0 , \"BASE\" : 1 , \"CMND\" : \"SO114 1 | SO65 0;\" } If you have a power monitoring device, when under load the power monitoring chip should trigger switches which will display in the console. Then its just a matter of finding the right power monitoring components and their combination. Step 4. ~ Once you have found which GPIO are connected to each input, change the GPIO setting in the configuration to your input component or use case (f.e. Button<x> or Switch<x> ). Proper operation may dictate the use of regular, inverted or no pulldown settings. For buttons, you may need to determine whether the internal pull-up or pull-down is used or not. Finishing Configuration ~ Step 1 ~ Once you have determined which GPIO your device uses, set any remaining GPIOs to None (0) . Save the configuration. Once the device reboots, set the options change back to defaults with: Backlog SetOption0 1; SetOption114 0 Step 2. ~ Submit the new configuration: Since you have now configured a device not previously known to the Tasmota user base, you can export the template and submit it to the Tasmota Supported Devices Repository . Devices with TuyaMCU ~ In case your device is a Tuya device with an MCU which controls everything see TuyaMCU for instructions on how to configure it. Video for a tutorial on this procedure.","title":"Configure Unknown Device"},{"location":"Configuration-Procedure-for-New-Devices/#configuration-procedure-for-new-devices","text":"If your device is not a built-in module listed in the module configuration menu, a user contributed device template ( explanation ) may be available. Otherwise, follow this procedure for configuring the ESP chip pins used by your device. Some smart devices have additional functionality which may be handled by codes sent to a separate MCU in the device. Devices with functions offloaded to a separate MCU require additional coding in the software or via rules. Certain supported Tasmota BASE devices have built-in code to handle MCU controlled devices. Using a template with an appropriate BASE device may have the programming logic required to manage the MCU commands for your device. If an existing BASE device with the logic for your device is not available, a modified device driver will be required. This case is outside of the scope of this article. If your device is similar to the existing built-in module (e.g., a particular MCU or power monitoring algorithm) it is best to use that as a starting point. When you are not sure which module is suitable for your device, use Generic module (18) . ESP8266 ESP32","title":"Configuration procedure for new devices"},{"location":"Configuration-Procedure-for-New-Devices/#finding-relays-and-lights","text":"","title":"Finding Relays and Lights"},{"location":"Configuration-Procedure-for-New-Devices/#step-1","text":"Begin this procedure by disabling power state saves. Some improper GPIO assignments can cause device reboots. Disabling this setting avoids repeated flash writes. Also, it is best to allow Tasmota to return to a fail safe state in case of a bad configuration. Ensure that boot loop control is not disabled. Backlog SetOption0 0 ; SetOption36 1","title":"Step 1."},{"location":"Configuration-Procedure-for-New-Devices/#step-2","text":"Assign every available GPIO to successive Relay<x> components. For the initial GPIO probe, exclude \"dedicated\" GPIO such as GPIO0/GPIO2 and Tx/Rx, etc. You can use a Template to easily perform these assignments: { \"NAME\" : \"ID Relays\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 224 , 225 , 0 , 0 , 226 , 227 , 228 , 229 , 230 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } Save the configuration. Once the device reboots, use the virtual buttons on the web UI to find which of the assigned GPIO actually control the physical relays and LEDs on the device. Make note of which GPIO act on which device peripheral.","title":"Step 2."},{"location":"Configuration-Procedure-for-New-Devices/#buttons-switches-nonpwm-lights-or-power-monitoring","text":"","title":"Buttons, Switches, nonPWM Lights or Power Monitoring"},{"location":"Configuration-Procedure-for-New-Devices/#step-1_2","text":"Begin this procedure by disabling power state saves. Some improper GPIO assignments can cause device reboots. Disabling this setting avoids repeated flash writes. Also, it is best to allow Tasmota to return to a fail safe state in case of a bad configuration. Ensure that boot loop control is not disabled. Backlog SetOption0 0 ; SetOption36 1","title":"Step 1."},{"location":"Configuration-Procedure-for-New-Devices/#step-2_2","text":"Assign every available GPIO to successive Relay<x> components. For the initial GPIO probe, exclude \"dedicated\" GPIO such as Tx/Rx, etc. You can use a Template to easily perform these assignments: { \"NAME\" : \"Find Relays\" , \"GPIO\" :[ 224 , 0 , 225 , 0 , 226 , 227 , 1 , 1 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 0 , 0 , 0 , 0 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 ], \"FLAG\" : 0 , \"BASE\" : 1 } Save the configuration. Once the device reboots, use the virtual buttons on the web UI to find which of the assigned GPIO actually control the physical relays and LEDs on the device. Make note of which GPIO act on which device peripheral.","title":"Step 2."},{"location":"Configuration-Procedure-for-New-Devices/#buttons-switches-nonpwm-lights-or-power-monitoring_1","text":"","title":"Buttons, Switches, nonPWM Lights or Power Monitoring"},{"location":"Configuration-Procedure-for-New-Devices/#finishing-configuration","text":"","title":"Finishing Configuration"},{"location":"Configuration-Procedure-for-New-Devices/#step-1_4","text":"Once you have determined which GPIO your device uses, set any remaining GPIOs to None (0) . Save the configuration. Once the device reboots, set the options change back to defaults with: Backlog SetOption0 1; SetOption114 0","title":"Step 1"},{"location":"Configuration-Procedure-for-New-Devices/#step-2_3","text":"Submit the new configuration: Since you have now configured a device not previously known to the Tasmota user base, you can export the template and submit it to the Tasmota Supported Devices Repository .","title":"Step 2."},{"location":"Configuration-Procedure-for-New-Devices/#devices-with-tuyamcu","text":"In case your device is a Tuya device with an MCU which controls everything see TuyaMCU for instructions on how to configure it. Video for a tutorial on this procedure.","title":"Devices with TuyaMCU"},{"location":"Contributing/","text":"Any contribution helps our team and makes Tasmota better for the entire community! You can contribute by: providing Pull Requests (Features, Proof of Concepts, Language files or Fixes) testing new released features and report issues donating to acquire hardware for testing and implementing or out of gratitude contributing documentation for features and devices submitting new device templates fixing spelling mistakes, broken links and other errors in the documentation writing guides on wiring and using sensors or your DIY projects featuring Tasmota Editing Articles ~ You need a GitHub user account to be able to edit If you spot an error in an article use the pencil icon link at the top of the page, near the title, to correct it. This version of documentation uses strict markdown syntax with some enhancements. See Markdown Cheatsheet for all features You'll be taken to the GitHub repository page of that file, after a \"fork\" (copy) of the docs are made into your own GitHub account. Click on the edit button (pencil icon). Edit/Add the text you wanted. When finished find the Propose changes button at the bottom and click it. Next you need to click Create pull request which is GitHub speak for propose changes. In the PR window add a small description of what you did and click Create pull request Now you wait for one of the Tasmota admins to approve your PR (or deny , no guarantees!) Congratulations ! You've made a contribution to the Tasmota project making it a better experience for all future users. Thank you! Adding devices to the documentation ~ If you're adding a new page, go to documentation GitHub and click Create new file , name the file with .md extension.","title":"Contributing"},{"location":"Contributing/#editing-articles","text":"You need a GitHub user account to be able to edit If you spot an error in an article use the pencil icon link at the top of the page, near the title, to correct it. This version of documentation uses strict markdown syntax with some enhancements. See Markdown Cheatsheet for all features You'll be taken to the GitHub repository page of that file, after a \"fork\" (copy) of the docs are made into your own GitHub account. Click on the edit button (pencil icon). Edit/Add the text you wanted. When finished find the Propose changes button at the bottom and click it. Next you need to click Create pull request which is GitHub speak for propose changes. In the PR window add a small description of what you did and click Create pull request Now you wait for one of the Tasmota admins to approve your PR (or deny , no guarantees!) Congratulations ! You've made a contribution to the Tasmota project making it a better experience for all future users. Thank you!","title":"Editing Articles"},{"location":"Contributing/#adding-devices-to-the-documentation","text":"If you're adding a new page, go to documentation GitHub and click Create new file , name the file with .md extension.","title":"Adding devices to the documentation"},{"location":"Control-a-Sonoff-using-a-remote-button/","text":"REMOTE BUTTON ~ IMPORTANT: The ESP8266 needs GPIO0 and GPIO2 to be high (not connected to anything, or connected to 3.3V) during boot. GPIO0 and GPIO2 are the pins D3 and D4 on the Wemos D1 mini. D3 and D4 should only be used to connect push buttons (which are only low when pressed), not toggle switches. I have a cabin that is remote from my house, and I'm using a Sonoff to turn on/off the heaters remotely, so the place can be warm when I get there. The Sonoff(heater control) is located near the fuse box, and it controls a relay which switches the 120V/30A to the heaters. It's awkward to get at the Sonoff(heater control) to physically press the toggle button, so when I'm using it, I use MQTT commands to control the heaters. But I have some family members that are not comfortable with MQTT usage and certainly don't want to open the fuse box. So I built a small ESP-01 and a DHT22 and a push button, and used this project code to drive it (>rev 1.0.30). I use the cmnd/my_DHT/buttontopic to set the mqtt command to control the heaters. Yes, you can program a sonoff so that the button sends out any arbitrary command. In this case, I'm using the button to control the other sonoff. This ESP+DHT device is in the common area of the cabin, so my family members can simply push the button to toggle the heater. In other words, I'm using one trivial (DHT+button) wifi device to control the other (sonoff+heater relay). This technique uses Theo's flexible design, since buttontopic can be made different from topic . Schematic ~ NOTE: with this schematic, the DHT sensor is on GPIO2. You'll have to change the #define DHT_PIN in this project's source code from 14 to 2. Also, make sure you use the black ESP01 with 1MB of flash; most 2016 purchases should be ok. Of course you can use an ESP12 if you wish. The optional block shown attaches an LED to the DHT data line, so you can watch when the data is being fetched from the DHT device. Power regulator, 5V to 3.3V: search eBay for 5v/3.3v power 1117 ESP: search eBay for esp-01 and pick a black one DHT22: search eBay for dht22 ; any AM2302, DHT11 or DHT12 will do in its place; or you can omit the DHT and just use the button Cost (2016-09-05) USB-5V-adapter: CAD$1 + DC5V->3.3V: CAD$1 + ESP01: CAD$2.62 + DHT12: CAD$1.50 = CAD$6.12 = EUR 4.25 This little device has two inputs (DHT & button), and no output . You can use either the Sonoff or the ElectroDragon version of this project, but because this has no output, the following commands don't make any sense: power, light, ledstate . You may also want to change the #define APP_NAME and #define PROJECT to reflect that this isn't a real Sonoff. Pat B Update ~ 2017-11-12 ~ This design still works with version 5.5.2 of the firmware. There's no need anymore to create a special build; the new design allows you to customize the code at runtime. For the above schematic, go into the Config Module menu and set - Module: 18 WeMos D1 mini - GPIO0: 09 Switch1 - GPIO2: 03 DHT22 and set switchtopic1 to the topic for the device you want to control, and switchmode1 to 3 (toggle). That's all you need to do :) I also discovered that the button must be a momentary pushbutton; don't use a switch, because both GPIO0 and GPIO2 must be floating at boot time. Another Update ~ 2017-09-22 ~ I have installed the above device at my cabin in the woods, and I'm using a cellular modem to connect to the internet for data. If I set the Tasmota-Sonoff software with a teleperiod=3600 (once per hour), the MQTT traffic is about 6kB/hour, which is about 4.2MB/month. That includes the TCP keep-alives and the telemetry messages. So two devices (the main sonoff power switch and the esp-01 button device) takes 8.4MB/month, just below my economy 10MB/month sim card. Just FYI, I also have tried using a Raspberry PI at the cabin, and instructing it to SSH to my public-facing server, and creating a reverse tunnel back so that I can access my cabin from my public-facing server. The keep-alives on that connection is about 7.6MB/month. [The cellular phone company is probably using NAT, so I have to connect from cabin->server and not the other way around]","title":"Control a Sonoff using a remote button"},{"location":"Control-a-Sonoff-using-a-remote-button/#remote-button","text":"IMPORTANT: The ESP8266 needs GPIO0 and GPIO2 to be high (not connected to anything, or connected to 3.3V) during boot. GPIO0 and GPIO2 are the pins D3 and D4 on the Wemos D1 mini. D3 and D4 should only be used to connect push buttons (which are only low when pressed), not toggle switches. I have a cabin that is remote from my house, and I'm using a Sonoff to turn on/off the heaters remotely, so the place can be warm when I get there. The Sonoff(heater control) is located near the fuse box, and it controls a relay which switches the 120V/30A to the heaters. It's awkward to get at the Sonoff(heater control) to physically press the toggle button, so when I'm using it, I use MQTT commands to control the heaters. But I have some family members that are not comfortable with MQTT usage and certainly don't want to open the fuse box. So I built a small ESP-01 and a DHT22 and a push button, and used this project code to drive it (>rev 1.0.30). I use the cmnd/my_DHT/buttontopic to set the mqtt command to control the heaters. Yes, you can program a sonoff so that the button sends out any arbitrary command. In this case, I'm using the button to control the other sonoff. This ESP+DHT device is in the common area of the cabin, so my family members can simply push the button to toggle the heater. In other words, I'm using one trivial (DHT+button) wifi device to control the other (sonoff+heater relay). This technique uses Theo's flexible design, since buttontopic can be made different from topic .","title":"REMOTE BUTTON"},{"location":"Control-a-Sonoff-using-a-remote-button/#schematic","text":"NOTE: with this schematic, the DHT sensor is on GPIO2. You'll have to change the #define DHT_PIN in this project's source code from 14 to 2. Also, make sure you use the black ESP01 with 1MB of flash; most 2016 purchases should be ok. Of course you can use an ESP12 if you wish. The optional block shown attaches an LED to the DHT data line, so you can watch when the data is being fetched from the DHT device. Power regulator, 5V to 3.3V: search eBay for 5v/3.3v power 1117 ESP: search eBay for esp-01 and pick a black one DHT22: search eBay for dht22 ; any AM2302, DHT11 or DHT12 will do in its place; or you can omit the DHT and just use the button Cost (2016-09-05) USB-5V-adapter: CAD$1 + DC5V->3.3V: CAD$1 + ESP01: CAD$2.62 + DHT12: CAD$1.50 = CAD$6.12 = EUR 4.25 This little device has two inputs (DHT & button), and no output . You can use either the Sonoff or the ElectroDragon version of this project, but because this has no output, the following commands don't make any sense: power, light, ledstate . You may also want to change the #define APP_NAME and #define PROJECT to reflect that this isn't a real Sonoff. Pat B","title":"Schematic"},{"location":"Control-a-Sonoff-using-a-remote-button/#update","text":"","title":"Update"},{"location":"Control-a-Sonoff-using-a-remote-button/#another-update","text":"","title":"Another Update"},{"location":"Create-your-own-Firmware-Build-without-IDE/","text":"PlatformIO is not just an IDE. In fact, all its features are accessible from the command line, and the IDE is a convenience wrapper layer around it. Thus, we can build Tasmota using only this PlatformIO-Core, which may come handy for automated builds, or for those who feel more comfortable with the command line than with the IDE. The steps are surprisingly simple and straightforward: Provision a Linux VM ~ At least if you want to work in a cloud environment, but you may also choose to work on your physical machine as well. PlatformIO is based on python, so if we use python-virtualenv , then all the dependent packages will be confined to a separate folder, so it won't even taint the OS installation. As all of python , python-virtualenv and python-pip are available in most of the recent distros, you may pick your favourite one. Install python and tools ~ Install python and python-virtualenv , and python-pip , because we don't want to mess up the python ecosystem of the distro. Update pip by pip install --upgrade pip , and this was the last step done as root, the rest goes as a plain user. I used CentOS here, so if you prefer Debian-based distros, just substitute apt-get install -y ... for yum install -y ... . [tasmota_builder@jtest ~]$ sudo yum install -y python python-virtualenv python-pip Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile ... Complete! You may update pip in the host environment, but we'll do it in the virtualenv as well, so it's optional: [tasmota_builder@jtest ~]$ sudo pip install --upgrade pip Collecting pip ... Successfully installed pip-18.1 Prepare a PlatformIO-Core environment contained in a folder ~ virtualenv creates a folder and prepares a whole self-contained python subsystem there. To activate it, so that all python-related things refer to this environment and not to the system global, you need to source the file bin/activate within it. NOTE : Not just execute in a subshell, but include it into the current one, so please note the . before bin/activate below: [tasmota_builder@jtest ~]$ virtualenv platformio-core New python executable in /home/tasmota_builder/platformio-core/bin/python Installing setuptools, pip, wheel...done. [tasmota_builder@jtest ~]$ cd platformio-core [tasmota_builder@jtest platformio-core]$ . bin/activate (platformio-core) [tasmota_builder@jtest platformio-core]$ Now we are ready to install PlatformIO-Core into this small virtual environment: (platformio-core) [tasmota_builder@jtest platformio-core]$ pip install -U platformio Collecting platformio Downloading https://files.pythonhosted.org/packages/95/4a/3ccce45ba750dd9a8d48dcbe9b9080011ac2a5a248312b19552bbaec6b7d/platformio-3.6.3-py27-none-any.whl (160kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 4.5MB/s Collecting semantic-version<3,>=2.5.0 (from platformio) Downloading https://files.pythonhosted.org/packages/72/83/f76958017f3094b072d8e3a72d25c3ed65f754cc607fdb6a7b33d84ab1d5/semantic_version-2.6.0.tar.gz Collecting click<6,>=5 (from platformio) Downloading https://files.pythonhosted.org/packages/8f/98/14966b6d772fd5fba1eb3bb34a62a7f736d609572493397cdc5715c14514/click-5.1-py2.py3-none-any.whl (65kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 71kB 8.1MB/s Collecting colorama (from platformio) Downloading https://files.pythonhosted.org/packages/4f/a6/728666f39bfff1719fc94c481890b2106837da9318031f71a8424b662e12/colorama-0.4.1-py2.py3-none-any.whl Collecting requests<3,>=2.4.0 (from platformio) Downloading https://files.pythonhosted.org/packages/7d/e3/20f3d364d6c8e5d2353c72a67778eb189176f08e873c9900e10c0287b84b/requests-2.21.0-py2.py3-none-any.whl (57kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.9MB/s Collecting pyserial!=3.3,<4,>=3 (from platformio) Downloading https://files.pythonhosted.org/packages/0d/e4/2a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30/pyserial-3.4-py2.py3-none-any.whl (193kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 194kB 4.7MB/s Collecting bottle<0.13 (from platformio) Downloading https://files.pythonhosted.org/packages/32/4e/ed046324d5ec980c252987c1dca191e001b9f06ceffaebf037eef469937c/bottle-0.12.16.tar.gz (72kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81kB 8.8MB/s Collecting urllib3<1.25,>=1.21.1 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/62/00/ee1d7de624db8ba7090d1226aebefab96a2c71cd5cfa7629d6ad3f61b79e/urllib3-1.24.1-py2.py3-none-any.whl (118kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 122kB 7.5MB/s Collecting chardet<3.1.0,>=3.0.2 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/bc/a9/01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 143kB 6.8MB/s Collecting idna<2.9,>=2.5 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/14/2c/cd551d81dbe15200be1cf41cd03869a46fe7226e7450af7a6545bfc474c9/idna-2.8-py2.py3-none-any.whl (58kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.8MB/s Collecting certifi>=2017.4.17 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/9f/e0/accfc1b56b57e9750eba272e24c4dddeac86852c2bebd1236674d7887e8a/certifi-2018.11.29-py2.py3-none-any.whl (154kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 5.9MB/s Building wheels for collected packages: semantic-version, bottle Running setup.py bdist_wheel for semantic-version ... done Stored in directory: /home/tasmota_builder/.cache/pip/wheels/60/bb/50/215d669d31f992767f5dd8d3c974e79261707ee7f898f0dc10 Running setup.py bdist_wheel for bottle ... done Stored in directory: /home/tasmota_builder/.cache/pip/wheels/0c/68/ac/1546dcb27101ca6c4e50c5b5da92dbd3307f07cda5d88e81c7 Successfully built semantic-version bottle Installing collected packages: semantic-version, click, colorama, urllib3, chardet, idna, certifi, requests, pyserial, bottle, platformio Successfully installed bottle-0.12.16 certifi-2018.11.29 chardet-3.0.4 click-5.1 colorama-0.4.1 idna-2.8 platformio-3.6.3 pyserial-3.4 requests-2.21.0 semantic-version> You are using pip version 9.0.1, however version 18.1 is available. As it would prefer a recent pip instead of the one set up by virtualenv , so let's upgrade it: (platformio-core) [tasmota_builder@jtest platformio-core]$ pip install --upgrade pip Collecting pip Downloading https://files.pythonhosted.org/packages/c2/d7/90f34cb0d83a6c5631cf71dfe64cc1054598c843a92b400e55675cc2ac37/pip-18.1-py2.py3-none-any.whl (1.3MB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1.3MB 793kB/s Installing collected packages: pip Found existing installation: pip 9.0.1 Uninstalling pip-9.0.1: Successfully uninstalled pip-9.0.1 Successfully installed pip-18.1 Fetch the Tasmota sources ~ If you want only to build, then the original repo will do, but if you want to contribute as well, then fork an own copy of the repo and clone out that one. (platformio-core) [tasmota_builder@jtest platformio-core]$ git clone https://github.com/arendst/Tasmota.git Cloning into 'Tasmota'... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (5/5), done. remote: Total 16930 (delta 1), reused 3 (delta 1), pack-reused 16924 Receiving objects: 100% (16930/16930), 23.75 MiB | 12.94 MiB/s, done. Resolving deltas: 100% (11426/11426), done. After changing to the working copy, we are ready to go: (platformio-core) [tasmota_builder@jtest platformio-core]$ cd Tasmota/ (platformio-core) [tasmota_builder@jtest Tasmota]$ Configure the sources ~ Now you may want to configure the sources for your needs. Actually, the sources do build fine right out-of-the box, only it'll be a full build, including all the language localisation and all the build flavours as well, while you are usually interested only in one language and one build flavour only. In tasmota/user_config_override.h fine tune the default values for the module, the wifi, the MQTT server, and so on. Build the firmware ~ The build command itself is pio run , but as it emits quite a lot of messages (including errors if you're developing), so you may want to redirect a copy of the standard output and error to a file, so it'll be pio run 2>&1 | tee build.log . (platformio-core) [tasmota_builder@jtest Tasmota]$ time pio run 2>&1 | tee build.log ************************************************************************************************************************************************************************ If you like PlatformIO, please: - follow us on Twitter to stay up-to-date on the latest project news > https://twitter.com/PlatformIO_Org - star it on GitHub > https://github.com/platformio/platformio - try PlatformIO IDE for IoT development > https://platformio.org/platformio-ide - support us with PlatformIO Plus > https://pioplus.com ************************************************************************************************************************************************************************ Processing tasmota (framework: arduino; platform: espressif8266@1.8.0; board: esp01_1m) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ PlatformManager: Installing espressif8266 @ 1.8.0 Downloading ... Environment tasmota-TW [SUCCESS] Environment tasmota-UK [SUCCESS] ==================================================================== [SUCCESS] Took 797.56 seconds ==================================================================== That's all, really :D ! PlatformIO seems to handle the rebuilds and dependencies well, but if you want a clean build, the say pio run -t clean first, and then the pio run . Collect the results ~ The results will be here: build_output About build times ~ The recent versions of PlatformIO-Core seem to parallelise quite well. When you've changed only a few files, not everything needs to be recompiled (though the image must still be re-packed), so that minute-like build time is the maximum, usually it'll be less. Prepare the local installer tool ~ You may rebuild the firmware on a remote machine, but you must have the installer tool on the local machine where the module is connected to. Fortunately, it's also python-based, so we can again employ virtualenv here. If you built the firmware also on your localhost, then there is no need for a separate environment, you may quite well install esptool into that one. Otherwise, create a virtual environment the usual way: [tasmota_installer@lantash ~]$ virtualenv esptool New python executable in /home/tasmota_installer/esptool/bin/python2.7 Also creating executable in /home/tasmota_installer/esptool/bin/python Installing setuptools, pip, wheel...done. [tasmota_installer@lantash ~]$ cd esptool/ [tasmota_installer@lantash ~/esptool]$ . bin/activate (esptool) [tasmota_installer@lantash ~/esptool]$ pip install --upgrade pip Requirement already up-to-date: pip in ./lib/python2.7/site-packages (18.1) Now let's install esptool : (esptool) [tasmota_installer@lantash ~/esptool]$ pip install esptool Collecting esptool Downloading https://files.pythonhosted.org/packages/5c/85/5654e7b9019739d3d89af0adf528c9ae57a9a26682e3aa012e1e30f20674/esptool-2.6.tar.gz (80kB) 100% |################################| 81kB 222kB/s Collecting pyserial>=3.0 (from esptool) Downloading https://files.pythonhosted.org/packages/0d/e4/2a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30/pyserial-3.4-py2.py3-none-any.whl (193kB) 100% |################################| 194kB 491kB/s Collecting pyaes (from esptool) Downloading https://files.pythonhosted.org/packages/44/66/2c17bae31c906613795711fc78045c285048168919ace2220daa372c7d72/pyaes-1.6.1.tar.gz Collecting ecdsa (from esptool) Downloading https://files.pythonhosted.org/packages/63/f4/73669d51825516ce8c43b816c0a6b64cd6eb71d08b99820c00792cb42222/ecdsa-0.13-py2.py3-none-any.whl (86kB) 100% |################################| 92kB 382kB/s Building wheels for collected packages: esptool, pyaes Running setup.py bdist_wheel for esptool ... done Stored in directory: /home/tasmota_installer/.cache/pip/wheels/cf/1f/62/7ad4e47843affd4f5b7032a39f1ef8a153c6d27533614d21aa Running setup.py bdist_wheel for pyaes ... done Stored in directory: /home/tasmota_installer/.cache/pip/wheels/bd/cf/7b/ced9e8f28c50ed666728e8ab178ffedeb9d06f6a10f85d6432 Successfully built esptool pyaes Installing collected packages: pyserial, pyaes, ecdsa, esptool Successfully installed ecdsa-0.13 esptool-2.6 pyaes-1.6.1 pyserial-3.4 If you've built the firmware on a remote machine, now it's time to download it into this installer environment (e.g. via scp or sftp ). IMPORTANT : For the subsequent steps your user must have the permission to write the serial port. Back up the current firmware (optional) ~ First of all, disconnect the bulb from the mains and wire up the serial connection and a button on GPIO0. If this GPIO0 is connected to GND when the module gets power, it starts in a firmware-update mode, and you can then read/write its flash storage. Switch off the power of the board, this will be the reference 'steady state' of the system. (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py read_flash 0x00000 0x100000 fcmila_bulb_orig.bin esptool.py v2.6 Found 1 serial ports Serial port /dev/cuaU0 Connecting...... Now, it'll wait for the module to appear connected, so press the button (GPIO0 to GND), keep it pressed switch on the power of the board now you may release the button ... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: bc:dd:c2:e0:2a:f2 Uploading stub... Running stub... Stub running... 1048576 (100 %) Read 1048576 bytes at 0x0 in 95.0 seconds (88.3 kbit/s)... Hard resetting via RTS pin... If all is well, the flash is being dumped, it may take a minute or so. If done, then power the module off , as this management mode is not restartable! If it's not well, then you may try some queries: (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py -p /dev/ttyU0 chip_id ... Chip ID: 0x00e02af2 ... (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py -p /dev/ttyU0 flash_id ... Manufacturer: c8 Device: 4014 Detected flash size: 1MB ... If they don't work, then check your cabling and your serial adapter. Until you can't get this step working, don't proceed to the next one, it won't work either. Erase the flash ~ (With the usual button-pressed-power-on rain dance, and don't forget to power the module off afterwards.) (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py erase_flash ... Erasing flash (this may take a while)... Chip erase completed successfully in 1.6s Install the firmware to your module ~ (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py write_flash --flash_size 1MB --flash_mode dout 0x00000 firmware.bin Configuring flash size... Compressed 535424 bytes to 367679... Wrote 535424 bytes (367679 compressed) at 0x00000000 in 33.8 seconds (effective 126.6 kbit/s)... Hash of data verified. Leaving... Power on for normal operation ~ No button-pressing, power on, and see what you achieved :). The module sends its logs on the serial line at 115200 baud 8N1, so to check the logs: (esptool) [tasmota_installer@lantash ~/esptool]$ cu -s 115200 -l /dev/ttyU0 | tee -a my_sonoff.log Connected <some initial binary data> 00:00:00 CFG: Use defaults 00:00:00 SM16716: ModuleSelected; clk_pin=4, dat_pin=14) 00:00:00 SRC: Restart 00:00:00 SM16716: Entry; function=FUNC_SET_DEVICE_POWER, index=00, payload=02 00:00:00 SM16716: Update; pwr=00, rgb=000000 00:00:00 Project sonoff Sonoff Version 6.4.1.9(sonoff)-2_4_2 00:00:00 SM16716: Entry; function=FUNC_INIT 00:00:00 SM16716: ModuleSelected; clk_pin=4, dat_pin=14) 00:00:00 WIF: Attempting connection... ... (Assuming that you're using FreeBSD. On Linux you set the speed via setserial or stty , and then do the dump with dd . Or just minicom , if you prefer.) Now you have a complete build path from source to device, and a log feedback as well, so you've got everything needed for being able to implement your ideas :D !","title":"Create your own Firmware Build without IDE"},{"location":"Create-your-own-Firmware-Build-without-IDE/#provision-a-linux-vm","text":"At least if you want to work in a cloud environment, but you may also choose to work on your physical machine as well. PlatformIO is based on python, so if we use python-virtualenv , then all the dependent packages will be confined to a separate folder, so it won't even taint the OS installation. As all of python , python-virtualenv and python-pip are available in most of the recent distros, you may pick your favourite one.","title":"Provision a Linux VM"},{"location":"Create-your-own-Firmware-Build-without-IDE/#install-python-and-tools","text":"Install python and python-virtualenv , and python-pip , because we don't want to mess up the python ecosystem of the distro. Update pip by pip install --upgrade pip , and this was the last step done as root, the rest goes as a plain user. I used CentOS here, so if you prefer Debian-based distros, just substitute apt-get install -y ... for yum install -y ... . [tasmota_builder@jtest ~]$ sudo yum install -y python python-virtualenv python-pip Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile ... Complete! You may update pip in the host environment, but we'll do it in the virtualenv as well, so it's optional: [tasmota_builder@jtest ~]$ sudo pip install --upgrade pip Collecting pip ... Successfully installed pip-18.1","title":"Install python and tools"},{"location":"Create-your-own-Firmware-Build-without-IDE/#prepare-a-platformio-core-environment-contained-in-a-folder","text":"virtualenv creates a folder and prepares a whole self-contained python subsystem there. To activate it, so that all python-related things refer to this environment and not to the system global, you need to source the file bin/activate within it. NOTE : Not just execute in a subshell, but include it into the current one, so please note the . before bin/activate below: [tasmota_builder@jtest ~]$ virtualenv platformio-core New python executable in /home/tasmota_builder/platformio-core/bin/python Installing setuptools, pip, wheel...done. [tasmota_builder@jtest ~]$ cd platformio-core [tasmota_builder@jtest platformio-core]$ . bin/activate (platformio-core) [tasmota_builder@jtest platformio-core]$ Now we are ready to install PlatformIO-Core into this small virtual environment: (platformio-core) [tasmota_builder@jtest platformio-core]$ pip install -U platformio Collecting platformio Downloading https://files.pythonhosted.org/packages/95/4a/3ccce45ba750dd9a8d48dcbe9b9080011ac2a5a248312b19552bbaec6b7d/platformio-3.6.3-py27-none-any.whl (160kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 4.5MB/s Collecting semantic-version<3,>=2.5.0 (from platformio) Downloading https://files.pythonhosted.org/packages/72/83/f76958017f3094b072d8e3a72d25c3ed65f754cc607fdb6a7b33d84ab1d5/semantic_version-2.6.0.tar.gz Collecting click<6,>=5 (from platformio) Downloading https://files.pythonhosted.org/packages/8f/98/14966b6d772fd5fba1eb3bb34a62a7f736d609572493397cdc5715c14514/click-5.1-py2.py3-none-any.whl (65kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 71kB 8.1MB/s Collecting colorama (from platformio) Downloading https://files.pythonhosted.org/packages/4f/a6/728666f39bfff1719fc94c481890b2106837da9318031f71a8424b662e12/colorama-0.4.1-py2.py3-none-any.whl Collecting requests<3,>=2.4.0 (from platformio) Downloading https://files.pythonhosted.org/packages/7d/e3/20f3d364d6c8e5d2353c72a67778eb189176f08e873c9900e10c0287b84b/requests-2.21.0-py2.py3-none-any.whl (57kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.9MB/s Collecting pyserial!=3.3,<4,>=3 (from platformio) Downloading https://files.pythonhosted.org/packages/0d/e4/2a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30/pyserial-3.4-py2.py3-none-any.whl (193kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 194kB 4.7MB/s Collecting bottle<0.13 (from platformio) Downloading https://files.pythonhosted.org/packages/32/4e/ed046324d5ec980c252987c1dca191e001b9f06ceffaebf037eef469937c/bottle-0.12.16.tar.gz (72kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81kB 8.8MB/s Collecting urllib3<1.25,>=1.21.1 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/62/00/ee1d7de624db8ba7090d1226aebefab96a2c71cd5cfa7629d6ad3f61b79e/urllib3-1.24.1-py2.py3-none-any.whl (118kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 122kB 7.5MB/s Collecting chardet<3.1.0,>=3.0.2 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/bc/a9/01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 143kB 6.8MB/s Collecting idna<2.9,>=2.5 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/14/2c/cd551d81dbe15200be1cf41cd03869a46fe7226e7450af7a6545bfc474c9/idna-2.8-py2.py3-none-any.whl (58kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.8MB/s Collecting certifi>=2017.4.17 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/9f/e0/accfc1b56b57e9750eba272e24c4dddeac86852c2bebd1236674d7887e8a/certifi-2018.11.29-py2.py3-none-any.whl (154kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 5.9MB/s Building wheels for collected packages: semantic-version, bottle Running setup.py bdist_wheel for semantic-version ... done Stored in directory: /home/tasmota_builder/.cache/pip/wheels/60/bb/50/215d669d31f992767f5dd8d3c974e79261707ee7f898f0dc10 Running setup.py bdist_wheel for bottle ... done Stored in directory: /home/tasmota_builder/.cache/pip/wheels/0c/68/ac/1546dcb27101ca6c4e50c5b5da92dbd3307f07cda5d88e81c7 Successfully built semantic-version bottle Installing collected packages: semantic-version, click, colorama, urllib3, chardet, idna, certifi, requests, pyserial, bottle, platformio Successfully installed bottle-0.12.16 certifi-2018.11.29 chardet-3.0.4 click-5.1 colorama-0.4.1 idna-2.8 platformio-3.6.3 pyserial-3.4 requests-2.21.0 semantic-version> You are using pip version 9.0.1, however version 18.1 is available. As it would prefer a recent pip instead of the one set up by virtualenv , so let's upgrade it: (platformio-core) [tasmota_builder@jtest platformio-core]$ pip install --upgrade pip Collecting pip Downloading https://files.pythonhosted.org/packages/c2/d7/90f34cb0d83a6c5631cf71dfe64cc1054598c843a92b400e55675cc2ac37/pip-18.1-py2.py3-none-any.whl (1.3MB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1.3MB 793kB/s Installing collected packages: pip Found existing installation: pip 9.0.1 Uninstalling pip-9.0.1: Successfully uninstalled pip-9.0.1 Successfully installed pip-18.1","title":"Prepare a PlatformIO-Core environment contained in a folder"},{"location":"Create-your-own-Firmware-Build-without-IDE/#fetch-the-tasmota-sources","text":"If you want only to build, then the original repo will do, but if you want to contribute as well, then fork an own copy of the repo and clone out that one. (platformio-core) [tasmota_builder@jtest platformio-core]$ git clone https://github.com/arendst/Tasmota.git Cloning into 'Tasmota'... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (5/5), done. remote: Total 16930 (delta 1), reused 3 (delta 1), pack-reused 16924 Receiving objects: 100% (16930/16930), 23.75 MiB | 12.94 MiB/s, done. Resolving deltas: 100% (11426/11426), done. After changing to the working copy, we are ready to go: (platformio-core) [tasmota_builder@jtest platformio-core]$ cd Tasmota/ (platformio-core) [tasmota_builder@jtest Tasmota]$","title":"Fetch the Tasmota sources"},{"location":"Create-your-own-Firmware-Build-without-IDE/#configure-the-sources","text":"Now you may want to configure the sources for your needs. Actually, the sources do build fine right out-of-the box, only it'll be a full build, including all the language localisation and all the build flavours as well, while you are usually interested only in one language and one build flavour only. In tasmota/user_config_override.h fine tune the default values for the module, the wifi, the MQTT server, and so on.","title":"Configure the sources"},{"location":"Create-your-own-Firmware-Build-without-IDE/#build-the-firmware","text":"The build command itself is pio run , but as it emits quite a lot of messages (including errors if you're developing), so you may want to redirect a copy of the standard output and error to a file, so it'll be pio run 2>&1 | tee build.log . (platformio-core) [tasmota_builder@jtest Tasmota]$ time pio run 2>&1 | tee build.log ************************************************************************************************************************************************************************ If you like PlatformIO, please: - follow us on Twitter to stay up-to-date on the latest project news > https://twitter.com/PlatformIO_Org - star it on GitHub > https://github.com/platformio/platformio - try PlatformIO IDE for IoT development > https://platformio.org/platformio-ide - support us with PlatformIO Plus > https://pioplus.com ************************************************************************************************************************************************************************ Processing tasmota (framework: arduino; platform: espressif8266@1.8.0; board: esp01_1m) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ PlatformManager: Installing espressif8266 @ 1.8.0 Downloading ... Environment tasmota-TW [SUCCESS] Environment tasmota-UK [SUCCESS] ==================================================================== [SUCCESS] Took 797.56 seconds ==================================================================== That's all, really :D ! PlatformIO seems to handle the rebuilds and dependencies well, but if you want a clean build, the say pio run -t clean first, and then the pio run .","title":"Build the firmware"},{"location":"Create-your-own-Firmware-Build-without-IDE/#collect-the-results","text":"The results will be here: build_output","title":"Collect the results"},{"location":"Create-your-own-Firmware-Build-without-IDE/#about-build-times","text":"The recent versions of PlatformIO-Core seem to parallelise quite well. When you've changed only a few files, not everything needs to be recompiled (though the image must still be re-packed), so that minute-like build time is the maximum, usually it'll be less.","title":"About build times"},{"location":"Create-your-own-Firmware-Build-without-IDE/#prepare-the-local-installer-tool","text":"You may rebuild the firmware on a remote machine, but you must have the installer tool on the local machine where the module is connected to. Fortunately, it's also python-based, so we can again employ virtualenv here. If you built the firmware also on your localhost, then there is no need for a separate environment, you may quite well install esptool into that one. Otherwise, create a virtual environment the usual way: [tasmota_installer@lantash ~]$ virtualenv esptool New python executable in /home/tasmota_installer/esptool/bin/python2.7 Also creating executable in /home/tasmota_installer/esptool/bin/python Installing setuptools, pip, wheel...done. [tasmota_installer@lantash ~]$ cd esptool/ [tasmota_installer@lantash ~/esptool]$ . bin/activate (esptool) [tasmota_installer@lantash ~/esptool]$ pip install --upgrade pip Requirement already up-to-date: pip in ./lib/python2.7/site-packages (18.1) Now let's install esptool : (esptool) [tasmota_installer@lantash ~/esptool]$ pip install esptool Collecting esptool Downloading https://files.pythonhosted.org/packages/5c/85/5654e7b9019739d3d89af0adf528c9ae57a9a26682e3aa012e1e30f20674/esptool-2.6.tar.gz (80kB) 100% |################################| 81kB 222kB/s Collecting pyserial>=3.0 (from esptool) Downloading https://files.pythonhosted.org/packages/0d/e4/2a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30/pyserial-3.4-py2.py3-none-any.whl (193kB) 100% |################################| 194kB 491kB/s Collecting pyaes (from esptool) Downloading https://files.pythonhosted.org/packages/44/66/2c17bae31c906613795711fc78045c285048168919ace2220daa372c7d72/pyaes-1.6.1.tar.gz Collecting ecdsa (from esptool) Downloading https://files.pythonhosted.org/packages/63/f4/73669d51825516ce8c43b816c0a6b64cd6eb71d08b99820c00792cb42222/ecdsa-0.13-py2.py3-none-any.whl (86kB) 100% |################################| 92kB 382kB/s Building wheels for collected packages: esptool, pyaes Running setup.py bdist_wheel for esptool ... done Stored in directory: /home/tasmota_installer/.cache/pip/wheels/cf/1f/62/7ad4e47843affd4f5b7032a39f1ef8a153c6d27533614d21aa Running setup.py bdist_wheel for pyaes ... done Stored in directory: /home/tasmota_installer/.cache/pip/wheels/bd/cf/7b/ced9e8f28c50ed666728e8ab178ffedeb9d06f6a10f85d6432 Successfully built esptool pyaes Installing collected packages: pyserial, pyaes, ecdsa, esptool Successfully installed ecdsa-0.13 esptool-2.6 pyaes-1.6.1 pyserial-3.4 If you've built the firmware on a remote machine, now it's time to download it into this installer environment (e.g. via scp or sftp ). IMPORTANT : For the subsequent steps your user must have the permission to write the serial port.","title":"Prepare the local installer tool"},{"location":"Create-your-own-Firmware-Build-without-IDE/#back-up-the-current-firmware-optional","text":"First of all, disconnect the bulb from the mains and wire up the serial connection and a button on GPIO0. If this GPIO0 is connected to GND when the module gets power, it starts in a firmware-update mode, and you can then read/write its flash storage. Switch off the power of the board, this will be the reference 'steady state' of the system. (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py read_flash 0x00000 0x100000 fcmila_bulb_orig.bin esptool.py v2.6 Found 1 serial ports Serial port /dev/cuaU0 Connecting...... Now, it'll wait for the module to appear connected, so press the button (GPIO0 to GND), keep it pressed switch on the power of the board now you may release the button ... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: bc:dd:c2:e0:2a:f2 Uploading stub... Running stub... Stub running... 1048576 (100 %) Read 1048576 bytes at 0x0 in 95.0 seconds (88.3 kbit/s)... Hard resetting via RTS pin... If all is well, the flash is being dumped, it may take a minute or so. If done, then power the module off , as this management mode is not restartable! If it's not well, then you may try some queries: (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py -p /dev/ttyU0 chip_id ... Chip ID: 0x00e02af2 ... (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py -p /dev/ttyU0 flash_id ... Manufacturer: c8 Device: 4014 Detected flash size: 1MB ... If they don't work, then check your cabling and your serial adapter. Until you can't get this step working, don't proceed to the next one, it won't work either.","title":"Back up the current firmware (optional)"},{"location":"Create-your-own-Firmware-Build-without-IDE/#erase-the-flash","text":"(With the usual button-pressed-power-on rain dance, and don't forget to power the module off afterwards.) (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py erase_flash ... Erasing flash (this may take a while)... Chip erase completed successfully in 1.6s","title":"Erase the flash"},{"location":"Create-your-own-Firmware-Build-without-IDE/#install-the-firmware-to-your-module","text":"(esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py write_flash --flash_size 1MB --flash_mode dout 0x00000 firmware.bin Configuring flash size... Compressed 535424 bytes to 367679... Wrote 535424 bytes (367679 compressed) at 0x00000000 in 33.8 seconds (effective 126.6 kbit/s)... Hash of data verified. Leaving...","title":"Install the firmware to your module"},{"location":"Create-your-own-Firmware-Build-without-IDE/#power-on-for-normal-operation","text":"No button-pressing, power on, and see what you achieved :). The module sends its logs on the serial line at 115200 baud 8N1, so to check the logs: (esptool) [tasmota_installer@lantash ~/esptool]$ cu -s 115200 -l /dev/ttyU0 | tee -a my_sonoff.log Connected <some initial binary data> 00:00:00 CFG: Use defaults 00:00:00 SM16716: ModuleSelected; clk_pin=4, dat_pin=14) 00:00:00 SRC: Restart 00:00:00 SM16716: Entry; function=FUNC_SET_DEVICE_POWER, index=00, payload=02 00:00:00 SM16716: Update; pwr=00, rgb=000000 00:00:00 Project sonoff Sonoff Version 6.4.1.9(sonoff)-2_4_2 00:00:00 SM16716: Entry; function=FUNC_INIT 00:00:00 SM16716: ModuleSelected; clk_pin=4, dat_pin=14) 00:00:00 WIF: Attempting connection... ... (Assuming that you're using FreeBSD. On Linux you set the speed via setserial or stty , and then do the dump with dd . Or just minicom , if you prefer.) Now you have a complete build path from source to device, and a log feedback as well, so you've got everything needed for being able to implement your ideas :D !","title":"Power on for normal operation"},{"location":"DFR0299/","text":"DFRobot DFPlayer Mini MP3 Player ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MP3_PLAYER #define USE_MP3_PLAYER // Use of the DFPlayer Mini MP3 Player RB-DFR-562 commands: play, pause, stop, track, volume and reset #define MP3_VOLUME 30 // Set the startup volume on init, the range can be 0..100(max) #endif Small and low price MP3 module with an simplified output directly to the speaker See manufacturer site for more information. Configuration ~ Wiring ~ DFPlayer ESP GND GND 5V 5V RX GPIO Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIO RX to MP3 Player Available commands","title":"DFRobot DFPlayer Mini MP3 Player"},{"location":"DFR0299/#dfrobot-dfplayer-mini-mp3-player","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MP3_PLAYER #define USE_MP3_PLAYER // Use of the DFPlayer Mini MP3 Player RB-DFR-562 commands: play, pause, stop, track, volume and reset #define MP3_VOLUME 30 // Set the startup volume on init, the range can be 0..100(max) #endif Small and low price MP3 module with an simplified output directly to the speaker See manufacturer site for more information.","title":"DFRobot DFPlayer Mini MP3 Player"},{"location":"DFR0299/#configuration","text":"","title":"Configuration"},{"location":"DFR0299/#wiring","text":"DFPlayer ESP GND GND 5V 5V RX GPIO","title":"Wiring"},{"location":"DFR0299/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIO RX to MP3 Player Available commands","title":"Tasmota Settings"},{"location":"DHT11-Wiring---Sonoff-Basic/","text":"To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see [[Pinouts]]. I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like:","title":"DHT11 Wiring   Sonoff Basic"},{"location":"DHT11/","text":"DHT11 temperature and humidity sensor ~ This feature is included in tasmota , tasmota32 , tasmota-knx and tasmota-display binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DHT #define USE_DHT // Add support for DHT11, AM2301 (DHT21, DHT22, AM2302, AM2321) and SI7021 Temperature and Humidity sensor (1k6 code) #endif DHT11 is a basic, ultra low-cost digital temperature and humidity sensor. It is very inaccurate and surpassed by others (AM2301, BME280, ...) thus not recommended by the Tasmota team. Configuration ~ Wiring ~ DHT11 ESP - GND OUT GPIOx + 3.3V Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to DHT11 After reboot of the device the temperature and humidity are displayed. Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Wemos DHT11 Shield ~ Note: this is ONLY for v1.0.0 of the DHT11 shield, since v2.0.0 uses I 2 C and pinned differently. From the Wemos DHT11 shield specs the DATA OUT pin is connected to D4 of the Wemos. Note: Having the shield compact on top of the processor increases the temperature. In normal Mode this can be up to 6\u00b0C. So you should add sleep mode. Adding normal \"Sleep 100\" and putting the sensor vertically reduces the temperature difference to 2\u00b0C Sonoff Basic specific ~ To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see GPIO Locations . I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like: OpenHab ~ sonoff.items: // DHT-6 Number DHT6_Temp \"Bathroom DHT-6 [%.1f \u00b0C]\" <temperature> (gTemperature,gTemperatureRoom) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Temperature)]\" } Number DHT6_Humidity \"Bathroom DHT-6 [%.1f %%]\" <humidity> (gHumidity) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Humidity)]\" } Switch DHT6_Reachable \"DHT-6 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-dht-6/LWT:state:MAP(reachable.map)]\" } Number DHT6_RSSI \"DHT-6 RSSI [%d %%]\" <qualityofservice> (gRSSI) { mqtt=\"<[broker:tele/sonoff-dht-6/STATE:state:JSONPATH($.Wifi.RSSI)]\" } sonoff.sitemap Frame { Text item=DHT6_Temp labelcolor=[DHT6_Reachable == \"ON\" = \"green\",DHT6_Reachable == \"OFF\" = \"red\"] { Text item=DHT6_Temp Text item=DHT6_Humidity Text item=DHT6_Reachable Text item=DHT6_RSSI } } Printable Housing ~ https://www.thingiverse.com/thing:2814909","title":"DHT11 temperature and humidity sensor"},{"location":"DHT11/#dht11-temperature-and-humidity-sensor","text":"This feature is included in tasmota , tasmota32 , tasmota-knx and tasmota-display binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DHT #define USE_DHT // Add support for DHT11, AM2301 (DHT21, DHT22, AM2302, AM2321) and SI7021 Temperature and Humidity sensor (1k6 code) #endif DHT11 is a basic, ultra low-cost digital temperature and humidity sensor. It is very inaccurate and surpassed by others (AM2301, BME280, ...) thus not recommended by the Tasmota team.","title":"DHT11 temperature and humidity sensor"},{"location":"DHT11/#configuration","text":"","title":"Configuration"},{"location":"DHT11/#wiring","text":"DHT11 ESP - GND OUT GPIOx + 3.3V","title":"Wiring"},{"location":"DHT11/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to DHT11 After reboot of the device the temperature and humidity are displayed.","title":"Tasmota Settings"},{"location":"DHT11/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"DHT11/#wemos-dht11-shield","text":"Note: this is ONLY for v1.0.0 of the DHT11 shield, since v2.0.0 uses I 2 C and pinned differently. From the Wemos DHT11 shield specs the DATA OUT pin is connected to D4 of the Wemos. Note: Having the shield compact on top of the processor increases the temperature. In normal Mode this can be up to 6\u00b0C. So you should add sleep mode. Adding normal \"Sleep 100\" and putting the sensor vertically reduces the temperature difference to 2\u00b0C","title":"Wemos DHT11 Shield"},{"location":"DHT11/#sonoff-basic-specific","text":"To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see GPIO Locations . I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like:","title":"Sonoff Basic specific"},{"location":"DHT11/#openhab","text":"sonoff.items: // DHT-6 Number DHT6_Temp \"Bathroom DHT-6 [%.1f \u00b0C]\" <temperature> (gTemperature,gTemperatureRoom) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Temperature)]\" } Number DHT6_Humidity \"Bathroom DHT-6 [%.1f %%]\" <humidity> (gHumidity) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Humidity)]\" } Switch DHT6_Reachable \"DHT-6 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-dht-6/LWT:state:MAP(reachable.map)]\" } Number DHT6_RSSI \"DHT-6 RSSI [%d %%]\" <qualityofservice> (gRSSI) { mqtt=\"<[broker:tele/sonoff-dht-6/STATE:state:JSONPATH($.Wifi.RSSI)]\" } sonoff.sitemap Frame { Text item=DHT6_Temp labelcolor=[DHT6_Reachable == \"ON\" = \"green\",DHT6_Reachable == \"OFF\" = \"red\"] { Text item=DHT6_Temp Text item=DHT6_Humidity Text item=DHT6_Reachable Text item=DHT6_RSSI } }","title":"OpenHab"},{"location":"DHT11/#printable-housing","text":"https://www.thingiverse.com/thing:2814909","title":"Printable Housing"},{"location":"DS18x20/","text":"DS18x20 temperature sensor ~ This feature is included in tasmota , tasmota32 , tasmota-knx and tasmota-display binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DS18x20 #define USE_DS18x20 // Add support for DS18x20 sensors with id sort, single scan and read retry (+2k6 code) // #define W1_PARASITE_POWER // Optimize for parasite powered sensors #endif DS18x20 driver supports DS18B20 , DS18S20 , DS1822 and MAX31850 1-Wire digital temperature sensors. Configuration ~ Wiring ~ DS18b20 ESP 1 GND GND 2 Data GPIOx 3 VCC 3.3v Warning: DS18x20 will not work on GPIO16 You need to connect a 4.7K pullup resistor from data to 3.3V. Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to DS18x20 After a reboot the driver will display Temperature. Shelly 1 Temperature Addon ~ Shelly dual pin mode is supported by an additional pin assignment: GPIOy to DS18x20-o Commands ~ SetOption74 may be used to enable/disable internal pullup when using a single DS18x20 sensor (for multiple sensors, you have to use an external pullup resistor). SetOption126 Enable arithmetic mean over teleperiod for JSON temperature for DS18x20 sensors. TempRes Temperature sensor resolution: 0..3 = maximum number of decimal places. TempOffset can be used to add/sub an offset to the measured temperature. This setting affects all temperature sensors on the device. Multiple Sensors ~ Tasmota supports multiple DS18x20 sensors connected to a single ESP8266 chip using a single GPIO (multiple DS18x20 GPIO are not supported). The default maximum is set to 8 ( driver code ). It is possible to override this number in user_config_override.h by adding a line with #define DS18X20_MAX_SENSORS <new-value> (ESP8266 only). However one should take into account that: Display on the console is limited and SENSOR log will be truncated above 11 DS18x20. MQTT buffer length is limited and SENSOR message will be truncated above 18 DS18x20. Even less if other sensors are attached to the ESP device and present in the SENSOR message. 1-wire has been designed to be a board-bus, not to run through long distances across a whole house. At minimum, use a shielded cable. Note If you increase the value above default, you are on your own. No support will be provided. Every sensors will get a unique ID used in webUI and MQTT telemetry. { \"Time\" : \"2021-01-02T09:09:44\" , \"DS18B20-1\" :{ \"Id\" : \"00000566CC39\" , \"Temperature\" : 13.3 }, \"DS18B20-2\" :{ \"Id\" : \"0000059352D4\" , \"Temperature\" : 1.2 }, \"DS18B20-3\" :{ \"Id\" : \"000005937C90\" , \"Temperature\" : 22.5 }, \"TempUnit\" : \"C\" } Compile Options ~ There are some compile options ( driver code ): USE_DS18x20_RECONFIGURE : When sensor is lost keep retrying or re-configure DS18x20_USE_ID_AS_NAME : Use last 3 bytes for naming of sensors Sensor Versions ~ Pinout when looking at the flat side of the TO-92 package sensor: GND, Signal, VDD. Pinout of the wired sensor: black: GND; yellow or white: Signal, red: VDD THR316D/THR320D Wiring Notes ~ 4P4C RJ11 pin ESP DS18b20 1 (Yellow on image) 3V3 GPIO27 providing 3V3 Red on wired sensor 2 (Green on image) GPIO25 data Yellow or White on wired sensor 3 (Red on image) NC 4 (Black on image) GND Black on wired sensor ESP-01 Wiring Notes ~ Danger BEWARE OF MANY VISUALLY SIMILAR BOARDS TO THIS RELAY BOARD but different schematics Some modules have culprits: * \"CH_PD\" is not set to HI (3.3V) as actually required. Usually this is done with a 10K resistor or directly to 3.3V, I have connected directly to the 3.3V * A resistor (R2 10k) which is connected between the terminal GPIO0 to ground. This ensures that the GPIO0 is always pulled to ground, which actually places the ESP-01 in program mode (flashing). To make the module working it is necessary to remove (solder out). Connect DS18B20 to the GPIO2 (see diagram below - soldering not necessary , it is possible to put the wires and the resistor directly in to the female part of the connector together with ESP 01S module pins) After flashing, set up Tasmota (see images below): * \"Generic module\" * GPIO0 as Relay 1 * GPIO2 as DS18x20 Rule Triggers ~ The following trigger events are supported for use in Rules : Single sensor attached: ON DS1820#Temperature DO <command> ENDON Multiple sensors attached: ON DS1820_1#Temperature DO <command> ENDON ON DS1820_2#Temperature DO <command> ENDON ON DS1820_3#Temperature DO <command> ENDON ON DS1820_..#Temperature DO <command> ENDON Example: ON DS1820_1#Temperature!=%Var1% DO backlog publish espTempertature/sensor/DS1820_1/data %value%; Var1 %value% ENDON","title":"DS18x20 temperature sensor"},{"location":"DS18x20/#ds18x20-temperature-sensor","text":"This feature is included in tasmota , tasmota32 , tasmota-knx and tasmota-display binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DS18x20 #define USE_DS18x20 // Add support for DS18x20 sensors with id sort, single scan and read retry (+2k6 code) // #define W1_PARASITE_POWER // Optimize for parasite powered sensors #endif DS18x20 driver supports DS18B20 , DS18S20 , DS1822 and MAX31850 1-Wire digital temperature sensors.","title":"DS18x20 temperature sensor"},{"location":"DS18x20/#configuration","text":"","title":"Configuration"},{"location":"DS18x20/#wiring","text":"DS18b20 ESP 1 GND GND 2 Data GPIOx 3 VCC 3.3v Warning: DS18x20 will not work on GPIO16 You need to connect a 4.7K pullup resistor from data to 3.3V.","title":"Wiring"},{"location":"DS18x20/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to DS18x20 After a reboot the driver will display Temperature.","title":"Tasmota Settings"},{"location":"DS18x20/#commands","text":"SetOption74 may be used to enable/disable internal pullup when using a single DS18x20 sensor (for multiple sensors, you have to use an external pullup resistor). SetOption126 Enable arithmetic mean over teleperiod for JSON temperature for DS18x20 sensors. TempRes Temperature sensor resolution: 0..3 = maximum number of decimal places. TempOffset can be used to add/sub an offset to the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"DS18x20/#multiple-sensors","text":"Tasmota supports multiple DS18x20 sensors connected to a single ESP8266 chip using a single GPIO (multiple DS18x20 GPIO are not supported). The default maximum is set to 8 ( driver code ). It is possible to override this number in user_config_override.h by adding a line with #define DS18X20_MAX_SENSORS <new-value> (ESP8266 only). However one should take into account that: Display on the console is limited and SENSOR log will be truncated above 11 DS18x20. MQTT buffer length is limited and SENSOR message will be truncated above 18 DS18x20. Even less if other sensors are attached to the ESP device and present in the SENSOR message. 1-wire has been designed to be a board-bus, not to run through long distances across a whole house. At minimum, use a shielded cable. Note If you increase the value above default, you are on your own. No support will be provided. Every sensors will get a unique ID used in webUI and MQTT telemetry. { \"Time\" : \"2021-01-02T09:09:44\" , \"DS18B20-1\" :{ \"Id\" : \"00000566CC39\" , \"Temperature\" : 13.3 }, \"DS18B20-2\" :{ \"Id\" : \"0000059352D4\" , \"Temperature\" : 1.2 }, \"DS18B20-3\" :{ \"Id\" : \"000005937C90\" , \"Temperature\" : 22.5 }, \"TempUnit\" : \"C\" }","title":"Multiple Sensors"},{"location":"DS18x20/#compile-options","text":"There are some compile options ( driver code ): USE_DS18x20_RECONFIGURE : When sensor is lost keep retrying or re-configure DS18x20_USE_ID_AS_NAME : Use last 3 bytes for naming of sensors","title":"Compile Options"},{"location":"DS18x20/#sensor-versions","text":"Pinout when looking at the flat side of the TO-92 package sensor: GND, Signal, VDD. Pinout of the wired sensor: black: GND; yellow or white: Signal, red: VDD","title":"Sensor Versions"},{"location":"DS18x20/#thr316dthr320d-wiring-notes","text":"4P4C RJ11 pin ESP DS18b20 1 (Yellow on image) 3V3 GPIO27 providing 3V3 Red on wired sensor 2 (Green on image) GPIO25 data Yellow or White on wired sensor 3 (Red on image) NC 4 (Black on image) GND Black on wired sensor","title":"THR316D/THR320D Wiring Notes"},{"location":"DS18x20/#esp-01-wiring-notes","text":"Danger BEWARE OF MANY VISUALLY SIMILAR BOARDS TO THIS RELAY BOARD but different schematics Some modules have culprits: * \"CH_PD\" is not set to HI (3.3V) as actually required. Usually this is done with a 10K resistor or directly to 3.3V, I have connected directly to the 3.3V * A resistor (R2 10k) which is connected between the terminal GPIO0 to ground. This ensures that the GPIO0 is always pulled to ground, which actually places the ESP-01 in program mode (flashing). To make the module working it is necessary to remove (solder out). Connect DS18B20 to the GPIO2 (see diagram below - soldering not necessary , it is possible to put the wires and the resistor directly in to the female part of the connector together with ESP 01S module pins) After flashing, set up Tasmota (see images below): * \"Generic module\" * GPIO0 as Relay 1 * GPIO2 as DS18x20","title":"ESP-01 Wiring Notes"},{"location":"DS18x20/#rule-triggers","text":"The following trigger events are supported for use in Rules : Single sensor attached: ON DS1820#Temperature DO <command> ENDON Multiple sensors attached: ON DS1820_1#Temperature DO <command> ENDON ON DS1820_2#Temperature DO <command> ENDON ON DS1820_3#Temperature DO <command> ENDON ON DS1820_..#Temperature DO <command> ENDON Example: ON DS1820_1#Temperature!=%Var1% DO backlog publish espTempertature/sensor/DS1820_1/data %value%; Var1 %value% ENDON","title":"Rule Triggers"},{"location":"DS3231/","text":"DS3231 Real Time Clock ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DS3231 #define USE_DS3231 // [I2cDriver26] Enable DS3231 RTC (I2C address 0x68) (+1k2 code) #endif If you use a DS3231 with a different I 2 C address, uncomment and change your address with: #define USE_RTC_ADDR 0x68 Tasmota requires that it's system time is set in order to use timers. Usually, when the device boots, it gets the time and date from an an NTP (Network Time Protocol) server located somewhere on the Internet. When there is no Internet connection, Tasmota is not able to request the current date and time. The DS3231 is an external Real Time Clock (RTC) component used for keeping the time and date set in the device when it cannot establish an Internet connection. Optionally, the Time command is available to manually set date and time for the real time clock. The DS3231 will evaluate this time and sync to it if date is later than Jan 1, 2016. Note that the Time command will disable NTP sync, and the real time clock will drift based on the accuracy of the DS3231 module. The DS3231 driver includes a simple NTP server based on the code used for the GPS driver. It will respond to NTP requests on the standard port 123 as a stratum 1 server. This is useful as a backup time source for network devices if internet access is unavailable. NTP server can be activated with the command Sensor33 1 and deactivated with Sensor33 0 Configuration ~ Wiring ~ DS3231 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL Wiring on D1 mini ~ Tasmota Settings ~ Any time your device has an NTP connection, the DS3231 internal clock will be set automatically. The first time RTC is used, you must have an Internet connection . From that point forward, the time is stored in the RTC and the device time will be restored from the RTC when there is no Internet connection. You can use your mobile phone hotspot for your device in a location where it can't get a Wi-Fi connection Check that the time is set correctly by inspecting the log in the Console. You should see messages that Tasmota read or wrote the time from and to the DS3231. Make sure that the time is set correctly even when you do not have Internet connection .","title":"DS3231 Real Time Clock"},{"location":"DS3231/#ds3231-real-time-clock","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DS3231 #define USE_DS3231 // [I2cDriver26] Enable DS3231 RTC (I2C address 0x68) (+1k2 code) #endif If you use a DS3231 with a different I 2 C address, uncomment and change your address with: #define USE_RTC_ADDR 0x68 Tasmota requires that it's system time is set in order to use timers. Usually, when the device boots, it gets the time and date from an an NTP (Network Time Protocol) server located somewhere on the Internet. When there is no Internet connection, Tasmota is not able to request the current date and time. The DS3231 is an external Real Time Clock (RTC) component used for keeping the time and date set in the device when it cannot establish an Internet connection. Optionally, the Time command is available to manually set date and time for the real time clock. The DS3231 will evaluate this time and sync to it if date is later than Jan 1, 2016. Note that the Time command will disable NTP sync, and the real time clock will drift based on the accuracy of the DS3231 module. The DS3231 driver includes a simple NTP server based on the code used for the GPS driver. It will respond to NTP requests on the standard port 123 as a stratum 1 server. This is useful as a backup time source for network devices if internet access is unavailable. NTP server can be activated with the command Sensor33 1 and deactivated with Sensor33 0","title":"DS3231 Real Time Clock"},{"location":"DS3231/#configuration","text":"","title":"Configuration"},{"location":"DS3231/#wiring","text":"DS3231 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"DS3231/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL","title":"Tasmota Settings"},{"location":"DS3231/#tasmota-settings_1","text":"Any time your device has an NTP connection, the DS3231 internal clock will be set automatically. The first time RTC is used, you must have an Internet connection . From that point forward, the time is stored in the RTC and the device time will be restored from the RTC when there is no Internet connection. You can use your mobile phone hotspot for your device in a location where it can't get a Wi-Fi connection Check that the time is set correctly by inspecting the log in the Console. You should see messages that Tasmota read or wrote the time from and to the DS3231. Make sure that the time is set correctly even when you do not have Internet connection .","title":"Tasmota Settings"},{"location":"DY-SV17F/","text":"DY-SV17F MP3 Player module ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DY_SV17F #define USE_DY_SV17F // Use of DY-SV17F MP3 Player commands: play, stop, track and volume #define MP3_VOLUME 30 // Set the startup volume on init, the range can be 0..100(max) #endif The DY-SV17F MP3 Player module has 4MBytes of internal flash storage for audio files you can upload via USB. An onboard 5W amplifier can power 4, 3-5W speakers Configuration ~ Wiring ~ DY-SV17F ESP GND GND 5V 5V RX GPIO Commands ~ Command Parameters MP3Play Play, works as a normal play on a real MP3 Player, starts at first MP3 file MP3Stop Stop MP3Track x = play track <x> MP3Volume 0..100 = set Volume Datasheet","title":"DY-SV17F MP3 Player module"},{"location":"DY-SV17F/#dy-sv17f-mp3-player-module","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DY_SV17F #define USE_DY_SV17F // Use of DY-SV17F MP3 Player commands: play, stop, track and volume #define MP3_VOLUME 30 // Set the startup volume on init, the range can be 0..100(max) #endif The DY-SV17F MP3 Player module has 4MBytes of internal flash storage for audio files you can upload via USB. An onboard 5W amplifier can power 4, 3-5W speakers","title":"DY-SV17F MP3 Player module"},{"location":"DY-SV17F/#configuration","text":"","title":"Configuration"},{"location":"DY-SV17F/#wiring","text":"DY-SV17F ESP GND GND 5V 5V RX GPIO","title":"Wiring"},{"location":"DY-SV17F/#commands","text":"Command Parameters MP3Play Play, works as a normal play on a real MP3 Player, starts at first MP3 file MP3Stop Stop MP3Track x = play track <x> MP3Volume 0..100 = set Volume Datasheet","title":"Commands"},{"location":"DeepSleep/","text":"DeepSleep support for up to 10 years (i.e., 86,400 seconds = 1 day) (e.g., if used with KNX) ( DeepSleepTime ). DeepSleepTime sets the time the device remains in DeepSleep before it returns to full operating mode. Once the command is issued, the DeepSleep cycle commences. During DeepSleep, the device is effectively off and, as such, it is not possible to modify DeepSleepTime without exiting DeepSleep. Example With DeepSleepTime 3600 , the device will wake up exactly every hour (e.g., 8:00am, 9:00am, ...). If you define DeepSleepTime 86400 (i.e., 60*60*24), it will wake-up exactly at 0:00 local time. There is no option to shift the wakeup time; except changing the timezone. If you define DeepSleepTime 600 , it will wake-up every 10 minutes (e.g., 8:00, 8:10, 8:20, ...). Warning Please be aware that the minimum DeepSleep time is 10 seconds. In order for the device to wake itself to perform its function during the DeepSleep cycle, the RST pin must be connected to the D0/GPIO16 pin. This is the only pin which can perform this function as the wake-up signal is sent from the RTC through D0/GPIO16 to RST. When connected to RST for DeepSleep purpose, GPIO16 may not be used for other functions. As such, it is recommended to leave it configured as None (0) . On the diagram, black denotes existing parts and connections on a standard ESP board (mini-D1, NodeMCU, ...). Red denotes what is added to the DeepSleep feature. Methods to (temporarly) disable DeepSleep mode ~ Using a switch ~ Select another GPIO (let's call it \"GPIOn\") and connect it GND. This can be performed through a switch per the schematic below. Flipping the switch to \"ON\" will prevent Tasmota to enter DeepSleep again after next wake-up until the switch is flipped back OFF. On the diagram, blue denotes additional parts and connections to be able to disableDeepSleep. GPIOn should be defined as DeepSleep (182) in the configuration as shown below: The following GPIOs CANNOT be used for the purpose of temporarily disabling DeepSleep as described above: - GPIO16 (because it is connected to RST), - GPIO15 (because of an existing on-board pull-down resistor), - GPIO0 (because pulling it down at wake up will enter serial bootload mode). All others GPIO should be acceptable. An interresting use-case is to disable DeepSleep when external power (USB, PSU, solar panel...) is applied to the device using a transistor. If the device is not (easily) accessible, methods can be used to disable the DeepSleep loop without physical access. Using MQTT ~ Send a retained DeepSleepTime 0 command to your device. As the message is retained in the MQTT broker, the device will receive it as soon as it connectes to the MQTT broker. Example: Sending from another Tasmota In another Tasmota console you can type the following command: Publish2 cmnd/%topic%/DeepSleepTime 0 To clear the retained message, once your device is out of DeepSleep, use: Publish2 cmnd/%topic%/DeepSleepTime Example: Sending using mosquitto utilities Command to send a retained message: mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -m \"0\" Remove retained message mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -n You can also send retained message or clear them with other MQTT tools: MQTT Explorer, .... Once you have made your configuration change, you will need to re-enable DeepSleep mode using DeepSleepTime command. Using smart home automation ~ Configure a settable flag in your home automation hub (e.g., Node-Red, openHAB, Home Assistant). The flag should subscribe to the tele/%topic%/LWT topic for the payload Online . Alternatively, if testing the payload value is not easy, subscribe to the topic tele/%topic%/STATE which is the 2nd topic on which the device publish right after waking-up. The moment a message is received on this topic, the automation can publish a message to topic cmnd/%topic%/DeepSleepTime with payload 0 . This will cause the device to disable DeepSleep and allow maintenance such as firmware updates to be performed without having an unexpected DeepSleep event. Send the DeepSleepTime 0 command only once . Once device maintenance is completed, place it back into DeepSleep mode using original configuration. Rules ~ The following triggers can be used to execute commands upon wake-up or right before entering DeepSleep: - Power1#Boot : is the earliest trigger. But valid only if you have a Relay output defined. - Switch1#Boot : is the next trigger, also occur very early in the boot process. But valid only if you have Switch input defined. - System#Boot : is occuring later in the Tasmota boot process but is always available. - System#Save : is occuring right before a restart or before entering DeepSleep. For example the ruleset below turn on power right after Tasmota started, and turn it off just before entering DeepSleep Rule1 ON Power1#Boot DO Power on ENDON ON System#Save DO Power off ENDON Any rule apply AFTER the Init() procedures of all sensors/drivers. This does mean that a POWER OFF on the GPIO may prevent sensors from being initialized correctly during start-up (e.g. DS18B20) and do not show up in teleperiod message. To ensure the GPIO is HIGH during restart you should define in the Configure --> Configure module --> GPIO x to Output Hi instead of RELAY 1 and avoid using any rules. To ensure the GPIO goes LOW after deepsleep you need to solder a 4.7K resistor between GND and the GPIO. Sequence is then as follow (only key lines are shown): 00:00:00.085 CFG: Loaded from File, Count 122 00:00:00.095 Project tasmota demo-sensor Version 9.5.0(tasmota-sensors) 00:00:00.105 RUL: POWER1#BOOT performs \"Power ON\" 00:00:00.109 RSL: POWER = {\"POWER\":\"ON\"} 00:00:00.111 RSL: POWER = ON 00:00:04.454 WIF: Connecting to AP1 DEMOAP Channel 1 BSSId XX:XX:XX:XX:XX:XX in mode 11n as demo-sensor... 00:00:05.756 WIF: Connected 00:00:06.008 HTP: Web server active on dev-4119 with IP address 192.168.168.199 15:03:40.010 MQT: Attempting connection... 15:03:40.024 MQT: Connected 15:03:40.028 MQT: tele/demo-sensor/LWT = Online (retained) 15:03:40.032 MQT: cmnd/demo-sensor/POWER = 15:03:40.047 MQT: stat/demo-sensor/POWER = {\"POWER\":\"ON\"} 15:03:40.050 MQT: stat/demo-sensor/POWER = ON (retained) 15:03:44.472 MQT: tele/demo-sensor/STATE = {\"Time\":\"2021-06-27T15:03:44+02:00\",\"Uptime\":\"0T00:00:13\",\"UptimeSec\":13,\"Heap\":28,\"SleepMode\":\"Dynamic\",\"Sleep\":50,\"LoadAvg\":19,\"MqttCount\":1,\"POWER\":\"ON\",\"Wifi\":{\"AP\":1,\"SSId\":\"DEMOAP\",\"BSSId\":\"XX:XX:XX:XX:XX:XX\",\"Channel\":1,\"Mode\":\"11n\",\"RSSI\":86,\"Signal\":-57,\"LinkCount\":1,\"Downtime\":\"0T00:00:07\"}} 15:03:44.500 MQT: tele/demo-sensor/SENSOR = {\"Time\":\"2021-06-27T15:03:44+02:00\",\"Switch1\":\"OFF\",\"Switch2\":\"ON\"} (retained) 15:03:44.515 RUL: SYSTEM#SAVE performs \"Power OFF\" 15:03:44.524 MQT: stat/demo-sensor/POWER = {\"POWER\":\"OFF\"} 15:03:44.527 MQT: stat/demo-sensor/POWER = OFF (retained) 15:03:44.539 MQT: stat/demo-sensor/DEEPSLEEP = {\"DeepSleep\":{\"Time\":\"2021-06-27T15:04:00\",\"Epoch\":1624799040}} 15:03:47.433 APP: Sleeping Driver writer: Executing commands before entering DeepSleep ~ When writing a driver for a sensor, if the sensor supports a low power mode, it is a good practice to set the sensor in such low power mode in the FUNC_SAVE_BEFORE_RESTART handler. When Tasmota will restart at next wake-up, sensor will be automatically re-initialized. Exemple from xsns_09_bmp.ino : #ifdef USE_DEEPSLEEP case FUNC_SAVE_BEFORE_RESTART : BMP_EnterSleep (); break ; #endif // USE_DEEPSLEEP In general you can also execute any command or special script BEFORE device goes into DeepSleep using handler FUNC_SAVE_BEFORE_RESTART as a predefined hook to implement your own procedure. This requires you to code your own function and self-compile custom firmware. Overcome network issues ~ If the device is not able to make a WIFI connection and get an IP during the first 15 seconds after boot it will go again without any further actions into deepsleep for another cycle. If you compile your own firmware you can change the timeout (e.g. 30 seconds) by setting #define DEEPSLEEP_NETWORK_TIMEOUT 30 in user_config.override or disable completly (device stay online until network connected) with #define DEEPSLEEP_NETWORK_TIMEOUT 0 . If MQTT or NTP does not work the TELEPERIOD will execute anyhow and send the device to deepsleep afterwards. A wrong NTP will result in wrong timestamp send to MQTT. A missing MQTT connection will avoid any send. Another method to send the device into deepsleep after start is creating a rule like the one below. In this case the timeout can be configured online and changed. Rule1 ON Dimmer#Boot DO RuleTimer1 30 ENDON ON Rules#Timer=1 DO DeepSleepTime 3600 ENDON Rule1 ON DeepSleep Algorithm General Timing ~ Let's assume you have set DeepSleepTime 3600 (one hour) and TelePeriod 300 (five minutes). The device will first wake at 8:00 am. The device will boot and connect Wi-Fi. Next, the correct time must be sync'ed from one of the NTP servers. Now the device has all prerequisites for going into DeepSleep. DeepSleep is then triggered after the TelePeriod event. In this example, it will occur after five minutes. Telemetry will be collected and sent (e.g., via MQTT). Now, DeepSleep can happen. First, Offline is published to the LWT topic on MQTT. It then calculates the new sleeping time to wake-up at 9:00 am (3600 seconds after the last wake-up). At 9:00 am this same sequence of events happens again. If you want to minimize the time that the device is in operation, decrease TelePeriod down to 10 seconds. This period of time is counted after MQTT is connected. Also, in this case, the device will wake up at 9:00 am even if the uptime was much smaller. If the device missed a wake-up it will try a start at the next event - in this case 10:00 am. ESP8266 DeepSleep Side-effects ~ Not all GPIO behave the same during DeepSleep. Some GPIO go HIGH, some LOW, some FOLLOW the relay but work only on FET transistors. As soon as current flows they go LOW. I use one GPIO to trigger a BC337 transistor to switch OFF all connected devices during DeepSleep. Findings: Pin GPIO Behavior D0 16 Excluded due to use as wake-up pin D1 5 KEEP STATE, go LOW if resistance to ground < infinite D2 4 KEEP STATE, go LOW if resistance to ground < infinite D3 0 HIGH D4 2 HIGH D5 14 HIGH, go LOW if resistance to ground < infinite D6 12 HIGH, go LOW if resistance to ground < infinite D7 13 HIGH, go LOW if resistance to ground < infinite D8 15 LOW Log Output Explanation ~ (logging level 4 ) When MQTT connects at 13:08:38 , this sets the system to READY. 13:08:43 MQT: tele/tasmota/INFO3 = {\"RestartReason\":\"Deep-Sleep Wake\"} 13:08:44 APP: Boot Count 3 13:08:44 CFG: Saved to flash at F4, Count 96, Bytes 3824 In the context of DeepSleep, maintaining a device boot count is not relevant. When DeepSleep is enabled, boot count will not be incremented. This avoids excessive flash writes which will deteriorate the flash memory chip and eventually cause the device to fail. Boot count incrementing can be enabled using SetOption76 . In this example, TelePeriod is 10. Therefore when it is reached, telemetry reporting occurs. 13:08:48 MQT: tele/tasmota/STATE = {\"Time\":\"2019-09-04T13:08:48\",\"Epoch\":1567595328,\"Uptime\":\"0T00:00:14\",\"UptimeSec\":14,\"Heap\":24,\"SleepMode\":\"Dynamic\",\"Sleep\":50,\"LoadAvg\":20,\"MqttCount\":1,\"Wifi\":{\"AP\":1,\"SSId\":\"MyWLAN\",\"BSSId\":\"AA:FF:AA:AA:AA:AA\",\"Channel\":11,\"RSSI\":100,\"LinkCount\":1,\"Downtime\":\"0T00:00:08\",\"DeepSleep\":300,\"Heap\":25160}} 13:08:48 MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-09-04T13:08:48\",\"Epoch\":1567595328,\"ANALOG\":{\"A0\":8}} Date and time is set, status and telemetry sent. Now start shutdown procedure. First, send MQTT offline. 13:08:48 MQT: state/sonoff/LWT = Offline DeepSleep is 300 seconds. Therefore +-30 sec is allowed as deviation between proposed wake-up time and real wake-up time. Reporting in 0.1sec. In this case wake-up was one second late. 13:08:48 Timeslip 0.1 sec:? -300 < -10 < 300 If the error is in the range, this is tagged as a normal wake up where drift can be recalculated 13:08:48 Normal deepsleep? 1 Recalculate a new drift that is a multiplier for the next wake-up in 1/10000. In this case, the multiplier is 1.0257 13:08:48 % RTC new drift 10257 And for information: New target wake-up time 13:08:48 Next wakeup 2019-09-04T13:10:00 Based on run time and the error in the last loop, a new sleeping time will be calculated. This will be multiplied by the deepsleep_slip and, ideally, the device will wake up at the time above. 13:08:48 Sleeptime 285 sec, deepsleep_slip 10257 The effectiveness of the compensation can be seen here. Instead of typically 160-200 seconds, most times it is better than 10 seconds in a one hour DeepSleep cycle. Rules to adapt DeepSleep period to battery level. ~ In some applications, it is interresting to adjust the DeepSleep period to the level of the battery. For this, we consider that: the battery level is measured by the ESP ADC with the appropriate voltage divider, the Tasmota ADC mode is set to Range mode, AdcParams 6 has been used so the range value represent the battery voltage in millivolts The below graph represent the adaptation paths we want to follow to adjust DeepSleepTime: one path while the level is dropping, another path while the level is rising. To implement this in Tasmota we can use Rules . As Rules do not provide an AND operator, we also need the optional IF feature. This requires to compile a customized firmware with the following items in user_config_override.h : #define USE_RULES #define SUPPORT_IF_STATEMENT First, we need to know the current value of DeepSleepTime. Values for internal settings are not available as %variable% but they can generally be obtained by sending the command and capturing the result with a rule. To get the current value of DeepSleepTime, we need a trigger early in the boot process. For example Wifi#Connected . Our first rules to get the current DeepSleepTime into %var1% would be: ON Wifi#Connected DO Backlog DeepSleepTime ENDON ON DeepSleepTime#Data DO var1 %value% ENDON The best moment to compare the batery level and decide if it is necessary to change the DeepSleepTime is right after the TelePeriod SENSOR message has been sent, which is just before Tasmota calculate the next wake-up time. So we can use tele-ANALOG#Range as a trigger for our rules. Using BREAK allows to compare the trigger only to the upper value of the segment and stop further rules evaluations if the comparison is met. In the rule statement for a given battery level, we compare the current value of DeepSleepTime (which is %var1%) with the value we vant (given by the graph). If the current value is lower than the value we want, we are on the decreasing path and we can apply the new value. If the current value is greater than the value we want, we are on the rising path and we can apply the new value. All above can be set into Rule1. As it is a long command, it may be necessary to enter the rule in 2 parts (note the usage of the + ) : Rule1 on Wifi#Connected do backlog deepsleeptime endon on deepsleeptime#data do var1 %value% endon on tele-Analog#Range<3450 do if (%var1%<3600) deepsleeptime 3600 endif break on tele-Analog#Range<3650 do if (%var1%<1800) deepsleeptime 1800 endif break Rule1 +on tele-Analog#Range<3800 do if (%var1%<900) deepsleeptime 900 elseif (%var1%>1800) deepsleeptime 1800 endif break on tele-Analog#Range<4000 do if (%var1%>900)deepsleeptime 900 endif break on tele-Analog#Range>=4000 do if (%var1%> 600) deepsleeptime 600 endif endon Don't forget to enable using Rule1 1","title":"DeepSleep"},{"location":"DeepSleep/#methods-to-temporarly-disable-deepsleep-mode","text":"","title":"Methods to (temporarly) disable DeepSleep mode"},{"location":"DeepSleep/#using-a-switch","text":"Select another GPIO (let's call it \"GPIOn\") and connect it GND. This can be performed through a switch per the schematic below. Flipping the switch to \"ON\" will prevent Tasmota to enter DeepSleep again after next wake-up until the switch is flipped back OFF. On the diagram, blue denotes additional parts and connections to be able to disableDeepSleep. GPIOn should be defined as DeepSleep (182) in the configuration as shown below: The following GPIOs CANNOT be used for the purpose of temporarily disabling DeepSleep as described above: - GPIO16 (because it is connected to RST), - GPIO15 (because of an existing on-board pull-down resistor), - GPIO0 (because pulling it down at wake up will enter serial bootload mode). All others GPIO should be acceptable. An interresting use-case is to disable DeepSleep when external power (USB, PSU, solar panel...) is applied to the device using a transistor. If the device is not (easily) accessible, methods can be used to disable the DeepSleep loop without physical access.","title":"Using a switch"},{"location":"DeepSleep/#using-mqtt","text":"Send a retained DeepSleepTime 0 command to your device. As the message is retained in the MQTT broker, the device will receive it as soon as it connectes to the MQTT broker. Example: Sending from another Tasmota In another Tasmota console you can type the following command: Publish2 cmnd/%topic%/DeepSleepTime 0 To clear the retained message, once your device is out of DeepSleep, use: Publish2 cmnd/%topic%/DeepSleepTime Example: Sending using mosquitto utilities Command to send a retained message: mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -m \"0\" Remove retained message mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -n You can also send retained message or clear them with other MQTT tools: MQTT Explorer, .... Once you have made your configuration change, you will need to re-enable DeepSleep mode using DeepSleepTime command.","title":"Using MQTT"},{"location":"DeepSleep/#using-smart-home-automation","text":"Configure a settable flag in your home automation hub (e.g., Node-Red, openHAB, Home Assistant). The flag should subscribe to the tele/%topic%/LWT topic for the payload Online . Alternatively, if testing the payload value is not easy, subscribe to the topic tele/%topic%/STATE which is the 2nd topic on which the device publish right after waking-up. The moment a message is received on this topic, the automation can publish a message to topic cmnd/%topic%/DeepSleepTime with payload 0 . This will cause the device to disable DeepSleep and allow maintenance such as firmware updates to be performed without having an unexpected DeepSleep event. Send the DeepSleepTime 0 command only once . Once device maintenance is completed, place it back into DeepSleep mode using original configuration.","title":"Using smart home automation"},{"location":"DeepSleep/#rules","text":"The following triggers can be used to execute commands upon wake-up or right before entering DeepSleep: - Power1#Boot : is the earliest trigger. But valid only if you have a Relay output defined. - Switch1#Boot : is the next trigger, also occur very early in the boot process. But valid only if you have Switch input defined. - System#Boot : is occuring later in the Tasmota boot process but is always available. - System#Save : is occuring right before a restart or before entering DeepSleep. For example the ruleset below turn on power right after Tasmota started, and turn it off just before entering DeepSleep Rule1 ON Power1#Boot DO Power on ENDON ON System#Save DO Power off ENDON Any rule apply AFTER the Init() procedures of all sensors/drivers. This does mean that a POWER OFF on the GPIO may prevent sensors from being initialized correctly during start-up (e.g. DS18B20) and do not show up in teleperiod message. To ensure the GPIO is HIGH during restart you should define in the Configure --> Configure module --> GPIO x to Output Hi instead of RELAY 1 and avoid using any rules. To ensure the GPIO goes LOW after deepsleep you need to solder a 4.7K resistor between GND and the GPIO. Sequence is then as follow (only key lines are shown): 00:00:00.085 CFG: Loaded from File, Count 122 00:00:00.095 Project tasmota demo-sensor Version 9.5.0(tasmota-sensors) 00:00:00.105 RUL: POWER1#BOOT performs \"Power ON\" 00:00:00.109 RSL: POWER = {\"POWER\":\"ON\"} 00:00:00.111 RSL: POWER = ON 00:00:04.454 WIF: Connecting to AP1 DEMOAP Channel 1 BSSId XX:XX:XX:XX:XX:XX in mode 11n as demo-sensor... 00:00:05.756 WIF: Connected 00:00:06.008 HTP: Web server active on dev-4119 with IP address 192.168.168.199 15:03:40.010 MQT: Attempting connection... 15:03:40.024 MQT: Connected 15:03:40.028 MQT: tele/demo-sensor/LWT = Online (retained) 15:03:40.032 MQT: cmnd/demo-sensor/POWER = 15:03:40.047 MQT: stat/demo-sensor/POWER = {\"POWER\":\"ON\"} 15:03:40.050 MQT: stat/demo-sensor/POWER = ON (retained) 15:03:44.472 MQT: tele/demo-sensor/STATE = {\"Time\":\"2021-06-27T15:03:44+02:00\",\"Uptime\":\"0T00:00:13\",\"UptimeSec\":13,\"Heap\":28,\"SleepMode\":\"Dynamic\",\"Sleep\":50,\"LoadAvg\":19,\"MqttCount\":1,\"POWER\":\"ON\",\"Wifi\":{\"AP\":1,\"SSId\":\"DEMOAP\",\"BSSId\":\"XX:XX:XX:XX:XX:XX\",\"Channel\":1,\"Mode\":\"11n\",\"RSSI\":86,\"Signal\":-57,\"LinkCount\":1,\"Downtime\":\"0T00:00:07\"}} 15:03:44.500 MQT: tele/demo-sensor/SENSOR = {\"Time\":\"2021-06-27T15:03:44+02:00\",\"Switch1\":\"OFF\",\"Switch2\":\"ON\"} (retained) 15:03:44.515 RUL: SYSTEM#SAVE performs \"Power OFF\" 15:03:44.524 MQT: stat/demo-sensor/POWER = {\"POWER\":\"OFF\"} 15:03:44.527 MQT: stat/demo-sensor/POWER = OFF (retained) 15:03:44.539 MQT: stat/demo-sensor/DEEPSLEEP = {\"DeepSleep\":{\"Time\":\"2021-06-27T15:04:00\",\"Epoch\":1624799040}} 15:03:47.433 APP: Sleeping","title":"Rules"},{"location":"DeepSleep/#driver-writer-executing-commands-before-entering-deepsleep","text":"When writing a driver for a sensor, if the sensor supports a low power mode, it is a good practice to set the sensor in such low power mode in the FUNC_SAVE_BEFORE_RESTART handler. When Tasmota will restart at next wake-up, sensor will be automatically re-initialized. Exemple from xsns_09_bmp.ino : #ifdef USE_DEEPSLEEP case FUNC_SAVE_BEFORE_RESTART : BMP_EnterSleep (); break ; #endif // USE_DEEPSLEEP In general you can also execute any command or special script BEFORE device goes into DeepSleep using handler FUNC_SAVE_BEFORE_RESTART as a predefined hook to implement your own procedure. This requires you to code your own function and self-compile custom firmware.","title":"Driver writer: Executing commands before entering DeepSleep"},{"location":"DeepSleep/#overcome-network-issues","text":"If the device is not able to make a WIFI connection and get an IP during the first 15 seconds after boot it will go again without any further actions into deepsleep for another cycle. If you compile your own firmware you can change the timeout (e.g. 30 seconds) by setting #define DEEPSLEEP_NETWORK_TIMEOUT 30 in user_config.override or disable completly (device stay online until network connected) with #define DEEPSLEEP_NETWORK_TIMEOUT 0 . If MQTT or NTP does not work the TELEPERIOD will execute anyhow and send the device to deepsleep afterwards. A wrong NTP will result in wrong timestamp send to MQTT. A missing MQTT connection will avoid any send. Another method to send the device into deepsleep after start is creating a rule like the one below. In this case the timeout can be configured online and changed. Rule1 ON Dimmer#Boot DO RuleTimer1 30 ENDON ON Rules#Timer=1 DO DeepSleepTime 3600 ENDON Rule1 ON","title":"Overcome network issues"},{"location":"DeepSleep/#deepsleep-algorithm-general-timing","text":"Let's assume you have set DeepSleepTime 3600 (one hour) and TelePeriod 300 (five minutes). The device will first wake at 8:00 am. The device will boot and connect Wi-Fi. Next, the correct time must be sync'ed from one of the NTP servers. Now the device has all prerequisites for going into DeepSleep. DeepSleep is then triggered after the TelePeriod event. In this example, it will occur after five minutes. Telemetry will be collected and sent (e.g., via MQTT). Now, DeepSleep can happen. First, Offline is published to the LWT topic on MQTT. It then calculates the new sleeping time to wake-up at 9:00 am (3600 seconds after the last wake-up). At 9:00 am this same sequence of events happens again. If you want to minimize the time that the device is in operation, decrease TelePeriod down to 10 seconds. This period of time is counted after MQTT is connected. Also, in this case, the device will wake up at 9:00 am even if the uptime was much smaller. If the device missed a wake-up it will try a start at the next event - in this case 10:00 am.","title":"DeepSleep Algorithm General Timing"},{"location":"DeepSleep/#esp8266-deepsleep-side-effects","text":"Not all GPIO behave the same during DeepSleep. Some GPIO go HIGH, some LOW, some FOLLOW the relay but work only on FET transistors. As soon as current flows they go LOW. I use one GPIO to trigger a BC337 transistor to switch OFF all connected devices during DeepSleep. Findings: Pin GPIO Behavior D0 16 Excluded due to use as wake-up pin D1 5 KEEP STATE, go LOW if resistance to ground < infinite D2 4 KEEP STATE, go LOW if resistance to ground < infinite D3 0 HIGH D4 2 HIGH D5 14 HIGH, go LOW if resistance to ground < infinite D6 12 HIGH, go LOW if resistance to ground < infinite D7 13 HIGH, go LOW if resistance to ground < infinite D8 15 LOW","title":"ESP8266 DeepSleep Side-effects"},{"location":"DeepSleep/#log-output-explanation","text":"(logging level 4 ) When MQTT connects at 13:08:38 , this sets the system to READY. 13:08:43 MQT: tele/tasmota/INFO3 = {\"RestartReason\":\"Deep-Sleep Wake\"} 13:08:44 APP: Boot Count 3 13:08:44 CFG: Saved to flash at F4, Count 96, Bytes 3824 In the context of DeepSleep, maintaining a device boot count is not relevant. When DeepSleep is enabled, boot count will not be incremented. This avoids excessive flash writes which will deteriorate the flash memory chip and eventually cause the device to fail. Boot count incrementing can be enabled using SetOption76 . In this example, TelePeriod is 10. Therefore when it is reached, telemetry reporting occurs. 13:08:48 MQT: tele/tasmota/STATE = {\"Time\":\"2019-09-04T13:08:48\",\"Epoch\":1567595328,\"Uptime\":\"0T00:00:14\",\"UptimeSec\":14,\"Heap\":24,\"SleepMode\":\"Dynamic\",\"Sleep\":50,\"LoadAvg\":20,\"MqttCount\":1,\"Wifi\":{\"AP\":1,\"SSId\":\"MyWLAN\",\"BSSId\":\"AA:FF:AA:AA:AA:AA\",\"Channel\":11,\"RSSI\":100,\"LinkCount\":1,\"Downtime\":\"0T00:00:08\",\"DeepSleep\":300,\"Heap\":25160}} 13:08:48 MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-09-04T13:08:48\",\"Epoch\":1567595328,\"ANALOG\":{\"A0\":8}} Date and time is set, status and telemetry sent. Now start shutdown procedure. First, send MQTT offline. 13:08:48 MQT: state/sonoff/LWT = Offline DeepSleep is 300 seconds. Therefore +-30 sec is allowed as deviation between proposed wake-up time and real wake-up time. Reporting in 0.1sec. In this case wake-up was one second late. 13:08:48 Timeslip 0.1 sec:? -300 < -10 < 300 If the error is in the range, this is tagged as a normal wake up where drift can be recalculated 13:08:48 Normal deepsleep? 1 Recalculate a new drift that is a multiplier for the next wake-up in 1/10000. In this case, the multiplier is 1.0257 13:08:48 % RTC new drift 10257 And for information: New target wake-up time 13:08:48 Next wakeup 2019-09-04T13:10:00 Based on run time and the error in the last loop, a new sleeping time will be calculated. This will be multiplied by the deepsleep_slip and, ideally, the device will wake up at the time above. 13:08:48 Sleeptime 285 sec, deepsleep_slip 10257 The effectiveness of the compensation can be seen here. Instead of typically 160-200 seconds, most times it is better than 10 seconds in a one hour DeepSleep cycle.","title":"Log Output Explanation"},{"location":"DeepSleep/#rules-to-adapt-deepsleep-period-to-battery-level","text":"In some applications, it is interresting to adjust the DeepSleep period to the level of the battery. For this, we consider that: the battery level is measured by the ESP ADC with the appropriate voltage divider, the Tasmota ADC mode is set to Range mode, AdcParams 6 has been used so the range value represent the battery voltage in millivolts The below graph represent the adaptation paths we want to follow to adjust DeepSleepTime: one path while the level is dropping, another path while the level is rising. To implement this in Tasmota we can use Rules . As Rules do not provide an AND operator, we also need the optional IF feature. This requires to compile a customized firmware with the following items in user_config_override.h : #define USE_RULES #define SUPPORT_IF_STATEMENT First, we need to know the current value of DeepSleepTime. Values for internal settings are not available as %variable% but they can generally be obtained by sending the command and capturing the result with a rule. To get the current value of DeepSleepTime, we need a trigger early in the boot process. For example Wifi#Connected . Our first rules to get the current DeepSleepTime into %var1% would be: ON Wifi#Connected DO Backlog DeepSleepTime ENDON ON DeepSleepTime#Data DO var1 %value% ENDON The best moment to compare the batery level and decide if it is necessary to change the DeepSleepTime is right after the TelePeriod SENSOR message has been sent, which is just before Tasmota calculate the next wake-up time. So we can use tele-ANALOG#Range as a trigger for our rules. Using BREAK allows to compare the trigger only to the upper value of the segment and stop further rules evaluations if the comparison is met. In the rule statement for a given battery level, we compare the current value of DeepSleepTime (which is %var1%) with the value we vant (given by the graph). If the current value is lower than the value we want, we are on the decreasing path and we can apply the new value. If the current value is greater than the value we want, we are on the rising path and we can apply the new value. All above can be set into Rule1. As it is a long command, it may be necessary to enter the rule in 2 parts (note the usage of the + ) : Rule1 on Wifi#Connected do backlog deepsleeptime endon on deepsleeptime#data do var1 %value% endon on tele-Analog#Range<3450 do if (%var1%<3600) deepsleeptime 3600 endif break on tele-Analog#Range<3650 do if (%var1%<1800) deepsleeptime 1800 endif break Rule1 +on tele-Analog#Range<3800 do if (%var1%<900) deepsleeptime 900 elseif (%var1%>1800) deepsleeptime 1800 endif break on tele-Analog#Range<4000 do if (%var1%>900)deepsleeptime 900 endif break on tele-Analog#Range>=4000 do if (%var1%> 600) deepsleeptime 600 endif endon Don't forget to enable using Rule1 1","title":"Rules to adapt DeepSleep period to battery level."},{"location":"Device-Groups/","text":"Device Groups ~ Allow devices to share values and control entire groups of devices A framework to allow multiple devices to be in a group with values such as power, light color, color temperature, brightness, PWM values, sensor values and more, all shared with other devices in the group. For example, with multiple lights in a device group, light settings can be changed on one light and the settings will automatically be changed on other lights. Dimmer switches could be in a device group with lights and that dimmer switch could control the power, brightness and colors of all the lights in the group. Multiple dimmer switches could be in a device group to form a 3-way/4-way dimmer switch. UDP multicasts, followed by UDP unicasts if necessary, are used to send updates to all devices so updates are fast. There is no need for an MQTT server but all the devices in a group must be on the same multicast network. The multicast address and port are specified at compile time with the DEVICE_GROUPS_ADDRESS (default = 239.255.250.250) and DEVICE_GROUPS_PORT (default = 4447) macros respectively. To enable device groups, execute command: SetOption85 1 . All devices in a group must be running firmware with device group support and have device groups enabled. Operation ~ The device group name is set with the DevGroupName command ( GroupTopic prior to v8.2.0.3). If a device group name is not set for a group, the MQTT group topic is used (with the device group number appended for device group numbers > 1). All devices in the same multicast network with the same device group name are in the same group. Some modules may define additional device groups. For example, if Remote Device Mode is enabled, the PWM Dimmer module defines three devices groups. The items sent and received from the group are selected with the DevGroupShare command. By default all items are sent and received. An example of when the DevGroupShare command would be used is when you have a group of lights that you control with a dimmer switch and home automation software. You want the dimmer switch to be able to control all items. The home automation software controls each light individually. When it controls the whole group, it actually sends command to each light in the group. If you use the home automation software to turn an individual light on or off or change it's brightness, color or scheme, you do not want the change to be replicated to the other lights. In this case, you would set the incoming and outgoing item masks to 0xffffffff (all items) on the dimmer switch ( DevGroupShare 0xffffffff,0xffffffff ) and set the incoming item mask to 0xffffffff and outgoing item mask to 0 on all the lights ( DevGroupShare 0xffffffff,0 ). By default, the state of all relays, light settings, etc, are sent to and received from device group 1. To enable each relay (or light channels if option 68 is enabled) to be in a separate device group, enable option 88 ( SetOption88 1 ). When option 88 is enabled, the DevGroupTie sets which relay each device group is tied to. Each device group can only be tied to a single relay. By default, relay 1 is tied to device group 1 (relay 1 updates are sent to/received from device group 1), device 2 is tied to device group 2, device 3 is tied to device group 3 and device 4 is tied to device group 4. If a device group is only to be used by DevGroupSend to send updates to a device group, tie it to device 0. To implement a device group with lights that change color in sequence (colors move progressively from light to light), use the SequenceOffset command to specify the offset of each light from the master. If your devices have friendly names or MQTT topics that end in the number of the light, SequenceOffset1 can automatically set the offset based on the friendly name/MQTT topic. Once the sequence offset is set, each light will delay light channel changes by the specified number of updates. For example, if you have three lights with friendly names Light1, Light2 and Light3, you can use the SequenceOffset1 command to set the sequence offsets. When you set the color on Light1 to red, then to green and then to blue, the color on Light2 will be green and the color on Light3 will be red. When you set the color on Light1 back to red, the color on Light2 will change to blue and the color on Light3 will change to green. When a device reboots or looses network connectivity, it requests the current status from device group members when it reconnects. There are times when devices in a device group may be set to a mix of power states, colors, brightnesses, etc. via automation software. For example, you may have a scene that sets the lights in the group to different colors. In this case, the devices in the group should not send light channel information until the color is changed on one of the dimmer switches/masters. To indicate that devices in a device group currently have one or more items that should not be kept in sync, publish/execute the DevGroupSend command with the item value prefixed with N on one of the devices that includes the item in its outgoing share mask. For example, the command DevGroupSend 224=NFF0000 executed on a dimmer switch in the group would set the color to red on the dimmer switch and inform the group that light channel information is not to be shared. You can then set the colors on the lights in the group to assorted colors and the dimmer switch will not change them. Once you set the color on the dimmer switch again (either with the Color command or with DevGroupSend without the N prefix), the syncing will resumt and the colors on the lights will be changed to the that color. You can directly control which items are not shared until they are changed using the DevGroupSend command No Status Share (129) item. Troubleshooting ~ If no values seem to be shared between devices, perform the following checks: Enter the command SetOption85 on all devices in the group and make sure the result is ON on all devices. Enter the command DevGroupName on all devices in the group and make sure the result for device group 1 is the exact same (case-sensitive) name on all devices. Enter the command DevGroupShare -1,-1 on all devices in the group to enable sharing of all items. Enter the command DevGroupSend 128=1 on one device in the group. If the power turns on on the other devices, the device groups feature is working. Enter the command DevGroupStatus on all devices in the group. If you do not see all the other devices in the group listed as members, multicast packets are not being received by the devices. Check the network infrastructure that connects the devices together to make sure multicasts are enabled are not being filtered. Commands ~ Command Parameters DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group name and restart.\\ If a device group name is not set for a group, the MQTT group topic ( GroupTopic ) is used (with the device group number appended for device group numbers > 1). DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract), ^ (invert), & (bitwise AND) or | (bitwise OR). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. To indicate that an item should not be shared with the group until changed again, prefix the value with N. 1 = Send the current value of all items. This will bring all the devices in sync after devices in a group have been set to different values (such as different colors on lights in a group). If N is not specified for the value, the list of items previously sent with an N prefix is cleared. 3 = Light fade (0 = Off, 1 = On) 4 = Light speed (1..40) 5 = Light brightness (0..255) 6 = Light Scheme 7 = Light fixed color (0 = white (using CT channels), other values according to Color ) 8 = PWM dimmer low preset (0..255) 9 = PWM dimmer high preset (0..255) 10 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 129 = No Status Share - DevGroupShare bitmask indicating which items should not be shared until changed. 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) or hex color value (#RRGGBB, #RRGGBBWW, etc.) Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=@^ - toggle all the relays. DevGroupSend 224=NFF0000 - set the color to red locally and inform the group that light channel information is not to be shared until changed. DevGroupSend 129=@\\|18 - do not share light brightness or channel status until changed. DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members. DevGroupTie<x> <relay> = Tie the relay to the device group <x>. Only applies when option 88 is enabled. SequenceOffset<x> 0..255 = set device group color sequence offset. Color updates received from device group will be delayed by the specified number of updates. x = 0..2 0 = set offset to <value> 1 = set offset to friendly name 1 ending digits + <value> [default -1] 2 = set offset to MQTT topic ending digits + <value> [default -1] Example.: For friendly name of Light4, SequenceOffset1 will set sequence offset to 3; SequenceOffset1 2 will set offset to 6.","title":"Device Groups"},{"location":"Device-Groups/#device-groups","text":"Allow devices to share values and control entire groups of devices A framework to allow multiple devices to be in a group with values such as power, light color, color temperature, brightness, PWM values, sensor values and more, all shared with other devices in the group. For example, with multiple lights in a device group, light settings can be changed on one light and the settings will automatically be changed on other lights. Dimmer switches could be in a device group with lights and that dimmer switch could control the power, brightness and colors of all the lights in the group. Multiple dimmer switches could be in a device group to form a 3-way/4-way dimmer switch. UDP multicasts, followed by UDP unicasts if necessary, are used to send updates to all devices so updates are fast. There is no need for an MQTT server but all the devices in a group must be on the same multicast network. The multicast address and port are specified at compile time with the DEVICE_GROUPS_ADDRESS (default = 239.255.250.250) and DEVICE_GROUPS_PORT (default = 4447) macros respectively. To enable device groups, execute command: SetOption85 1 . All devices in a group must be running firmware with device group support and have device groups enabled.","title":"Device Groups"},{"location":"Device-Groups/#operation","text":"The device group name is set with the DevGroupName command ( GroupTopic prior to v8.2.0.3). If a device group name is not set for a group, the MQTT group topic is used (with the device group number appended for device group numbers > 1). All devices in the same multicast network with the same device group name are in the same group. Some modules may define additional device groups. For example, if Remote Device Mode is enabled, the PWM Dimmer module defines three devices groups. The items sent and received from the group are selected with the DevGroupShare command. By default all items are sent and received. An example of when the DevGroupShare command would be used is when you have a group of lights that you control with a dimmer switch and home automation software. You want the dimmer switch to be able to control all items. The home automation software controls each light individually. When it controls the whole group, it actually sends command to each light in the group. If you use the home automation software to turn an individual light on or off or change it's brightness, color or scheme, you do not want the change to be replicated to the other lights. In this case, you would set the incoming and outgoing item masks to 0xffffffff (all items) on the dimmer switch ( DevGroupShare 0xffffffff,0xffffffff ) and set the incoming item mask to 0xffffffff and outgoing item mask to 0 on all the lights ( DevGroupShare 0xffffffff,0 ). By default, the state of all relays, light settings, etc, are sent to and received from device group 1. To enable each relay (or light channels if option 68 is enabled) to be in a separate device group, enable option 88 ( SetOption88 1 ). When option 88 is enabled, the DevGroupTie sets which relay each device group is tied to. Each device group can only be tied to a single relay. By default, relay 1 is tied to device group 1 (relay 1 updates are sent to/received from device group 1), device 2 is tied to device group 2, device 3 is tied to device group 3 and device 4 is tied to device group 4. If a device group is only to be used by DevGroupSend to send updates to a device group, tie it to device 0. To implement a device group with lights that change color in sequence (colors move progressively from light to light), use the SequenceOffset command to specify the offset of each light from the master. If your devices have friendly names or MQTT topics that end in the number of the light, SequenceOffset1 can automatically set the offset based on the friendly name/MQTT topic. Once the sequence offset is set, each light will delay light channel changes by the specified number of updates. For example, if you have three lights with friendly names Light1, Light2 and Light3, you can use the SequenceOffset1 command to set the sequence offsets. When you set the color on Light1 to red, then to green and then to blue, the color on Light2 will be green and the color on Light3 will be red. When you set the color on Light1 back to red, the color on Light2 will change to blue and the color on Light3 will change to green. When a device reboots or looses network connectivity, it requests the current status from device group members when it reconnects. There are times when devices in a device group may be set to a mix of power states, colors, brightnesses, etc. via automation software. For example, you may have a scene that sets the lights in the group to different colors. In this case, the devices in the group should not send light channel information until the color is changed on one of the dimmer switches/masters. To indicate that devices in a device group currently have one or more items that should not be kept in sync, publish/execute the DevGroupSend command with the item value prefixed with N on one of the devices that includes the item in its outgoing share mask. For example, the command DevGroupSend 224=NFF0000 executed on a dimmer switch in the group would set the color to red on the dimmer switch and inform the group that light channel information is not to be shared. You can then set the colors on the lights in the group to assorted colors and the dimmer switch will not change them. Once you set the color on the dimmer switch again (either with the Color command or with DevGroupSend without the N prefix), the syncing will resumt and the colors on the lights will be changed to the that color. You can directly control which items are not shared until they are changed using the DevGroupSend command No Status Share (129) item.","title":"Operation"},{"location":"Device-Groups/#troubleshooting","text":"If no values seem to be shared between devices, perform the following checks: Enter the command SetOption85 on all devices in the group and make sure the result is ON on all devices. Enter the command DevGroupName on all devices in the group and make sure the result for device group 1 is the exact same (case-sensitive) name on all devices. Enter the command DevGroupShare -1,-1 on all devices in the group to enable sharing of all items. Enter the command DevGroupSend 128=1 on one device in the group. If the power turns on on the other devices, the device groups feature is working. Enter the command DevGroupStatus on all devices in the group. If you do not see all the other devices in the group listed as members, multicast packets are not being received by the devices. Check the network infrastructure that connects the devices together to make sure multicasts are enabled are not being filtered.","title":"Troubleshooting"},{"location":"Device-Groups/#commands","text":"Command Parameters DevGroupName<x> 0 = clear device group <x> name and restart <value> = set device group name and restart.\\ If a device group name is not set for a group, the MQTT group topic ( GroupTopic ) is used (with the device group number appended for device group numbers > 1). DevGroupSend<x> <item> = <value>[ ...] = send an update to device group <x>. The device group name must have been previously set with DevGroupName<x>. Multiple item/value pairs can be specified separated by a space. Spaces in <value> must be escaped with a backslash (\\). The message sent is also processed on the local device as if it had been received from the network. For items with numeric values, <value> can be specified as @<operator>[<operand>] to send a value after performing an operation on the current value. <operator> can be + (add), - (subtract), ^ (invert), & (bitwise AND) or | (bitwise OR). If <operand> is not specified, it defaults to 0xffffffff for the invert operator and 1 for other operators. To indicate that an item should not be shared with the group until changed again, prefix the value with N. 1 = Send the current value of all items. This will bring all the devices in sync after devices in a group have been set to different values (such as different colors on lights in a group). If N is not specified for the value, the list of items previously sent with an N prefix is cleared. 3 = Light fade (0 = Off, 1 = On) 4 = Light speed (1..40) 5 = Light brightness (0..255) 6 = Light Scheme 7 = Light fixed color (0 = white (using CT channels), other values according to Color ) 8 = PWM dimmer low preset (0..255) 9 = PWM dimmer high preset (0..255) 10 = PWM dimmer power-on brightness (0..255) 128 = Relay Power - bitmask with bits set for relays to be powered on. The number of relays can be specified in bits 24 - 31. If the number of relays is not specified, only relay 1 is set 129 = No Status Share - DevGroupShare bitmask indicating which items should not be shared until changed. 192 = Event - event name and arguments 193 = Command - command and arguments 224 = Light channels - comma separated list of brightness levels (0..255) for channels 1 - 5 (e.g. 255,128,0,0,0 will turn the red channel on at 100% and the green channel on at 50% on an RBG light) or hex color value (#RRGGBB, #RRGGBBWW, etc.) Examples: DevGroupSend 4=90 128=1 - send an update to set the light brightness to 90 and turn relay 1 on. DevGroupSend 193=Buzzer\\ 2,3 - send the Buzzer 2,3 command. DevGroupSend 6=@+ 4=@-10 - set the next fixed color and decrease the brightness by 10. DevGroupSend 128=@^ - toggle all the relays. DevGroupSend 224=NFF0000 - set the color to red locally and inform the group that light channel information is not to be shared until changed. DevGroupSend 129=@\\|18 - do not share light brightness or channel status until changed. DevGroupShare <in>,<out> = set incoming and outgoing shared items (default = 0xffffffff,0xffffffff ) <in> and <out> are bit masks where each mask is the sum of the values for the categories (listed below) to be shared. For example, to receive only power (1), light brightness (2) and light color (16) and send only power (1), enter the command DevGroupShare 19,1. 1 = Power 2 = Light brightness 4 = Light fade/speed 8 = Light scheme 16 = Light color 32 = Dimmer settings (presets) 64 = Event DevGroupStatus<x> Show the status of device group <x> including a list of the currently known members. DevGroupTie<x> <relay> = Tie the relay to the device group <x>. Only applies when option 88 is enabled. SequenceOffset<x> 0..255 = set device group color sequence offset. Color updates received from device group will be delayed by the specified number of updates. x = 0..2 0 = set offset to <value> 1 = set offset to friendly name 1 ending digits + <value> [default -1] 2 = set offset to MQTT topic ending digits + <value> [default -1] Example.: For friendly name of Light4, SequenceOffset1 will set sequence offset to 3; SequenceOffset1 2 will set offset to 6.","title":"Commands"},{"location":"Device-Recovery/","text":"Device Recovery ~ Configuration problems can cause boot loops, erratic behavior, devices which will not appear (i.e., no tasmota-xxxx AP) or connect to Wi-Fi, etc. In cases such as these when there is no proper operation a recovery process is required. By default, the firmware tries to preserve the existing configuration (to support automated updates via OTA upgrades). However, various things can happen that cause the existing configuration to become problematic, e.g., when upgrading from old releases without following the migration path . When code updates change the values or the way settings are used, those code changes don't directly write the settings on the running device when you load the new firmware. What happens is that when it boots up, the firmware looks to see if it has a valid configuration (if its an upgrade from an older Tasmota version) and if the CFG_HOLDER value is in the right place it assumes that the existing configuration is valid. If it doesn't find the right value it assumes that this is not a \"simple\" upgrade and takes the compiled-in configuration settings and writes them out to the configuration area. Recovery Techniques ~ Listed below are a few ways to reset the device to what is set in the firmware binary ( my_user_config.h and user_config_override.h ) aka firmware defaults, in order to recover a device: Hold the button ( Button1 ) down, if available, for 40 seconds. After that the device should reset and reboot. Fully cycle power after that is done to make sure everything is starting from scratch. Issue Reset 1 command via the console, MQTT or HTTP. After the device reboots fully cycle power. use Fast Power Cycle Device Recovery procedure Fast Power Cycle Device Recovery ~ Implemented for situations where a device cannot be reset to firmware defaults by other means (no serial access, no button). It resets ALL Tasmota settings (equal to Reset 1 ) after 7 power cycles. SetOption65 must be set to 0 (default) in order for this feature to be enabled. Warning If you have a weak power grid or frequent power brownouts its best to disable this feature with SetOption65 1 immediately or you'll end up with firmware default devices after a brownout event. Procedure ~ Cut power from the device completely for 30 seconds Power the device on and off six times with intervals lower than 10 seconds and leave it on after seventh time Fast power cycle device recovery should activate and the device should be reset to firmware defaults If you flashed a precompiled binary you can reconfigure the device using the web UI after the reset. After Recovery ~ Once recovered, the device should be observed that it operates without instabilities before attempting to configure the device in any way. If the device still does not, follow these steps if you are able to configure its Wi-Fi and connect: Configure the device as Generic (18) Perform an OTA upgrade specifically to tasmota-minimal.bin . Taking this intermediate step ensures that the firmware will be reloaded. Since Tasmota performs a version comparison before performing the OTA update, explicitly changing the firmware that is on the device will ensure that the firmware is indeed replaced in the next step. Perform an OTA upgrade to the desired firmware variant. Once the device operates reliably, begin the configuration to set the GPIO configuration (via a Template or Module). Take any further configuration steps one at a time to ensure that after each setting is applied, the device continues to operate reliably. If the device exhibits defective behavior immediately after a particular individual setting is changed, then be aware that there may be a problem in the firmware. Please report this behavior via the Tasmota Discord Chat . That Didn't Work, What Now? ~ If none of these methods result in a working and reliable device, the only remaining option is to connect the device to the serial programming interface, erase the flash memory and flash a different precompiled firmware binary.","title":"Device Recovery"},{"location":"Device-Recovery/#device-recovery","text":"Configuration problems can cause boot loops, erratic behavior, devices which will not appear (i.e., no tasmota-xxxx AP) or connect to Wi-Fi, etc. In cases such as these when there is no proper operation a recovery process is required. By default, the firmware tries to preserve the existing configuration (to support automated updates via OTA upgrades). However, various things can happen that cause the existing configuration to become problematic, e.g., when upgrading from old releases without following the migration path . When code updates change the values or the way settings are used, those code changes don't directly write the settings on the running device when you load the new firmware. What happens is that when it boots up, the firmware looks to see if it has a valid configuration (if its an upgrade from an older Tasmota version) and if the CFG_HOLDER value is in the right place it assumes that the existing configuration is valid. If it doesn't find the right value it assumes that this is not a \"simple\" upgrade and takes the compiled-in configuration settings and writes them out to the configuration area.","title":"Device Recovery"},{"location":"Device-Recovery/#recovery-techniques","text":"Listed below are a few ways to reset the device to what is set in the firmware binary ( my_user_config.h and user_config_override.h ) aka firmware defaults, in order to recover a device: Hold the button ( Button1 ) down, if available, for 40 seconds. After that the device should reset and reboot. Fully cycle power after that is done to make sure everything is starting from scratch. Issue Reset 1 command via the console, MQTT or HTTP. After the device reboots fully cycle power. use Fast Power Cycle Device Recovery procedure","title":"Recovery Techniques"},{"location":"Device-Recovery/#fast-power-cycle-device-recovery","text":"Implemented for situations where a device cannot be reset to firmware defaults by other means (no serial access, no button). It resets ALL Tasmota settings (equal to Reset 1 ) after 7 power cycles. SetOption65 must be set to 0 (default) in order for this feature to be enabled. Warning If you have a weak power grid or frequent power brownouts its best to disable this feature with SetOption65 1 immediately or you'll end up with firmware default devices after a brownout event.","title":"Fast Power Cycle Device Recovery"},{"location":"Device-Recovery/#after-recovery","text":"Once recovered, the device should be observed that it operates without instabilities before attempting to configure the device in any way. If the device still does not, follow these steps if you are able to configure its Wi-Fi and connect: Configure the device as Generic (18) Perform an OTA upgrade specifically to tasmota-minimal.bin . Taking this intermediate step ensures that the firmware will be reloaded. Since Tasmota performs a version comparison before performing the OTA update, explicitly changing the firmware that is on the device will ensure that the firmware is indeed replaced in the next step. Perform an OTA upgrade to the desired firmware variant. Once the device operates reliably, begin the configuration to set the GPIO configuration (via a Template or Module). Take any further configuration steps one at a time to ensure that after each setting is applied, the device continues to operate reliably. If the device exhibits defective behavior immediately after a particular individual setting is changed, then be aware that there may be a problem in the firmware. Please report this behavior via the Tasmota Discord Chat .","title":"After Recovery"},{"location":"Device-Recovery/#that-didnt-work-what-now","text":"If none of these methods result in a working and reliable device, the only remaining option is to connect the device to the serial programming interface, erase the flash memory and flash a different precompiled firmware binary.","title":"That Didn't Work, What Now?"},{"location":"Displays/","text":"This feature is included only in -displays.bin Supported Displays ~ DisplayModel Name Interface 1 LCD display I 2 C 2 SSD1306 OLED display I 2 C 3 8x8 MATRIX display GPIO 4 ILI934x TFT display DisplayIliMode 1 for ILI9341 or DisplayIliMode 3 for ILI9342 When second SPI bus on ESP32 is used, SSPI must be defined instead of SPI SPI 5 Waveshare E-Paper 2.9\" display (black/white, partial update) SPI 6 Waveshare E-Paper 4.2\" display (black/white, full update) SPI 7 SH1106 OLED display I 2 C 8 ILI9488 TFT display SPI 9 SSD1351 OLED color display SPI 10 RA8876 TFT display SPI 11 7 segment common anode display I 2 C 12 ST7789 TFT display SPI 14 SD1331 TFT display SPI 15 TM1637, TM1638 and MAX7219 7-segment displays GPIO 16 LilyGO T5 4.7\" E-Paper display ESP32 device 17 Universal Display Driver SPI or I 2 C 18 Interface to virtual display driver with Berry Display Commands ~ See commands page for full list of available Display Commands DisplayMode ~ The display driver is able to display predefined setups of text or user defined text. To display text using DisplayText set DisplayMode to 0 , or set DisplayMode to 1 for the HT16K33 dot-matrix display. To use the seven-segment-specific TM1637, TM1638 and MAX7219 Display- commands, set DisplayMode to 0 . Parameter LCD Display OLED Display TFT Display 7-segment Display (TM163x and MAX7219) 0 DisplayText DisplayText DisplayText All TM163x Display- functions 1 Time/Date Time/Date Time/Date Time 2 Local sensors Local sensors Local sensors Date 3 MQTT and Time/Date Local sensors and Time/Date Local sensors and Time/Date Time/Date 4 Local sensors MQTT and local sensors MQTT and local sensors NA 5 MQTT and Time/Date MQTT, local sensors and Time/Date MQTT, local sensors and Time/Date NA DisplayText ~ The DisplayText command is used to display text as well as graphics and graphs on LCD, OLED and e-Paper displays (EPD). The command argument is a string that is printed on the display at the current position. The string can be prefixed by embedded control commands enclosed in brackets [] . In order to use the DisplayText command the DisplayMode must be set to 0 (or optional 1 on LCD displays) or other modes must be disabled before compilation with #undef USE_DISPLAY_MODES1TO5 . The DisplayText command is customised for the TM1637, TM1638 and MAX7219 seven-segment display modules. This is documented here . DisplayText Parameters ~ In the list below p stands for parameter and may be a number from 1 to n digits. On monochrome graphic displays things are drawn into a local frame buffer and sent to the display either via the d command or automatically at the end of the command. Positioning ~ lp = sets a character line to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) cp = sets a character column to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) xp = sets the x position for consecutive prints yp = sets the y position for consecutive prints Text is printed at the last provided position, either l or y for the vertical position, and either x or x for the horizontal position. Neither x nor y are advanced/updated after printing text. Line Primitives ~ hp = draws a horizontal line with length p (x is advanced) vp = draws a vertical line with length p (y is advanced) Lp:p = draws a line top: p (x,y are advanced) kp = draws a circle with radius p Kp = draws a filled circle with radius p rp:p = draws a rectangle with p with and p height Rp:p = draws a filled rectangle with p with and p height up:p:p = draws a rounded rectangle with p with, p height and p radius v Up:p:p = draws a filled rounded rectangle with p with, p height and p radius Miscellaneous ~ z = clear the display i = (re)init the display (in e-Paper mode with partial update) I = (re)init the display (in e-Paper mode with full update) d = update the display Dp = switch display drawing options: bit 0: auto updates => 1 auto draw on each displaytext cmd, 0 display must be updated manually with d ( only valid for bw oled and epaper displays, color displays draw always immediately) bit 1: character drawing => 0 opaque character drawing, 1 transparent character drawing o = switch display off O = switch display on ap = p (0..3) set rotation angle t = display Tasmota time in HH:MM tS = display Tasmota time in HH:MM:SS T = display Tasmota date in DD.MM.YY pp = pad text with spaces, positive values align left, negative values align right sp = set text scaling for all fonts (scaling factor 1...N) fp = set font (1=12, 2=24,(opt 3=8)) if font==0 the classic GFX font is used, if font==7 RA8876 internal font is used, if font==4 special 7 segment 24 pixel number font is used, a ram based font is selected if font==5 Cp = set foreground color (0,1) for black or white and RGB decimal code for color (see color codes ) Bp = set background color (0,1) for black or white and RGB decimal code for color (see color codes ) Cip = set foreground index color (0..31) for color displays (see index color table below) Bip = set background index color (0..31) for color displays (see index color table below) wp = draws an analog watch with radius p (#define USE_AWATCH) Pfilename: = display an rgb 16-bit color (or jpg on ESP32) image when file system is present, Scripteditor contains a converter to convert jpg to special RGB16 pictures Ffilename: = load RAM font file when file system is present. the font is selected with font Nr. 5, these fonts are special binary versions of GFX fonts of any type. they end with .fnt. an initial collection is found in Folder BinFonts SXfilename: = load display descriptor for multiple display support (X = 1..3) for up to 3 displays. SX: = switch to display number (X = 1..3). dcI:V = define index color entry Index 19-31, V 16 bit color value (index 0-18 is fixed) Touch Buttons and Sliders ~ Requires #define USE_TOUCH_BUTTONS Draw up to 16 GFX buttons to switch real Tasmota devices such as relays or draw Sliders to dimm e.g. a lamp Button number + 256 - a virtual touch toggle button is created (MQTT => TBT) Button number + 512 - a virtual touch push button is created (MQTT => PBT) b#:xp:yp:xa:ys:oc:fc:tc:ts:text: Parameters are separated by colons. b# where # = define a button number 0-15 xp = x position yp = y position xa = x size ys = y size oc = outline index color fc = fill index color tc = text index color ts = text size on buttons text: = button text (must end with a colon :) (max 9 chars) b0:260:260:100:50:2:11:4:2:Rel 1: Picture Buttons ~ To create picture touch buttons (jpg on ESP32 only) requires #define JPEG_PICTS and #define USE_UFILESYS . Upload pictures to the file system with a \".jpg\" extension, then give the path to the picture as button text omitting the .jpg extension. Create a picture button with a picture file named wifi.jpg b0:260:260:100:50:2:11:4:2:/wifi: The size of the picture is not scaled and the dimensions of the button must fit the picture size. Clicked buttons will invert the colors of the picture. You may specify a picture for selected and unselected button state. Picture filename ending with '1' is used for unselected state and ending '2' is for selected state. Sliders ~ bs# where # = is slider number 0..15 xp = x position yp = y position xa = x size ys = y size ne = number of elements bc = background color fc = frame color bc = bar color Set the state of a button or slider with: b#sX where # = is slider number 0..15 X = 0 or 1 for buttons, 0..100 for sliders Display JSON variables ~ Requires #define USE_DT_VARS Display variables that are exposed in JSON MQTT strings e.g. in TelePeriod messages. The values are updated every second. dv#:xp:yp:gc:fc:fo:ts:tl:dp:ut:JSON:ut: Parameters are separated by colons. dv# where # = defines a variable number 0-7 (may be expanded by #define MAX_DT_VARS N) xp = x position yp = y position gc = text background color (index color) fc = text foreground color (index color) fo = text font ts = text size (negativ value denotes transparent text) tl = text field length (if negative align right) dp = decimal precision (if < 0 denotes a string) ut = update time in seconds (1...N) jt = JSON VARIABLE NAME (uppercase) if you specify a string in brackets here it is treated as displaytext cmd ut = unit string (max 5 chars and must end with a colon :) example: ; ILI9341 320 x240 portrait mode [ x0y0P / corona . rgb : ] [ dc19 : 31000 ] [ x60y30f2Ci3D2 ] Tasmota ; display text cmd displays time with seconds [ dv0 : 50 : 70 : 19 : 3 : 2 : 1 : 11 : 1 : 1 : [ tS ] :: ] ; display text cmd displays analog watch [ dv1 : 120 : 250 : 19 : 2 : 2 : 1 : 11 : 1 : 5 : [ w40 ] :: ] ; displays Wifi SSID JSON [ dv2 : 10 : 10 : 0 : 3 : 1 :- 1 : 10 :- 1 : 1 :WIFI # SSID :: ] [ x10y150f1s1Ci3Bi19 ] Counter: ; displays a sensor JSON variable ( here counter1 ) [ dv3 : 80 : 150 : 0 : 7 : 1 : 1 : 11 : 0 : 1 :COUNTER # C1: cnt : ] [ x10y300f1s1Ci3Bi19 ] memory free : ; displays pre memory space JSON ( heap ) [ dv4 : 100 : 300 : 0 : 7 : 1 : 1 :- 7 :- 1 : 1 :HEAP: kb : ] Line chart ~ ( #define USE_GRAPH and #define NUM_GRAPHS 4 - maximum of 16) Up to 4 line charts may be defined. Ticks may be defined by adding tick numbers to the n parameter. Example n = graph number (0..3) + x ticks (16*number of x ticks) + y ticks (1024*number of y ticks). Gn:xp:yp:xs:ys:t:fmax:fmin defines a line chart: Parameters are separated by colons. n = number up to 4 charts (0..3) + optional ticks xp = x position yp = y position xs = x size (if xs<0) graph is not reinitialized on second call (e.g., restart of scripter) ys = y size t = time in minutes for total chart ymin = float chart minimum y ymax = float chart maximum y icol = line color index (only for color graphs) gn:v adds a value to the chart buffer: n = number up to 4 charts (0..3) v = float value to add Gdn:m sets graph n draw mode 0 = off, 1 = on. When on, redraw graph Gsn:path: = save graph n to path (if optional file system is present) Grn:path: = restore graph n from path (if optional file system is present) Batch files ~ When a file system is present you may define displaytext batch files. If a file named \"display.bat\" is present in the file system this batch file is executed. The file may contain any number of diplaytext cmds, one at a line. You may have comment lines beginning with a ; Example ; clr screen [ z ] ; draw full screen picture [ x0y0P / corona . rgb : ] ; define index color [ dc19 : 31000 ] ; draw transparent text with new index color over picture [ x60y30f2Ci19D2 ] Tasmota A displaytext batch file may be executed from console by displaybatch /file Color Codes ~ While computers and web design are generally using a 24-bit RGB888 color code built from a byte-triplet such as (255, 136, 56) or #FF8038, small color panels often use a more compact code 16-bit RGB565 color code. This means that the R, G and B coefficient are coded on less number of bits: Red on 5 bits = 0..31 Green on 6 bits = 0..63 Blue on 5 bits = 0..31 For Cp and Bp , p is calculated as p = 2048 * Red + 64 * Green + Blue Example Red 50% + Green 20% + Blue 100% = 2048 * 16 + 64 * 12 + 31 = 33576 equivalent to web #8033FF Common colors table: Color Code Color Code Color Code Black 0 Navy 15 Dark green 3 Dark cyan 1007 Maroon 30720 Purple 30735 Olive 31712 Light grey 50712 Dark grey 31727 Blue 31 Green 7 Cyan 2047 Red 63488 Magenta 63519 Yellow 65504 White 65535 Orange 64800 Green yellow 45029 Pink 64536 Color Indices ~ Selected with Ci and Bi in the ILI9488, SSD1351, RA8876 and ST7789 color panels Index Color Index Color Index Color 0 BLACK 1 WHITE 2 RED 3 GREEN 4 BLUE 5 CYAN 6 MAGENTA 7 YELLOW 8 NAVY 9 DARKGREEN 10 DARKCYAN 11 MAROON 12 PURPLE 13 OLIVE 14 LIGHTGREY 15 DARKGREY 16 ORANGE 17 GREENYELLOW 18 PINK You may expand the index color table up from index 19 to 31. the cmd [dcI:V] defines the index color with index I (19-31) to the 16 bit color value V Note on e-Paper Displays ~ E-Paper displays have 2 operating modes: full update and partial update. While full update delivers a clean and sharp picture, it has the disadvantage of taking several seconds for the screen update and shows severe flickering during update. Partial update is quite fast (300 ms) with no flickering but there is the possibility that erased content is still slightly visible. It is therefore useful to perform a full update in regular intervals (e.g., each hour) to fully refresh the display. Compilation directives: #define USE_SPI , #define USE_DISPLAY , #define USE_DISPLAY_EPAPER29 , or #define USE_DISPLAY_EPAPER42 Remark : the 4.2 e-Paper display requires about 15k of RAM. Therefore it only works with Core 2.42 and above. OLED Lifetime ~ The typical specifications for the lifetime of an OLED when permanently on is about 10000 hours (416 days). Dimming to 50% expands the lifetime to about 25000 hours. Burn-in ~ The data sheets of the TFT and OLED displays mention burn-in effects when a static display is shown for extended periods of time. You may want to consider turning on the display on demand only. Fonts ~ The EPD font contains 95 characters starting from code 32, while the classic GFX font contains 256 characters ranging from 0 to 255. Custom characters above 127 can be displayed. To display these characters, you must specify an escape sequence (standard octal escapes do not work). The ~ character followed by a hex byte can define any character code. GFXFont: EPDFont: Hardware Connections ~ I 2 C displays are connected in the usual manner and defined via the GPIO component selection. The I 2 C address must be specified using DisplayAddress XX , e.g., 60 . The model must be spedified with DisplayModel , e.g., 2 for SSD1306. To permanently turn the display on set DisplayDimmer 100 . Display rotation can be permanently set using DisplayRotate X (x = 0..3 ). On SPI the CS and DC pins when needed must use the pin definition with Display_ID + CS e.g. ST7789_CS E-Paper displays are connected via software 3-wire SPI (CS, SCLK, MOSI) . DC should be connected to GND , Reset to 3.3 V and busy may be left unconnected. The jumper on the circuit board of the display must be set to 3-wire SPI. The ILI9488 is connected via hardware 3-wire SPI (SPI_MOSI=GPIO13, SPI_SCLK=GPIO14, CS=GPIO15) and must also be connected to the backlight pin The SSD1351 may be connected via hardware 3-wire SPI or 4-wire SPI with support for dimmer. The ILI9341 is connected via hardware 4-wire SPI, Backlight and OLEDRESET (dimmer supported on ESP32) Wiring The RA8876 is connected via standard hardware 4-wire SPI (SPI_MOSI=GPIO13, SPI_SCLK=GPIO14, RA_8876_CS=GPIO15, SSPI_MISO=GPIO12) . No backlight pin is needed, dimmer supported, on ESP32 gpio pins may be freeley defined (below gpio 33). The ST7789 is connected via 4 Wire software SPI ((ST7789_CS), SSPI_SCLK, SSPI_MOSI, ST7789_DC, OLEDRESET, Backlight ) Rule Examples ~ For scripting examples see Scripting Cookbook Print Text at size 1 on line 1, column 1: DisplayText [s1l1c1]Hello how are you? Draw a rectangle and draw text inside with size 2 and 7 chars padded with spaces: DisplayText [x85y95h130v30h-130v-30s2p7x90y100]37.25 C Refresh screen: DisplayText [z] Draw rectangle from x,y with width and height: DisplayText [x50y50r200:100] Display Local Sensors ~ (line breaks and indentation added to the rules for readability) Use Tasmota rules to display sensor values, time, and a separation line. Refresh the display every 60 minutes: rule1 on tele - SHT3X - 0x44 # Temperature do DisplayText [ f1p7x0y5 ] % value % C endon on tele - SHT3X - 0x44 # Humidity do DisplayText [ f1p10x70y5 ] % value % % [ x0y20h296x250y5t ] endon on tele - BMP280 # Pressure do DisplayText [ f1p10x140y5 ] % value % hPa endon on Time # Minute | 60 do DisplayText [ Tt ] endon Show 4 analog channels: rule1 on tele - ADS1115 # A0 do DisplayText [ s1p21c1l01 ] Analog1: % value % adc endon on tele - ADS1115 # A1 do DisplayText [ s1p21c1l3 ] Analog2: % value % adc endon on tele - ADS1115 # A2 do DisplayText [ s1p21c1l5 ] Analog3: % value % adc endon on tele - ADS1115 # A3 do DisplayText [ s1p21c1l7 ] Analog4: % value % adc endon Show BME280 + SGP30: rule1 on tele - BME280 # Temperature do DisplayText [ s1p21x0y0 ] Temp: % value % C endon on tele - BME280 # Humidity do DisplayText [ s1p21x0y10 ] Hum : % value % %% endon on tele - BME280 # Pressure do DisplayText [ s1p21x0y20 ] Prss: % value % hPa endon on tele - SGP30 # TVOC do DisplayText [ s1p21x0y30 ] TVOC: % value % ppb endon on tele - SGP30 # eCO2 do DisplayText [ s1p21x0y40 ] eCO2 : % value % ppm [ s1p0x0y50 ] Time: [ x35y50t ] endon WaveShare Display Drivers ~ Waveshare has two kinds of display controllers: with partial update and without partial update. The 2.9 inch driver is for partial update and should also support other Waveshare partial update models with modified WIDTH and HEIGHT parameters. The 4.2 inch driver is a hack which makes the full update display behave like a partial update and should probably work with other full update displays. The drivers are subclasses of the Adafruit GFX library. The class hierarchy is LOWLEVEL :: Paint :: Renderer :: GFX , where: GFX : unmodified Adafruit library Renderer : the interface for Tasmota Paint : the modified pixel driver for e-paper there are several virtual functions that can be subclassed down to LOWLEVEL The display dispatcher only does the class initialization call. All other calls go to the Renderer class. In black and white displays, a local RAM buffer must be allocated before calling the driver. This must be set to zero on character or TFT color displays. The EPD fonts use about 9k space, which can be selected at compile time using #ifdef directives. SSD1306 - 1.15k EPD42 - 2.57k EPD29 - 2.1k Display and Render class - ~12k Universal Display Driver ~ Universal Display Driver or uDisplay is a way to define your display settings using a simple text file and easily add it to Tasmota. uDisplay is DisplayModel 17 . It supports I2C and hardware or software SPI (3 or 4 wire). The driver is enabled by compiling with #define USE_UNIVERSAL_DISPLAY and setting an unused GPIO to Option A3 . Descriptor File ~ The display itself is defined by a descriptor file. Many display descriptor files are included in Tasmota GitHub in tasmota/displaydesc folder which may be provided by any of the following methods: A display.ini file present in the flash file system. preferred option A special >d section in scripting. Copy the file to the >d script section and place a ->displayreinit cmd into >B section Copy the descriptor to Rule 3 but do not enable it (descriptor may not contain ANY spaces in this mode) Compile the descriptor into the binary in a section in user_config_override.h under driver 17 (const char) Options 2 and 4 work well for 1M flash devices. Descriptor text file has the following elements: :H Header line describes the main features of the display (comma seperated, no spaces allowed) name x size in pixels y size in pixels bits per pixel (1 for bw displays, 16 for color displays) hardware interface used either I2C or SPI I2C I2C address in HEX SCL pin SDA pin RESET pin SPI Number (1 = hardware SPI 1, 2 = Hardware SPI 2 (ESP32), 3 = software SPI CS pin CLK pin MOSI pin DC pin Backlight pin RESET pin MISO pin SPI Speed in MHz All signals must be given. Unused pins may be set to -1. If you specify a * char the pin number is derived from the Tasmota GPIO GUI. The CS and DC pins must be the standard pins e.g. SPI_CS or SPI_DC . Example :H , SH1106 , 128 , 64 , 1 , I2C , 3 c , * , * , * :H , ILI9341 , 240 , 320 , 16 , SPI , 1 , - 1 , 14 , 13 , 5 , 4 , 15 , * , 40 :S ( optional ) Splash setup, also defines initial colors. If omitted screen is not cleared initially. Font number Font size FG color (as index color) BG color (as index color) x position of text y position of text Example :S , 2 , 1 , 1 , 0 , 40 , 20 :I Initial register setup for the display controler. ( IC marks that the controller is using command mode even with command parameters) All values are in hex. On SPI the first value is the command, then the number of arguments and the the arguments itself. Bi7 7 on the number of arguments set indicate a wait of 150 ms. On I 2 C all hex values are sent to I 2 C. Example :I EF , 3 , 03 , 80 , 02 CF , 3 , 00 , C1 , 30 ED , 4 , 64 , 03 , 12 , 81 E8 , 3 , 85 , 00 , 78 CB , 5 , 39 , 2 C , 00 , 34 , 02 F7 , 1 , 20 EA , 2 , 00 , 00 C0 , 1 , 23 C1 , 1 , 10 C5 , 2 , 3 e , 28 C7 , 1 , 86 36 , 1 , 48 37 , 1 , 00 3 A , 1 , 55 B1 , 2 , 00 , 18 B6 , 3 , 08 , 82 , 27 F2 , 1 , 00 26 , 1 , 01 E0 , 0 F , 0 F , 31 , 2 B , 0 C , 0 E , 08 , 4 E , F1 , 37 , 07 , 10 , 03 , 0 E , 09 , 00 E1 , 0 F , 00 , 0 E , 14 , 03 , 11 , 07 , 31 , C1 , 48 , 08 , 0 F , 0 C , 31 , 36 , 0 F 11 , 80 29 , 80 :o ,OP OP = controller OPCODE to switch display off :O ,OP OP = controller OPCODE to switch display on :R ,OP,SL OP = rotation opcode SL = startline opcode (optional) :0 :1 :2 :3 Register values for all 4 rotations (color display only) rotation code x offset y offset rotation pseudo opcode for touch panel the appropriate coordinate convervsions are defined via pseudo opcodes 0 = no conversion 1 = swap and flip x 2 = flipx, flip y 3 = swap and flip y 4 = flip x 5 = flip y bit 7 = swap x,y :A 3 OPCODES to set adress window (all but epaper displays) set column opcode set row opcode start write opcode pixel size (optional) :P Pixel transfer size (default = 16 bit RGB) (optional) :i invert display opcodes 1. inversion off 2. inversion on :D dimmer opcode (optional) :B LVGL (optional) number of display lines flushed at once (min 10) the lower the lesser memory needed bit 0: DMA enables ( 0 for no DMA, 1 use DMA) - not supported on all displays bit 1: selects color swap, 2 = swap 16 bit color bit 2: enable async DMA, 0 wait for DMA to complete before returning, 4 run DMA async in the background. This later mode is only valid if the SPI bus is not shared between the display and any other SPI device like SD Card Reader. :T Wait times used for E-paper display 1. full refresh wait in ms 2. partial refresh wait in ms 3. wait after update in ms :L Lookup table for full refresh (Waveshare 29) :l Lookuptable for partial refresh (Waveshare 29) :Lx ,OP Lookuptable for full refresh (Waveshare 42) x = 1..5 OP = opcode for sending refresh table :TIx,AA,SCL,SDA Defines a touch panel an I2C bus nr x (1 or 2) AA is device address SCL, SDA are the pins used (or * for tasmota definition) :TS,CS_PIN Defines a touch panel an SPI bus with chip select CS_PIN (or *) :M,X1,X2,Y1,Y2 Defines an optional mapping for touch controllers (always needed on resistive touch) X1 = display left margin X2 = display right margin Y1 = display upper margin Y1 = display lower margin :r,X Defines optional display rotation X = 0..3 :b,X Defines optional inverted backpanel X = 1 = use inverted logic for backpanel Full configuration for SH1106 (comment lines starting with ; are allowed) :H , SH1106 , 128 , 64 , 1 , I2C , 3 c , * , * , * :S , 0 , 2 , 1 , 0 , 30 , 20 :I AE D5 , 80 A8 , 3 f D3 , 00 40 8 D , 14 20 , 00 A1 C8 DA , 12 81 , CF D9F1 DB , 40 A4 A6 AF : o , AE :O , AF :A , 00 , 10 , 40 # Full configuration for ILI9341: (comment lines starting with ; are allowed) :H , ILI9341 , 240 , 320 , 16 , SPI , 1 , * , * , * , * , * , * , * , 40 :S , 2 , 1 , 1 , 0 , 40 , 20 :I EF , 3 , 03 , 80 , 02 CF , 3 , 00 , C1 , 30 ED , 4 , 64 , 03 , 12 , 81 E8 , 3 , 85 , 00 , 78 CB , 5 , 39 , 2 C , 00 , 34 , 02 F7 , 1 , 20 EA , 2 , 00 , 00 C0 , 1 , 23 C1 , 1 , 10 C5 , 2 , 3 e , 28 C7 , 1 , 86 36 , 1 , 48 37 , 1 , 00 3 A , 1 , 55 B1 , 2 , 00 , 18 B6 , 3 , 08 , 82 , 27 F2 , 1 , 00 26 , 1 , 01 E0 , 0 F , 0 F , 31 , 2 B , 0 C , 0 E , 08 , 4 E , F1 , 37 , 07 , 10 , 03 , 0 E , 09 , 00 E1 , 0 F , 00 , 0 E , 14 , 03 , 11 , 07 , 31 , C1 , 48 , 08 , 0 F , 0 C , 31 , 36 , 0 F 11 , 80 29 , 80 : o , 28 :O , 29 :A , 2 A , 2 B , 2 C :R , 36 : 0 , 48 , 00 , 00 , 00 : 1 , 28 , 00 , 00 , 01 : 2 , 88 , 00 , 00 , 02 : 3 , E8 , 00 , 00 , 02 # Scripter is the nost convenient way to edit and develop a uDisplay driver. On every scripter save the display is reinitialized and you immediately see results of your changes. Scripter driven display descriptor > D > B => displayreinit > d ; name , xs , ys , bpp , interface , address , scl , sda , reset :H , SH1106 , 128 , 64 , 1 , I2C , 3 c , * , * , * :S , 0 , 2 , 1 , 0 , 30 , 20 :I AE D5 , 80 A8 , 3 f D3 , 00 40 8 D , 14 20 , 00 A1 C8 DA , 12 81 , CF D9F1 DB , 40 A4 A6 AF : o , AE :O , AF :A , 00 , 10 , 40 # Compiling ~ There are also many variants of each display available and not all variants may be supported. #define directive Description USE_DISPLAY Enable display support. Also requires at least one of the following compilation directives USE_DISPLAY_LCD Enable LCD display. Also requires USE_I2C USE_DISPLAY_SSD1306 Enable OLED SSD1306 display. Also requires USE_I2C USE_DISPLAY_MATRIX Enable MATRIX display USE_DISPLAY_ILI9341 Enable TFT ILI9341 display. Also requires USE_SPI if seconds SPI bus on ESP32 shall be used SSPI must be defined instead of SPI ILI9342 also supported, select with cmd displayilimode 3, default is: displayilimode 1 (ILI9341) USE_DISPLAY_EPAPER_29 Enable Waveshare EPAPER_29 display.(black/white, partial update) Also requires USE_SPI USE_DISPLAY_EPAPER_42 Enable Waveshare EPAPER_42 display.(black/white, full update) Also requires USE_SPI USE_DISPLAY_SH1106 Enable OLED SH1106 display. Also requires USE_I2C USE_DISPLAY_ILI9488 Enable TFT ILI9488 display. Also requires USE_SPI USE_DISPLAY_SSD1351 Enable color OLED SSD1351 display. Also requires USE_SPI USE_DISPLAY_RA8876 Enable TFT RA8876 display. Also requires USE_SPI USE_DISPLAY_SEVENSEG Enable 7 segment display. Also requires USE_I2C USE_DISPLAY_ST7789 Enable TFT ST7789 display. Also requires USE_SPI USE_DISPLAY_ILI9342 Enable TFT ILI9342 display. Also requires USE_SPI USE_DISPLAY_SD1331 Enable TFT SD1331 display. Also requires USE_SPI USE_DISPLAY_TM1637 Enable 7-segment TM1637, TM1638 and MAX7219 display. USE_DISPLAY_SEVENSEG_COMMON_ANODE Common anode 7 segment displays. Also requires USE_I2C USE_DISPLAY_TM1637 Enable TM1637 display USE_LILYGO47 Enable LILGO 4.7 Epaper display ESP32 combo USE_UNIVERSAL_DISPLAY Enable universal display driver USE_LVGL Enable LVGL, currently only supported by berry scripting USE_TOUCH_BUTTONS Enable virtual touch button support with touch displays SHOW_SPLASH Enable initialization splash message on the display USE_RAMFONT Enable loadable Fonts USE_MULTI_DISPLAY Enable mutiple display support (up to 3) USE_AWATCH Enables analog watch support USE_GRAPH Enable line charts. Also requires NUM_GRAPHS","title":"Displays"},{"location":"Displays/#supported-displays","text":"DisplayModel Name Interface 1 LCD display I 2 C 2 SSD1306 OLED display I 2 C 3 8x8 MATRIX display GPIO 4 ILI934x TFT display DisplayIliMode 1 for ILI9341 or DisplayIliMode 3 for ILI9342 When second SPI bus on ESP32 is used, SSPI must be defined instead of SPI SPI 5 Waveshare E-Paper 2.9\" display (black/white, partial update) SPI 6 Waveshare E-Paper 4.2\" display (black/white, full update) SPI 7 SH1106 OLED display I 2 C 8 ILI9488 TFT display SPI 9 SSD1351 OLED color display SPI 10 RA8876 TFT display SPI 11 7 segment common anode display I 2 C 12 ST7789 TFT display SPI 14 SD1331 TFT display SPI 15 TM1637, TM1638 and MAX7219 7-segment displays GPIO 16 LilyGO T5 4.7\" E-Paper display ESP32 device 17 Universal Display Driver SPI or I 2 C 18 Interface to virtual display driver with Berry","title":"Supported Displays"},{"location":"Displays/#display-commands","text":"See commands page for full list of available Display Commands","title":"Display Commands"},{"location":"Displays/#displaymode","text":"The display driver is able to display predefined setups of text or user defined text. To display text using DisplayText set DisplayMode to 0 , or set DisplayMode to 1 for the HT16K33 dot-matrix display. To use the seven-segment-specific TM1637, TM1638 and MAX7219 Display- commands, set DisplayMode to 0 . Parameter LCD Display OLED Display TFT Display 7-segment Display (TM163x and MAX7219) 0 DisplayText DisplayText DisplayText All TM163x Display- functions 1 Time/Date Time/Date Time/Date Time 2 Local sensors Local sensors Local sensors Date 3 MQTT and Time/Date Local sensors and Time/Date Local sensors and Time/Date Time/Date 4 Local sensors MQTT and local sensors MQTT and local sensors NA 5 MQTT and Time/Date MQTT, local sensors and Time/Date MQTT, local sensors and Time/Date NA","title":"DisplayMode"},{"location":"Displays/#displaytext","text":"The DisplayText command is used to display text as well as graphics and graphs on LCD, OLED and e-Paper displays (EPD). The command argument is a string that is printed on the display at the current position. The string can be prefixed by embedded control commands enclosed in brackets [] . In order to use the DisplayText command the DisplayMode must be set to 0 (or optional 1 on LCD displays) or other modes must be disabled before compilation with #undef USE_DISPLAY_MODES1TO5 . The DisplayText command is customised for the TM1637, TM1638 and MAX7219 seven-segment display modules. This is documented here .","title":"DisplayText"},{"location":"Displays/#displaytext-parameters","text":"In the list below p stands for parameter and may be a number from 1 to n digits. On monochrome graphic displays things are drawn into a local frame buffer and sent to the display either via the d command or automatically at the end of the command.","title":"DisplayText Parameters"},{"location":"Displays/#positioning","text":"lp = sets a character line to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) cp = sets a character column to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) xp = sets the x position for consecutive prints yp = sets the y position for consecutive prints Text is printed at the last provided position, either l or y for the vertical position, and either x or x for the horizontal position. Neither x nor y are advanced/updated after printing text.","title":"Positioning"},{"location":"Displays/#line-primitives","text":"hp = draws a horizontal line with length p (x is advanced) vp = draws a vertical line with length p (y is advanced) Lp:p = draws a line top: p (x,y are advanced) kp = draws a circle with radius p Kp = draws a filled circle with radius p rp:p = draws a rectangle with p with and p height Rp:p = draws a filled rectangle with p with and p height up:p:p = draws a rounded rectangle with p with, p height and p radius v Up:p:p = draws a filled rounded rectangle with p with, p height and p radius","title":"Line Primitives"},{"location":"Displays/#miscellaneous","text":"z = clear the display i = (re)init the display (in e-Paper mode with partial update) I = (re)init the display (in e-Paper mode with full update) d = update the display Dp = switch display drawing options: bit 0: auto updates => 1 auto draw on each displaytext cmd, 0 display must be updated manually with d ( only valid for bw oled and epaper displays, color displays draw always immediately) bit 1: character drawing => 0 opaque character drawing, 1 transparent character drawing o = switch display off O = switch display on ap = p (0..3) set rotation angle t = display Tasmota time in HH:MM tS = display Tasmota time in HH:MM:SS T = display Tasmota date in DD.MM.YY pp = pad text with spaces, positive values align left, negative values align right sp = set text scaling for all fonts (scaling factor 1...N) fp = set font (1=12, 2=24,(opt 3=8)) if font==0 the classic GFX font is used, if font==7 RA8876 internal font is used, if font==4 special 7 segment 24 pixel number font is used, a ram based font is selected if font==5 Cp = set foreground color (0,1) for black or white and RGB decimal code for color (see color codes ) Bp = set background color (0,1) for black or white and RGB decimal code for color (see color codes ) Cip = set foreground index color (0..31) for color displays (see index color table below) Bip = set background index color (0..31) for color displays (see index color table below) wp = draws an analog watch with radius p (#define USE_AWATCH) Pfilename: = display an rgb 16-bit color (or jpg on ESP32) image when file system is present, Scripteditor contains a converter to convert jpg to special RGB16 pictures Ffilename: = load RAM font file when file system is present. the font is selected with font Nr. 5, these fonts are special binary versions of GFX fonts of any type. they end with .fnt. an initial collection is found in Folder BinFonts SXfilename: = load display descriptor for multiple display support (X = 1..3) for up to 3 displays. SX: = switch to display number (X = 1..3). dcI:V = define index color entry Index 19-31, V 16 bit color value (index 0-18 is fixed)","title":"Miscellaneous"},{"location":"Displays/#touch-buttons-and-sliders","text":"Requires #define USE_TOUCH_BUTTONS Draw up to 16 GFX buttons to switch real Tasmota devices such as relays or draw Sliders to dimm e.g. a lamp Button number + 256 - a virtual touch toggle button is created (MQTT => TBT) Button number + 512 - a virtual touch push button is created (MQTT => PBT) b#:xp:yp:xa:ys:oc:fc:tc:ts:text: Parameters are separated by colons. b# where # = define a button number 0-15 xp = x position yp = y position xa = x size ys = y size oc = outline index color fc = fill index color tc = text index color ts = text size on buttons text: = button text (must end with a colon :) (max 9 chars) b0:260:260:100:50:2:11:4:2:Rel 1:","title":"Touch Buttons and Sliders"},{"location":"Displays/#picture-buttons","text":"To create picture touch buttons (jpg on ESP32 only) requires #define JPEG_PICTS and #define USE_UFILESYS . Upload pictures to the file system with a \".jpg\" extension, then give the path to the picture as button text omitting the .jpg extension. Create a picture button with a picture file named wifi.jpg b0:260:260:100:50:2:11:4:2:/wifi: The size of the picture is not scaled and the dimensions of the button must fit the picture size. Clicked buttons will invert the colors of the picture. You may specify a picture for selected and unselected button state. Picture filename ending with '1' is used for unselected state and ending '2' is for selected state.","title":"Picture Buttons"},{"location":"Displays/#sliders","text":"bs# where # = is slider number 0..15 xp = x position yp = y position xa = x size ys = y size ne = number of elements bc = background color fc = frame color bc = bar color Set the state of a button or slider with: b#sX where # = is slider number 0..15 X = 0 or 1 for buttons, 0..100 for sliders","title":"Sliders"},{"location":"Displays/#display-json-variables","text":"Requires #define USE_DT_VARS Display variables that are exposed in JSON MQTT strings e.g. in TelePeriod messages. The values are updated every second. dv#:xp:yp:gc:fc:fo:ts:tl:dp:ut:JSON:ut: Parameters are separated by colons. dv# where # = defines a variable number 0-7 (may be expanded by #define MAX_DT_VARS N) xp = x position yp = y position gc = text background color (index color) fc = text foreground color (index color) fo = text font ts = text size (negativ value denotes transparent text) tl = text field length (if negative align right) dp = decimal precision (if < 0 denotes a string) ut = update time in seconds (1...N) jt = JSON VARIABLE NAME (uppercase) if you specify a string in brackets here it is treated as displaytext cmd ut = unit string (max 5 chars and must end with a colon :) example: ; ILI9341 320 x240 portrait mode [ x0y0P / corona . rgb : ] [ dc19 : 31000 ] [ x60y30f2Ci3D2 ] Tasmota ; display text cmd displays time with seconds [ dv0 : 50 : 70 : 19 : 3 : 2 : 1 : 11 : 1 : 1 : [ tS ] :: ] ; display text cmd displays analog watch [ dv1 : 120 : 250 : 19 : 2 : 2 : 1 : 11 : 1 : 5 : [ w40 ] :: ] ; displays Wifi SSID JSON [ dv2 : 10 : 10 : 0 : 3 : 1 :- 1 : 10 :- 1 : 1 :WIFI # SSID :: ] [ x10y150f1s1Ci3Bi19 ] Counter: ; displays a sensor JSON variable ( here counter1 ) [ dv3 : 80 : 150 : 0 : 7 : 1 : 1 : 11 : 0 : 1 :COUNTER # C1: cnt : ] [ x10y300f1s1Ci3Bi19 ] memory free : ; displays pre memory space JSON ( heap ) [ dv4 : 100 : 300 : 0 : 7 : 1 : 1 :- 7 :- 1 : 1 :HEAP: kb : ]","title":"Display JSON variables"},{"location":"Displays/#line-chart","text":"( #define USE_GRAPH and #define NUM_GRAPHS 4 - maximum of 16) Up to 4 line charts may be defined. Ticks may be defined by adding tick numbers to the n parameter. Example n = graph number (0..3) + x ticks (16*number of x ticks) + y ticks (1024*number of y ticks). Gn:xp:yp:xs:ys:t:fmax:fmin defines a line chart: Parameters are separated by colons. n = number up to 4 charts (0..3) + optional ticks xp = x position yp = y position xs = x size (if xs<0) graph is not reinitialized on second call (e.g., restart of scripter) ys = y size t = time in minutes for total chart ymin = float chart minimum y ymax = float chart maximum y icol = line color index (only for color graphs) gn:v adds a value to the chart buffer: n = number up to 4 charts (0..3) v = float value to add Gdn:m sets graph n draw mode 0 = off, 1 = on. When on, redraw graph Gsn:path: = save graph n to path (if optional file system is present) Grn:path: = restore graph n from path (if optional file system is present)","title":"Line chart"},{"location":"Displays/#batch-files","text":"When a file system is present you may define displaytext batch files. If a file named \"display.bat\" is present in the file system this batch file is executed. The file may contain any number of diplaytext cmds, one at a line. You may have comment lines beginning with a ; Example ; clr screen [ z ] ; draw full screen picture [ x0y0P / corona . rgb : ] ; define index color [ dc19 : 31000 ] ; draw transparent text with new index color over picture [ x60y30f2Ci19D2 ] Tasmota A displaytext batch file may be executed from console by displaybatch /file","title":"Batch files"},{"location":"Displays/#color-codes","text":"While computers and web design are generally using a 24-bit RGB888 color code built from a byte-triplet such as (255, 136, 56) or #FF8038, small color panels often use a more compact code 16-bit RGB565 color code. This means that the R, G and B coefficient are coded on less number of bits: Red on 5 bits = 0..31 Green on 6 bits = 0..63 Blue on 5 bits = 0..31 For Cp and Bp , p is calculated as p = 2048 * Red + 64 * Green + Blue Example Red 50% + Green 20% + Blue 100% = 2048 * 16 + 64 * 12 + 31 = 33576 equivalent to web #8033FF Common colors table: Color Code Color Code Color Code Black 0 Navy 15 Dark green 3 Dark cyan 1007 Maroon 30720 Purple 30735 Olive 31712 Light grey 50712 Dark grey 31727 Blue 31 Green 7 Cyan 2047 Red 63488 Magenta 63519 Yellow 65504 White 65535 Orange 64800 Green yellow 45029 Pink 64536","title":"Color Codes"},{"location":"Displays/#color-indices","text":"Selected with Ci and Bi in the ILI9488, SSD1351, RA8876 and ST7789 color panels Index Color Index Color Index Color 0 BLACK 1 WHITE 2 RED 3 GREEN 4 BLUE 5 CYAN 6 MAGENTA 7 YELLOW 8 NAVY 9 DARKGREEN 10 DARKCYAN 11 MAROON 12 PURPLE 13 OLIVE 14 LIGHTGREY 15 DARKGREY 16 ORANGE 17 GREENYELLOW 18 PINK You may expand the index color table up from index 19 to 31. the cmd [dcI:V] defines the index color with index I (19-31) to the 16 bit color value V","title":"Color Indices"},{"location":"Displays/#fonts","text":"The EPD font contains 95 characters starting from code 32, while the classic GFX font contains 256 characters ranging from 0 to 255. Custom characters above 127 can be displayed. To display these characters, you must specify an escape sequence (standard octal escapes do not work). The ~ character followed by a hex byte can define any character code. GFXFont: EPDFont:","title":"Fonts"},{"location":"Displays/#hardware-connections","text":"I 2 C displays are connected in the usual manner and defined via the GPIO component selection. The I 2 C address must be specified using DisplayAddress XX , e.g., 60 . The model must be spedified with DisplayModel , e.g., 2 for SSD1306. To permanently turn the display on set DisplayDimmer 100 . Display rotation can be permanently set using DisplayRotate X (x = 0..3 ). On SPI the CS and DC pins when needed must use the pin definition with Display_ID + CS e.g. ST7789_CS E-Paper displays are connected via software 3-wire SPI (CS, SCLK, MOSI) . DC should be connected to GND , Reset to 3.3 V and busy may be left unconnected. The jumper on the circuit board of the display must be set to 3-wire SPI. The ILI9488 is connected via hardware 3-wire SPI (SPI_MOSI=GPIO13, SPI_SCLK=GPIO14, CS=GPIO15) and must also be connected to the backlight pin The SSD1351 may be connected via hardware 3-wire SPI or 4-wire SPI with support for dimmer. The ILI9341 is connected via hardware 4-wire SPI, Backlight and OLEDRESET (dimmer supported on ESP32) Wiring The RA8876 is connected via standard hardware 4-wire SPI (SPI_MOSI=GPIO13, SPI_SCLK=GPIO14, RA_8876_CS=GPIO15, SSPI_MISO=GPIO12) . No backlight pin is needed, dimmer supported, on ESP32 gpio pins may be freeley defined (below gpio 33). The ST7789 is connected via 4 Wire software SPI ((ST7789_CS), SSPI_SCLK, SSPI_MOSI, ST7789_DC, OLEDRESET, Backlight )","title":"Hardware Connections"},{"location":"Displays/#rule-examples","text":"For scripting examples see Scripting Cookbook Print Text at size 1 on line 1, column 1: DisplayText [s1l1c1]Hello how are you? Draw a rectangle and draw text inside with size 2 and 7 chars padded with spaces: DisplayText [x85y95h130v30h-130v-30s2p7x90y100]37.25 C Refresh screen: DisplayText [z] Draw rectangle from x,y with width and height: DisplayText [x50y50r200:100]","title":"Rule Examples"},{"location":"Displays/#display-local-sensors","text":"(line breaks and indentation added to the rules for readability) Use Tasmota rules to display sensor values, time, and a separation line. Refresh the display every 60 minutes: rule1 on tele - SHT3X - 0x44 # Temperature do DisplayText [ f1p7x0y5 ] % value % C endon on tele - SHT3X - 0x44 # Humidity do DisplayText [ f1p10x70y5 ] % value % % [ x0y20h296x250y5t ] endon on tele - BMP280 # Pressure do DisplayText [ f1p10x140y5 ] % value % hPa endon on Time # Minute | 60 do DisplayText [ Tt ] endon Show 4 analog channels: rule1 on tele - ADS1115 # A0 do DisplayText [ s1p21c1l01 ] Analog1: % value % adc endon on tele - ADS1115 # A1 do DisplayText [ s1p21c1l3 ] Analog2: % value % adc endon on tele - ADS1115 # A2 do DisplayText [ s1p21c1l5 ] Analog3: % value % adc endon on tele - ADS1115 # A3 do DisplayText [ s1p21c1l7 ] Analog4: % value % adc endon Show BME280 + SGP30: rule1 on tele - BME280 # Temperature do DisplayText [ s1p21x0y0 ] Temp: % value % C endon on tele - BME280 # Humidity do DisplayText [ s1p21x0y10 ] Hum : % value % %% endon on tele - BME280 # Pressure do DisplayText [ s1p21x0y20 ] Prss: % value % hPa endon on tele - SGP30 # TVOC do DisplayText [ s1p21x0y30 ] TVOC: % value % ppb endon on tele - SGP30 # eCO2 do DisplayText [ s1p21x0y40 ] eCO2 : % value % ppm [ s1p0x0y50 ] Time: [ x35y50t ] endon","title":"Display Local Sensors"},{"location":"Displays/#waveshare-display-drivers","text":"Waveshare has two kinds of display controllers: with partial update and without partial update. The 2.9 inch driver is for partial update and should also support other Waveshare partial update models with modified WIDTH and HEIGHT parameters. The 4.2 inch driver is a hack which makes the full update display behave like a partial update and should probably work with other full update displays. The drivers are subclasses of the Adafruit GFX library. The class hierarchy is LOWLEVEL :: Paint :: Renderer :: GFX , where: GFX : unmodified Adafruit library Renderer : the interface for Tasmota Paint : the modified pixel driver for e-paper there are several virtual functions that can be subclassed down to LOWLEVEL The display dispatcher only does the class initialization call. All other calls go to the Renderer class. In black and white displays, a local RAM buffer must be allocated before calling the driver. This must be set to zero on character or TFT color displays. The EPD fonts use about 9k space, which can be selected at compile time using #ifdef directives. SSD1306 - 1.15k EPD42 - 2.57k EPD29 - 2.1k Display and Render class - ~12k","title":"WaveShare Display Drivers"},{"location":"Displays/#universal-display-driver","text":"Universal Display Driver or uDisplay is a way to define your display settings using a simple text file and easily add it to Tasmota. uDisplay is DisplayModel 17 . It supports I2C and hardware or software SPI (3 or 4 wire). The driver is enabled by compiling with #define USE_UNIVERSAL_DISPLAY and setting an unused GPIO to Option A3 .","title":"Universal Display Driver"},{"location":"Displays/#descriptor-file","text":"The display itself is defined by a descriptor file. Many display descriptor files are included in Tasmota GitHub in tasmota/displaydesc folder which may be provided by any of the following methods: A display.ini file present in the flash file system. preferred option A special >d section in scripting. Copy the file to the >d script section and place a ->displayreinit cmd into >B section Copy the descriptor to Rule 3 but do not enable it (descriptor may not contain ANY spaces in this mode) Compile the descriptor into the binary in a section in user_config_override.h under driver 17 (const char) Options 2 and 4 work well for 1M flash devices. Descriptor text file has the following elements: :H Header line describes the main features of the display (comma seperated, no spaces allowed) name x size in pixels y size in pixels bits per pixel (1 for bw displays, 16 for color displays) hardware interface used either I2C or SPI I2C I2C address in HEX SCL pin SDA pin RESET pin SPI Number (1 = hardware SPI 1, 2 = Hardware SPI 2 (ESP32), 3 = software SPI CS pin CLK pin MOSI pin DC pin Backlight pin RESET pin MISO pin SPI Speed in MHz All signals must be given. Unused pins may be set to -1. If you specify a * char the pin number is derived from the Tasmota GPIO GUI. The CS and DC pins must be the standard pins e.g. SPI_CS or SPI_DC . Example :H , SH1106 , 128 , 64 , 1 , I2C , 3 c , * , * , * :H , ILI9341 , 240 , 320 , 16 , SPI , 1 , - 1 , 14 , 13 , 5 , 4 , 15 , * , 40 :S ( optional ) Splash setup, also defines initial colors. If omitted screen is not cleared initially. Font number Font size FG color (as index color) BG color (as index color) x position of text y position of text Example :S , 2 , 1 , 1 , 0 , 40 , 20 :I Initial register setup for the display controler. ( IC marks that the controller is using command mode even with command parameters) All values are in hex. On SPI the first value is the command, then the number of arguments and the the arguments itself. Bi7 7 on the number of arguments set indicate a wait of 150 ms. On I 2 C all hex values are sent to I 2 C. Example :I EF , 3 , 03 , 80 , 02 CF , 3 , 00 , C1 , 30 ED , 4 , 64 , 03 , 12 , 81 E8 , 3 , 85 , 00 , 78 CB , 5 , 39 , 2 C , 00 , 34 , 02 F7 , 1 , 20 EA , 2 , 00 , 00 C0 , 1 , 23 C1 , 1 , 10 C5 , 2 , 3 e , 28 C7 , 1 , 86 36 , 1 , 48 37 , 1 , 00 3 A , 1 , 55 B1 , 2 , 00 , 18 B6 , 3 , 08 , 82 , 27 F2 , 1 , 00 26 , 1 , 01 E0 , 0 F , 0 F , 31 , 2 B , 0 C , 0 E , 08 , 4 E , F1 , 37 , 07 , 10 , 03 , 0 E , 09 , 00 E1 , 0 F , 00 , 0 E , 14 , 03 , 11 , 07 , 31 , C1 , 48 , 08 , 0 F , 0 C , 31 , 36 , 0 F 11 , 80 29 , 80 :o ,OP OP = controller OPCODE to switch display off :O ,OP OP = controller OPCODE to switch display on :R ,OP,SL OP = rotation opcode SL = startline opcode (optional) :0 :1 :2 :3 Register values for all 4 rotations (color display only) rotation code x offset y offset rotation pseudo opcode for touch panel the appropriate coordinate convervsions are defined via pseudo opcodes 0 = no conversion 1 = swap and flip x 2 = flipx, flip y 3 = swap and flip y 4 = flip x 5 = flip y bit 7 = swap x,y :A 3 OPCODES to set adress window (all but epaper displays) set column opcode set row opcode start write opcode pixel size (optional) :P Pixel transfer size (default = 16 bit RGB) (optional) :i invert display opcodes 1. inversion off 2. inversion on :D dimmer opcode (optional) :B LVGL (optional) number of display lines flushed at once (min 10) the lower the lesser memory needed bit 0: DMA enables ( 0 for no DMA, 1 use DMA) - not supported on all displays bit 1: selects color swap, 2 = swap 16 bit color bit 2: enable async DMA, 0 wait for DMA to complete before returning, 4 run DMA async in the background. This later mode is only valid if the SPI bus is not shared between the display and any other SPI device like SD Card Reader. :T Wait times used for E-paper display 1. full refresh wait in ms 2. partial refresh wait in ms 3. wait after update in ms :L Lookup table for full refresh (Waveshare 29) :l Lookuptable for partial refresh (Waveshare 29) :Lx ,OP Lookuptable for full refresh (Waveshare 42) x = 1..5 OP = opcode for sending refresh table :TIx,AA,SCL,SDA Defines a touch panel an I2C bus nr x (1 or 2) AA is device address SCL, SDA are the pins used (or * for tasmota definition) :TS,CS_PIN Defines a touch panel an SPI bus with chip select CS_PIN (or *) :M,X1,X2,Y1,Y2 Defines an optional mapping for touch controllers (always needed on resistive touch) X1 = display left margin X2 = display right margin Y1 = display upper margin Y1 = display lower margin :r,X Defines optional display rotation X = 0..3 :b,X Defines optional inverted backpanel X = 1 = use inverted logic for backpanel Full configuration for SH1106 (comment lines starting with ; are allowed) :H , SH1106 , 128 , 64 , 1 , I2C , 3 c , * , * , * :S , 0 , 2 , 1 , 0 , 30 , 20 :I AE D5 , 80 A8 , 3 f D3 , 00 40 8 D , 14 20 , 00 A1 C8 DA , 12 81 , CF D9F1 DB , 40 A4 A6 AF : o , AE :O , AF :A , 00 , 10 , 40 # Full configuration for ILI9341: (comment lines starting with ; are allowed) :H , ILI9341 , 240 , 320 , 16 , SPI , 1 , * , * , * , * , * , * , * , 40 :S , 2 , 1 , 1 , 0 , 40 , 20 :I EF , 3 , 03 , 80 , 02 CF , 3 , 00 , C1 , 30 ED , 4 , 64 , 03 , 12 , 81 E8 , 3 , 85 , 00 , 78 CB , 5 , 39 , 2 C , 00 , 34 , 02 F7 , 1 , 20 EA , 2 , 00 , 00 C0 , 1 , 23 C1 , 1 , 10 C5 , 2 , 3 e , 28 C7 , 1 , 86 36 , 1 , 48 37 , 1 , 00 3 A , 1 , 55 B1 , 2 , 00 , 18 B6 , 3 , 08 , 82 , 27 F2 , 1 , 00 26 , 1 , 01 E0 , 0 F , 0 F , 31 , 2 B , 0 C , 0 E , 08 , 4 E , F1 , 37 , 07 , 10 , 03 , 0 E , 09 , 00 E1 , 0 F , 00 , 0 E , 14 , 03 , 11 , 07 , 31 , C1 , 48 , 08 , 0 F , 0 C , 31 , 36 , 0 F 11 , 80 29 , 80 : o , 28 :O , 29 :A , 2 A , 2 B , 2 C :R , 36 : 0 , 48 , 00 , 00 , 00 : 1 , 28 , 00 , 00 , 01 : 2 , 88 , 00 , 00 , 02 : 3 , E8 , 00 , 00 , 02 # Scripter is the nost convenient way to edit and develop a uDisplay driver. On every scripter save the display is reinitialized and you immediately see results of your changes. Scripter driven display descriptor > D > B => displayreinit > d ; name , xs , ys , bpp , interface , address , scl , sda , reset :H , SH1106 , 128 , 64 , 1 , I2C , 3 c , * , * , * :S , 0 , 2 , 1 , 0 , 30 , 20 :I AE D5 , 80 A8 , 3 f D3 , 00 40 8 D , 14 20 , 00 A1 C8 DA , 12 81 , CF D9F1 DB , 40 A4 A6 AF : o , AE :O , AF :A , 00 , 10 , 40 #","title":"Descriptor File"},{"location":"Displays/#compiling","text":"There are also many variants of each display available and not all variants may be supported. #define directive Description USE_DISPLAY Enable display support. Also requires at least one of the following compilation directives USE_DISPLAY_LCD Enable LCD display. Also requires USE_I2C USE_DISPLAY_SSD1306 Enable OLED SSD1306 display. Also requires USE_I2C USE_DISPLAY_MATRIX Enable MATRIX display USE_DISPLAY_ILI9341 Enable TFT ILI9341 display. Also requires USE_SPI if seconds SPI bus on ESP32 shall be used SSPI must be defined instead of SPI ILI9342 also supported, select with cmd displayilimode 3, default is: displayilimode 1 (ILI9341) USE_DISPLAY_EPAPER_29 Enable Waveshare EPAPER_29 display.(black/white, partial update) Also requires USE_SPI USE_DISPLAY_EPAPER_42 Enable Waveshare EPAPER_42 display.(black/white, full update) Also requires USE_SPI USE_DISPLAY_SH1106 Enable OLED SH1106 display. Also requires USE_I2C USE_DISPLAY_ILI9488 Enable TFT ILI9488 display. Also requires USE_SPI USE_DISPLAY_SSD1351 Enable color OLED SSD1351 display. Also requires USE_SPI USE_DISPLAY_RA8876 Enable TFT RA8876 display. Also requires USE_SPI USE_DISPLAY_SEVENSEG Enable 7 segment display. Also requires USE_I2C USE_DISPLAY_ST7789 Enable TFT ST7789 display. Also requires USE_SPI USE_DISPLAY_ILI9342 Enable TFT ILI9342 display. Also requires USE_SPI USE_DISPLAY_SD1331 Enable TFT SD1331 display. Also requires USE_SPI USE_DISPLAY_TM1637 Enable 7-segment TM1637, TM1638 and MAX7219 display. USE_DISPLAY_SEVENSEG_COMMON_ANODE Common anode 7 segment displays. Also requires USE_I2C USE_DISPLAY_TM1637 Enable TM1637 display USE_LILYGO47 Enable LILGO 4.7 Epaper display ESP32 combo USE_UNIVERSAL_DISPLAY Enable universal display driver USE_LVGL Enable LVGL, currently only supported by berry scripting USE_TOUCH_BUTTONS Enable virtual touch button support with touch displays SHOW_SPLASH Enable initialization splash message on the display USE_RAMFONT Enable loadable Fonts USE_MULTI_DISPLAY Enable mutiple display support (up to 3) USE_AWATCH Enables analog watch support USE_GRAPH Enable line charts. Also requires NUM_GRAPHS","title":"Compiling"},{"location":"Domoticz/","text":"Tasmota supports Domoticz MQTT 'out of the box' for both relays and sensors. Find below the procedure to configure Domoticz and Tasmota. Prerequisites ~ The following servers should be made available: You have installed/access to a MQTT broker server and made contact with your Tasmota device You have installed Domoticz MQTT and Virtual Sensor ~ If not already done configure Domoticz MQTT and Virtual Sensor hardware. On the hardware page add Type MQTT Client Gateway with LAN interface Give it a name Configure the interface with access to your MQTT server ( Remote Address , Port , Username and Password ) Set the Public Topic to flat (which seems to relate to out in the select field) On the hardware page add Type Dummy (used for virtual switches) Give it a name Virtual Switch ~ Make a new virtual switch and remeber its Idx number. Make a new virtual switch to be used with Sonoff by clicking Create Virtual Sensors Give it a name Select Sensor Type Switch On the Devices page find the new switch by it's name Remember it's Idx number Tasmota Configuration ~ Tasmota provides different ways to configure Domoticz parameters. Choose the method you prefer: [The sections below don't look like they are needed any longer. The in topic and out topic entry areas don't appear to be in the Domoticz configure section - at least they are not there in mine and mine is working 17/03/2018] Use the webinterface and select Configuration - Configure Domoticz : Set In topic to domoticz/in as hardcoded in Domoticz Set Out topic to domoticz/out as hardcoded in Domoticz Configure Idx 1 to the value read in step 2.i Use MQTT and execute commands (if necessary, replace tasmota with unique topic you configured in Initital Configuration, see point 5 there ): cmnd/tasmota/DzInTopic with payload domoticz/in as hardcoded in Domoticz cmnd/tasmota/DzOutTopic with payload domoticz/out as hardcoded in Domoticz cmnd/tasmota/DzIdx1 with payload value read in step 2.i Use the serial interface and execute commands: DzInTopic with domoticz/in as hardcoded in Domoticz DzOutTopic with domoticz/out as hardcoded in Domoticz DzIdx1 with the value read in step 2.i Usage ~ That's it! You can now control your device from the Domoticz user interface. On the Switches page scroll down and find your Switch as configured in step 1 Toggle the light bulb; Tasmota should respond Automatic Disovery ~ Tasmota supports automatic discovery by Domoticz through the Domoticz MQTT Discovery plugin . Prerequisites ~ The following services should be made available: You have installed/access to a MQTT broker server and made contact with your sonoff You have installed Domoticz You have installed the Domoticz MQTT Discovery plugin MQTT Discovery Plugin ~ Configure Domoticz MQTT Discovery plugin. On the hardware page add Type MQTT Discovery Give it a name, e.g. Tasmota Configure the interface with access to your MQTT server ( MQTT Server Address , Port , Username and Password ) Set the Discovery topic to homeassistant unless it has been changed in a custom Tasmota build Set the Ignored device topic to /tasmota/ to avoid unconfigured Tasmota devices from being discoved Tasmota Configuration ~ Precompiled Binary ~ Each Tasmota device must have it's own topic, the easiest way is to set topic to tasmota_%06X (%06X will be replaced by MAC address). See here for how to set the topic. Use MQTT or Serial or Web console and execute commands (replace %topic% with the device's unique topic) cmnd/%topic%/SetOption19 with payload 1 to enable MQTT discovery Custom Binary ~ The above settings can be defined in user_config_override.h (TBD) Usage ~ That's it! You will now find your Sonoff in the Domoticz user interface. On the Switches page scroll down and find your Switch as configured in step 1 Toggle the light bulb; Sonoff should respond ...including sensors ~","title":"Domoticz"},{"location":"Domoticz/#mqtt-and-virtual-sensor","text":"If not already done configure Domoticz MQTT and Virtual Sensor hardware. On the hardware page add Type MQTT Client Gateway with LAN interface Give it a name Configure the interface with access to your MQTT server ( Remote Address , Port , Username and Password ) Set the Public Topic to flat (which seems to relate to out in the select field) On the hardware page add Type Dummy (used for virtual switches) Give it a name","title":"MQTT and Virtual Sensor"},{"location":"Domoticz/#virtual-switch","text":"Make a new virtual switch and remeber its Idx number. Make a new virtual switch to be used with Sonoff by clicking Create Virtual Sensors Give it a name Select Sensor Type Switch On the Devices page find the new switch by it's name Remember it's Idx number","title":"Virtual Switch"},{"location":"Domoticz/#tasmota-configuration","text":"Tasmota provides different ways to configure Domoticz parameters. Choose the method you prefer: [The sections below don't look like they are needed any longer. The in topic and out topic entry areas don't appear to be in the Domoticz configure section - at least they are not there in mine and mine is working 17/03/2018] Use the webinterface and select Configuration - Configure Domoticz : Set In topic to domoticz/in as hardcoded in Domoticz Set Out topic to domoticz/out as hardcoded in Domoticz Configure Idx 1 to the value read in step 2.i Use MQTT and execute commands (if necessary, replace tasmota with unique topic you configured in Initital Configuration, see point 5 there ): cmnd/tasmota/DzInTopic with payload domoticz/in as hardcoded in Domoticz cmnd/tasmota/DzOutTopic with payload domoticz/out as hardcoded in Domoticz cmnd/tasmota/DzIdx1 with payload value read in step 2.i Use the serial interface and execute commands: DzInTopic with domoticz/in as hardcoded in Domoticz DzOutTopic with domoticz/out as hardcoded in Domoticz DzIdx1 with the value read in step 2.i","title":"Tasmota Configuration"},{"location":"Domoticz/#automatic-disovery","text":"Tasmota supports automatic discovery by Domoticz through the Domoticz MQTT Discovery plugin .","title":"Automatic Disovery"},{"location":"Domoticz/#mqtt-discovery-plugin","text":"Configure Domoticz MQTT Discovery plugin. On the hardware page add Type MQTT Discovery Give it a name, e.g. Tasmota Configure the interface with access to your MQTT server ( MQTT Server Address , Port , Username and Password ) Set the Discovery topic to homeassistant unless it has been changed in a custom Tasmota build Set the Ignored device topic to /tasmota/ to avoid unconfigured Tasmota devices from being discoved","title":"MQTT Discovery Plugin"},{"location":"Domoticz/#tasmota-configuration_1","text":"","title":"Tasmota Configuration"},{"location":"Domoticz/#including-sensors","text":"","title":"...including sensors"},{"location":"Download/","text":"Download binaries from: Official OTA Server: ~ Current release Development branch ESP32 Current release ESP32 Development branch Older release binaries: v9.3.1 v9.1.0 v8.5.1 v7.2.0 v6.7.1","title":"Download"},{"location":"Download/#official-ota-server","text":"Current release Development branch ESP32 Current release ESP32 Development branch Older release binaries: v9.3.1 v9.1.0 v8.5.1 v7.2.0 v6.7.1","title":"Official OTA Server:"},{"location":"Dynamic-Sleep/","text":"Dynamic Sleep (CPU Main loop target / CPU Power Management) ~ SetOption60 may be used to configure your device to use Normal Sleep or Dynamic Sleep. Dynamic Sleep is enabled by default from Tasmota version 6.3.0.15 but may be reconfigured by setting the value of SetOption60 accordingly. Command Description SetOption60 0 Dynamic Sleep is ENABLED (Default since 6.3.0.15) SetOption60 1 Normal Sleep is ENABLED The term CPU is used loosely here for the sake of making it easier to understand - When the term CPU is used it is actually referring to the ESP8266 SoC Micro Controller. With the introduction of many new drivers, sensors and other functions as part of the Tasmota firmware, it has become more important to pay specific attention to the amount of microcontroller clock cycles shared with the underlying SDK/Arduino ESP8266 Core. The main application loop of the Tasmota firmware needs to visit each of the driver callbacks within the main loop to make sure all the required drivers and sensors receive the necessary processing time whilst ensuring that the main loop does not overwhelm the need for processing time by the SDK / Arduino ESP8266 core. The highest priority drivers/sensors need to be called once per 50ms to operate as designed but most of the normal run of the mill drivers and sensors do not necessarily require this amount of intense polling. The 50-millisecond mark would normally be considered to be an absolute minimum duty cycle for the main processing loop on ESP8266 boards whilst most Sonoff device derivatives will function perfectly well way above this default setting. To make this manageable from device to device a new setting has been introduced enabling the setting of the main loop target to a specific value in milliseconds. For default operation, this will be set to 50 milliseconds as there are generally no drivers or sensors that need to be polled at a rate higher than this. To allow for power usage flexibility this value may also be increased to a value of up to 250 milliseconds which is very useful to reduce power and processing demand on non-time critical devices such as switches (which is what most of Tasmota is used for.) The purpose of this setting is to allow you as a user to set the speed at which driver and sensors will be serviced and as a result also the amount of time given to the SDK / Arduino ESP8266 core to handle its background tasks (which are not under direct control of the Tasmota firmware.) Example Use Case ~ Let's assume the default value of 50 for sleep and that a simple device such as a Sonoff Basic R1 or R2 is being used. In this case, the main firmware loop will iterate through all the drivers and sensors once per 50 milliseconds. Current tests suggest that a simple device such as a Sonoff Basic requires only about 9.5 milliseconds to complete one iteration of servicing all the drivers and sensors enabled in the standard tasmota.bin firmware. The time management functionality offered by dynamic sleep will compute this time requirement automatically and allow the SDK / Arduino ESP8266 Core to service background tasks such as maintaining WiFi connectivity for the remainder of the time not spent in the main firmware loop - i.e. in the case of sleep 50 this would mean 50 milliseconds - ~9.5 milliseconds = ~40.5 milliseconds spent outside of the main firmware loop servicing SDK / ESP8266 Core functions which automatically consume fewer clock cycles when there is nothing intense for the SDK / ESP8266 Core to maintain or perform. Normal Sleep was previously the only option for Tasmota powered devices wishing to take advantage of power saving but it does have the disadvantage that the sleep would be a constant setting insofar that the entire firmware codebase would run at a pre-determined speed causing some drivers to run slower than expected and decreasing the speed at which services such as the WebUI is rendered (This varies between the various underlying cores depending on which version is used.) Using Dynamic Sleep (SetOption60 = 0) instead of Normal Sleep (SetOption60 = 1) has the advantage that CPU time will be given to any particular driver or process (let's say the WebUI) on demand as and when needed whilst spending most of its time waiting for the next main loop iteration to occur. During this time of waiting the ESP8266's power demand can go from 80mA all the way down to 20mA which yields great benefits for power saving vs. firmware responsiveness compared to the traditional sleep setting. Normally the target main loop setting would be 50 milliseconds. The firmware will service all the driver and sensor callbacks up to a maximum of 20 times per second. In most cases, this is unnecessary as most normal sensors like temperature sensors only need polling once per second. So, whether you poll the temperature sensor 20 times per second (sleep 50) or 5 times per second (sleep 200) it has no impact on the functionality. Allowing the main loop to iterate 20 times per second vs. 5 times per second is obviously more time consuming and processor consuming leaving less time to idle (i.e., save power). For example, if you were using an MCP230xx with interrupts, and you need a high interrupt response then sleep 50 or lower would make sense since that specific driver can poll once per 50 milliseconds to check for interrupts. Most other sensor polling can be done in intervals longer than 50 milliseconds so you achieve more idle time, and therefore also more sleep time so it saves power. Monitoring Performance ~ Given all the above it is an obvious conclusion that in order to manage something you would need to be able to measure it. For this reason two new variables have been added to the telemetry data namely LoopSet and LoadAvg and are represented in the telemetry JSON as follows: MQT: tele/sound1/STATE = {\"Time\":\"2018-11-26T17:41:27\",\"Uptime\":\"0T05:05:17\",\"Vcc\":3.504,\"SleepMode\":\"Dynamic\",\"Sleep\":50,\"LoadAvg\":19,\"POWER\":\"OFF\",\"Wifi\":{\"AP\":1,\"SSId\":\"Wireless\",\"BSSId\":\"DE:AD:00:00:BE:EF\",\"Channel\":3,\"RSSI\":100}} The two values indicated for LoopSet and LoadAvg have the following relation: Variable Value Description SleepMode Normal Normal Sleep mode is enabled (SetOption60 = 1) SleepMode Dynamic Dynamic Sleep mode is enabled (SetOption60 = 0) Sleep 50 Current setting for sleep LoadAvg 19 Reported % time of Sleep spent doing Tasmota main loop processing In this example, 19% of 50 milliseconds would be 9.5 milliseconds (19/100*50), so we can see that there is sufficient headroom for the SDK / ESP8266 Arduino Core to do its background work. On some devices which have many sensors connected you may observe the LoadAvg value exceeding 100 - This means that you have not set the value of sleep high enough to accommodate all the sensors and drivers which need to be serviced. In the latter case, you have two options - either increase the value of sleep to a higher one to maintain a load average well below 100 or use multiple devices to spread the load across separate Tasmota powered devices/boards. For the most part, all Sonoff based products should perform well balanced with the default setting of 50 for sleep. How to use Dynamic Sleep ~ From serial console, or webui console enter command SetOption60 0 and Sleep xx Where xx is the number of milliseconds you wish to target your main processing loop at ranging from 0 through to 250. Should you set a sleep value that is too low you will observe output on telemetry for the value of LoadAvg to be in excess of 100 - This is not ideal and should be avoided as it starves the Arduino Core / SDK of the needed processing time to take care of background tasks such as WiFi management. For optimal operation of the Tasmota firmware, it is recommended to keep your device running at a LoadAvg value of 75 or lower. If your device does not have any time critical drivers/sensors connected you are encouraged to increase the sleep value to a higher value to gain from the power saving benefits thereof.","title":"Dynamic Sleep"},{"location":"Dynamic-Sleep/#dynamic-sleep-cpu-main-loop-target-cpu-power-management","text":"SetOption60 may be used to configure your device to use Normal Sleep or Dynamic Sleep. Dynamic Sleep is enabled by default from Tasmota version 6.3.0.15 but may be reconfigured by setting the value of SetOption60 accordingly. Command Description SetOption60 0 Dynamic Sleep is ENABLED (Default since 6.3.0.15) SetOption60 1 Normal Sleep is ENABLED The term CPU is used loosely here for the sake of making it easier to understand - When the term CPU is used it is actually referring to the ESP8266 SoC Micro Controller. With the introduction of many new drivers, sensors and other functions as part of the Tasmota firmware, it has become more important to pay specific attention to the amount of microcontroller clock cycles shared with the underlying SDK/Arduino ESP8266 Core. The main application loop of the Tasmota firmware needs to visit each of the driver callbacks within the main loop to make sure all the required drivers and sensors receive the necessary processing time whilst ensuring that the main loop does not overwhelm the need for processing time by the SDK / Arduino ESP8266 core. The highest priority drivers/sensors need to be called once per 50ms to operate as designed but most of the normal run of the mill drivers and sensors do not necessarily require this amount of intense polling. The 50-millisecond mark would normally be considered to be an absolute minimum duty cycle for the main processing loop on ESP8266 boards whilst most Sonoff device derivatives will function perfectly well way above this default setting. To make this manageable from device to device a new setting has been introduced enabling the setting of the main loop target to a specific value in milliseconds. For default operation, this will be set to 50 milliseconds as there are generally no drivers or sensors that need to be polled at a rate higher than this. To allow for power usage flexibility this value may also be increased to a value of up to 250 milliseconds which is very useful to reduce power and processing demand on non-time critical devices such as switches (which is what most of Tasmota is used for.) The purpose of this setting is to allow you as a user to set the speed at which driver and sensors will be serviced and as a result also the amount of time given to the SDK / Arduino ESP8266 core to handle its background tasks (which are not under direct control of the Tasmota firmware.)","title":"Dynamic Sleep (CPU Main loop target / CPU Power Management)"},{"location":"Dynamic-Sleep/#example-use-case","text":"Let's assume the default value of 50 for sleep and that a simple device such as a Sonoff Basic R1 or R2 is being used. In this case, the main firmware loop will iterate through all the drivers and sensors once per 50 milliseconds. Current tests suggest that a simple device such as a Sonoff Basic requires only about 9.5 milliseconds to complete one iteration of servicing all the drivers and sensors enabled in the standard tasmota.bin firmware. The time management functionality offered by dynamic sleep will compute this time requirement automatically and allow the SDK / Arduino ESP8266 Core to service background tasks such as maintaining WiFi connectivity for the remainder of the time not spent in the main firmware loop - i.e. in the case of sleep 50 this would mean 50 milliseconds - ~9.5 milliseconds = ~40.5 milliseconds spent outside of the main firmware loop servicing SDK / ESP8266 Core functions which automatically consume fewer clock cycles when there is nothing intense for the SDK / ESP8266 Core to maintain or perform. Normal Sleep was previously the only option for Tasmota powered devices wishing to take advantage of power saving but it does have the disadvantage that the sleep would be a constant setting insofar that the entire firmware codebase would run at a pre-determined speed causing some drivers to run slower than expected and decreasing the speed at which services such as the WebUI is rendered (This varies between the various underlying cores depending on which version is used.) Using Dynamic Sleep (SetOption60 = 0) instead of Normal Sleep (SetOption60 = 1) has the advantage that CPU time will be given to any particular driver or process (let's say the WebUI) on demand as and when needed whilst spending most of its time waiting for the next main loop iteration to occur. During this time of waiting the ESP8266's power demand can go from 80mA all the way down to 20mA which yields great benefits for power saving vs. firmware responsiveness compared to the traditional sleep setting. Normally the target main loop setting would be 50 milliseconds. The firmware will service all the driver and sensor callbacks up to a maximum of 20 times per second. In most cases, this is unnecessary as most normal sensors like temperature sensors only need polling once per second. So, whether you poll the temperature sensor 20 times per second (sleep 50) or 5 times per second (sleep 200) it has no impact on the functionality. Allowing the main loop to iterate 20 times per second vs. 5 times per second is obviously more time consuming and processor consuming leaving less time to idle (i.e., save power). For example, if you were using an MCP230xx with interrupts, and you need a high interrupt response then sleep 50 or lower would make sense since that specific driver can poll once per 50 milliseconds to check for interrupts. Most other sensor polling can be done in intervals longer than 50 milliseconds so you achieve more idle time, and therefore also more sleep time so it saves power.","title":"Example Use Case"},{"location":"Dynamic-Sleep/#monitoring-performance","text":"Given all the above it is an obvious conclusion that in order to manage something you would need to be able to measure it. For this reason two new variables have been added to the telemetry data namely LoopSet and LoadAvg and are represented in the telemetry JSON as follows: MQT: tele/sound1/STATE = {\"Time\":\"2018-11-26T17:41:27\",\"Uptime\":\"0T05:05:17\",\"Vcc\":3.504,\"SleepMode\":\"Dynamic\",\"Sleep\":50,\"LoadAvg\":19,\"POWER\":\"OFF\",\"Wifi\":{\"AP\":1,\"SSId\":\"Wireless\",\"BSSId\":\"DE:AD:00:00:BE:EF\",\"Channel\":3,\"RSSI\":100}} The two values indicated for LoopSet and LoadAvg have the following relation: Variable Value Description SleepMode Normal Normal Sleep mode is enabled (SetOption60 = 1) SleepMode Dynamic Dynamic Sleep mode is enabled (SetOption60 = 0) Sleep 50 Current setting for sleep LoadAvg 19 Reported % time of Sleep spent doing Tasmota main loop processing In this example, 19% of 50 milliseconds would be 9.5 milliseconds (19/100*50), so we can see that there is sufficient headroom for the SDK / ESP8266 Arduino Core to do its background work. On some devices which have many sensors connected you may observe the LoadAvg value exceeding 100 - This means that you have not set the value of sleep high enough to accommodate all the sensors and drivers which need to be serviced. In the latter case, you have two options - either increase the value of sleep to a higher one to maintain a load average well below 100 or use multiple devices to spread the load across separate Tasmota powered devices/boards. For the most part, all Sonoff based products should perform well balanced with the default setting of 50 for sleep.","title":"Monitoring Performance"},{"location":"Dynamic-Sleep/#how-to-use-dynamic-sleep","text":"From serial console, or webui console enter command SetOption60 0 and Sleep xx Where xx is the number of milliseconds you wish to target your main processing loop at ranging from 0 through to 250. Should you set a sleep value that is too low you will observe output on telemetry for the value of LoadAvg to be in excess of 100 - This is not ideal and should be avoided as it starves the Arduino Core / SDK of the needed processing time to take care of background tasks such as WiFi management. For optimal operation of the Tasmota firmware, it is recommended to keep your device running at a LoadAvg value of 75 or lower. If your device does not have any time critical drivers/sensors connected you are encouraged to increase the sleep value to a higher value to gain from the power saving benefits thereof.","title":"How to use Dynamic Sleep"},{"location":"EQ3-TRV/","text":"This driver allows the control of Eqiva TRV's (i.e. Thermostat Radiator Valve). Compatible models are: Eqiva eQ-3 Bluetooth Smart (141771E0/141771E0A) Eqiva eQ-3 Bluetooth Smart(UK Version) (142461D0) Other Eqiva EQ3 models should work as well, but make sure you select a Bluetooth model as there are also non-Bluetooth models. Compiling from source ~ In order to have EQ3 valves working when compiling from source you need to add these define in user_config_override.h : #ifdef USE_EQ3_ESP32 #undef USE_EQ3_ESP32 #endif #define USE_EQ3_ESP32 Setup ~ Before you can use the TRV you will need to enable Bluetooth on the TRV: Press the Mode/Menu button for at least 3 seconds. Select the menu item bLE with the control wheel and confirm by pressing the control wheel shortly. The display will show OFF to deactivate the function or On to activate the function. Confirm by pressing the control wheel shortly. Note: No need to pair the TRV Next you will need to make sure that BLE is enabled in Tasmota: Configuration Configure BLE Enable Bluetooth To determine the mac addresses of a TRV: Go to the BLE menu in Tasmota Enable active scan In to the tasmota console: TRV devlist This will give you the mac address of each valve. Note Enable 1 valve at a time as this makes it easier to identify You might need to wait a minute or so or repeat the \"TRV devlist\" command a few times before the devices have been properly identified Keep in mind that the TRV does NOT report the current temperature, only the requested, target, temperature. The Xiaomi Thermometer LYWSD03MMC makes a perfect combo for measuring the room temperature (~USD 4) Operating your TRV ~ There are 2 ways to control your TRV: The Tasmota Console (convenient for setup) syntax: TRV <MAC Address> <command> [options] example: TRV 001A2216A458 settemp 21.5 MQTT: syntax: cmnd/<tasmota_topic>/EQ3/<MAC Address>/command [options] example: cmnd/ble_esp32/EQ3/001A2216A458/settemp 22.5 As you can see from the example the MQTT topic is made of: Standard Tasmota %prefix% : cmnd , stat %topic% of the BLE_ESP32 gateway device, here ble_esp32 An EQ3 element to specify this command is specific to the EQ3 driver The MAC address or alias of the EQ3 The command to the EQ3 or result from the EQ3 The EQ3 TRV has 3 modes of operation: Mode Description auto follows the week program. A temperature different from the week program can be set any time, but at the next programmed timeslot the TRV will switch back to the given temperature manual keeps the current requested temperature holiday keeps the temperature requested for the period of holiday and then switches back to the mode that was active before: auto or manual These 3 modes can be set and configured using different commands described below. After submitting a command you will see one or more of the possible results. Status Description queued Command has been accepted by the BLE driver DONENOTIFIED Command has been successfully processed by the TRV and the results are send in a json format ignoredbusy Currently we can only accept a single command in the queue, during the processing of a TRV command subsequent commands will be rejected. Please resubmit. FAILCONNECT After 3 automatic retries we were not able to contact the TRV and we give up. Please resubmit Under normal circumstance you will get a JSON formatted response from the valve: { \"cmd\" : \"settemp\" , \"result\" : \"ok\" , \"MAC\" : \"001A2216A458\" , \"tas\" : \"ble-esp32-0936\" , \"RSSI\" : -79 , \"stattime\" : 1642328707 , \"temp\" : 21.0 , \"posn\" : 95 , \"mode\" : \"auto\" , \"hassmode\" : \"auto\" , \"boost\" : \"inactive\" , \"dst\" : \"set\" , \"window\" : \"closed\" , \"state\" : \"unlocked\" , \"battery\" : \"GOOD\" , \"holidayend\" : \"00-00-00 00:00\" , \"windowtemp\" : 12.0 , \"windowdur\" : 15 , \"day\" : 21.0 , \"night\" : 17.0 , \"offset\" : 0.0 } If the mode is holiday, \"holidayend\" will show when the holiday period and mode is about to end: { \"mode\" : \"holiday\" , \"holidayend\" : \"22-01-19 17:00\" } In the response for the command setprofile, \"profiledayset\" will be added: { \"cmd\" : \"setprofile\" , \"profiledayset\" : 4 } In the response for the command reqprofile, \"profileday n \" (n=0\u20266) will be added: { \"cmd\" : \"reqprofile\" , \"profileday4\" : \"17.0-07:00,23.0-10:00,17.0-17:00,21.0-23:00,17.0-24:00\" } Field Description cmd recent command the response is given for MAC mac address. It is always the mac address even if an alias was used in the command. tas hostname of your tasmota RSSI BLE signal strength stattime seconds since Unix Epoch (January 1st, 1970) temp target temperature posn valve position (0=closed / 100=fully opened) mode manual / auto / holiday hassmode mode for Home Assistant usage: auto (=mode auto ) / off (valve is set to frost protection = off) / heat (valve is open) / idle (valve is closed) boost boost mode (valve opened 80 % for 5 minutes): active / inactive dst daylight savings time: set / unset window status of the window open functionality (activated when the temperature suddenly drops): open / closed state child lock enabled (disables the buttons on the TRV): locked / unlocked battery battery status of the TRV: GOOD / LOW holidayend end of holiday mode windowtemp window open temperature windowdur window open duration day comfort temperature night reduction temperature offset offset temperature profiledayset day the profile was set for: (0 \u2026 9). Only included for command setprofile profileday n profile for the day it just has been requested for. (n=0\u20266). Only included for command reqprofile Available commands ~ Base commands ~ Command Description and parameters TRVperiod Display/Set the EQ3 poll interval in seconds. In this intervall to every TRV matching the following critera a poll (= state ) command will be sent automatically. TRVonlyaliased Display/Set the EQ3 OnlyAliased parameter set to 1 for any aliased BLE devices set to 2 for only aliases starting with EQ3 TrvMatchPrefix Display/Set the EQ3 MatchPrefix parameter set to 1 to not require active scan to identify EQ3 - identify from MAC (default) Set to 0 to disable this matching TRV subcommands ~ Command Description and parameters devlist Display all TRV's which have been found in BLE scan mode. No parameters. scan Alias of devlist. No parameters. state Current valve state without changing anything. (except the time on the valve) No parameters. Note: If your ESP32 tasmota is not sychronized with a valid date and time, this command will set the wrong time and date to the TRV. See set time . settemp Set the desired target temperature. temperature . valve Control the valve state. off Enable frost protection on Open the valve completely Note: If the current mode is auto or holiday: at the next programmed timeslot the valve will switch back to the given temperature. To set the valve permanently please use direct commands on or off . on Set mode to manual and enable frost protection. Note:Temperature will be reported as 30.0 C. off Set mode to manual and open the valve completely (saves potentially battery in summer while the central heating is not working). Note:Temperature will be reported as 4.5 C. mode Define the current operating mode. auto same as auto , see below manual same as manual , see below. on same as on , see above. off same as off , see above. heat same as on , see above. cool same as off , see above. Note: The 3rd mode holiday can only be set with the setholiday command auto Define auto as the current operating mode. Run the week program as stored in the TRV. Note: When setting a temperature, switch to day or night temperature: at the next programmed timeslot the TRV will switch back to the given temperature. manual Define manual as the current operating mode. Disable the week program and keep the temperature as selected with settemp / day / night day Set to comfort temperature night Set to reduction temperature setdaynight Change the comfort and reduction temperature. daytemp nighttemp . boost Activate boost mode (valve 80% open for 5 minutes). Note: boost mode will stop automatically after 5 minutes. unboost Deactivate boost mode lock Disable TRV buttons unlock Enable TRV buttons settime Synchronize current tasmota time to the TRV: No parameters. Send an alternate time to the TRV: yyMMddhhmmss (byte by byte conversion from decimal to hexadecimal). Note: If your ESP32 tasmota is not sychronized with a valid date and time, this command (with no parameters) will set the wrong time and date to the TRV. setprofile Set the temperature schedule for the given day. (0=Saturday, 1=Sunday, \u2026 6=Friday) Up to seven pairs of temperature-timeslot (e.g. 20.5-07:30) can be given. day temperature-timeslot, temperature-timeslot It is also possible to set a couple of days with one command: use 7=weekend, 8=workday, 9=everyday for this purpose. Note: The last timeslot shall always be -24:00, otherwise a default temperature is used for this timeslot. reqprofile Read the temperature schedule for the given day. **(0=Saturday, 1=Sunday, \u2026 6=Friday) day** setholiday Define holiday as the current operating mode. end-date,end-time temperature . holiday mode will automatically terminate and resume the former mode and temperature when the end date and time are reached. Note: During this period it makes no sense to apply any commands for setting different temperatures. For manually ending holiday mode call auto or manual . Only then other commands will be accepted again. setwindowtempdur set window open temperature and duration in minutes. temperature minutes . offset set offset temperature temperature Examples ~ Request the current status without changing anything: cmnd/tasmota/EQ3/001A2216A458/state set a target temperature (21.5 C) cmnd/tasmota/EQ3/001A2216A458/settemp 21.5 Select TRV mode auto : run the week program as stored in the TRV cmnd/tasmota/EQ3/001A2216A458/auto Select TRV mode manual : disable the week program and keep the temperature as selected (settemp/day/night) cmnd/tasmota/EQ3/001A2216A458/manual Select TRV mode holiday : suspend the week program or manually applied temperature until 2022 - Jan - 19 - 17:00 and set the temperature to 18.5 C cmnd/tasmota/EQ3/001A2216A458/setholiday 22-01-19,17:00 18.5 Select TRV temperature day : Switch to comfort temperature cmnd/tasmota/EQ3/001A2216A458/day Select TRV temperature night : Switch to reduction temperature cmnd/tasmota/EQ3/001A2216A458/night Note If auto is the current mode: When setting a temperature, switch to day or night temperature, the TRV will switch back to the temperature according the next programmed timeslot. Disable the TRV and enable frost protection. Until the next programmed timeslot cmnd/tasmota/EQ3/001A2216A458/valve off Permanently: cmnd/tasmota/EQ3/001A2216A458/off Disable the TRV and open the valve completely (saves potentially battery in summer while the central heating is not working): Until the next programmed timeslot cmnd/tasmota/EQ3/001A2216A458/valve on Permanently: cmnd/tasmota/EQ3/001A2216A458/on Change the comfort and reduction temperature to 22 C and 17.5 C cmnd/tasmota/EQ3/001A2216A458/setdaynight 22 17.5 Enable boost mode (valve 80% open for 5 minutes) cmnd/tasmota/EQ3/001A2216A458/boost Disable TRV buttons cmnd/tasmota/EQ3/001A2216A458/lock Synchronize current tasmota time with the TRV cmnd/tasmota/EQ3/001A2216A458/settime Set the time and date (byte by byte conversion from decimal to hexadecimal) Date: 2021 - jan - 04 - 13:00:00 In hex: 15 - 01 - 04 - 0d:00:00 (yyMMddhhmmss) Concatenate: 1501040d0000 cmnd/tasmota/EQ3/001A2216A458/settime 1501040d0000 Set the temperature schedule for day 3 (Tuesday) as 20.5 C until 07:30 17.0 C until 17:00 22.5 C until 22:00 18.0 C until 24:00 cmnd/tasmota/EQ3/001A2216A458/setprofile 3 20.5-07:30,17.0-17:00,22.5-22:00,18.0-24:00","title":"EQ3 TRV"},{"location":"EQ3-TRV/#compiling-from-source","text":"In order to have EQ3 valves working when compiling from source you need to add these define in user_config_override.h : #ifdef USE_EQ3_ESP32 #undef USE_EQ3_ESP32 #endif #define USE_EQ3_ESP32","title":"Compiling from source"},{"location":"EQ3-TRV/#setup","text":"Before you can use the TRV you will need to enable Bluetooth on the TRV: Press the Mode/Menu button for at least 3 seconds. Select the menu item bLE with the control wheel and confirm by pressing the control wheel shortly. The display will show OFF to deactivate the function or On to activate the function. Confirm by pressing the control wheel shortly. Note: No need to pair the TRV Next you will need to make sure that BLE is enabled in Tasmota: Configuration Configure BLE Enable Bluetooth To determine the mac addresses of a TRV: Go to the BLE menu in Tasmota Enable active scan In to the tasmota console: TRV devlist This will give you the mac address of each valve. Note Enable 1 valve at a time as this makes it easier to identify You might need to wait a minute or so or repeat the \"TRV devlist\" command a few times before the devices have been properly identified Keep in mind that the TRV does NOT report the current temperature, only the requested, target, temperature. The Xiaomi Thermometer LYWSD03MMC makes a perfect combo for measuring the room temperature (~USD 4)","title":"Setup"},{"location":"EQ3-TRV/#operating-your-trv","text":"There are 2 ways to control your TRV: The Tasmota Console (convenient for setup) syntax: TRV <MAC Address> <command> [options] example: TRV 001A2216A458 settemp 21.5 MQTT: syntax: cmnd/<tasmota_topic>/EQ3/<MAC Address>/command [options] example: cmnd/ble_esp32/EQ3/001A2216A458/settemp 22.5 As you can see from the example the MQTT topic is made of: Standard Tasmota %prefix% : cmnd , stat %topic% of the BLE_ESP32 gateway device, here ble_esp32 An EQ3 element to specify this command is specific to the EQ3 driver The MAC address or alias of the EQ3 The command to the EQ3 or result from the EQ3 The EQ3 TRV has 3 modes of operation: Mode Description auto follows the week program. A temperature different from the week program can be set any time, but at the next programmed timeslot the TRV will switch back to the given temperature manual keeps the current requested temperature holiday keeps the temperature requested for the period of holiday and then switches back to the mode that was active before: auto or manual These 3 modes can be set and configured using different commands described below. After submitting a command you will see one or more of the possible results. Status Description queued Command has been accepted by the BLE driver DONENOTIFIED Command has been successfully processed by the TRV and the results are send in a json format ignoredbusy Currently we can only accept a single command in the queue, during the processing of a TRV command subsequent commands will be rejected. Please resubmit. FAILCONNECT After 3 automatic retries we were not able to contact the TRV and we give up. Please resubmit Under normal circumstance you will get a JSON formatted response from the valve: { \"cmd\" : \"settemp\" , \"result\" : \"ok\" , \"MAC\" : \"001A2216A458\" , \"tas\" : \"ble-esp32-0936\" , \"RSSI\" : -79 , \"stattime\" : 1642328707 , \"temp\" : 21.0 , \"posn\" : 95 , \"mode\" : \"auto\" , \"hassmode\" : \"auto\" , \"boost\" : \"inactive\" , \"dst\" : \"set\" , \"window\" : \"closed\" , \"state\" : \"unlocked\" , \"battery\" : \"GOOD\" , \"holidayend\" : \"00-00-00 00:00\" , \"windowtemp\" : 12.0 , \"windowdur\" : 15 , \"day\" : 21.0 , \"night\" : 17.0 , \"offset\" : 0.0 } If the mode is holiday, \"holidayend\" will show when the holiday period and mode is about to end: { \"mode\" : \"holiday\" , \"holidayend\" : \"22-01-19 17:00\" } In the response for the command setprofile, \"profiledayset\" will be added: { \"cmd\" : \"setprofile\" , \"profiledayset\" : 4 } In the response for the command reqprofile, \"profileday n \" (n=0\u20266) will be added: { \"cmd\" : \"reqprofile\" , \"profileday4\" : \"17.0-07:00,23.0-10:00,17.0-17:00,21.0-23:00,17.0-24:00\" } Field Description cmd recent command the response is given for MAC mac address. It is always the mac address even if an alias was used in the command. tas hostname of your tasmota RSSI BLE signal strength stattime seconds since Unix Epoch (January 1st, 1970) temp target temperature posn valve position (0=closed / 100=fully opened) mode manual / auto / holiday hassmode mode for Home Assistant usage: auto (=mode auto ) / off (valve is set to frost protection = off) / heat (valve is open) / idle (valve is closed) boost boost mode (valve opened 80 % for 5 minutes): active / inactive dst daylight savings time: set / unset window status of the window open functionality (activated when the temperature suddenly drops): open / closed state child lock enabled (disables the buttons on the TRV): locked / unlocked battery battery status of the TRV: GOOD / LOW holidayend end of holiday mode windowtemp window open temperature windowdur window open duration day comfort temperature night reduction temperature offset offset temperature profiledayset day the profile was set for: (0 \u2026 9). Only included for command setprofile profileday n profile for the day it just has been requested for. (n=0\u20266). Only included for command reqprofile","title":"Operating your TRV"},{"location":"EQ3-TRV/#available-commands","text":"","title":"Available commands"},{"location":"ESP32-Devices/","text":"LilyGO TTGO T-Camera OV2640_V05 ~ In platformio_override.ini uncomment the line with tasmota32 and set the correct COM port. In user_config_override.h add: #define USE_BMP #define USE_I2C #define USE_SPI #define USE_DISPLAY #define USE_DISPLAY_SSD1306 #define SHOW_SPLASH #define USE_WEBCAM Upload via USB, then apply the following Template: { \"NAME\" : \"TTGO_V05\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 5090 , 5088 , 1 , 1 , 5056 , 5024 , 5089 , 5091 , 1 , 1 , 5092 , 5184 , 0 , 640 , 608 , 5093 , 0 , 5152 , 4928 , 5120 , 0 , 0 , 0 , 0 , 4992 , 160 , 32 , 1 , 5094 , 0 , 0 , 5095 ], \"FLAG\" : 0 , \"BASE\" : 2 } The PIR will turn ON/OFF the display and send over MQTT the POWER status. The display shows the sensor data. To make the device work nicely, change the following settings in the Console: Camera settings to correct orientation (USB on the bottom): WCFlip ON WCMirror ON WCResolution 6 WCSaturation 0 WCBrightness -1 WCContrast 1 Display Settings (USB on the bottom): DisplayRotate 2 DisplayCols 21 DisplayRows 7 DisplayMode 2 BME280 Settings (it is not very trustable): HumOffset 10 TempOffset -15 PIR/Button Settings: SwitchMode1 1 SetOption73 1 ODROID-GO ~ is supported via build Tasmota32-lvgl. Upload firmware and configure via Menu Auto-configuration To make the device work nicely, change the following settings in the Console: adcparam3 6,0,4095,0,6160 Rule for Joystick to dim the display: on analog#joy2=1 do dimmer - endon on analog#joy2=2 do dimmer + endon AITHINKER CAM ~ { \"NAME\" : \"AITHINKER CAM\" , \"GPIO\" :[ 4992 , 1 , 672 , 1 , 416 , 5088 , 1 , 1 , 1 , 6720 , 736 , 704 , 1 , 1 , 5089 , 5090 , 0 , 5091 , 5184 , 5152 , 0 , 5120 , 5024 , 5056 , 0 , 0 , 0 , 0 , 4928 , 576 , 5094 , 5095 , 5092 , 0 , 0 , 5093 ], \"FLAG\" : 0 , \"BASE\" : 2 } wESP32 ~ { \"NAME\" : \"wESP32\" , \"GPIO\" :[ 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 5568 , 5600 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } WT32-ETH01 ~ { \"NAME\" : \"WT32-ETH01\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 3840 , 576 , 5600 , 0 , 0 , 0 , 0 , 5568 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } Denky (Teleinfo) ~ { \"NAME\" : \"Denky (Teleinfo)\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 5664 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1376 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 5632 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } Olimex ESP32-PoE ~ { \"NAME\" : \"Olimex ESP32-PoE\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 5536 , 1 , 1 , 1 , 1 , 0 , 5600 , 0 , 0 , 0 , 0 , 5568 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } M5Stack Atom ~ { \"NAME\" : \"M5Stack Atom\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1056 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 609 , 1 , 1 , 0 , 641 , 640 , 1376 , 0 , 0 , 0 , 0 , 608 , 1 , 1 , 1 , 1 , 0 , 0 , 32 ], \"FLAG\" : 0 , \"BASE\" : 1 } M5Stack Atom lite ~ { \"NAME\" : \"M5Stack Atom Lite\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1056 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 640 , 1376 , 0 , 0 , 0 , 0 , 608 , 1 , 1 , 1 , 1 , 0 , 0 , 32 ], \"FLAG\" : 0 , \"BASE\" : 1 } LilyGO ttgo-t-eth-poe ~ { \"NAME\" : \"LilyGO ttgo-t-eth-poe\" , \"GPIO\" :[ 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5600 , 1 , 0 , 1 , 1 , 5568 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } For working Ethernet, change the following setting in the Console: EthClockMode 1 these 3 devices are also fully supported, more detailed info will be added later TTGO ESP32 watch ~ fully supported with all sensors TTGO T4 ~ fully supported m5stack CORE2 ~ is fully supported with all sensors and SD card. Upload firmware Tasmota32-lvgl and configure via Menu Auto-configuration Heltec WiFi Kit 32 ~ OLED display needs the following template { \"NAME\" : \"WiFi Kit 32\" , \"GPIO\" :[ 1 , 1 , 1 , 1 , 640 , 1 , 1 , 1 , 1 , 1 , 1 , 608 , 3840 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 224 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], \"FLAG\" : 0 , \"BASE\" : 1 } WEMOS / LOLIN D32 ~ verified support for board plus I2C sensors to use I2C, set IO21 to SDA and IO22 to SCL Displays, sensors and other options ~ displays: (most probably all I2C displays will work) USE_DISPLAY_SH1106 USE_DISPLAY_EPAPER_29 USE_DISPLAY_EPAPER_42 USE_DISPLAY_ILI9341 USE_DISPLAY_ILI9488 USE_DISPLAY_SSD1351 USE_DISPLAY_RA8876 USE_DISPLAY_ST7789 USE_DISPLAY_ILI9341_2 USE_DISPLAY_ILI9342 sensors: (most probably all I2C sensors will work) USE_SHT3X USE_BMP USE_VL53L0X USE_MLX90614 USE_IBEACON USE_SML_M misc: USE_MP3_PLAYER USE_SCRIPT ( scripting and all its options ) USE_24C256 USE_SENDMAIL USE_ESP32MAIL","title":"ESP32 Devices"},{"location":"ESP32/","text":"ESP32 ~ ESP32-S2/S3 support is in beta and not all functions or supported peripherals will work reliably. Due to the scope and activity of development there might be breaking changes and incompatibilities between major and minor versions of Tasmota32. In case of problems first erase flash and serial flash the latest development binary. ESP32 Differences ~ All ESP32 systems on a chip (SoC) are 32-bit MCUs with 2.4 GHz Wi-Fi & Bluetooth/Bluetooth LE built in. There are distinct product lines which differ from each other in varying degrees. See ESP32 modules list for the full list. ESP32 ~ An ESP32 has two or one Xtensa\u00ae 32-bit LX6 microprocessor(s) with clock frequency ranging from 80 MHz to 240 MHz. Tasmota32 is initially developed and tested with the dual core ESP32-D0WD-V3 and later expanded to include single core or PSRAM versions. Single core SoCs do not work with standard binaries, for those use only tasmota32solo1.bin or compile your own binary using the tasmota32solo1 environment. ESP32-S2 ~ A more cost-efficient version of ESP32, cut down to a single core and several dedicated hardware security features (eFuse, flash encryption, secure boot, signature verification, integrated AES, SHA and RSA algorithms). It has 43 available GPIOs. Product page for ESP32-S2 Beta support in Tasmota Use tasmota32s2- binaries for this line of chips. ESP32-S3 ~ Keeping the security improvements the S3 line now again features the dual core SoC with Bluetooth upgraded to V5 . Product page for ESP32-S3 . Beta support in Tasmota Use tasmota32s3- binaries for this line of chips. ESP32-C3 ~ Unlike previous versions, C3 is a single-core Wi-Fi and Bluetooth 5 (LE) microcontroller SoC based on the open-source RISC-V architecture. It is available as ESP32-C3-MINI-1 and ESP32-C3-WROOM-02 modules. Product page for ESP32-C3 Beta Support in Tasmota Use tasmota32c3- binaries for this line of chips. Exclusive Features ~ Autoconf ~ As devices get more complex, it was useful to find a simpler way for users to configure a device in one click, including Template information, Ethernet configuration, SetOptions and Berry drivers. After flashing Tasmota, open the web UI of the device and navigate to Configuration -> Auto-configuration . Select your device from the drop-down and click Apply Configuration . Configuration files are stored here: https://github.com/tasmota/autoconf To use it you need to have #define USE_AUTOCONF . CPU Temperature Sensor ~ Tasmota will create an internal temperature sensor and display the values in the webUI and MQTT. { \"Time\" : \"2021-01-01T00:00:00\" , \"ESP32\" :{ \"Temperature\" : 41.7 }, \"TempUnit\" : \"C\" } You can deactivate it using command SetSensor127 0 DAC ~ DAC GPIOs are supported through Berry gpio module . Hall Sensor ~ ESP32 has a built in hall effect sensor that detects changes in the magnetic field in its surroundings. It is located behind the metal lid of the module and connected to GPIO36 and GPIO39. To enable set in module configuration or template: GPIO36 as HallEffect 1 GPIO39 as HallEffect 2 I2S ~ Inter-IC Sound or I2S is possible through Berry gpio module Touch Pins ~ ESP32 has 10 capacitive touch GPIOs. More on configuring and using them... . Berry Scripting ~ ESP32 introduces Berry language as a more approachable scripting language. Berry is very powerful and you can even code an I2C driver using it. LVGL ~ Use LVGL in conjunction with Berry on devices with displays and touch displays to design your own UI. Flashing ~ Use Tasmota Web Installer to easily flash ESP32 devices. Other options include: ESP_Flasher for flashing an ESP32 or ESP82xx (Windows, MacOs or Linux (Ubuntu)). esptool.py - use the following command syntax: esptool.py --chip esp32 --baud 921600 --before default_reset --after hard_reset write_flash -z --flash_mode dout --flash_size detect 0x0 tasmota32.factory.bin Use a proper power supply! ESP32 is power hungry and there's a high chance it will not be able to boot properly off the serial-to-USB power. Power it from a separate power supply that can provide at least 500mA. You can download precompiled binaries: development branch from http://ota.tasmota.com/tasmota32/ stable releases from http://ota.tasmota.com/tasmota32/release/ the required flash files (not needed when using ESP_Flasher) OTA upgrade from older versions of tasmota32 might fail due to significant changes in partition tables. Compiling ~ Uncomment the tasmota32xxx build you want to compile in platformio_override.ini . For example, uncommenting tasmota32 will build tasmota32.bin on the next Build task in Platformio. All binaries use user_config_override.h if it exists. Working Devices ~ Tasmota Supported Devices Repository has a more extenstive list of ESP32 based devices. ESP32 Devices","title":"Tasmota32 Features"},{"location":"ESP32/#esp32","text":"ESP32-S2/S3 support is in beta and not all functions or supported peripherals will work reliably. Due to the scope and activity of development there might be breaking changes and incompatibilities between major and minor versions of Tasmota32. In case of problems first erase flash and serial flash the latest development binary.","title":"ESP32"},{"location":"ESP32/#esp32-differences","text":"All ESP32 systems on a chip (SoC) are 32-bit MCUs with 2.4 GHz Wi-Fi & Bluetooth/Bluetooth LE built in. There are distinct product lines which differ from each other in varying degrees. See ESP32 modules list for the full list.","title":"ESP32 Differences"},{"location":"ESP32/#esp32_1","text":"An ESP32 has two or one Xtensa\u00ae 32-bit LX6 microprocessor(s) with clock frequency ranging from 80 MHz to 240 MHz. Tasmota32 is initially developed and tested with the dual core ESP32-D0WD-V3 and later expanded to include single core or PSRAM versions. Single core SoCs do not work with standard binaries, for those use only tasmota32solo1.bin or compile your own binary using the tasmota32solo1 environment.","title":"ESP32"},{"location":"ESP32/#esp32-s2","text":"A more cost-efficient version of ESP32, cut down to a single core and several dedicated hardware security features (eFuse, flash encryption, secure boot, signature verification, integrated AES, SHA and RSA algorithms). It has 43 available GPIOs. Product page for ESP32-S2 Beta support in Tasmota Use tasmota32s2- binaries for this line of chips.","title":"ESP32-S2"},{"location":"ESP32/#esp32-s3","text":"Keeping the security improvements the S3 line now again features the dual core SoC with Bluetooth upgraded to V5 . Product page for ESP32-S3 . Beta support in Tasmota Use tasmota32s3- binaries for this line of chips.","title":"ESP32-S3"},{"location":"ESP32/#esp32-c3","text":"Unlike previous versions, C3 is a single-core Wi-Fi and Bluetooth 5 (LE) microcontroller SoC based on the open-source RISC-V architecture. It is available as ESP32-C3-MINI-1 and ESP32-C3-WROOM-02 modules. Product page for ESP32-C3 Beta Support in Tasmota Use tasmota32c3- binaries for this line of chips.","title":"ESP32-C3"},{"location":"ESP32/#exclusive-features","text":"","title":"Exclusive Features"},{"location":"ESP32/#autoconf","text":"As devices get more complex, it was useful to find a simpler way for users to configure a device in one click, including Template information, Ethernet configuration, SetOptions and Berry drivers. After flashing Tasmota, open the web UI of the device and navigate to Configuration -> Auto-configuration . Select your device from the drop-down and click Apply Configuration . Configuration files are stored here: https://github.com/tasmota/autoconf To use it you need to have #define USE_AUTOCONF .","title":"Autoconf"},{"location":"ESP32/#cpu-temperature-sensor","text":"Tasmota will create an internal temperature sensor and display the values in the webUI and MQTT. { \"Time\" : \"2021-01-01T00:00:00\" , \"ESP32\" :{ \"Temperature\" : 41.7 }, \"TempUnit\" : \"C\" } You can deactivate it using command SetSensor127 0","title":"CPU Temperature Sensor"},{"location":"ESP32/#dac","text":"DAC GPIOs are supported through Berry gpio module .","title":"DAC"},{"location":"ESP32/#hall-sensor","text":"ESP32 has a built in hall effect sensor that detects changes in the magnetic field in its surroundings. It is located behind the metal lid of the module and connected to GPIO36 and GPIO39. To enable set in module configuration or template: GPIO36 as HallEffect 1 GPIO39 as HallEffect 2","title":"Hall Sensor"},{"location":"ESP32/#i2s","text":"Inter-IC Sound or I2S is possible through Berry gpio module","title":"I2S"},{"location":"ESP32/#touch-pins","text":"ESP32 has 10 capacitive touch GPIOs. More on configuring and using them... .","title":"Touch Pins"},{"location":"ESP32/#berry-scripting","text":"ESP32 introduces Berry language as a more approachable scripting language. Berry is very powerful and you can even code an I2C driver using it.","title":"Berry Scripting"},{"location":"ESP32/#lvgl","text":"Use LVGL in conjunction with Berry on devices with displays and touch displays to design your own UI.","title":"LVGL"},{"location":"ESP32/#flashing","text":"Use Tasmota Web Installer to easily flash ESP32 devices. Other options include: ESP_Flasher for flashing an ESP32 or ESP82xx (Windows, MacOs or Linux (Ubuntu)). esptool.py - use the following command syntax: esptool.py --chip esp32 --baud 921600 --before default_reset --after hard_reset write_flash -z --flash_mode dout --flash_size detect 0x0 tasmota32.factory.bin Use a proper power supply! ESP32 is power hungry and there's a high chance it will not be able to boot properly off the serial-to-USB power. Power it from a separate power supply that can provide at least 500mA. You can download precompiled binaries: development branch from http://ota.tasmota.com/tasmota32/ stable releases from http://ota.tasmota.com/tasmota32/release/ the required flash files (not needed when using ESP_Flasher) OTA upgrade from older versions of tasmota32 might fail due to significant changes in partition tables.","title":"Flashing"},{"location":"ESP32/#compiling","text":"Uncomment the tasmota32xxx build you want to compile in platformio_override.ini . For example, uncommenting tasmota32 will build tasmota32.bin on the next Build task in Platformio. All binaries use user_config_override.h if it exists.","title":"Compiling"},{"location":"ESP32/#working-devices","text":"Tasmota Supported Devices Repository has a more extenstive list of ESP32 based devices. ESP32 Devices","title":"Working Devices"},{"location":"EZO/","text":"EZO sensors ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : // #define USE_EZOPH // [I2cDriver55] Enable support for EZO's pH sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOORP // [I2cDriver55] Enable support for EZO's ORP sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZORTD // [I2cDriver55] Enable support for EZO's RTD sensor (+0k2 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOHUM // [I2cDriver55] Enable support for EZO's HUM sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOEC // [I2cDriver55] Enable support for EZO's EC sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOCO2 // [I2cDriver55] Enable support for EZO's CO2 sensor (+0k2 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOO2 // [I2cDriver55] Enable support for EZO's O2 sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOPRS // [I2cDriver55] Enable support for EZO's PRS sensor (+0k7 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOFLO // [I2cDriver55] Enable support for EZO's FLO sensor (+0k4 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZODO // [I2cDriver55] Enable support for EZO's DO sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZORGB // [I2cDriver55] Enable support for EZO's RGB sensor (+0k5 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOPMP // [I2cDriver55] Enable support for EZO's PMP sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) EZO is a series of chemical sensors provided by Atlas Scientific At this point in time, the following EZO sensors are supported: build #define Sensor ID Sensor Name USE_EZODO EZO-D.O. Disolved Oxygen USE_EZOORP EZO-ORP Oxygen Reduction Potential USE_EZOPH EZO-pH pH USE_EZOEC EZO-EC Electric Conductivity USE_EZORTD EZO-RTD Temperature USE_EZOFLO EZO-FLO Flow Meter USE_EZOCO2 EZO-CO2 Carbon Dioxyde (gas) USE_EZOPRS EZO-PRS Pressure USE_EZOO2 EZO-O2 Oxygen (gas) USE_EZOHUM EZO-HUM Humidity USE_EZORGB EZO-RGB Color Configuration ~ All EZO devices must operate under the I 2 C mode to be compatible with Tasmota. One of the easiest way to achieve this is to short SDA/Tx to PGND while powering the device through VCC & GND . For more details, see Instructables . Tasmota will automatically detect any new device that has an I 2 C bus address between 0x61-0x70 (which covers the default address range of all EZO devices). Tasmota supports any multiple of EZO devices (up to 16 of any kind). When more than one device is detected, the devices will be indexed starting at index 1 (ex: EZO-1) and ordered by their I 2 C address. If only one EZO device is connected, there will be no indexing of them. You may change the address of your device by sending an I 2 C command to the device. For example, to change the address of a single EZOpH sensor, the following command can be issued in the console: Sensor78 I^2^C,100 Specific details about the list of commands available for your EZO device can be found in the device-specific datasheet on the Atlas Scientific's website. In order to individually address a single EZO sensor when more than one is detected, the index must be specified on the command by appending \"-#\" to the command: Sensor78-2 I2C,101 Calibration ~ Many EZO devices require calibration in order to accurately report values. Calibration can be easily achieved by issuing the appropriate commands and following the instructions in the EZO datasheets. One easy way to achieve this is to put the sensor in the baseline environement and use the web interface to see when the value stabilizes. Once it does, visit the console and issue the device-specific calibration command. Readings ~ Currently, Tasmota samples the sensor information at the rate of 1Hz (1 sample/second) irrespective of the EZO device. Some EZO devices support reporting different units. For example EZO-RTD supports reading the temperature in \u00b0C, \u00b0K, or \u00b0F. In order to save memory, Tasmota will only be able reading the default format (ie: \u00b0C). If you wish to see the value in another format, you can use Tasmota's ability to display Farenheit to do the conversion for you. For conversions that are not supported by Tasmota, you may use OpenHab, Home Assistant or any other system in conjunction with MQTT to do the cnoversion. In every case, there exists a simple formula that will allow you to convert from one format to another and the EZO device are merely utilizing that formula to return the value. It's important to make sure that the default units are used. If that's not the case, Tasmota will simply assume that the default units are used and the number will seem drastically wrong. Some device supports the output of multiple diffrent sensors in one single EZO devices. One example of this is the EZO-HUM which supports outputing the humidity as well as the temperature. By default, only the humidity is enabled, but a command can be sent to enable the temperature as well. In that case, Tasmota does support reading the additional sensor provided that the command enables its output. Some readings can be made more precise by specifying additional parameters. The most common one is temperature. For example, the EZO-pH sensor can return more accurate values if it compensates for the temperature. At this point in time, Tasmota does not support reading sensor data which compensates with any other sensor's data. That said, these are typically well-established equations that will allow you to convert the existing reading and adjust it based on the reading from the other sensor. A simple Google search can be done to understand how to compensate in each case. Sleep mode for EZO devices is currently NOT supported by Tasmota.","title":"EZO sensors"},{"location":"EZO/#ezo-sensors","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : // #define USE_EZOPH // [I2cDriver55] Enable support for EZO's pH sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOORP // [I2cDriver55] Enable support for EZO's ORP sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZORTD // [I2cDriver55] Enable support for EZO's RTD sensor (+0k2 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOHUM // [I2cDriver55] Enable support for EZO's HUM sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOEC // [I2cDriver55] Enable support for EZO's EC sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOCO2 // [I2cDriver55] Enable support for EZO's CO2 sensor (+0k2 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOO2 // [I2cDriver55] Enable support for EZO's O2 sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOPRS // [I2cDriver55] Enable support for EZO's PRS sensor (+0k7 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOFLO // [I2cDriver55] Enable support for EZO's FLO sensor (+0k4 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZODO // [I2cDriver55] Enable support for EZO's DO sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZORGB // [I2cDriver55] Enable support for EZO's RGB sensor (+0k5 code) - Shared EZO code required for any EZO device (+1k2 code) // #define USE_EZOPMP // [I2cDriver55] Enable support for EZO's PMP sensor (+0k3 code) - Shared EZO code required for any EZO device (+1k2 code) EZO is a series of chemical sensors provided by Atlas Scientific At this point in time, the following EZO sensors are supported: build #define Sensor ID Sensor Name USE_EZODO EZO-D.O. Disolved Oxygen USE_EZOORP EZO-ORP Oxygen Reduction Potential USE_EZOPH EZO-pH pH USE_EZOEC EZO-EC Electric Conductivity USE_EZORTD EZO-RTD Temperature USE_EZOFLO EZO-FLO Flow Meter USE_EZOCO2 EZO-CO2 Carbon Dioxyde (gas) USE_EZOPRS EZO-PRS Pressure USE_EZOO2 EZO-O2 Oxygen (gas) USE_EZOHUM EZO-HUM Humidity USE_EZORGB EZO-RGB Color","title":"EZO sensors"},{"location":"EZO/#configuration","text":"All EZO devices must operate under the I 2 C mode to be compatible with Tasmota. One of the easiest way to achieve this is to short SDA/Tx to PGND while powering the device through VCC & GND . For more details, see Instructables . Tasmota will automatically detect any new device that has an I 2 C bus address between 0x61-0x70 (which covers the default address range of all EZO devices). Tasmota supports any multiple of EZO devices (up to 16 of any kind). When more than one device is detected, the devices will be indexed starting at index 1 (ex: EZO-1) and ordered by their I 2 C address. If only one EZO device is connected, there will be no indexing of them. You may change the address of your device by sending an I 2 C command to the device. For example, to change the address of a single EZOpH sensor, the following command can be issued in the console: Sensor78 I^2^C,100 Specific details about the list of commands available for your EZO device can be found in the device-specific datasheet on the Atlas Scientific's website. In order to individually address a single EZO sensor when more than one is detected, the index must be specified on the command by appending \"-#\" to the command: Sensor78-2 I2C,101","title":"Configuration"},{"location":"EZO/#calibration","text":"Many EZO devices require calibration in order to accurately report values. Calibration can be easily achieved by issuing the appropriate commands and following the instructions in the EZO datasheets. One easy way to achieve this is to put the sensor in the baseline environement and use the web interface to see when the value stabilizes. Once it does, visit the console and issue the device-specific calibration command.","title":"Calibration"},{"location":"EZO/#readings","text":"Currently, Tasmota samples the sensor information at the rate of 1Hz (1 sample/second) irrespective of the EZO device. Some EZO devices support reporting different units. For example EZO-RTD supports reading the temperature in \u00b0C, \u00b0K, or \u00b0F. In order to save memory, Tasmota will only be able reading the default format (ie: \u00b0C). If you wish to see the value in another format, you can use Tasmota's ability to display Farenheit to do the conversion for you. For conversions that are not supported by Tasmota, you may use OpenHab, Home Assistant or any other system in conjunction with MQTT to do the cnoversion. In every case, there exists a simple formula that will allow you to convert from one format to another and the EZO device are merely utilizing that formula to return the value. It's important to make sure that the default units are used. If that's not the case, Tasmota will simply assume that the default units are used and the number will seem drastically wrong. Some device supports the output of multiple diffrent sensors in one single EZO devices. One example of this is the EZO-HUM which supports outputing the humidity as well as the temperature. By default, only the humidity is enabled, but a command can be sent to enable the temperature as well. In that case, Tasmota does support reading the additional sensor provided that the command enables its output. Some readings can be made more precise by specifying additional parameters. The most common one is temperature. For example, the EZO-pH sensor can return more accurate values if it compensates for the temperature. At this point in time, Tasmota does not support reading sensor data which compensates with any other sensor's data. That said, these are typically well-established equations that will allow you to convert the existing reading and adjust it based on the reading from the other sensor. A simple Google search can be done to understand how to compensate in each case. Sleep mode for EZO devices is currently NOT supported by Tasmota.","title":"Readings"},{"location":"Energy-Saving/","text":"Using the Sleep command you can instruct Tasmota to sleep for the set milliseconds in its main cycle. While sleeping your device will consume less power. Dynamic Sleep is enabled by default with a value of 50. To continue using Normal Sleep you may disable it by using the command: SetOption60 1 Setting Sleep to lowest value 1 reduces power consumption already about ~30% in idle mode (relay off) and button presses are still noticed without any delay. Setting this around 50 ms reduces power consumption from ~1.1 W to ~0.6 W on an idling (relay off) device and button presses are still noticed correctly. With this setting you have to concentrate very hard to click the button so fast that it is not recognized by the device. If your device needs to do something continuously, this will be affected. E.g., device LED will flicker and Sonoff POW will not be able to correctly total the energy consumption. Spot readings of power, voltage, etc. will however remain correct. From the release notes: Expect overall button/key/switch misses and wrong values on Sonoff Pow Notes: - Starting with Tasmota 6.1.1.12 Sleep \u2260 0 has no impact on real time related commands like Delay , PulseTime , TelePeriod and Blinktime . - As the WiFi Modem on an ESP8266 is the major consumer - using Sleep with WiFi AP mode enabled is more or less without effect. Device power consumption and measurement ~ Most low-price plug-in home energy meters like Sonoff devices are very imprecise for power consumption < 10 W and become more and more imprecise for power consumption (< 1.5 W). Furthermore, the results of such meters are very strongly dependant on the load type (capacitive/inductive) and are absolutely imprecise for non-ohmic load types having switch-mode power supplies. In addition, using Sleep - which periodically cycles the power of the device between 20% and 100% - on such meters makes their readings more or less useless. Example of power consumption ~ Absolute AC line measurement using calibrated meter ~ The following measurement was done directly on 230 V/AC line using a Sonoff Dual R2 and two different Sonoff S20 connected on different MID calibrated meter (Eastron SMD630 MID/saia-burgess ALE3). Device power consumption using Sleep ~ Device Sleep 0 Sleep 1 Sleep 50 Sleep 200 Sonoff Dual R2 1.24 W 0.84 W 0.76 W 0.68 W Sonoff S20 1.11 W 0.77 W 0.59 W 0.51 W All measurements were done with - WiFi STA mode, enabled and connected (70%) - MQTT enabled and connected - Syslog enabled and connected - TelePeriod 60 for debugging - Relays off - Measurement period of 24-56 hours to reduce measurement discrepancies The first impression is that a higher sleep value reduces the consumption, but only slightly. The second result is that using Sleep <value> ( value \u2260 0, e. g., 1) is good enough to reduce the power consumption anywhere between 1/3 and up to 45% (value=200). Quantity measurement of ESP-12 module/ESP8266 3.3V line ~ To find out why Sleep reduces the power consumption and how its value should be set, the current of the 3.3V DC ESP8266 of an ESP-12 module was measured using an oscilloscope and (for easy reading the oscilloscope diagram) a 1 \u03a9 shunt which results in a 1:1 interpretation between voltage and current. This measurement simplified the measure of a time based power consumption; no integration must be done. On the other side note that the quantity measurement does not respect the effectiveness of the complete device circuit. Sleep 0 ~ Using Sleep 0 there are no delay() calls in Tasmota main loop and therefore the power consumption is continuous at current ~80 mA: Sleep 1 ~ Due to the fact that the Tasmota main loop now calls delay() (even with 1ms) it seems it results in periodically (100ms) enabling the WiFi Modem Sleep mode within the WiFi Manager library. It results in periodically lowering the current to 15-20 mA for ~90ms of each loop: Sleep 100 ~ By increasing the sleep value, there are more and more ~90ms periods with additional lowering of the current to 8-10 mA - I really don't know where this comes from: Sleep 250 ~ As already noticed with Sleep 100 the number periods having 8-10 mA instead of 15-20 mA increase again: The quantity measurement confirms the suspicion that a Sleep value \u2260 0 results in reducing the power consumption about 1/3.","title":"Energy Saving"},{"location":"Energy-Saving/#device-power-consumption-and-measurement","text":"Most low-price plug-in home energy meters like Sonoff devices are very imprecise for power consumption < 10 W and become more and more imprecise for power consumption (< 1.5 W). Furthermore, the results of such meters are very strongly dependant on the load type (capacitive/inductive) and are absolutely imprecise for non-ohmic load types having switch-mode power supplies. In addition, using Sleep - which periodically cycles the power of the device between 20% and 100% - on such meters makes their readings more or less useless.","title":"Device power consumption and measurement"},{"location":"Energy-Saving/#example-of-power-consumption","text":"","title":"Example of power consumption"},{"location":"Energy-Saving/#absolute-ac-line-measurement-using-calibrated-meter","text":"The following measurement was done directly on 230 V/AC line using a Sonoff Dual R2 and two different Sonoff S20 connected on different MID calibrated meter (Eastron SMD630 MID/saia-burgess ALE3).","title":"Absolute AC line measurement using calibrated meter"},{"location":"Energy-Saving/#quantity-measurement-of-esp-12-moduleesp8266-33v-line","text":"To find out why Sleep reduces the power consumption and how its value should be set, the current of the 3.3V DC ESP8266 of an ESP-12 module was measured using an oscilloscope and (for easy reading the oscilloscope diagram) a 1 \u03a9 shunt which results in a 1:1 interpretation between voltage and current. This measurement simplified the measure of a time based power consumption; no integration must be done. On the other side note that the quantity measurement does not respect the effectiveness of the complete device circuit.","title":"Quantity measurement of ESP-12 module/ESP8266 3.3V line"},{"location":"Esptool/","text":"How to setup and configure Esptool for Tasmota upload. The information below is for the Python version of esptool - If you want to use the Windows/Linux/OSX(MAC) executable version of esptool (as would be included in Arduino ESP8266 cores) then please go to the esptool executable (Windows & Linux) section at the bottom. Download Esptool ~ If you do not have an installed copy of Python download and install it from https://www.python.org/. Download Esptool Source code from https://github.com/espressif/esptool/releases to a known folder. Install Esptool ~ Go to the known folder and install Esptool with command python setup.py install . Packages for Esptool are maintained for Debian and Ubuntu and can be installed with sudo apt install esptool . Download Tasmota ~ Download the latest Tasmota release firmware file tasmota.bin to a known folder. Upload Tasmota ~ Put device in firmware upload mode ~ When performing a firmware upload do not connect the device to AC but use the power supply provided by your (FTDI type) serial interface. Put the device in firmware upload mode by grounding pin GPIO00 while applying power. Grounding pin GPIO00 can often be achieved by pressing button 1 on the Sonoff device or using a wire between GPIO00 and Gnd if the button is not available. Deviations may apply. Connect the serial interface of your PC to the device while GPIO00 to Gnd. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2 etc. On Linux these interfaces are called /dev/ttyUSB0, /dev/ttyUSB1 etc. Before using Esptool make sure you know to which serial interface name your device is connected to. In the following commands I use COM5 as an example. Optional: Backup firmware ~ Ensure the device is in firmware upload mode. Backup the current firmware with the following command: esptool.py --port COM5 read_flash 0x00000 0x100000 image1M.bin NOTE: When the command completes the device is out of firmware upload mode! Erase firmware ~ Ensure the device is in firmware upload mode. Erase the complete flash memory holding the firmware with the following command: esptool.py --port COM5 erase_flash NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: It only takes a few seconds to erase 1M of flash. Upload firmware ~ Ensure the device is in firmware upload mode. Load the downloaded Tasmota firmware file tasmota.bin with the following command: esptool.py --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: For a proper device initialization after first firmware upload power down and power up the device. ESPTOOL Executable (Windows, MacOs and Linux) ~ The executable version of esptool can be dpwnloaded from https://github.com/espressif/esptool/releases Download and Install ~ For the purpose of simplicity only the Windows version will be explained here, but the command and parameters are the same for Windows, Linux and MAC/OSX. Download the latest release from https://github.com/espressif/esptool/releases and extract the compressed file to a known location. Download Tasmota ~ Download the latest Tasmota release firmware file tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) If you want features from the current development codebase which has not been included in the last release please download this tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) The information posted further up in this Wiki for placing the device into bootload / firmware upgrade mode may be followed as this process does not change irrespective whether you use the Python or executable version of esptool. Once the device is in firmware upload mode the following commands are recommended for completion of the firmware flashing. Erase the flash completely with the following command (substituting the COM port for the one which was used on your computer) esptool.exe --port COM5 erase_flash Once the erase is complete, reset your device back into programming mode and then upload the firmware using the following command esptool.exe --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin","title":"Esptool"},{"location":"Esptool/#download-esptool","text":"If you do not have an installed copy of Python download and install it from https://www.python.org/. Download Esptool Source code from https://github.com/espressif/esptool/releases to a known folder.","title":"Download Esptool"},{"location":"Esptool/#install-esptool","text":"Go to the known folder and install Esptool with command python setup.py install . Packages for Esptool are maintained for Debian and Ubuntu and can be installed with sudo apt install esptool .","title":"Install Esptool"},{"location":"Esptool/#download-tasmota","text":"Download the latest Tasmota release firmware file tasmota.bin to a known folder.","title":"Download Tasmota"},{"location":"Esptool/#upload-tasmota","text":"","title":"Upload Tasmota"},{"location":"Esptool/#put-device-in-firmware-upload-mode","text":"When performing a firmware upload do not connect the device to AC but use the power supply provided by your (FTDI type) serial interface. Put the device in firmware upload mode by grounding pin GPIO00 while applying power. Grounding pin GPIO00 can often be achieved by pressing button 1 on the Sonoff device or using a wire between GPIO00 and Gnd if the button is not available. Deviations may apply. Connect the serial interface of your PC to the device while GPIO00 to Gnd. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2 etc. On Linux these interfaces are called /dev/ttyUSB0, /dev/ttyUSB1 etc. Before using Esptool make sure you know to which serial interface name your device is connected to. In the following commands I use COM5 as an example.","title":"Put device in firmware upload mode"},{"location":"Esptool/#optional-backup-firmware","text":"Ensure the device is in firmware upload mode. Backup the current firmware with the following command: esptool.py --port COM5 read_flash 0x00000 0x100000 image1M.bin NOTE: When the command completes the device is out of firmware upload mode!","title":"Optional: Backup firmware"},{"location":"Esptool/#erase-firmware","text":"Ensure the device is in firmware upload mode. Erase the complete flash memory holding the firmware with the following command: esptool.py --port COM5 erase_flash NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: It only takes a few seconds to erase 1M of flash.","title":"Erase firmware"},{"location":"Esptool/#upload-firmware","text":"Ensure the device is in firmware upload mode. Load the downloaded Tasmota firmware file tasmota.bin with the following command: esptool.py --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: For a proper device initialization after first firmware upload power down and power up the device.","title":"Upload firmware"},{"location":"Esptool/#esptool-executable-windows-macos-and-linux","text":"The executable version of esptool can be dpwnloaded from https://github.com/espressif/esptool/releases","title":"ESPTOOL Executable (Windows, MacOs and Linux)"},{"location":"Esptool/#download-and-install","text":"For the purpose of simplicity only the Windows version will be explained here, but the command and parameters are the same for Windows, Linux and MAC/OSX. Download the latest release from https://github.com/espressif/esptool/releases and extract the compressed file to a known location.","title":"Download and Install"},{"location":"Esptool/#download-tasmota_1","text":"Download the latest Tasmota release firmware file tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) If you want features from the current development codebase which has not been included in the last release please download this tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) The information posted further up in this Wiki for placing the device into bootload / firmware upgrade mode may be followed as this process does not change irrespective whether you use the Python or executable version of esptool. Once the device is in firmware upload mode the following commands are recommended for completion of the firmware flashing. Erase the flash completely with the following command (substituting the COM port for the one which was used on your computer) esptool.exe --port COM5 erase_flash Once the erase is complete, reset your device back into programming mode and then upload the firmware using the following command esptool.exe --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin","title":"Download Tasmota"},{"location":"Expanding-4CH/","text":"Opening my Sonoff 4CH (https://www.itead.cc/sonoff-4ch.html) I realized that on PCB there is a predisposition for 2.5 mm jack (also confirmed by schematic on Itead wiki: https://www.itead.cc/wiki/File:Sonoff_4CH.SCHMATIC.pdf). I ordered on Aliexpress some 2.5 mm jacks and when I received it after some work... The schematic reports that 2.5 mm jack is configured as following (jack on right side, ESP8285 on the left side: 3.3V and GND are very welcome for sensors expansions but GPIO7 and GPIO8 are not usable because they are used internally by ESP8285 for flash memory connection (sigh!) R35 and R36 resistors are not soldered on Sonoff 4CH PCB and it is possible to use their pads to \"manually route\" the jack contact on another ESP8285 pin (!). I selected R35 pad because my \"waterproof\" DS18B20 sensors provide signal line on TEM1 jack contact. For ESP8285 pin I prefer IO2 that is already available on header programming pins... Then the route to do is: TEM1 -> R35 pad -> GPIO2: DS18B20 sensors need a 4.7Kohm pullup resistor between DATA pin and 3.3V and this is also useful to pullup GPIO2 in order to avoid ESP8285 reset. Final result in these photos: Tasmota is also configured with DS18x20 on GPIO2 and it works ! * Note * : source file sonoff/sonoff_template.h provides the configuration on Sonoff 4CH and it is also possible to use GPIO16 (as in the screenshot above) but be aware that no interrupts can be used on GPIO16 and you could have problems with some sensors.","title":"Expanding 4CH"},{"location":"Expanding-Tasmota/","text":"You can wire peripherals (sensors, displays, switches, LED lights, ...) to available pins of the ESP8266 chip that controls these devices. To make a link between the different naming schemes the Pin Definition overview in the ESP8266 wiki is quite helpful. Examples ~ Connect switch ~ If you take a Sonoff Basic and connect a switch between pin4 (GND) and pin5 (GPIO14) of the 5 pin programming header you now have a second switch connected to the device. You can set this through the module config page as option Switch1 (9) or from the command line with gpio14 9 . See Buttons and Switches for more information. Connect jack ~ Instead of connecting a switch, you could connect a 4-pin 2.5mm jack, with the pins wired: Jack Pin ESP8266 tip 5 GPIO14 R1 no connection R2 1 GND R3 4 3.3V You can then plug a sensor into the jack like you would to a Sonoff TH and define what sensor you have connected to GPIO14. Restrictions ~ Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document . Voltage and Current ~ Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA. Power Supply ~ Danger The power supplied to the device is one of the most important elements for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself. Electrical Considerations ~ When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 ) The ESP8266 Hardware ~ Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html Digital I/O ~ Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current). Usable pins ~ The ESP8266 and ESP8255 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8255 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data. Boot modes ~ Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor. PWM ~ Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions . Analog input ~ The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits. Communication ~ Serial ~ The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins. I\u00b2C ~ ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz. SPI ~ The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software). GPIO overview ~ NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"Expanding Tasmota"},{"location":"Expanding-Tasmota/#examples","text":"","title":"Examples"},{"location":"Expanding-Tasmota/#restrictions","text":"Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document .","title":"Restrictions"},{"location":"Expanding-Tasmota/#voltage-and-current","text":"Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA.","title":"Voltage and Current"},{"location":"Expanding-Tasmota/#power-supply","text":"Danger The power supplied to the device is one of the most important elements for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself.","title":"Power Supply"},{"location":"Expanding-Tasmota/#electrical-considerations","text":"When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 )","title":"Electrical Considerations"},{"location":"Expanding-Tasmota/#the-esp8266-hardware","text":"Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html","title":"The ESP8266 Hardware"},{"location":"Expanding-Tasmota/#digital-io","text":"Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current).","title":"Digital I/O"},{"location":"Expanding-Tasmota/#usable-pins","text":"The ESP8266 and ESP8255 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8255 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data.","title":"Usable pins"},{"location":"Expanding-Tasmota/#boot-modes","text":"Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor.","title":"Boot modes"},{"location":"Expanding-Tasmota/#pwm","text":"Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions .","title":"PWM"},{"location":"Expanding-Tasmota/#analog-input","text":"The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits.","title":"Analog input"},{"location":"Expanding-Tasmota/#communication","text":"","title":"Communication"},{"location":"Expanding-Tasmota/#serial","text":"The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins.","title":"Serial"},{"location":"Expanding-Tasmota/#i2c","text":"ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz.","title":"I\u00b2C"},{"location":"Expanding-Tasmota/#spi","text":"The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software).","title":"SPI"},{"location":"Expanding-Tasmota/#gpio-overview","text":"NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"GPIO overview"},{"location":"FAQ/","text":"Wi-Fi ~ Cannot connect to Wi-Fi ~ If your device does not connect to your Wi-Fi and you've made sure the Wi-Fi credentials are correct, it is caused by using special chars or white spaces in your SSID or Password of your Wi-Fi. Remove them and try again. Other reason can be using an SSID longer than the allowed 32 characters. With some Wi-Fi routers (i.e. Linksys with DD-WRT), you may have conflicts with the 5GHz radio. Don't choose \"Mixed\" option. Select \"AC/N-Mixed\" instead. Moreover, you probably should disconnect 5GHz radio during the configuration process. DD-WRT also has Wi-Fi Multi-Media (WMM) enabled by default. Disabling WMM can resolve connectivity issues. Some Tasmota devices also have issues with OFDMA (WiFi 6) enabled on the 2.4GHz band. Disabling OFDMA can solve problems with WiFi failing to connect. I entered wrong Wi-Fi information ~ If you have a device with a button and the button is configured as a component in the Tasmota settings (e.g., GPIO0 - Button1), you can try pressing the button to force the device into Wi-Fi configuration mode with 4 short presses of the button. Note: Since version 8.3.0 this requires 6 short presses instead. If that didn't work reset your device using Fast power cycle device recovery If you are unsure what SSID you have entered, you can try to find that with special Wi-Fi sniffing tools. For example Nirsoft WifiChannelMonitor can show your mistakenly configured SSID name. Linux system example: apt install aircrack-ng wireshark airmon-ng check kill airmon-ng start (e.g. wlp58s0 or wlan0) wireshark Select your Wi-Fi device from the list. Plug in the mis-configured device and immediately watch SSIDs. You should see your mis-configured SSID fairly soon. If these methods don't work, it may still be possible to save the device without opening it to perform a serial flash. Since Tasmota uses GET request for forms, the password may be in your browser history. Search in your browser history for 192.168.4.1 (or whatever address you used for configuring it) There should be an entry similar to this: http://192.168.4.1/wi?s1=<mySSID>&p1=<myPassword>-********&s2=&p2=********&h=hostName&save= s1 is your first AP SSID p1 is the first AP password s2 and p2 are the same parameters but for the second AP h is the hostname given to the device by the Tasmota configuration After getting the incorrectly entered configuration from this URL, configure an access point with these settings as described above Access your device and set the correct Wi-Fi credentials If you flashed a light bulb or any device without a built-in button and entered wrong Wi-Fi password you now have a device that won't connect to your Wi-Fi and you have no button to force it into Wi-Fi configuration mode. This tip takes advantage of a security risk present in Arduino Cores prior to 2.6.0. It will not work with Tasmota binaries compiled with 2.6.0 or later. To solve this you can try creating a new Wi-Fi AP with the same SSID and no (none) authentication. Use an old router, a mobile phone or, if you're desperate, change the settings on your main router (but remember to turn authentication back on when you're done). Depending on the router/phone it will ignore the wrong Wi-Fi password since authentication is set to none and let your Tasmota flashed device connect to it. Now simply connect to the same AP and open the web UI, triple check your ssid and password, enter some simple info for SSID2 which you can create as a hotspot on your phone and save. Device disconnects from Wi-Fi often ~ First thing to try when having Wi-Fi issues: Reset 3 which will erase wi-fi calibration data only and will keep configuration intact. Make sure to power cycle restart after that. If that doesn't help try rebooting the router as well As a last resort try : Erase all flash using esptool.py or esptool.exe and flash via serial (as explained here ) using the latest precompiled binaries . This approach has solved many of the reported issues. Sometimes this is due to a bad flash, a bad OTA or invalid data that remains in the flash where the SDK memory is. If you still have issues, you should look into your Wi-Fi network: Some new routers have many modern features enabled with default which don't work well with the old ESP82xx chip. Disable any channel surfing, band changing and similar features. Check the Wi-Fi channel availability and noise with an Android app like Wi-Fi Analyzer. Disable Auto Channel in your Wi-Fi router and select any Wi-Fi channel that is not very congested in your area. Disable Wi-Fi Repeaters and Mesh Networks. Check Wi-Fi signal in your device. The same Mesh may be stable in one area and lead to unwanted Tasmota reconnects in other areas, presumably when the signals of access points overlap with similar strength. If disabling Mesh Networks is not an option, then keeping the network busy, e.g. by issuing a Ping from another host every 20 seconds has helped to avoid the reconnects. Wi-Fi Stops Working ~ There have been many reports of Wi-Fi no longer working after it was working for a while. Every time this has been reported, it's ended up being a hardware or signal interference problem. On the hardware side, we've seen reports of bad solder joints on the board that when touched up seem to solve the problem (capacitors being loose can cause this) or low quality/weak power supplies or voltage regulators that cannot cope with the power requirements of Tasmota or have degraded over time. We've also seen reports then when a specific LED light bulb was hooked up near one, the signal quality dropped to unusable. All you can really do is check the solder joints, move the device closer to your Access Point. If all else fails, replace the device. Weaker Wi-Fi signal after upgrade ~ On an ESP82xx, Wi-Fi calibration is sensitive to the power supplied. If this changes substantially (e.g., you add a sensor, configure a new Tasmota feature, upgrade the firmware or Arduino Core, etc.), the device's Wi-Fi calibration may not be set properly any longer. The Wi-Fi signal strength (RSSI) can drop significantly and impact Wi-Fi performance. In such a case, the Wi-Fi calibration needs to be deleted to force the device to re-calibrate Wi-Fi after it restarts. Run Reset 3 in the Console. The device will restart Cycle the power on the device. Wi-Fi calibration will not be done unless the device performs a cold boot from power up. WebUI unavailable but device can be controlled ~ Some routers have issues with ARP implementation. To help with that use SetOption41 to make your device send grauitous ARP in a desired interval (try 30 or 60 seconds for start). MQTT ~ Cannot connect to my MQTT broker ~ Make sure you've configured MQTT correctly. If that didn't solve the issue check your MQTT broker logs. Most likely problem is your broker doesn't allow logins for your Tasmota configure user and password or your ACL settings do not include your device. In some very specific cases the MQTT broker code clashes with the Arduino Core and doesn't allow a connection. In that case create a different user for your device, try another core binary or a different MQTT broker. Frequent MQTT reconnects ~ Most MQTT reconnect messages are linked with Wi-Fi instability first. Resolve any Wi-Fi issue first! If the console shows repeated messages like: 02:32:54 MQTT: tele/MYSONOFF/LWT = Online (retained) 02:32:54 MQTT: cmnd/MYSONOFF/POWER = 02:32:55 MQTT: Attempting connection... 02:32:56 mDNS: Query done with 0 mqtt services found 02:32:56 MQTT: Connected or your mosquitto broker log shows messages like this - 1496455347: New client connected from IP_addr_1 as SONOFF (c1, k15, u'SONOFF_USER'). 1496455349: New connection from IP_addr_1 on port 1883. 1496455349: Client SONOFF already connected, closing old connection. 1496455349: Client SONOFF disconnected. 1496455349: New client connected from IP_addr_2 as SONOFF (c1, k15, u'SONOFF_USER'). 1496455350: New connection from IP_addr_2 on port 1883. 1496455350: Client SONOFF already connected, closing old connection. 1496455350: Client SONOFF disconnected. You have more than one device connected with the same %topic% defined. Its important that each device has a unique %topic% instead of the default sonoff . If that is not the issue, erase all flash using esptool.py or esptool.exe and flash again by wire (as explained here ) using the latest precompiled bins with core v2.7.1 . Device is often unavailable, ussually 30 seconds every minute ~ Due to a bug in the Arduino core that we are working on to solve, Tasmota devices require time to be correctly setup to work properly (see https://github.com/tasmota/docs/blob/master/docs/FAQ.md#timers-trigger-at-the-wrong-time for details and alternatives). If a Tasmota device cannot reach one of the NTP server after restarting, the device will be unavailable during 30 seconds every minute while trying to update the time. To confirm this issue, the command weblog can be set to 4 (typing \"weblog 4\" in the console), and log should indicate \"NTP: Sync time...\" followed by \"NTP: Unable to resolve IP address\" 30 seconds later, in the 30 seconds period the device is unavailable. Configuration ~ Device reset to defaults on its own ~ Bad power supply ~ Most common culprit is Power Cycle Recovery which can be activated if the device has a bad power supply or your power grid has fluctuations/brownouts. Disable the feature with SetOption65 1 Button in ON state when depressed ~ If a button is configure to be in ON state when depressed it will activate \"Firmware Reset\" feature. Either change the button mode or use SetOption1 1 to disable factory reset mode. Frequent reboots/bootloops ~ Your device may be in a boot loop - a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME ( default 10 seconds ). The number of boot loops allowed before beginning to reset settings is determined by SetOption36 . When Tasmota reaches this situation, it will begin restoring default settings as follows: 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI 2 nd restart: disable rules causing boot loop 3 rd restart: disable all rules 4 th restart: reset user defined GPIOs to disable any attached peripherals 5 th restart: reset module to Sonoff Basic (1) Relay clicks and LED flashes at 1 second intervals ~ This indicates that your device did not get flashed properly. In this case it will toggle all it's pins at 1 sec intervals. A flash erase and a new flash is required. Status LED blinking ~ Your device status LED blinks repeatedly when Wi-Fi and/or MQTT is not connected. If you're not using MQTT and did not configure it the status LED will still keep blinking. You can disable status LED blinking using: Backlog LedPower 0; SetOption31 1 My device randomly switches on and off. Do I have ghosts in my house? ~ Most of the issues with random, or \"ghost\", switching are related to MQTT retain settings. In short, your MQTT broker is retaining a message with the POWER status of the device which gets applied on reboots. Solution here In some cases, adding a switch to a device causes ghost switching. In this case, you may need to add a low pass filter to dampen any spikes on the input. In the case of the Sonoff T1, a modification to change the filter capacitor on the PCB may be required. This short 10 minute video by TheHookUp nicely explains what it is and how to prevent it. Other cause can be of electrical nature. If you have connected an external switch using long wires they can pick up stray signals and cause the voltage on the GPIO to vary. Solution here Cannot find my device in Modules ~ If you flashed a device which is not listed in the Modules list, use Templates to configure your device. Try looking for it first in the Templates Repository . Device keeps restarting after changing config over MQTT ~ If you changed configurations over MQTT, the command can fail due to a bug and the command is repeatedly sent, causing the device to restart. The restart is normal if you change something at the device configuration. You need to clear the retain messages of your HA/Broker/MQTT Server. Read also: #2140 #2658 (comment) #2716 Tasmota is sending many status updates every 5 seconds ~ Turn off TasmoAdmin ! It is polling your device with STATUS 0 command with a HTTP request every 5 seconds which causes the status updates and unnecessary stress load on the device. In some cases it might even interfere with normal device operation. Web Interface Asks for Password ~ You modified the Web Admin password ( Configure Other ) and now you cannot access the web interface. You have set up a password for the web interface. You can login with the username admin and the password you entered. However, if you don't remember that password there are a few options you can try to gain access to the web interface again. Reset the password using the WebPassword command. If you have serial connection to the device: Execute WebPassword 0 using a serial terminal interface. If you have configured MQTT: Send 0 to cmnd/<device-topic>/WebPassword . You can send it from any MQTT client . You can also use another Tasmota device using the Publish command - Execute Publish cmnd/<device-topic>/WebPassword 0 from that device's Console. If the options above are not available: Since Tasmota uses GET request for forms, the password may be in your browser history. Look there for entries with the name you configured for the device. For example, in the following link: http://<device-ip>/co?t1={\"NAME\":\"Generic\"'\"GPIO\":[23'22'24'17'134'132'0'0'131'52'21'0'0]'\"FLAG\":0'\"BASE\":67}&p1=SecretPassword&b1=on&a1=Sonoff&a2=Sonoff2&a3=Sonoff3&a4=Sonoff4&b2=0&save= the p1 parameter contains the password for the web interface ( SecretPassword in this case). Note: special characters may appear as the characters' corresponding ASCII hexadecimal codes (e.g., \"{\" = '\\%7B', etc.) If you had set up WifiConfig 7 as your Wi-Fi fallback method (by previously executing WiFiConfig in the Console), you can reset the device by booting it into Wi-Fi Manager mode. If the SSID configured in the device is not available (e.g., turn off the router), the device will fallback to that restricted Wi-Fi Manager Mode. If your device has a physical push-button, reset the firmware to the default settings as detailed here . If nothing helps, then you have to flash the firmware again using the serial interface. Be sure to erase the flash memory before uploading the binary. Power monitoring shows wrong values ~ If the values shown in the Web UI don't seem right and you're using a Supported Module you need to calibrate the power monitoring sensor . In case you're using a template you created yourself or found in our Templates Repository try the calibration method first. If the values are still wrong or unrealistic the power monitoring sensors' GPIOs are not configured correctly and you will need to find the correct GPIO assignments before proceeding. Sensors do not show values ~ Make sure your sensor is properly wired and the GPIOs assigned. Your vanilla tasmota.bin doesn't have complete sensor support. Make sure you've installed tasmota-sensors.bin that support the largest number of sensors. Some sensors require enabling in the code and compiling your own binary. See Firmware-Builds for a comprehensive list of supported components. Timers trigger at the wrong time ~ Tasmota devices must have a their time of day set properly in order for any timers to work properly. Check the log in the web UI Console to see if the device's time is set correctly. There are two elements to setting the time: 1. obtaining the UTC time, and, 2. local Daylight Saving Time policies. There are three methods available to set the device time: 1. NTP , 2. An RTC peripheral , or 3. the Time command. The typical method Tasmota uses to set its time is to obtain the time from an Internet NTP server. It can also query an NTP server on its local network (e.g., a network router with an NTP service, a Raspberry Pi running the NTP daemon, the Chrony add-on in Home Assistant, etc.). The time sync request is forced to NTPSERVER1 . If can't connect, it tries NTPSERVER2 . And finally NTPSERVER3 . Ensure that these parameters are set appropriately and that the device can reach at least one of these time servers. You may want to consider setting up an NTP server locally. As long as the computer is able to set its time at some point from an Internet time server, this computer can serve as an NTP server for your Tasmota device(s). This can be the same computer that hosts your MQTT broker or home automation hub. You must also set the TimeZone and Daylight Saving Time policies ( TimeDST / TimeSTD ). If you have timers that use the sunset or sunrise times, you must set your latitude and longitude in order for these times to be calculated correctly for your location. Auto-discovery in Home Assistant does not work ~ The tasmota-lite.bin firmware binary (which comes packaged with Tuya-Convert) does not support auto-discovery. Please upgrade to tasmota.bin or a similar firmware variant that supports this feature. Make sure its enabled in Tasmota it with SetOption19 1 and you configured the Home Assistant MQTT integration with Discovery enabled. Why is my changed configuration not loaded? ~ If you have flashed a precompiled binary, be aware that all the configuration made after the flash (Wi-Fi, MQTT, topics, names, rules, etc) will be lost in a factory firmware reset. In short : The CFG_HOLDER is the place where the config is stored on your device. The device checks if a config is saved in this CFG_HOLDER (value from the my_user_config.h) and always loads this if exists. => won't load new applied configs in your my_user_config.h To get the new config on your device, you need to change the CFG_HOLDER. BUT: You should always try to stay on the default CFG_HOLDER, to reach this, you need to flash two times change your config in the my_user_config.h or better user_config_override.h change the CFG_HOLDER number. +1 or -1 is enough (e.g. 0x20161208) flash change the CFG_HOLDER back to default ( 0x20161209 ) flash again After this, your new config is saved in the default CFG_HOLDER on your device. This is necessary to avoid losing your config if you update to a new firmware by using the pre-build images or if you forget to change the CFG_HOLDER to your custom one if you build the firmware yourself. How CFG_HOLDER works : The config of your Tasmota is stored in an area of the flash memory (flash config area or FCA ). Using a new device (where Tasmota firmware runs the first time) the FCA does not contain a Tasmota configuration so on the very first start of Tasmota it uses your settings from my_user_config.h or user_config_override.h and copy this into the FCA. To prevent the following Tasmota starts from overwriting your FCA settings again (e.g. because you changed some things using commands), the FCA will be marked by a header value indicating not to copy the values from my_user_config.h / user_config_override.h again. This header becomes the value from CFG_HOLDER. On every start the device compares the header of FCA with the CFG_HOLDER from your source code and only if this header value is not identical, Tasmotat will copy the data from my_user_config.h/user_config_override.h to flash settings area - this is normally only the case on a fresh device or if you has changed the CFG_HOLDER value. Summary : To force Tasmota to overwrite current (valid or invalid) settings in FCA with your settings from my_user_config.h / user_config_override.h you can change CFG_HOLDER value once, compile, reflash device (as described above). To avoid overwriting settings by new versions don't forget either repeat the step above using original CFG_HOLDER value or never forget to change CFG_HOLDER value for even all upcoming version to your value or use the command Reset 1 or Reset 2 after changes in your my_user_config.h / user_config_override.h without the need to double reflash your device and/or double change your CFG_HOLDER value: change values in my_user_config.h / user_config_override.h leave CFG_HOLDER as is start your device and issue command Reset 1 or Reset 2 How do I invert the output of the green LED on the Sonoff Basic so the LED is on when the relay is off? ~ LedState default value is 1 (on) - Show power state on LED. The LED can be disabled completely with LedState 0 (off). However, there is no option to invert the output of the green LED on the Sonoff Basic. Flashing ~ Cannot enter flash mode ~ Be sure to press the button correctly, you must \"feel\" a click. If your on-device button doesn't allow you to enter flash mode or there is no GPIO0 broken out to the PCB, you can always bridge GND to GPIO0 pin directly on the chip. Search on the Internet for your chip's pinouts and use the tutorial . Be sure to keep GPIO0 grounded long enough (3-5 seconds) before disconnecting to ensure the chip has booted completely into programming mode. On devices that do not provide a GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems for flashing the device. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. Flashing issues ~ Double check if you wired the device the serial-to-USB adapter correctly. Almost every device needs RX and TX pins switched to TX and RX. See Hardware Preparation for more. Another common problem are the jumper cables used. Try another cable if you keep getting connection errors or check the cables for connectivity. Most of them are made cheaply and it happens quite often that those cables do not offer a good connection because of bad crimping or broken copper lines in them. Be sure to use a USB Data Cable and not a cheap loading cable for mobile phones for connecting the serial-to-USB adapter to your computer. If you are unsure, just try another USB cable. Data USB cables are often thicker than the normal loading cables (and more expensive). Another problem can be the difficulties in getting the ESP chip into programming mode when it boots. If the flash still fails or the progress interrupts, it could be that your computer or serial-to-USB adapter doesn't provide enough power to the device. Try another computer or use an external power supply (3.3V one). More infos about insufficient power Use the correct serial-to-USB adapter driver. Check the model of your adapter chip and get the correct driver. If the flash completes successfully, but you get a hash mismatch (esptool.py error message A fatal error occurred: MD5 of file does not match data in flash! ) ensure that your 3.3v current is sufficient. Workarounds include using a dedicated bread board power supply or using the 3.3v output of an additional microcontroller. If using an additional power supply to power the device, be sure to use a common ground for the power supply, the device to be flashed and the serial-to-USB adapter. If esptool.py stops at \"Uploading stub...\", use --no-stub If the flash fails or the device does not operate as expected, try using the default ESP82xx boot ROM baud rate - 74880 . This is the baud rate the ESP82xx is set to by default when it boots into programming mode. It can be specified as a command line option in esptool.py ( -b ) and esptool.exe ( -cb ). You may also want to select a serial monitor/terminal capable of setting this \"unusual\" baud rate. In Termite, type this value ( 74880 ) in the baud rate selection text box when configuring the port. Having the option to specify this unusual baud rate will allow you to view the ESP8266 boot ROM log while the device is booting. Device is hot to the touch ~ Remember - NEVER EVER FLASH WITH 5V! ? Better unpower your device and check if the wiring is correct and the voltage is on your FTDI is set to 3.3V. If you've connected VCC to the wrong pin it might cause your device to overheat and destroy it. There was white smoke and the device does not work anymore! ~ Yes, you've released the fabled \"white smoke\", the mysterious substance all electronic devices work on. In the immortal words of Doctor Bones: It's dead Jim! Sonoff 4CH V2 / Sonoff Dual V2 will not flash ~ Testing with two different (fairly new) FTDI boards and two Sonoff 4CH v2.0 and the Sonoff Dual v2.0 boards I found that I was getting errors uploading sketches i.e. \"warning: espcomm_sync failed\" basically a lack of communication between the two devices. I found that the problem in both Sonoff's was that instead of the FTDI Sonoff cross-over TX->RX and RX->TX I had to do TX->TX RX->RX this then allowed me to upload the sketch. Flashing fails on MacOS High Sierra ~ Related to issue #957 . Solution: Install the VCP drivers for Mac from the FTDI website After install, reboot (it does not work if you do not reboot). After reboot, plug the FTDI USB/serial converter. Accept the security alert from MacOS. Restart the flash process. It works! Miscellaneous ~ Can you add this unsupported sensor to Tasmota ~ Short answer: NO! Long answer: There is not enough time in our coders lives to take requests, if you can code a driver for that sensor and submit a PR it will be considered, otherwise you can only wait for someone else to do it. Available Characters for HOSTNAME ~ 24 chars max only a..z A..Z 0..9 '-' no '-' as last char Notice: Hostnames containing % will reset to MQTT_TOPIC-<4digits> . It is not intended to use internal Tasmota variables here. RFC952 ASSUMPTIONS A \"name\" (Net, Host, Gateway, or Domain name) is a text string up to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus sign (-), and period (.). Note that periods are only allowed when they serve to delimit components of \"domain style names\". (See RFC-921, \"Domain Name System Implementation Schedule\", for background). No blank or space characters are permitted as part of a name. No distinction is made between upper and lower case. The first character must be an alpha character. The last character must not be a minus sign or period. A host which serves as a GATEWAY should have \"-GATEWAY\" or \"-GW\" as part of its name. Hosts which do not serve as Internet gateways should not use \"-GATEWAY\" and \"-GW\" as part of their names. A host which is a TAC should have \"-TAC\" as the last part of its host name, if it is a DoD host. Single character names or nicknames are not allowed. Flash Memory Considerations ~ To stop saving parameter changes to Flash or Spiffs use command SaveData off . To stop saving power changes only to Flash or Spiffs use command SetOption0 off . This will disable the relay from returning to the same state after power on UNLESS you use the MQTT retain flag in which case the MQTT broker will send the last known MQTT state on restart or power on. The command ButtonRetain on will configure the button to send a MQTT command with Topic and the MQTT retain flag set. What is an Arduino Core ~ Arduino Core (open source) are the core libraries for ESP8266/ESP8285 chips to make them Arduino Framework Compatible. This Core is programmed on top of the Espressif SDK (closed source). Tasmota is only using the core and does not maintain it or can help in solving issues with it. You can see the Arduino Core Version and the Espressif SDK Version on the Tasmota WebUI under the Information Menu entry. I Cannot Find An Answer Here! ~ Check the Troubleshooting section or join Discord , Telegram , Reddit or Google Groups for assistance from other Tasmota users.","title":"FAQ"},{"location":"FAQ/#wi-fi","text":"","title":"Wi-Fi"},{"location":"FAQ/#cannot-connect-to-wi-fi","text":"If your device does not connect to your Wi-Fi and you've made sure the Wi-Fi credentials are correct, it is caused by using special chars or white spaces in your SSID or Password of your Wi-Fi. Remove them and try again. Other reason can be using an SSID longer than the allowed 32 characters. With some Wi-Fi routers (i.e. Linksys with DD-WRT), you may have conflicts with the 5GHz radio. Don't choose \"Mixed\" option. Select \"AC/N-Mixed\" instead. Moreover, you probably should disconnect 5GHz radio during the configuration process. DD-WRT also has Wi-Fi Multi-Media (WMM) enabled by default. Disabling WMM can resolve connectivity issues. Some Tasmota devices also have issues with OFDMA (WiFi 6) enabled on the 2.4GHz band. Disabling OFDMA can solve problems with WiFi failing to connect.","title":"Cannot connect to Wi-Fi"},{"location":"FAQ/#i-entered-wrong-wi-fi-information","text":"If you have a device with a button and the button is configured as a component in the Tasmota settings (e.g., GPIO0 - Button1), you can try pressing the button to force the device into Wi-Fi configuration mode with 4 short presses of the button. Note: Since version 8.3.0 this requires 6 short presses instead. If that didn't work reset your device using Fast power cycle device recovery If you are unsure what SSID you have entered, you can try to find that with special Wi-Fi sniffing tools. For example Nirsoft WifiChannelMonitor can show your mistakenly configured SSID name. Linux system example: apt install aircrack-ng wireshark airmon-ng check kill airmon-ng start (e.g. wlp58s0 or wlan0) wireshark Select your Wi-Fi device from the list. Plug in the mis-configured device and immediately watch SSIDs. You should see your mis-configured SSID fairly soon. If these methods don't work, it may still be possible to save the device without opening it to perform a serial flash. Since Tasmota uses GET request for forms, the password may be in your browser history. Search in your browser history for 192.168.4.1 (or whatever address you used for configuring it) There should be an entry similar to this: http://192.168.4.1/wi?s1=<mySSID>&p1=<myPassword>-********&s2=&p2=********&h=hostName&save= s1 is your first AP SSID p1 is the first AP password s2 and p2 are the same parameters but for the second AP h is the hostname given to the device by the Tasmota configuration After getting the incorrectly entered configuration from this URL, configure an access point with these settings as described above Access your device and set the correct Wi-Fi credentials If you flashed a light bulb or any device without a built-in button and entered wrong Wi-Fi password you now have a device that won't connect to your Wi-Fi and you have no button to force it into Wi-Fi configuration mode. This tip takes advantage of a security risk present in Arduino Cores prior to 2.6.0. It will not work with Tasmota binaries compiled with 2.6.0 or later. To solve this you can try creating a new Wi-Fi AP with the same SSID and no (none) authentication. Use an old router, a mobile phone or, if you're desperate, change the settings on your main router (but remember to turn authentication back on when you're done). Depending on the router/phone it will ignore the wrong Wi-Fi password since authentication is set to none and let your Tasmota flashed device connect to it. Now simply connect to the same AP and open the web UI, triple check your ssid and password, enter some simple info for SSID2 which you can create as a hotspot on your phone and save.","title":"I entered wrong Wi-Fi information"},{"location":"FAQ/#device-disconnects-from-wi-fi-often","text":"First thing to try when having Wi-Fi issues: Reset 3 which will erase wi-fi calibration data only and will keep configuration intact. Make sure to power cycle restart after that. If that doesn't help try rebooting the router as well As a last resort try : Erase all flash using esptool.py or esptool.exe and flash via serial (as explained here ) using the latest precompiled binaries . This approach has solved many of the reported issues. Sometimes this is due to a bad flash, a bad OTA or invalid data that remains in the flash where the SDK memory is. If you still have issues, you should look into your Wi-Fi network: Some new routers have many modern features enabled with default which don't work well with the old ESP82xx chip. Disable any channel surfing, band changing and similar features. Check the Wi-Fi channel availability and noise with an Android app like Wi-Fi Analyzer. Disable Auto Channel in your Wi-Fi router and select any Wi-Fi channel that is not very congested in your area. Disable Wi-Fi Repeaters and Mesh Networks. Check Wi-Fi signal in your device. The same Mesh may be stable in one area and lead to unwanted Tasmota reconnects in other areas, presumably when the signals of access points overlap with similar strength. If disabling Mesh Networks is not an option, then keeping the network busy, e.g. by issuing a Ping from another host every 20 seconds has helped to avoid the reconnects.","title":"Device disconnects from Wi-Fi often"},{"location":"FAQ/#wi-fi-stops-working","text":"There have been many reports of Wi-Fi no longer working after it was working for a while. Every time this has been reported, it's ended up being a hardware or signal interference problem. On the hardware side, we've seen reports of bad solder joints on the board that when touched up seem to solve the problem (capacitors being loose can cause this) or low quality/weak power supplies or voltage regulators that cannot cope with the power requirements of Tasmota or have degraded over time. We've also seen reports then when a specific LED light bulb was hooked up near one, the signal quality dropped to unusable. All you can really do is check the solder joints, move the device closer to your Access Point. If all else fails, replace the device.","title":"Wi-Fi Stops Working"},{"location":"FAQ/#weaker-wi-fi-signal-after-upgrade","text":"On an ESP82xx, Wi-Fi calibration is sensitive to the power supplied. If this changes substantially (e.g., you add a sensor, configure a new Tasmota feature, upgrade the firmware or Arduino Core, etc.), the device's Wi-Fi calibration may not be set properly any longer. The Wi-Fi signal strength (RSSI) can drop significantly and impact Wi-Fi performance. In such a case, the Wi-Fi calibration needs to be deleted to force the device to re-calibrate Wi-Fi after it restarts. Run Reset 3 in the Console. The device will restart Cycle the power on the device. Wi-Fi calibration will not be done unless the device performs a cold boot from power up.","title":"Weaker Wi-Fi signal after upgrade"},{"location":"FAQ/#webui-unavailable-but-device-can-be-controlled","text":"Some routers have issues with ARP implementation. To help with that use SetOption41 to make your device send grauitous ARP in a desired interval (try 30 or 60 seconds for start).","title":"WebUI unavailable but device can be controlled"},{"location":"FAQ/#mqtt","text":"","title":"MQTT"},{"location":"FAQ/#cannot-connect-to-my-mqtt-broker","text":"Make sure you've configured MQTT correctly. If that didn't solve the issue check your MQTT broker logs. Most likely problem is your broker doesn't allow logins for your Tasmota configure user and password or your ACL settings do not include your device. In some very specific cases the MQTT broker code clashes with the Arduino Core and doesn't allow a connection. In that case create a different user for your device, try another core binary or a different MQTT broker.","title":"Cannot connect to my MQTT broker"},{"location":"FAQ/#frequent-mqtt-reconnects","text":"Most MQTT reconnect messages are linked with Wi-Fi instability first. Resolve any Wi-Fi issue first! If the console shows repeated messages like: 02:32:54 MQTT: tele/MYSONOFF/LWT = Online (retained) 02:32:54 MQTT: cmnd/MYSONOFF/POWER = 02:32:55 MQTT: Attempting connection... 02:32:56 mDNS: Query done with 0 mqtt services found 02:32:56 MQTT: Connected or your mosquitto broker log shows messages like this - 1496455347: New client connected from IP_addr_1 as SONOFF (c1, k15, u'SONOFF_USER'). 1496455349: New connection from IP_addr_1 on port 1883. 1496455349: Client SONOFF already connected, closing old connection. 1496455349: Client SONOFF disconnected. 1496455349: New client connected from IP_addr_2 as SONOFF (c1, k15, u'SONOFF_USER'). 1496455350: New connection from IP_addr_2 on port 1883. 1496455350: Client SONOFF already connected, closing old connection. 1496455350: Client SONOFF disconnected. You have more than one device connected with the same %topic% defined. Its important that each device has a unique %topic% instead of the default sonoff . If that is not the issue, erase all flash using esptool.py or esptool.exe and flash again by wire (as explained here ) using the latest precompiled bins with core v2.7.1 .","title":"Frequent MQTT reconnects"},{"location":"FAQ/#device-is-often-unavailable-ussually-30-seconds-every-minute","text":"Due to a bug in the Arduino core that we are working on to solve, Tasmota devices require time to be correctly setup to work properly (see https://github.com/tasmota/docs/blob/master/docs/FAQ.md#timers-trigger-at-the-wrong-time for details and alternatives). If a Tasmota device cannot reach one of the NTP server after restarting, the device will be unavailable during 30 seconds every minute while trying to update the time. To confirm this issue, the command weblog can be set to 4 (typing \"weblog 4\" in the console), and log should indicate \"NTP: Sync time...\" followed by \"NTP: Unable to resolve IP address\" 30 seconds later, in the 30 seconds period the device is unavailable.","title":"Device is often unavailable, ussually 30 seconds every minute"},{"location":"FAQ/#configuration","text":"","title":"Configuration"},{"location":"FAQ/#device-reset-to-defaults-on-its-own","text":"","title":"Device reset to defaults on its own"},{"location":"FAQ/#relay-clicks-and-led-flashes-at-1-second-intervals","text":"This indicates that your device did not get flashed properly. In this case it will toggle all it's pins at 1 sec intervals. A flash erase and a new flash is required.","title":"Relay clicks and LED flashes at 1 second intervals"},{"location":"FAQ/#status-led-blinking","text":"Your device status LED blinks repeatedly when Wi-Fi and/or MQTT is not connected. If you're not using MQTT and did not configure it the status LED will still keep blinking. You can disable status LED blinking using: Backlog LedPower 0; SetOption31 1","title":"Status LED blinking"},{"location":"FAQ/#my-device-randomly-switches-on-and-off-do-i-have-ghosts-in-my-house","text":"Most of the issues with random, or \"ghost\", switching are related to MQTT retain settings. In short, your MQTT broker is retaining a message with the POWER status of the device which gets applied on reboots. Solution here In some cases, adding a switch to a device causes ghost switching. In this case, you may need to add a low pass filter to dampen any spikes on the input. In the case of the Sonoff T1, a modification to change the filter capacitor on the PCB may be required. This short 10 minute video by TheHookUp nicely explains what it is and how to prevent it. Other cause can be of electrical nature. If you have connected an external switch using long wires they can pick up stray signals and cause the voltage on the GPIO to vary. Solution here","title":"My device randomly switches on and off. Do I have ghosts in my house?"},{"location":"FAQ/#cannot-find-my-device-in-modules","text":"If you flashed a device which is not listed in the Modules list, use Templates to configure your device. Try looking for it first in the Templates Repository .","title":"Cannot find my device in Modules"},{"location":"FAQ/#device-keeps-restarting-after-changing-config-over-mqtt","text":"If you changed configurations over MQTT, the command can fail due to a bug and the command is repeatedly sent, causing the device to restart. The restart is normal if you change something at the device configuration. You need to clear the retain messages of your HA/Broker/MQTT Server. Read also: #2140 #2658 (comment) #2716","title":"Device keeps restarting after changing config over MQTT"},{"location":"FAQ/#tasmota-is-sending-many-status-updates-every-5-seconds","text":"Turn off TasmoAdmin ! It is polling your device with STATUS 0 command with a HTTP request every 5 seconds which causes the status updates and unnecessary stress load on the device. In some cases it might even interfere with normal device operation.","title":"Tasmota is sending many status updates every 5 seconds"},{"location":"FAQ/#web-interface-asks-for-password","text":"You modified the Web Admin password ( Configure Other ) and now you cannot access the web interface. You have set up a password for the web interface. You can login with the username admin and the password you entered. However, if you don't remember that password there are a few options you can try to gain access to the web interface again. Reset the password using the WebPassword command. If you have serial connection to the device: Execute WebPassword 0 using a serial terminal interface. If you have configured MQTT: Send 0 to cmnd/<device-topic>/WebPassword . You can send it from any MQTT client . You can also use another Tasmota device using the Publish command - Execute Publish cmnd/<device-topic>/WebPassword 0 from that device's Console. If the options above are not available: Since Tasmota uses GET request for forms, the password may be in your browser history. Look there for entries with the name you configured for the device. For example, in the following link: http://<device-ip>/co?t1={\"NAME\":\"Generic\"'\"GPIO\":[23'22'24'17'134'132'0'0'131'52'21'0'0]'\"FLAG\":0'\"BASE\":67}&p1=SecretPassword&b1=on&a1=Sonoff&a2=Sonoff2&a3=Sonoff3&a4=Sonoff4&b2=0&save= the p1 parameter contains the password for the web interface ( SecretPassword in this case). Note: special characters may appear as the characters' corresponding ASCII hexadecimal codes (e.g., \"{\" = '\\%7B', etc.) If you had set up WifiConfig 7 as your Wi-Fi fallback method (by previously executing WiFiConfig in the Console), you can reset the device by booting it into Wi-Fi Manager mode. If the SSID configured in the device is not available (e.g., turn off the router), the device will fallback to that restricted Wi-Fi Manager Mode. If your device has a physical push-button, reset the firmware to the default settings as detailed here . If nothing helps, then you have to flash the firmware again using the serial interface. Be sure to erase the flash memory before uploading the binary.","title":"Web Interface Asks for Password"},{"location":"FAQ/#power-monitoring-shows-wrong-values","text":"If the values shown in the Web UI don't seem right and you're using a Supported Module you need to calibrate the power monitoring sensor . In case you're using a template you created yourself or found in our Templates Repository try the calibration method first. If the values are still wrong or unrealistic the power monitoring sensors' GPIOs are not configured correctly and you will need to find the correct GPIO assignments before proceeding.","title":"Power monitoring shows wrong values"},{"location":"FAQ/#sensors-do-not-show-values","text":"Make sure your sensor is properly wired and the GPIOs assigned. Your vanilla tasmota.bin doesn't have complete sensor support. Make sure you've installed tasmota-sensors.bin that support the largest number of sensors. Some sensors require enabling in the code and compiling your own binary. See Firmware-Builds for a comprehensive list of supported components.","title":"Sensors do not show values"},{"location":"FAQ/#timers-trigger-at-the-wrong-time","text":"Tasmota devices must have a their time of day set properly in order for any timers to work properly. Check the log in the web UI Console to see if the device's time is set correctly. There are two elements to setting the time: 1. obtaining the UTC time, and, 2. local Daylight Saving Time policies. There are three methods available to set the device time: 1. NTP , 2. An RTC peripheral , or 3. the Time command. The typical method Tasmota uses to set its time is to obtain the time from an Internet NTP server. It can also query an NTP server on its local network (e.g., a network router with an NTP service, a Raspberry Pi running the NTP daemon, the Chrony add-on in Home Assistant, etc.). The time sync request is forced to NTPSERVER1 . If can't connect, it tries NTPSERVER2 . And finally NTPSERVER3 . Ensure that these parameters are set appropriately and that the device can reach at least one of these time servers. You may want to consider setting up an NTP server locally. As long as the computer is able to set its time at some point from an Internet time server, this computer can serve as an NTP server for your Tasmota device(s). This can be the same computer that hosts your MQTT broker or home automation hub. You must also set the TimeZone and Daylight Saving Time policies ( TimeDST / TimeSTD ). If you have timers that use the sunset or sunrise times, you must set your latitude and longitude in order for these times to be calculated correctly for your location.","title":"Timers trigger at the wrong time"},{"location":"FAQ/#auto-discovery-in-home-assistant-does-not-work","text":"The tasmota-lite.bin firmware binary (which comes packaged with Tuya-Convert) does not support auto-discovery. Please upgrade to tasmota.bin or a similar firmware variant that supports this feature. Make sure its enabled in Tasmota it with SetOption19 1 and you configured the Home Assistant MQTT integration with Discovery enabled.","title":"Auto-discovery in Home Assistant does not work"},{"location":"FAQ/#why-is-my-changed-configuration-not-loaded","text":"If you have flashed a precompiled binary, be aware that all the configuration made after the flash (Wi-Fi, MQTT, topics, names, rules, etc) will be lost in a factory firmware reset. In short : The CFG_HOLDER is the place where the config is stored on your device. The device checks if a config is saved in this CFG_HOLDER (value from the my_user_config.h) and always loads this if exists. => won't load new applied configs in your my_user_config.h To get the new config on your device, you need to change the CFG_HOLDER. BUT: You should always try to stay on the default CFG_HOLDER, to reach this, you need to flash two times change your config in the my_user_config.h or better user_config_override.h change the CFG_HOLDER number. +1 or -1 is enough (e.g. 0x20161208) flash change the CFG_HOLDER back to default ( 0x20161209 ) flash again After this, your new config is saved in the default CFG_HOLDER on your device. This is necessary to avoid losing your config if you update to a new firmware by using the pre-build images or if you forget to change the CFG_HOLDER to your custom one if you build the firmware yourself. How CFG_HOLDER works : The config of your Tasmota is stored in an area of the flash memory (flash config area or FCA ). Using a new device (where Tasmota firmware runs the first time) the FCA does not contain a Tasmota configuration so on the very first start of Tasmota it uses your settings from my_user_config.h or user_config_override.h and copy this into the FCA. To prevent the following Tasmota starts from overwriting your FCA settings again (e.g. because you changed some things using commands), the FCA will be marked by a header value indicating not to copy the values from my_user_config.h / user_config_override.h again. This header becomes the value from CFG_HOLDER. On every start the device compares the header of FCA with the CFG_HOLDER from your source code and only if this header value is not identical, Tasmotat will copy the data from my_user_config.h/user_config_override.h to flash settings area - this is normally only the case on a fresh device or if you has changed the CFG_HOLDER value. Summary : To force Tasmota to overwrite current (valid or invalid) settings in FCA with your settings from my_user_config.h / user_config_override.h you can change CFG_HOLDER value once, compile, reflash device (as described above). To avoid overwriting settings by new versions don't forget either repeat the step above using original CFG_HOLDER value or never forget to change CFG_HOLDER value for even all upcoming version to your value or use the command Reset 1 or Reset 2 after changes in your my_user_config.h / user_config_override.h without the need to double reflash your device and/or double change your CFG_HOLDER value: change values in my_user_config.h / user_config_override.h leave CFG_HOLDER as is start your device and issue command Reset 1 or Reset 2","title":"Why is my changed configuration not loaded?"},{"location":"FAQ/#how-do-i-invert-the-output-of-the-green-led-on-the-sonoff-basic-so-the-led-is-on-when-the-relay-is-off","text":"LedState default value is 1 (on) - Show power state on LED. The LED can be disabled completely with LedState 0 (off). However, there is no option to invert the output of the green LED on the Sonoff Basic.","title":"How do I invert the output of the green LED on the Sonoff Basic so the LED is on when the relay is off?"},{"location":"FAQ/#flashing","text":"","title":"Flashing"},{"location":"FAQ/#cannot-enter-flash-mode","text":"Be sure to press the button correctly, you must \"feel\" a click. If your on-device button doesn't allow you to enter flash mode or there is no GPIO0 broken out to the PCB, you can always bridge GND to GPIO0 pin directly on the chip. Search on the Internet for your chip's pinouts and use the tutorial . Be sure to keep GPIO0 grounded long enough (3-5 seconds) before disconnecting to ensure the chip has booted completely into programming mode. On devices that do not provide a GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems for flashing the device. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally.","title":"Cannot enter flash mode"},{"location":"FAQ/#flashing-issues","text":"Double check if you wired the device the serial-to-USB adapter correctly. Almost every device needs RX and TX pins switched to TX and RX. See Hardware Preparation for more. Another common problem are the jumper cables used. Try another cable if you keep getting connection errors or check the cables for connectivity. Most of them are made cheaply and it happens quite often that those cables do not offer a good connection because of bad crimping or broken copper lines in them. Be sure to use a USB Data Cable and not a cheap loading cable for mobile phones for connecting the serial-to-USB adapter to your computer. If you are unsure, just try another USB cable. Data USB cables are often thicker than the normal loading cables (and more expensive). Another problem can be the difficulties in getting the ESP chip into programming mode when it boots. If the flash still fails or the progress interrupts, it could be that your computer or serial-to-USB adapter doesn't provide enough power to the device. Try another computer or use an external power supply (3.3V one). More infos about insufficient power Use the correct serial-to-USB adapter driver. Check the model of your adapter chip and get the correct driver. If the flash completes successfully, but you get a hash mismatch (esptool.py error message A fatal error occurred: MD5 of file does not match data in flash! ) ensure that your 3.3v current is sufficient. Workarounds include using a dedicated bread board power supply or using the 3.3v output of an additional microcontroller. If using an additional power supply to power the device, be sure to use a common ground for the power supply, the device to be flashed and the serial-to-USB adapter. If esptool.py stops at \"Uploading stub...\", use --no-stub If the flash fails or the device does not operate as expected, try using the default ESP82xx boot ROM baud rate - 74880 . This is the baud rate the ESP82xx is set to by default when it boots into programming mode. It can be specified as a command line option in esptool.py ( -b ) and esptool.exe ( -cb ). You may also want to select a serial monitor/terminal capable of setting this \"unusual\" baud rate. In Termite, type this value ( 74880 ) in the baud rate selection text box when configuring the port. Having the option to specify this unusual baud rate will allow you to view the ESP8266 boot ROM log while the device is booting.","title":"Flashing issues"},{"location":"FAQ/#device-is-hot-to-the-touch","text":"Remember - NEVER EVER FLASH WITH 5V! ? Better unpower your device and check if the wiring is correct and the voltage is on your FTDI is set to 3.3V. If you've connected VCC to the wrong pin it might cause your device to overheat and destroy it.","title":"Device is hot to the touch"},{"location":"FAQ/#there-was-white-smoke-and-the-device-does-not-work-anymore","text":"Yes, you've released the fabled \"white smoke\", the mysterious substance all electronic devices work on. In the immortal words of Doctor Bones: It's dead Jim!","title":"There was white smoke and the device does not work anymore!"},{"location":"FAQ/#sonoff-4ch-v2-sonoff-dual-v2-will-not-flash","text":"Testing with two different (fairly new) FTDI boards and two Sonoff 4CH v2.0 and the Sonoff Dual v2.0 boards I found that I was getting errors uploading sketches i.e. \"warning: espcomm_sync failed\" basically a lack of communication between the two devices. I found that the problem in both Sonoff's was that instead of the FTDI Sonoff cross-over TX->RX and RX->TX I had to do TX->TX RX->RX this then allowed me to upload the sketch.","title":"Sonoff 4CH V2 / Sonoff Dual V2 will not flash"},{"location":"FAQ/#flashing-fails-on-macos-high-sierra","text":"Related to issue #957 . Solution: Install the VCP drivers for Mac from the FTDI website After install, reboot (it does not work if you do not reboot). After reboot, plug the FTDI USB/serial converter. Accept the security alert from MacOS. Restart the flash process. It works!","title":"Flashing fails on MacOS High Sierra"},{"location":"FAQ/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"FAQ/#can-you-add-this-unsupported-sensor-to-tasmota","text":"Short answer: NO! Long answer: There is not enough time in our coders lives to take requests, if you can code a driver for that sensor and submit a PR it will be considered, otherwise you can only wait for someone else to do it.","title":"Can you add this unsupported sensor to Tasmota"},{"location":"FAQ/#available-characters-for-hostname","text":"24 chars max only a..z A..Z 0..9 '-' no '-' as last char Notice: Hostnames containing % will reset to MQTT_TOPIC-<4digits> . It is not intended to use internal Tasmota variables here. RFC952 ASSUMPTIONS A \"name\" (Net, Host, Gateway, or Domain name) is a text string up to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus sign (-), and period (.). Note that periods are only allowed when they serve to delimit components of \"domain style names\". (See RFC-921, \"Domain Name System Implementation Schedule\", for background). No blank or space characters are permitted as part of a name. No distinction is made between upper and lower case. The first character must be an alpha character. The last character must not be a minus sign or period. A host which serves as a GATEWAY should have \"-GATEWAY\" or \"-GW\" as part of its name. Hosts which do not serve as Internet gateways should not use \"-GATEWAY\" and \"-GW\" as part of their names. A host which is a TAC should have \"-TAC\" as the last part of its host name, if it is a DoD host. Single character names or nicknames are not allowed.","title":"Available Characters for HOSTNAME"},{"location":"FAQ/#flash-memory-considerations","text":"To stop saving parameter changes to Flash or Spiffs use command SaveData off . To stop saving power changes only to Flash or Spiffs use command SetOption0 off . This will disable the relay from returning to the same state after power on UNLESS you use the MQTT retain flag in which case the MQTT broker will send the last known MQTT state on restart or power on. The command ButtonRetain on will configure the button to send a MQTT command with Topic and the MQTT retain flag set.","title":"Flash Memory Considerations"},{"location":"FAQ/#what-is-an-arduino-core","text":"Arduino Core (open source) are the core libraries for ESP8266/ESP8285 chips to make them Arduino Framework Compatible. This Core is programmed on top of the Espressif SDK (closed source). Tasmota is only using the core and does not maintain it or can help in solving issues with it. You can see the Arduino Core Version and the Espressif SDK Version on the Tasmota WebUI under the Information Menu entry.","title":"What is an Arduino Core"},{"location":"FAQ/#i-cannot-find-an-answer-here","text":"Check the Troubleshooting section or join Discord , Telegram , Reddit or Google Groups for assistance from other Tasmota users.","title":"I Cannot Find An Answer Here!"},{"location":"Features/","text":"Tasmota contains myriad features and supported peripherals (sensors, controllers and similar). Due to the flash size and memory constraints of ESP not all features can be included in precompiled release binaries. To enable some of the features you have to compile your own binary. Features with such requirement have a warning with instructions on how to enable them.","title":"Introduction"},{"location":"Firmware-Builds/","text":"There are many available features programmed into Tasmota. Not all devices need all of the available features. ESP based devices have a limited amount of memory available. To ensure that there is enough memory available to flash the firmware, it is best to keep the total size as small as possible, and definitely under 625K total to ensure OTA updates are possible. For this reason, Tasmota makes available the ability to create different firmware binary files to suit each particular device's requirements (e.g., sensors) and each application's needs (e.g., Rules, Timers, etc.). Once features such as support for sensors, rules, timers, etc. is compiled into the firmware binary, the features themselves can be configured at run-time, or, for some features, configured at compile time as well. Many times one just needs to download a pre-compiled binary and perform the necessary run-time configuration. It is not necessary to compile your own binary if these pre-compiled builds meet your needs. These available files provide a simpler approach to get up and going with Tasmota quickly. Release binaries are from the official OTA server . Firmware built from development branch code is available from the development OTA server . Features that are not available in any official release build have to be enabled in source code and compiled yourself. Read more about compiling your own build . Tip You might find some of the features you need included in one of our unofficial experimental builds over at https://github.com/tasmota/install . Firmware Variants ~ tasmota.bin supports most features. THIS IS THE RECOMMENDED BINARY tasmota-BG.bin to tasmota-TW.bin the same features as tasmota.bin with localized language support. (Note: tasmota-UK.bin is for the Ukrainian language) tasmota-sensors.bin enables many features as tasmota.bin - not all - and includes support for connectable sensors tasmota-lite.bin has a stripped down feature set. This reduces the required CPU cycles in order to reduce power draw to allow devices with a weak power supply to run reliably. Note This is similar to the pre-compiled Tasmota binary that comes bundled with Tuya-Convert. If you used Tuya-Convert to flash your device, it is strongly recommended to update to tasmota.bin . Otherwise some crucial features (e.g., energy monitoring, auto-discovery, etc.) will not work. tasmota-minimal.bin is a specialised build to subsequently allow OTA uploads. This version should NOT be used for initial installation! tasmota-knx.bin includes KNX support but omits some features. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-display.bin built for connecting displays but omits some features such as energy monitoring. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-ir.bin provides almost all IRremoteESP8266 protocols. If you need additional features, compile your own firmware (e.g., Gitpod ) to compile ircustom . tasmota-zbbridge.bin built specifically for Sonoff Zigbee Bridge device. Available Features and Sensors for Each Build ~","title":"Firmware Builds"},{"location":"Firmware-Builds/#firmware-variants","text":"tasmota.bin supports most features. THIS IS THE RECOMMENDED BINARY tasmota-BG.bin to tasmota-TW.bin the same features as tasmota.bin with localized language support. (Note: tasmota-UK.bin is for the Ukrainian language) tasmota-sensors.bin enables many features as tasmota.bin - not all - and includes support for connectable sensors tasmota-lite.bin has a stripped down feature set. This reduces the required CPU cycles in order to reduce power draw to allow devices with a weak power supply to run reliably. Note This is similar to the pre-compiled Tasmota binary that comes bundled with Tuya-Convert. If you used Tuya-Convert to flash your device, it is strongly recommended to update to tasmota.bin . Otherwise some crucial features (e.g., energy monitoring, auto-discovery, etc.) will not work. tasmota-minimal.bin is a specialised build to subsequently allow OTA uploads. This version should NOT be used for initial installation! tasmota-knx.bin includes KNX support but omits some features. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-display.bin built for connecting displays but omits some features such as energy monitoring. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-ir.bin provides almost all IRremoteESP8266 protocols. If you need additional features, compile your own firmware (e.g., Gitpod ) to compile ircustom . tasmota-zbbridge.bin built specifically for Sonoff Zigbee Bridge device.","title":"Firmware Variants"},{"location":"Firmware-Builds/#available-features-and-sensors-for-each-build","text":"","title":"Available Features and Sensors for Each Build"},{"location":"Flash-Sonoff-using-Raspberry-Pi/","text":"If you don't have a USB-to-TTL serial adapter available, but you have a Raspberry Pi, you can use this procedure for flashing your device. Tutorial (a little outdated) Summarizing the process and needed connections based on the above blog, please refer there for a more detailed explanation Preparation of the Raspberry Pi ~ Install esptool (pip needed) sudo pip install esptool Prepare serial connection. Note: Use the correct serial connection as per your version of the Raspberry Pi. Device Serial Connection RaspberryPi 1/2/3 (BT disabled or miniuart) /dev/ttyAMA0 RaspberryPi 3 /dev/ttyS0 sudo systemctl stop serial-getty@ttyS0.service sudo systemctl disable serial-getty@ttyS0.service sudo cp /boot/cmdline.txt /boot/cmdline.bak (This backups the file ;)) sudo nano /boot/cmdline.txt -> delete \"console=serial0,115200\" option I don\u2019t know if this is necessary, but I did it as it was mentioned here: https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/ sudo nano /boot/config.txt -> add the line (at the bottom): enable_uart=1 Please note following overlays setting port to /dev/ttyAMA0 pi3-miniuart-bt pi3-disable-bt Reboot your Pi Connections ~ Connect GND, RX->TX and TX->RX as shown below. If you power the device with the 3.3V power from the RPi it will cause it to reboot when connecting. You can still enter flash mode if you power up the RPi with the 3.3v connected and pressing the connecting GPIO0 to ground (e.g., pressing the button on the Sonoff Basic) simultaneously. It's recommended to use either an external power supply for this or use the 5V GPIO and a 3.3V Voltage Regulator. ( issue #4807 ) Do not connect 3.3V yet! https://www.sigmdel.ca/michel/ha/sonoff/flashing_sonoff_en.html (For RaspberryPi 3 (40 GPIO pins) GND is the last pin on the left, the 39th pin.) This is how it looks in real-life \ud83d\ude06 Flashing the firmware ~ Erase flash memory: Connect 3.3V while button pressed for about 10 seconds to enter flash-mode. Then release and run: # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 erase_flash # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 erase_flash You should see output like this: \u279c ~ esptool.py --port /dev/ttyAMA0 erase_flash esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22:ab:5e:dc Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 3 .3s Hard resetting via RTS pin... \u279c ~ Flash .bin, which you can download from the release server : Again connect 3.3V while pressing button for 10 seconds. Then release and run: # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin You should see output like this: \u279c ~ esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 tasmota.bin esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting..... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22:ab:5e:dc Uploading stub... Running stub... Stub running... Configuring flash size... Auto-detected Flash size: 1MB Compressed 456000 bytes to 312426 ... Wrote 456000 bytes ( 312426 compressed ) at 0x00000000 in 29 .2 seconds ( effective 124 .8 kbit/s ) ... Hash of data verified. Leaving... Hard resetting via RTS pin... \u279c ~ Setup Wi-Fi: Connect with an external device to the sonoff-xxxx Wi-Fi AP and configure over the browser. Alternative: Reboot your device after flashing (toggle power wire) and connect to the serial console via miniterm: # if using Raspberry Pi 1/2 use # miniterm.py /dev/ttyAMA0 115200 -e # if using Raspberry Pi 3 use miniterm.py /dev/ttyS0 115200 -e You will see some output, after pressing enter. Now just type in, your SSID, press enter and then type the password\u2026 Backlog ssid yourSSID; password yourPassword That\u2019s it ~ Sources: Flashing commands https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/","title":"Flash Sonoff using Raspberry Pi"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#preparation-of-the-raspberry-pi","text":"Install esptool (pip needed) sudo pip install esptool Prepare serial connection. Note: Use the correct serial connection as per your version of the Raspberry Pi. Device Serial Connection RaspberryPi 1/2/3 (BT disabled or miniuart) /dev/ttyAMA0 RaspberryPi 3 /dev/ttyS0 sudo systemctl stop serial-getty@ttyS0.service sudo systemctl disable serial-getty@ttyS0.service sudo cp /boot/cmdline.txt /boot/cmdline.bak (This backups the file ;)) sudo nano /boot/cmdline.txt -> delete \"console=serial0,115200\" option I don\u2019t know if this is necessary, but I did it as it was mentioned here: https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/ sudo nano /boot/config.txt -> add the line (at the bottom): enable_uart=1 Please note following overlays setting port to /dev/ttyAMA0 pi3-miniuart-bt pi3-disable-bt Reboot your Pi","title":"Preparation of the Raspberry Pi"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#connections","text":"Connect GND, RX->TX and TX->RX as shown below. If you power the device with the 3.3V power from the RPi it will cause it to reboot when connecting. You can still enter flash mode if you power up the RPi with the 3.3v connected and pressing the connecting GPIO0 to ground (e.g., pressing the button on the Sonoff Basic) simultaneously. It's recommended to use either an external power supply for this or use the 5V GPIO and a 3.3V Voltage Regulator. ( issue #4807 ) Do not connect 3.3V yet! https://www.sigmdel.ca/michel/ha/sonoff/flashing_sonoff_en.html (For RaspberryPi 3 (40 GPIO pins) GND is the last pin on the left, the 39th pin.) This is how it looks in real-life \ud83d\ude06","title":"Connections"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#flashing-the-firmware","text":"Erase flash memory: Connect 3.3V while button pressed for about 10 seconds to enter flash-mode. Then release and run: # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 erase_flash # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 erase_flash You should see output like this: \u279c ~ esptool.py --port /dev/ttyAMA0 erase_flash esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22:ab:5e:dc Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 3 .3s Hard resetting via RTS pin... \u279c ~ Flash .bin, which you can download from the release server : Again connect 3.3V while pressing button for 10 seconds. Then release and run: # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin You should see output like this: \u279c ~ esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 tasmota.bin esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting..... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22:ab:5e:dc Uploading stub... Running stub... Stub running... Configuring flash size... Auto-detected Flash size: 1MB Compressed 456000 bytes to 312426 ... Wrote 456000 bytes ( 312426 compressed ) at 0x00000000 in 29 .2 seconds ( effective 124 .8 kbit/s ) ... Hash of data verified. Leaving... Hard resetting via RTS pin... \u279c ~ Setup Wi-Fi: Connect with an external device to the sonoff-xxxx Wi-Fi AP and configure over the browser. Alternative: Reboot your device after flashing (toggle power wire) and connect to the serial console via miniterm: # if using Raspberry Pi 1/2 use # miniterm.py /dev/ttyAMA0 115200 -e # if using Raspberry Pi 3 use miniterm.py /dev/ttyS0 115200 -e You will see some output, after pressing enter. Now just type in, your SSID, press enter and then type the password\u2026 Backlog ssid yourSSID; password yourPassword","title":"Flashing the firmware"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#thats-it","text":"Sources: Flashing commands https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/","title":"That\u2019s it"},{"location":"For-Developers/","text":"Information for tool developers: ~ API Sensor API JSON Status Responses Berry Scripting Language Tasmota forks with added features ~ Time Proportioned Output Fork","title":"For Developers"},{"location":"For-Developers/#information-for-tool-developers","text":"API Sensor API JSON Status Responses Berry Scripting Language","title":"Information for tool developers:"},{"location":"For-Developers/#tasmota-forks-with-added-features","text":"Time Proportioned Output Fork","title":"Tasmota forks with added features"},{"location":"GPIO-Conversion/","text":"GPIO functions define the action being taken by a device connected to it's pin. The current GPIO function configuration supports 216 GPIO functions like Relay1 (21) or Inverted Button1 (122). The current implementation supports up to 250 functions as it is confined to 8-bits uint8_t arrays. As more devices need to be connected it would become impossible to have them addressed with this 8-bit scheme. Another problem is that the current implementation would need GUI drop down boxes with up to 250 items which is hard to use. Also user templates still need to be able to address all possible GPIO functions. To solve this issue Theo needed to change from 8-bit uint8_t to 16-bit uint16_t arrays. Without further action this would result in even more entries in the GUI drop down boxes and made adding more relays, buttons, switches, etc also very cumbersome. As the ESP32 would need to be supported too a challenge lay ahead. Theo decided for the following option where every GPIO function type (relays, buttons, switches) would have an id allowing for 32 devices. So every GPIO function would be offset by 32 (or 5-bits). These 5-bits can be used in the future to easily expand current max values like 4 buttons or 8 relays to max 32. How this works could have been seen in the ESP32 implementation. The GUI now contains two drop down boxes, one for the GPIO function (Relay) and one for the function index (1 to 8). For the ESP8266 the current maxed GPIO functions of 216 will be fixed an any new device will be using the GPIO addressing scheme. To make the transition transparent, a table is used to convert current 216 GPIO 8-bit function numbers to new 16-bit function numbers. As both are offset from 0 there will be some duplication in numbering so the only way to distinguish them by external programs like TDM is by checking the Tasmota version number: below 9.0 will be 8-bit GPIO and starting with development version 9.0.0.1 it will be 16-bit GPIO. See below how the numbers are being converted. The first number is 8-bit GPIO, the second the 16-bit GPIO. GPIO Conversion ~ Old GPIO New GPIO Name Description 255 1 User User 0 0 None Not used 1 1184 DHT11 DHT11 sensor 2 1216 AM2301 AM230X, DHT21 and DHT22 sensor 3 1248 SI7021 Only for Sonoff Si7021, not the i2c version 4 1312 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 608 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 640 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 1376 WS2812 Addressable LEDs such as WS281X or Neopixel 8 1056 IRsend IR Transmitter LED 9 160 Switch1 Switch 10 161 Switch2 Switch 11 162 Switch3 Switch 12 163 Switch4 Switch 13 164 Switch5 Switch 14 165 Switch6 Switch 15 166 Switch7 Switch 16 167 Switch8 Switch 17 32 Button1 Button 18 33 Button2 Button 19 34 Button3 Button 20 35 Button4 Button 21 224 Relay1 Relay 22 225 Relay2 Relay 23 226 Relay3 Relay 24 227 Relay4 Relay 25 228 Relay5 Relay 26 229 Relay6 Relay 27 230 Relay7 Relay 28 231 Relay8 Relay 29 256 Relay1i Relay inverted 30 257 Relay2i Relay inverted 31 258 Relay3i Relay inverted 32 259 Relay4i Relay inverted 33 260 Relay5i Relay inverted 34 261 Relay6i Relay inverted 35 262 Relay7i Relay inverted 36 263 Relay8i Relay inverted 37 416 PWM1 Pulse Width Modulated Output 38 417 PWM2 Pulse Width Modulated Output 39 418 PWM3 Pulse Width Modulated Output 40 419 PWM4 Pulse Width Modulated Output 41 420 PWM5 Pulse Width Modulated Output 42 352 Counter1 Counter Input 43 353 Counter2 Counter Input 44 354 Counter3 Counter Input 45 355 Counter4 Counter Input 46 448 PWM1i Pulse Width Modulated inverted Output 47 449 PWM2i Pulse Width Modulated inverted Output 48 450 PWM3i Pulse Width Modulated inverted Output 49 451 PWM4i Pulse Width Modulated inverted Output 50 452 PWM5i Pulse Width Modulated inverted Output 51 1088 IRrecv IR Receiver Input (for example TSOP1838) 52 288 Led1 LED 53 289 Led2 LED 54 290 Led3 LED 55 291 Led4 LED 56 320 Led1i Inverted LED - default state ON 57 321 Led2i Inverted LED - default state ON 58 322 Led3i Inverted LED - default state ON 59 323 Led4i Inverted LED - default state ON 60 1408 MHZ Rx MHZ 19 CO 2 Sensor 61 1440 MHZ Tx MHZ 19 CO 2 Sensor 62 1472 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 1504 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 1600 SAir Rx Sensor Senseair 65 1632 SAir Tx Sensor Senseair 66 768 SPI CS SPI Interface (ePaper Display) 67 800 SPI DC SPI Interface (ePaper Display) 68 992 BkLight Backlight (Display) 69 1696 PMS5003 PMS5003 Air Quality Sensor 70 1760 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 1792 SerBr Rx Serial Bridge Receive 72 1824 SerBr Tx Serial Bridge Transmit 73 1856 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 1888 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 1920 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 1952 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 1984 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 2016 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 2048 TM16 CLK TM1638 Switch Module 80 2080 TM16 DIO TM1638 Switch Module 81 2112 TM16 STB TM1638 Switch Module 82 192 Switch1n Switch, no pullup resistor 83 193 Switch2n Switch, no pullup resistor 84 194 Switch3n Switch, no pullup resistor 85 195 Switch4n Switch, no pullup resistor 86 196 Switch5n Switch, no pullup resistor 87 197 Switch6n Switch, no pullup resistor 88 198 Switch7n Switch, no pullup resistor 89 199 Switch8n Switch, no pullup resistor 90 64 Button1n Button, no pullup resistor 91 65 Button2n Button, no pullup resistor 92 66 Button3n Button, no pullup resistor 93 67 Button4n Button, no pullup resistor 94 384 Counter1n Counter sensor, no pullup resistor 95 385 Counter2n Counter sensor, no pullup resistor 96 386 Counter3n Counter sensor, no pullup resistor 97 387 Counter4n Counter sensor, no pullup resistor 98 1536 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 1568 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 2144 MP3 Player DF MP3 Player mini (Input) 101 1728 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 2176 HX711 SCK HX711 weight sensor serial clock input 103 2208 HX711 DAT HX711 weight sensor data output 104 2240 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 1120 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 1152 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 2272 Tuya Tx Tuya Transfer pin 108 2304 Tuya Rx Tuya Receive pin 109 2336 MGC3130 Xfr MGC3130 E-field Xfr pin 110 2368 MGC3130 Rst MGC3130 E-field Reset pin 111 832 SSPI MISO Software SPI MISO (Display) 112 864 SSPI MOSI Software SPI MOSI (Display) 113 896 SSPI SCLK Software SPI SCLK (Display) 114 928 SSPI CS Software SPI CS (Display) 115 960 SSPI DC Software SPI DC (Display) 116 2400 RF Sensor Theo Arendst RF433 Sensor 117 2432 AZ Rx AZ 7798 CO 2 datalogger 118 2464 AZ Tx AZ 7798 CO 2 datalogger 119 2496 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 2528 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 2560 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 96 Button1i Button inverted 123 97 Button2i Button inverted 124 98 Button3i Button inverted 125 99 Button4i Button inverted 126 128 Button1in Button inverted, no pullup resistor 127 129 Button2in Button inverted, no pullup resistor 128 130 Button3in Button inverted, no pullup resistor 129 131 Button4in Button inverted, no pullup resistor 130 2592 HLWBL SEL Energy Monitoring (for example Pow) 131 2624 HLWBL SELi Energy Monitoring (for example Pow) 132 2656 HLWBL CF1 Energy Monitoring (for example Pow) 133 2688 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 2720 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 2752 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 2784 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 2816 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 2848 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 2880 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 2912 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 2944 SM16716 DAT SM16716 Pixel LED Data pin 142 2976 SM16716 PWR SM16716 Pixel LED Power pin 143 3008 MY92x1 DI Light Bulb with MY92x controller 144 3040 MY92x1 DCKI Light Bulb with MY92x controller 145 3072 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 3104 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 3136 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 3200 Serial Tx Serial Transfer pin 149 3232 Serial Rx Serial Receive pin 150 3264 Rotary1a Rotary Encoder (Mi Desk Lamp) 151 3296 Rotary1b Rotary Encoder (Mi Desk Lamp) 152 3265 Rotary2a Rotary Encoder (Mi Desk Lamp) 153 3297 Rotary2b Rotary Encoder (Mi Desk Lamp) 154 3392 HRE CLOCK Clock/Power line for HR-E Water Meter 155 3424 HRE DATA Data line for HR-E Water Meter 156 3456 ADE7953_IRQ ADE7953 IRQ 157 544 LedLink Device Status LED 158 576 LedLinki Device Status LED, inverted 159 3168 ALux IrSel For AriLux devices - switches between IR/RF mode 160 480 Buzzer Sonoff iFan03 Buzzer 161 512 Buzzeri Sonoff iFan03 Buzzer inverted 162 1024 OLED Reset OLED Display Reset 163 3488 SolaxX1 Tx Solax Inverter Tx pin 164 3520 SolaxX1 Rx Solax Inverter Rx pin 165 3552 Zigbee Tx Zigbee Serial interface Tx 166 3584 Zigbee Rx Zigbee Serial interface Rx 167 3616 RDM6300 Rx RDM6300 RX 168 3648 iBeacon Tx HM17 iBeacon Tx 169 3680 iBeacon Rx HM17 iBeacon Rx 170 3712 A4988 DIR A4988 Motor Direction 171 3744 A4988 STP A4988 Step motor 172 3776 A4988 ENA A4988 Enable motor 173 3808 A4988 MS1 A4988 Microstep increment select pin1 174 3809 A4988 MS2 A4988 Microstep increment select pin2 175 3810 A4988 MS3 A4988 Microstep increment select pin3 176 3904 DDS238-2 Tx DDS2382 Serial interface Tx 177 3936 DDS238-2 Rx DDS2382 Serial interface Rx 178 3968 DDSU666 Tx DDSU666 Serial interface Tx 179 4000 DDSU666 Rx DDSU666 Serial interface Rx 180 4032 SM2135 CLK SM2135 Clk 181 4064 SM2135 DAT SM2135 Dat 182 4096 DeepSleep DeepSleep wake switch 183 4128 EXS Enable EXS Dimmer MCU Enable 184 4160 Slave TX TasmotaClient TX 185 4192 Slave RX TasmotaClient RX 186 4224 Slave RST TasmotaClient Reset Pin 187 4256 Slave RSTi TasmotaClient Reset Inverted 188 4288 HPMA RX Honeywell HPMA115S0 Serial Rx 189 4320 HPMA TX Honeywell HPMA115S0 Serial Tx 190 4352 GPS RX GPS Serial Tx 191 4384 GPS TX GPS Serial Tx 192 1344 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 1280 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 4416 HM10 RX HM10-BLE-Mijia-bridge Serial 195 4448 HM10 TX HM10-BLE-Mijia-bridge Serial 196 4480 LE01MR RX F&F LE-01MR Energy Meter Serial 197 4512 LE01MR TX F&F LE-01MR Energy Meter Serial 198 4544 CC1101 GDO0 CC1101 RX Pin 199 4576 CC1101 GDO2 CC1101 TX Pin 200 4608 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 4640 MOODL TX ElectriQ iQ-wifiMOODL Serial TX 202 4672 AS3935 Lightning Detector Interrupt Pin 203 1664 PMS5003 TX Plantower PMS5003 Serial interface 204 4928 Boiler OT Rx OpenTherm Boiler RX pin 205 4960 Boiler OT Tx OpenTherm Boiler TX pin 206 4992 Windmeter Speed WindMeter speed counter pin 207 5056 BL0940 RX BL0940 serial interface 208 5088 TCP TX TCP Serial bridge 209 5120 TCP RX TCP Serial bridge 210 5152 TELEINFO RX Teleinfo serial interface 211 5184 TELEINFO Enable Teleinfo Enable PIN 212 5216 LMT01 LMT01 input counting pin 213 5248 IEM3000 TX IEM3000 Serial interface 214 5280 IEM3000 RX IEM3000 Serial interface 215 5312 Zigbee RST Zigbee reset 216 5344 DYP Rx DYP-ME007 Rx pin ADC Conversion ~ Old ADC New ADC Option WebUI display MQTT mesage 0 0 None none none 1 4704 Analog Analog0 %value% {\"A0\":%value%} 2 4736 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 4768 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 4800 Button none none 5 4832 Buttoni none none 6 4864 Range Range %value% {\"Range\":%value%} 7 4896 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\": %value ,\"Power\": %value ,\"Voltage\":230,\"Current\": %value } 8 3328 Joystick none {\"ANALOG\":{\"Joy1\":%value%}","title":"GPIO Conversion"},{"location":"GPIO-Conversion/#gpio-conversion","text":"Old GPIO New GPIO Name Description 255 1 User User 0 0 None Not used 1 1184 DHT11 DHT11 sensor 2 1216 AM2301 AM230X, DHT21 and DHT22 sensor 3 1248 SI7021 Only for Sonoff Si7021, not the i2c version 4 1312 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 608 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 640 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 1376 WS2812 Addressable LEDs such as WS281X or Neopixel 8 1056 IRsend IR Transmitter LED 9 160 Switch1 Switch 10 161 Switch2 Switch 11 162 Switch3 Switch 12 163 Switch4 Switch 13 164 Switch5 Switch 14 165 Switch6 Switch 15 166 Switch7 Switch 16 167 Switch8 Switch 17 32 Button1 Button 18 33 Button2 Button 19 34 Button3 Button 20 35 Button4 Button 21 224 Relay1 Relay 22 225 Relay2 Relay 23 226 Relay3 Relay 24 227 Relay4 Relay 25 228 Relay5 Relay 26 229 Relay6 Relay 27 230 Relay7 Relay 28 231 Relay8 Relay 29 256 Relay1i Relay inverted 30 257 Relay2i Relay inverted 31 258 Relay3i Relay inverted 32 259 Relay4i Relay inverted 33 260 Relay5i Relay inverted 34 261 Relay6i Relay inverted 35 262 Relay7i Relay inverted 36 263 Relay8i Relay inverted 37 416 PWM1 Pulse Width Modulated Output 38 417 PWM2 Pulse Width Modulated Output 39 418 PWM3 Pulse Width Modulated Output 40 419 PWM4 Pulse Width Modulated Output 41 420 PWM5 Pulse Width Modulated Output 42 352 Counter1 Counter Input 43 353 Counter2 Counter Input 44 354 Counter3 Counter Input 45 355 Counter4 Counter Input 46 448 PWM1i Pulse Width Modulated inverted Output 47 449 PWM2i Pulse Width Modulated inverted Output 48 450 PWM3i Pulse Width Modulated inverted Output 49 451 PWM4i Pulse Width Modulated inverted Output 50 452 PWM5i Pulse Width Modulated inverted Output 51 1088 IRrecv IR Receiver Input (for example TSOP1838) 52 288 Led1 LED 53 289 Led2 LED 54 290 Led3 LED 55 291 Led4 LED 56 320 Led1i Inverted LED - default state ON 57 321 Led2i Inverted LED - default state ON 58 322 Led3i Inverted LED - default state ON 59 323 Led4i Inverted LED - default state ON 60 1408 MHZ Rx MHZ 19 CO 2 Sensor 61 1440 MHZ Tx MHZ 19 CO 2 Sensor 62 1472 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 1504 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 1600 SAir Rx Sensor Senseair 65 1632 SAir Tx Sensor Senseair 66 768 SPI CS SPI Interface (ePaper Display) 67 800 SPI DC SPI Interface (ePaper Display) 68 992 BkLight Backlight (Display) 69 1696 PMS5003 PMS5003 Air Quality Sensor 70 1760 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 1792 SerBr Rx Serial Bridge Receive 72 1824 SerBr Tx Serial Bridge Transmit 73 1856 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 1888 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 1920 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 1952 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 1984 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 2016 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 2048 TM16 CLK TM1638 Switch Module 80 2080 TM16 DIO TM1638 Switch Module 81 2112 TM16 STB TM1638 Switch Module 82 192 Switch1n Switch, no pullup resistor 83 193 Switch2n Switch, no pullup resistor 84 194 Switch3n Switch, no pullup resistor 85 195 Switch4n Switch, no pullup resistor 86 196 Switch5n Switch, no pullup resistor 87 197 Switch6n Switch, no pullup resistor 88 198 Switch7n Switch, no pullup resistor 89 199 Switch8n Switch, no pullup resistor 90 64 Button1n Button, no pullup resistor 91 65 Button2n Button, no pullup resistor 92 66 Button3n Button, no pullup resistor 93 67 Button4n Button, no pullup resistor 94 384 Counter1n Counter sensor, no pullup resistor 95 385 Counter2n Counter sensor, no pullup resistor 96 386 Counter3n Counter sensor, no pullup resistor 97 387 Counter4n Counter sensor, no pullup resistor 98 1536 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 1568 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 2144 MP3 Player DF MP3 Player mini (Input) 101 1728 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 2176 HX711 SCK HX711 weight sensor serial clock input 103 2208 HX711 DAT HX711 weight sensor data output 104 2240 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 1120 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 1152 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 2272 Tuya Tx Tuya Transfer pin 108 2304 Tuya Rx Tuya Receive pin 109 2336 MGC3130 Xfr MGC3130 E-field Xfr pin 110 2368 MGC3130 Rst MGC3130 E-field Reset pin 111 832 SSPI MISO Software SPI MISO (Display) 112 864 SSPI MOSI Software SPI MOSI (Display) 113 896 SSPI SCLK Software SPI SCLK (Display) 114 928 SSPI CS Software SPI CS (Display) 115 960 SSPI DC Software SPI DC (Display) 116 2400 RF Sensor Theo Arendst RF433 Sensor 117 2432 AZ Rx AZ 7798 CO 2 datalogger 118 2464 AZ Tx AZ 7798 CO 2 datalogger 119 2496 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 2528 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 2560 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 96 Button1i Button inverted 123 97 Button2i Button inverted 124 98 Button3i Button inverted 125 99 Button4i Button inverted 126 128 Button1in Button inverted, no pullup resistor 127 129 Button2in Button inverted, no pullup resistor 128 130 Button3in Button inverted, no pullup resistor 129 131 Button4in Button inverted, no pullup resistor 130 2592 HLWBL SEL Energy Monitoring (for example Pow) 131 2624 HLWBL SELi Energy Monitoring (for example Pow) 132 2656 HLWBL CF1 Energy Monitoring (for example Pow) 133 2688 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 2720 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 2752 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 2784 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 2816 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 2848 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 2880 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 2912 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 2944 SM16716 DAT SM16716 Pixel LED Data pin 142 2976 SM16716 PWR SM16716 Pixel LED Power pin 143 3008 MY92x1 DI Light Bulb with MY92x controller 144 3040 MY92x1 DCKI Light Bulb with MY92x controller 145 3072 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 3104 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 3136 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 3200 Serial Tx Serial Transfer pin 149 3232 Serial Rx Serial Receive pin 150 3264 Rotary1a Rotary Encoder (Mi Desk Lamp) 151 3296 Rotary1b Rotary Encoder (Mi Desk Lamp) 152 3265 Rotary2a Rotary Encoder (Mi Desk Lamp) 153 3297 Rotary2b Rotary Encoder (Mi Desk Lamp) 154 3392 HRE CLOCK Clock/Power line for HR-E Water Meter 155 3424 HRE DATA Data line for HR-E Water Meter 156 3456 ADE7953_IRQ ADE7953 IRQ 157 544 LedLink Device Status LED 158 576 LedLinki Device Status LED, inverted 159 3168 ALux IrSel For AriLux devices - switches between IR/RF mode 160 480 Buzzer Sonoff iFan03 Buzzer 161 512 Buzzeri Sonoff iFan03 Buzzer inverted 162 1024 OLED Reset OLED Display Reset 163 3488 SolaxX1 Tx Solax Inverter Tx pin 164 3520 SolaxX1 Rx Solax Inverter Rx pin 165 3552 Zigbee Tx Zigbee Serial interface Tx 166 3584 Zigbee Rx Zigbee Serial interface Rx 167 3616 RDM6300 Rx RDM6300 RX 168 3648 iBeacon Tx HM17 iBeacon Tx 169 3680 iBeacon Rx HM17 iBeacon Rx 170 3712 A4988 DIR A4988 Motor Direction 171 3744 A4988 STP A4988 Step motor 172 3776 A4988 ENA A4988 Enable motor 173 3808 A4988 MS1 A4988 Microstep increment select pin1 174 3809 A4988 MS2 A4988 Microstep increment select pin2 175 3810 A4988 MS3 A4988 Microstep increment select pin3 176 3904 DDS238-2 Tx DDS2382 Serial interface Tx 177 3936 DDS238-2 Rx DDS2382 Serial interface Rx 178 3968 DDSU666 Tx DDSU666 Serial interface Tx 179 4000 DDSU666 Rx DDSU666 Serial interface Rx 180 4032 SM2135 CLK SM2135 Clk 181 4064 SM2135 DAT SM2135 Dat 182 4096 DeepSleep DeepSleep wake switch 183 4128 EXS Enable EXS Dimmer MCU Enable 184 4160 Slave TX TasmotaClient TX 185 4192 Slave RX TasmotaClient RX 186 4224 Slave RST TasmotaClient Reset Pin 187 4256 Slave RSTi TasmotaClient Reset Inverted 188 4288 HPMA RX Honeywell HPMA115S0 Serial Rx 189 4320 HPMA TX Honeywell HPMA115S0 Serial Tx 190 4352 GPS RX GPS Serial Tx 191 4384 GPS TX GPS Serial Tx 192 1344 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 1280 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 4416 HM10 RX HM10-BLE-Mijia-bridge Serial 195 4448 HM10 TX HM10-BLE-Mijia-bridge Serial 196 4480 LE01MR RX F&F LE-01MR Energy Meter Serial 197 4512 LE01MR TX F&F LE-01MR Energy Meter Serial 198 4544 CC1101 GDO0 CC1101 RX Pin 199 4576 CC1101 GDO2 CC1101 TX Pin 200 4608 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 4640 MOODL TX ElectriQ iQ-wifiMOODL Serial TX 202 4672 AS3935 Lightning Detector Interrupt Pin 203 1664 PMS5003 TX Plantower PMS5003 Serial interface 204 4928 Boiler OT Rx OpenTherm Boiler RX pin 205 4960 Boiler OT Tx OpenTherm Boiler TX pin 206 4992 Windmeter Speed WindMeter speed counter pin 207 5056 BL0940 RX BL0940 serial interface 208 5088 TCP TX TCP Serial bridge 209 5120 TCP RX TCP Serial bridge 210 5152 TELEINFO RX Teleinfo serial interface 211 5184 TELEINFO Enable Teleinfo Enable PIN 212 5216 LMT01 LMT01 input counting pin 213 5248 IEM3000 TX IEM3000 Serial interface 214 5280 IEM3000 RX IEM3000 Serial interface 215 5312 Zigbee RST Zigbee reset 216 5344 DYP Rx DYP-ME007 Rx pin","title":"GPIO Conversion"},{"location":"GPIO-Conversion/#adc-conversion","text":"Old ADC New ADC Option WebUI display MQTT mesage 0 0 None none none 1 4704 Analog Analog0 %value% {\"A0\":%value%} 2 4736 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 4768 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 4800 Button none none 5 4832 Buttoni none none 6 4864 Range Range %value% {\"Range\":%value%} 7 4896 CT Power Voltage 230 V Current %value A Power %value W Energy Total %value kWh {\"Energy\": %value ,\"Power\": %value ,\"Voltage\":230,\"Current\": %value } 8 3328 Joystick none {\"ANALOG\":{\"Joy1\":%value%}","title":"ADC Conversion"},{"location":"GPS-NTP-server/","text":"GPS-based NTP-server (Serial) ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_GPS #define USE_GPS // Add support for GPS and NTP Server for becoming Stratus 1 Time Source (+3k1 code, +132 bytes RAM) #define USE_FLOG // Add support for GPS logging in OTA's Flash (Experimental) (+2k9 code, +8 bytes RAM) #endif The foremost reason for the inclusion of this driver was to have a network unrelated time source, but besides this location data is provided too. Only u-blox-devices are supported The UBX binary protocol was chosen, because it is very memory efficient and all the needed data can be read without further parsing. The genereric NMEA-standard is NOT supported! The driver is tested on a NEO-6m and a Beitian-220. Series 7 should work too. These modules are quite cheap, starting at about 3.50\u20ac for the NEO-6m. Features: ~ simplified NTP-Server sets system time automatically and Settings.latitude and Settings.longitude via command get position and time data can log postion data with timestamp to flash with a small memory footprint of only 12 Bytes per record (!!EXPERIMENTAL!!) constructs a GPX-file for download of this data Web-UI and console command interface Connecting the GPS-device to a Wemos D1 mini ~ Wemos D1 Mini GPS VCC +3.3V Vin GND GND TX Rx RX Tx Tasmota Settings ~ In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: GPX_TX 3. RX GPIO3 Serial In: GPX_RX No further installation steps needed. To get more debug information compile it with option \"DEBUG_TASMOTA_SENSOR\". The driver expects the device to be configured for 9600 baud, which is the default for most of these sensors. If necessary the configuration can be changed with the freely available \"u-center\"-software, which is windows-only but is reported to run quite well with WINE and can be confirmed to work with CrossOver on macOs Catalina. NTP-Server ~ Simply start the server with 'sensor60 9'. Flash-Log ~ This is highly experimental feature, which uses the OTA-partition to log position data. !! \u26a0\ufe0f FOR OBVIOUS REASONS THIS WILL SHORTEN THE LIFE OF THE FLASH MEMORY AND SHOULD BE USED WISELY \u26a0\ufe0f !! After the first recording, a download-link will appear in the web interface. By clicking on it, a GPX-file will be created on-the fly for download. All recorded data is lost after each OTA-update. Commands ~ Command Description sensor60 0 write to all available sectors, then restart and overwrite the older ones sensor60 1 write to all available sectors, then restart and overwrite the older ones sensor60 2 filter out horizontal drift noise sensor60 3 turn off noise filter sensor60 4 start recording, new data will be appended sensor60 5 start new recording, old data will lost sensor60 6 stop recording, download link will be visible in Web-UI sensor60 7 send mqtt on new postion TELE -> consider to set TELE to a very high value sensor60 8 only TELE message sensor60 9 start NTP-Server sensor60 10 deactivate NTP-Server sensor60 11 force update of Tasmota-system-UTC with every new GPS-time-message sensor60 12 do NOT update of Tasmota-system-UTC with every new GPS-time-message sensor60 13 set latitude and longitude in settings sensor60 14 open virtual serial port over TCP, usable for u-center tcp://ip-address:port (default port 1234) \u26a0\ufe0f misconfiguration via u-center can virtually brick the device \u26a0\ufe0f sensor60 15 pause virtual serial port over TCP (connection stays active in the background)","title":"GPS-based NTP-server (Serial)"},{"location":"GPS-NTP-server/#gps-based-ntp-server-serial","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_GPS #define USE_GPS // Add support for GPS and NTP Server for becoming Stratus 1 Time Source (+3k1 code, +132 bytes RAM) #define USE_FLOG // Add support for GPS logging in OTA's Flash (Experimental) (+2k9 code, +8 bytes RAM) #endif The foremost reason for the inclusion of this driver was to have a network unrelated time source, but besides this location data is provided too. Only u-blox-devices are supported The UBX binary protocol was chosen, because it is very memory efficient and all the needed data can be read without further parsing. The genereric NMEA-standard is NOT supported! The driver is tested on a NEO-6m and a Beitian-220. Series 7 should work too. These modules are quite cheap, starting at about 3.50\u20ac for the NEO-6m.","title":"GPS-based NTP-server (Serial)"},{"location":"GPS-NTP-server/#features","text":"simplified NTP-Server sets system time automatically and Settings.latitude and Settings.longitude via command get position and time data can log postion data with timestamp to flash with a small memory footprint of only 12 Bytes per record (!!EXPERIMENTAL!!) constructs a GPX-file for download of this data Web-UI and console command interface","title":"Features:"},{"location":"GPS-NTP-server/#connecting-the-gps-device-to-a-wemos-d1-mini","text":"Wemos D1 Mini GPS VCC +3.3V Vin GND GND TX Rx RX Tx","title":"Connecting the GPS-device to a Wemos D1 mini"},{"location":"GPS-NTP-server/#tasmota-settings","text":"In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: GPX_TX 3. RX GPIO3 Serial In: GPX_RX No further installation steps needed. To get more debug information compile it with option \"DEBUG_TASMOTA_SENSOR\". The driver expects the device to be configured for 9600 baud, which is the default for most of these sensors. If necessary the configuration can be changed with the freely available \"u-center\"-software, which is windows-only but is reported to run quite well with WINE and can be confirmed to work with CrossOver on macOs Catalina.","title":"Tasmota Settings"},{"location":"GPS-NTP-server/#ntp-server","text":"Simply start the server with 'sensor60 9'.","title":"NTP-Server"},{"location":"GPS-NTP-server/#flash-log","text":"This is highly experimental feature, which uses the OTA-partition to log position data. !! \u26a0\ufe0f FOR OBVIOUS REASONS THIS WILL SHORTEN THE LIFE OF THE FLASH MEMORY AND SHOULD BE USED WISELY \u26a0\ufe0f !! After the first recording, a download-link will appear in the web interface. By clicking on it, a GPX-file will be created on-the fly for download. All recorded data is lost after each OTA-update.","title":"Flash-Log"},{"location":"GPS-NTP-server/#commands","text":"Command Description sensor60 0 write to all available sectors, then restart and overwrite the older ones sensor60 1 write to all available sectors, then restart and overwrite the older ones sensor60 2 filter out horizontal drift noise sensor60 3 turn off noise filter sensor60 4 start recording, new data will be appended sensor60 5 start new recording, old data will lost sensor60 6 stop recording, download link will be visible in Web-UI sensor60 7 send mqtt on new postion TELE -> consider to set TELE to a very high value sensor60 8 only TELE message sensor60 9 start NTP-Server sensor60 10 deactivate NTP-Server sensor60 11 force update of Tasmota-system-UTC with every new GPS-time-message sensor60 12 do NOT update of Tasmota-system-UTC with every new GPS-time-message sensor60 13 set latitude and longitude in settings sensor60 14 open virtual serial port over TCP, usable for u-center tcp://ip-address:port (default port 1234) \u26a0\ufe0f misconfiguration via u-center can virtually brick the device \u26a0\ufe0f sensor60 15 pause virtual serial port over TCP (connection stays active in the background)","title":"Commands"},{"location":"Getting-Started/","text":"Prerequisites ~ Needed Hardware ~ ESP Device ~ Every Espressif ESP8266, ESP8285, ESP32, ESP32-S or ESP32-C3 chipset based device can be flashed with Tasmota. The term ESP refers to any of them. Serial-to-USB Adapter ~ The power supplied to the device is one of the most important elements for both flashing the device and for stable operation. You must ensure that the device receives sufficient power (current AND appropriate voltage level) to properly flash the firmware on the device. RECOMMENDED CH340G is the most reliable and the cheapest one to boot ( 1 , 2 ). FTDI FT232 - these adapters have a lot of fakes in the market so buy only from reliable sources ( example ). Buy only the variant with a separate 3.3V regulator on PCB! CP2102 or PL2303 - works with certain devices, but using an external 3.3V supply might be necessary. Not recommended for beginners! NodeMCU You can also use a NodeMCU (or similar) as a reliable serial-to-USB adapter if you disable the onboard ESP by bridging GND to the RST or EN pin, and connect TX and RX straight to another ESP82xx instead of crossed. RaspberryPi - only for advanced users. External 3.3V supply necessary. Don't forget to install drivers for your serial-to-USB adapter. Danger Some adapters can be switched between 3.3V and 5V for the data pins, but still provide 5V on the power pin which will irreparably destroy your device. You MUST make sure the data (RX and TX) and VCC pins are set for 3.3V. Some devices, such as NodeMCU , D1 mini or M5Stack products , have an USB upload port and the serial-to-USB adapter built in. Many CH340G devices will not work, the \"golden CH340G\" has a voltage regulator on it to supply enough power to the ESP device - many do not. The ESP requires at least 150mA, many 3.3V serial programmers do not supply this much current as many serial programming tasks do not require a large amount of power. When using an external 3.3V supply, simply ensure the ground (GND) of both are connected, this ensures a common ground. A PC power supply can be a source for 3.3V DC power. Soldering Tools ~ To solder you'll of course need a soldering iron, soldering tin and some flux. If you're new to soldering check out some soldering tutorial videos while you're at it. If you're intimidated by soldering there are 3D printed jigs available for different modules and devices. At worst, you could get away with holding the headers tightly with jumper wires in pin holes during flashing but it is not a foolproof process and flashing might fail. Jumper Wires ~ You could use any kind of wire but jumper wires (also called DuPont wires) are more practical than soldering and desoldering. Pin Headers ~ Pin headers come in male or female version. Choose according to your jumper wire connectors. Computer with Linux, Windows or MacOS ~ You need a computer with a USB port to upload the firmware to your device and configure it. Smartphone ~ Tasmota installed from a precompiled binary needs to be configured to work with your Wi-Fi network before you can access the Tasmota web UI. This is usually done by connecting to a Tasmota Wi-Fi Access Point with your smartphone (or tablet or computer with Wi-Fi). Needed Software ~ Tasmota Firmware Binary ~ Download a Tasmota firmware binary file (.bin). If you're not sure which binary is the right one for you just start with tasmota.bin or consult the builds table to see which features you need. Official release binaries can be downloaded from firmware server . Latest development branch binaries are available only from our OTA server . The latest merged development code is compiled hourly. Flashing Tool ~ Tasmota Web Installer - flash Tasmota using a Chrome based browser for ESP82XX and ESP32 Tasmotizer - flashing and firmware download tool for ESP82XX only . (Windows, Linux or Mac) ESP-Flasher - GUI flasher for Tasmota based on esptool.py for ESP82XX and ESP32. (Windows, Linux or Mac) Esptool.py - the official flashing tool from Espressif for ESP82XX and ESP32. (Requires Python) Compiling Tools (optional) If you want to modify the code or default settings and compile your own Tasmota firmware . MQTT Knowledge ~ Tasmota is designed to be controlled and communicate via MQTT . To use it to its fullest potential you need an MQTT broker . Read our article on MQTT to learn why it is essential in Tasmota. Hardware Preparation ~ We need to connect to the serial programming interface of the ESP chip. This is done by connecting our serial-to-USB converter TX and RX pins to the ESP RX and TX pins and powering the chip with the 3.3V and GND pins. In most cases those pins are available on the PCB in the form of pin holes or solder pads but pin headers or jumper wires need to be soldered or otherwise applied. In some cases you will need to solder wires directly on the chip's pins which requires some experience and good soldering equipment. DO NOT CONNECT DEVICES TO MAINS AC POWER WHILE THE COVER IS OPEN AND CIRCUIT BOARD IS EXPOSED!!! NEVER TRY TO FLASH WHILE YOUR DEVICE IS CONNECTED TO MAINS POWER!!! YOU CAN BE ELECTROCUTED IF YOU DO NOT KNOW WHAT YOU ARE DOING! If you are not careful, your own health will be in danger. Shorting your serial interface with mains AC power will fry your device and serial adapter and will also harm or destroy your computer. It is important to always have all mains power cables disconnected from the device while being connected via serial or even while the case of the device is opened. Serial Connection ~ Each device has its pins labelled differently. If the labelling isn't visible on the PCB please refer to the devices flashing guide or search the Internet for correct pin locations. Device specific instructions and restrictions are documented in the Tasmota Supported Devices Repository . Pinouts for commonly used Wi-Fi modules are found here When you have identified pins on your device, connect wires according to the table: Serial adapter ESP device 3V3 3V3 or VCC TX RX RX TX GND GND Note that TX from your adapter goes to RX on the ESP device and RX from adapter goes to TX on the device! Programming Mode ~ ESP needs to be put into programming mode or flash mode before the firmware can be uploaded. This is done by connecting GPIO0 pin to GND while the chip is booting. On many devices the installed control button is connected to GPIO0 and GND, making entering Programming Mode easy. On others you will need to bridge the pins on the PCB or directly on the chip with a jumper wire. GPIO0 locations for popular modules can be found in Pinouts ! Device specific instructions are documented in Tasmota Supported Devices Repository . To put the ESP into Programming Mode: Disconnect serial-to-USB adapter and power Bridge GPIO0 and GND (by pressing the on-board button or connection with a wire) Connect the serial-to-USB adapter to your computer After a few seconds disconnect GPIO0 from GND (release button or remove the wire connection). On devices that do not provide the GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. esptool.py programming mode test You can test whether your device is in Programming Mode by attempting to read information from the ESP82xx chip. This requires esptool.py . Instructions on installing and using esptool are provided below. For example ( COM5 will be your COM port): esptool.py -p COM5 read_mac (It should read the MAC address. It may fail afterwards during Uploading and running a \"stub\". This is normal.) esptool.py -p COM5 flash_id If everything went well, you are now in Programming Mode and ready to continue with flashing . If the flashing process is unable to start, disconnect the device and retry the steps. Common Mistakes ~ Wire connections and solder joints - Double check all connections and also check for solder overflow. Use a USB data cable - Some USB cables are for charging only and do not connect the data lines needed to load the firmware onto the device. Insufficient power delivered over the serial-to-USB adapter. This leads to flashing failures or corrupted flash altogether. Supply more power with a separate 3.3V power supply or get an adapter with a better power supply. Be sure all DC voltages use the same GND line. Recheck your serial-to-USB adapter so to ensure that it supplies 3.3V voltage and NOT 5V . 5V will damage the ESP chip! Releasing GPIO0 button/wire before booting is finished - It is safe to leave GPIO0 connected to GND during the entire programming process (erase & upload). Just be sure to remove the GPIO0 to GND bridge before booting the device for regular operation. Make sure that the RX pin is connected to the TX pin between the serial adapter and your ESP device, and vice versa. Erase the flash first and power cycle before uploading the Tasmota firmware binary. Not erasing can leave behind remnants of the previous flash contents which can interfere with the new firmware operation. Flashing ~ If you have followed Hardware preparation , your device should be in Programming Mode and ready for a Tasmota firmware binary to be installed. You may want to back up the device manufacturer's firmware on the one in a million chance you don't like Tasmota. Choose an installation method: Web Installer Tasmotizer! esptool.py OTA Conversion Flash Tasmota directly from your web browser. Tasmotizer! is specifically designed for use with Tasmota with an easy to use GUI and esptool.py under the hood. Download the latest release for your platform. In Windows just double click the downloaded file and it'll start, no installation required. For python follow the installation instructions . Note If you get an anti-virus infection warning don't fret, it is a known false positive . If you're still apprehensive you can always run the Python version. It is time to Tasmotize! Connect your device to the serial-to-USB adapter or plug in NodeMCU/D1 mini. Check whether the correct serial port (COM or tty port) is selected. Tasmotizer! will try its best to select the right one for you. Choose Tasmota firmware binary: BIN file - browse to the Tasmota firmware binary you downloaded or compiled. Release - select from a list of available release binaries Development - select from a list of latest development binaries optional Backup the original device firmware Erase flash Danger Leave Erase before flashing checked if it is the first time flashing Tasmota on the device or you're experiencing issues with the existing flash and need to do a full erase. If you're upgrading an already flashed Tasmota and wish to keep your settings, uncheck Erase before flashing . Click Tasmotize and wait until done. If the flash was successful it will display: Unplug your serial programming adapter or device and plug it back in or connect to another power source. Esptool is the official Espressif tool for flashing ESP chips. It requires Python, if you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org. Download the esptool Source code to a folder of your choice. Go to the folder and install Esptool with command python setup.py install Make sure you followed the steps to put your device in programming mode. Place your chosen firmware binary file in the same folder as esptool.py. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2, etc. and on Linux they are named /dev/ttyUSB0, /dev/ttyUSB1, etc. Before using esptool, make sure you know which serial port your programming adapter is connected to. The following use COM5 as an example. Change COM5 with your serial port designation. Ensure the device is in programming mode before each step. Backup Firmware (optional step) ~ Backup the current firmware with the following command: esptool.py --port COM5 read_flash 0x00000 0x100000 fwbackup.bin When the command completes the device is not in programming mode anymore. Repeat the process of putting your device in programming mode. Erase Flash Memory ~ Erase the complete flash memory holding the firmware with the following command: esptool.py --port COM5 erase_flash It only takes a few seconds to erase 1M of flash. When the command completes the device is not in programming mode anymore. Repeat the process of putting your device in programming mode. Upload Firmware ~ Load the chosen Tasmota firmware file with the following command (e.g., tasmota.bin in this example): esptool.py --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin Unplug your serial programming adapter or your device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . For proper device initialization after the firmware upload completes, power down and power up the device. Tasmota is NOT a developer of these tools. For help and troubleshooting you will need to get support from those projects . MgOS to Tasmota - OTA flash for Shelly devices Tuya-Convert - OTA flash for devices with Tuya chips. Does not work in 99% of cases Sonoff DIY - OTA flash for select Sonoff devices Does not work anymore esp2ino - OTA flash for select Wyze devices. Does not work anymore Initial Configuration ~ Using Tasmota Web Installer Using Web UI Using Serial Terminal Once the installation is successful, click on NEXT . The installer will scan for Wi-Fi networks and select the strongest one. Use the dropdown to select between networks. Enter the Wi-Fi password. Wait until configuration completes and click CONTINUE From here click on VISIT DEVICE to enter the WebUI for further configuration. Tasmota provides a wireless access point for easy Wi-Fi configuration. Connect your device to a power source and grab your smartphone (or tablet or laptop or any other web and Wi-Fi capable device). Search for a Wi-Fi AP named tasmota_XXXXXX-#### (where XXXXXX is a string derived from the device's MAC address and #### is a number) and connect to it. In this example the Wi-Fi AP is named tasmota_3D5E26-7718 . When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Warning Wi-Fi manager server is active for only 3 minutes. If you miss the window you might have to disconnect your device from power and reconnect. After you have connected to the Tasmota Wi-Fi AP, open http://192.168.4.1 in a web browser on the smartphone (or whatever device you used). Depending on the phone, it will take you to the Tasmota configuration page automatically, or you will get a prompt to sign in to Wi-Fi network or authorize . Tapping on the AP name should also open the configuration page. At the top of the page you can select one of the discovered Wi-Fi networks or have Tasmota scan again. Enter your WiFi credentials: WiFi Network - your Wi-Fi network name (SSID Selecting the desired network name from the list will enter it automatically in this field. SSID's are case sensitive WiFi Password - password for your Wi-Fi network Wi-Fi password has to be under 64 characters and without special characters (e.g. asterisks) or white spaces Click the checkbox if you want to see the password you enter to ensure that it is correct. Click on Save to apply the settings. The device will try to connect to the network entered. If it was successful, you will see this message: Some phones will redirect you to the new IP immediately, on others you need to click the link to open it in a browser. The tasmota_XXXXXX-#### network will no longer be present. Therefore your smartphone will automatically be disconnected and should connect back to its data network. Failure In case the network name or password were entered incorrectly, or it didn't manage to connect for some other reason, Tasmota will return to the \"Wi-Fi parameters\" screen with an error message. If you don't know the IP of the newly flashed device look in your router settings or find it with an IP scanner: Fing - for Android or iOS Angry IP Scanner - open source for Linux, Windows and Mac. Requires Java. Super Scan - Windows only (free) Open the IP address with your web browser and you have full access to Tasmota. Now is the time to set up MQTT and the last remaining, but equally important, step: Set up your device's feature using a Template in Configuration - Configure Template or Module in Configuration - Configure Module . Configure Other (optional) Configure your device name which is displayed in webUI and used for Home Assistant discovery . Configure web admin password for the webUI. Default username is admin . This type of security is rudimentary since Tasmota doesn't use HTTPS, do not expose your device outside of your local network. If you flashed the device using serial-to-USB adapter (or it is a NodeMCU/D1 mini) you can take advantage of the existing connection and configure your device over the serial connection using Commands . First you will need a serial terminal program that connects to Tasmota console over the serial connection you used to flash it. Termite - simple terminal for windows Termie - open source clone of Termite Putty - popular client available on every platform Minicom - one of many Linux terminals Tip Enable local echo so that you can see what is typed and transmitted to the device. Enable Append CR+LF since every request needs to end with <CR><LF> . In this example Termite on Windows is used. Download Termite and extract the .exe file, no installation necessary. Connect your serial-to-USB adapter or NodeMCU/D1 mini to the computer. Open Termite and set it to the proper COM port ( Termite selects the first available port by default ). Set Baud rate to 115200 and Forward to none. Connect your device to the serial-to-USB adapter. You should see the initial boot output in Termite. If your screen is empty type status in the bottom command bar and hit enter. If you get a return message from your device similar to the one displayed under purple status you're all set. To configure Tasmota you need to issue commands, some commands will reboot your device and to avoid that we will use the Backlog command feature. Configure your Wi-Fi network and a secondary Wi-Fi network Backlog ssid1 <yourssid>; password1 <your_password>; ssid2 <your_ssid2>; password2 <your_password> Device will restart and connect to your network. It will display your devices newly assigned IP. Direct your web browser to that IP address to access the Web UI for further configuration and control. Configure MQTT broker address, MQTT credentials, unique device topic and OTA url to the latest official release Backlog mqtthost <yourhost>; mqttuser <user>; mqttpassword <password>; topic <unique_topic>; otaurl http://ota.tasmota.com/tasmota/release/tasmota.bin Commands and Backlog are powerful and in time you can learn to configure almost everything (NTP servers, longitude and latitude, custom device options, etc) with a few copy and paste moves. Tip Keep your personal configuration in a text file and simply copy and paste the backlog commands to a newly flashed device. After Configuration ~ Your device running Tasmota is now ready to be controlled . Check out all the Tasmota features and ways to integrate it with other platforms. Warning If you experience power fluctuations in your power grid its best to immediately disable Power Cycle Recovery feature with command SetOption65 1 immediately or you might end up with firmware defaults on your device.","title":"Getting Started"},{"location":"Getting-Started/#prerequisites","text":"","title":"Prerequisites"},{"location":"Getting-Started/#needed-hardware","text":"","title":"Needed Hardware"},{"location":"Getting-Started/#needed-software","text":"","title":"Needed Software"},{"location":"Getting-Started/#mqtt-knowledge","text":"Tasmota is designed to be controlled and communicate via MQTT . To use it to its fullest potential you need an MQTT broker . Read our article on MQTT to learn why it is essential in Tasmota.","title":"MQTT Knowledge"},{"location":"Getting-Started/#hardware-preparation","text":"We need to connect to the serial programming interface of the ESP chip. This is done by connecting our serial-to-USB converter TX and RX pins to the ESP RX and TX pins and powering the chip with the 3.3V and GND pins. In most cases those pins are available on the PCB in the form of pin holes or solder pads but pin headers or jumper wires need to be soldered or otherwise applied. In some cases you will need to solder wires directly on the chip's pins which requires some experience and good soldering equipment. DO NOT CONNECT DEVICES TO MAINS AC POWER WHILE THE COVER IS OPEN AND CIRCUIT BOARD IS EXPOSED!!! NEVER TRY TO FLASH WHILE YOUR DEVICE IS CONNECTED TO MAINS POWER!!! YOU CAN BE ELECTROCUTED IF YOU DO NOT KNOW WHAT YOU ARE DOING! If you are not careful, your own health will be in danger. Shorting your serial interface with mains AC power will fry your device and serial adapter and will also harm or destroy your computer. It is important to always have all mains power cables disconnected from the device while being connected via serial or even while the case of the device is opened.","title":"Hardware Preparation"},{"location":"Getting-Started/#serial-connection","text":"Each device has its pins labelled differently. If the labelling isn't visible on the PCB please refer to the devices flashing guide or search the Internet for correct pin locations. Device specific instructions and restrictions are documented in the Tasmota Supported Devices Repository . Pinouts for commonly used Wi-Fi modules are found here When you have identified pins on your device, connect wires according to the table: Serial adapter ESP device 3V3 3V3 or VCC TX RX RX TX GND GND Note that TX from your adapter goes to RX on the ESP device and RX from adapter goes to TX on the device!","title":"Serial Connection"},{"location":"Getting-Started/#programming-mode","text":"ESP needs to be put into programming mode or flash mode before the firmware can be uploaded. This is done by connecting GPIO0 pin to GND while the chip is booting. On many devices the installed control button is connected to GPIO0 and GND, making entering Programming Mode easy. On others you will need to bridge the pins on the PCB or directly on the chip with a jumper wire. GPIO0 locations for popular modules can be found in Pinouts ! Device specific instructions are documented in Tasmota Supported Devices Repository . To put the ESP into Programming Mode: Disconnect serial-to-USB adapter and power Bridge GPIO0 and GND (by pressing the on-board button or connection with a wire) Connect the serial-to-USB adapter to your computer After a few seconds disconnect GPIO0 from GND (release button or remove the wire connection). On devices that do not provide the GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. esptool.py programming mode test You can test whether your device is in Programming Mode by attempting to read information from the ESP82xx chip. This requires esptool.py . Instructions on installing and using esptool are provided below. For example ( COM5 will be your COM port): esptool.py -p COM5 read_mac (It should read the MAC address. It may fail afterwards during Uploading and running a \"stub\". This is normal.) esptool.py -p COM5 flash_id If everything went well, you are now in Programming Mode and ready to continue with flashing . If the flashing process is unable to start, disconnect the device and retry the steps.","title":"Programming Mode"},{"location":"Getting-Started/#common-mistakes","text":"Wire connections and solder joints - Double check all connections and also check for solder overflow. Use a USB data cable - Some USB cables are for charging only and do not connect the data lines needed to load the firmware onto the device. Insufficient power delivered over the serial-to-USB adapter. This leads to flashing failures or corrupted flash altogether. Supply more power with a separate 3.3V power supply or get an adapter with a better power supply. Be sure all DC voltages use the same GND line. Recheck your serial-to-USB adapter so to ensure that it supplies 3.3V voltage and NOT 5V . 5V will damage the ESP chip! Releasing GPIO0 button/wire before booting is finished - It is safe to leave GPIO0 connected to GND during the entire programming process (erase & upload). Just be sure to remove the GPIO0 to GND bridge before booting the device for regular operation. Make sure that the RX pin is connected to the TX pin between the serial adapter and your ESP device, and vice versa. Erase the flash first and power cycle before uploading the Tasmota firmware binary. Not erasing can leave behind remnants of the previous flash contents which can interfere with the new firmware operation.","title":"Common Mistakes"},{"location":"Getting-Started/#flashing","text":"If you have followed Hardware preparation , your device should be in Programming Mode and ready for a Tasmota firmware binary to be installed. You may want to back up the device manufacturer's firmware on the one in a million chance you don't like Tasmota. Choose an installation method: Web Installer Tasmotizer! esptool.py OTA Conversion Flash Tasmota directly from your web browser. Tasmotizer! is specifically designed for use with Tasmota with an easy to use GUI and esptool.py under the hood. Download the latest release for your platform. In Windows just double click the downloaded file and it'll start, no installation required. For python follow the installation instructions . Note If you get an anti-virus infection warning don't fret, it is a known false positive . If you're still apprehensive you can always run the Python version. It is time to Tasmotize! Connect your device to the serial-to-USB adapter or plug in NodeMCU/D1 mini. Check whether the correct serial port (COM or tty port) is selected. Tasmotizer! will try its best to select the right one for you. Choose Tasmota firmware binary: BIN file - browse to the Tasmota firmware binary you downloaded or compiled. Release - select from a list of available release binaries Development - select from a list of latest development binaries optional Backup the original device firmware Erase flash Danger Leave Erase before flashing checked if it is the first time flashing Tasmota on the device or you're experiencing issues with the existing flash and need to do a full erase. If you're upgrading an already flashed Tasmota and wish to keep your settings, uncheck Erase before flashing . Click Tasmotize and wait until done. If the flash was successful it will display: Unplug your serial programming adapter or device and plug it back in or connect to another power source. Esptool is the official Espressif tool for flashing ESP chips. It requires Python, if you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org. Download the esptool Source code to a folder of your choice. Go to the folder and install Esptool with command python setup.py install Make sure you followed the steps to put your device in programming mode. Place your chosen firmware binary file in the same folder as esptool.py. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2, etc. and on Linux they are named /dev/ttyUSB0, /dev/ttyUSB1, etc. Before using esptool, make sure you know which serial port your programming adapter is connected to. The following use COM5 as an example. Change COM5 with your serial port designation. Ensure the device is in programming mode before each step.","title":"Flashing"},{"location":"Getting-Started/#initial-configuration","text":"Using Tasmota Web Installer Using Web UI Using Serial Terminal Once the installation is successful, click on NEXT . The installer will scan for Wi-Fi networks and select the strongest one. Use the dropdown to select between networks. Enter the Wi-Fi password. Wait until configuration completes and click CONTINUE From here click on VISIT DEVICE to enter the WebUI for further configuration. Tasmota provides a wireless access point for easy Wi-Fi configuration. Connect your device to a power source and grab your smartphone (or tablet or laptop or any other web and Wi-Fi capable device). Search for a Wi-Fi AP named tasmota_XXXXXX-#### (where XXXXXX is a string derived from the device's MAC address and #### is a number) and connect to it. In this example the Wi-Fi AP is named tasmota_3D5E26-7718 . When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Warning Wi-Fi manager server is active for only 3 minutes. If you miss the window you might have to disconnect your device from power and reconnect. After you have connected to the Tasmota Wi-Fi AP, open http://192.168.4.1 in a web browser on the smartphone (or whatever device you used). Depending on the phone, it will take you to the Tasmota configuration page automatically, or you will get a prompt to sign in to Wi-Fi network or authorize . Tapping on the AP name should also open the configuration page. At the top of the page you can select one of the discovered Wi-Fi networks or have Tasmota scan again. Enter your WiFi credentials: WiFi Network - your Wi-Fi network name (SSID Selecting the desired network name from the list will enter it automatically in this field. SSID's are case sensitive WiFi Password - password for your Wi-Fi network Wi-Fi password has to be under 64 characters and without special characters (e.g. asterisks) or white spaces Click the checkbox if you want to see the password you enter to ensure that it is correct. Click on Save to apply the settings. The device will try to connect to the network entered. If it was successful, you will see this message: Some phones will redirect you to the new IP immediately, on others you need to click the link to open it in a browser. The tasmota_XXXXXX-#### network will no longer be present. Therefore your smartphone will automatically be disconnected and should connect back to its data network. Failure In case the network name or password were entered incorrectly, or it didn't manage to connect for some other reason, Tasmota will return to the \"Wi-Fi parameters\" screen with an error message. If you don't know the IP of the newly flashed device look in your router settings or find it with an IP scanner: Fing - for Android or iOS Angry IP Scanner - open source for Linux, Windows and Mac. Requires Java. Super Scan - Windows only (free) Open the IP address with your web browser and you have full access to Tasmota. Now is the time to set up MQTT and the last remaining, but equally important, step: Set up your device's feature using a Template in Configuration - Configure Template or Module in Configuration - Configure Module . Configure Other (optional) Configure your device name which is displayed in webUI and used for Home Assistant discovery . Configure web admin password for the webUI. Default username is admin . This type of security is rudimentary since Tasmota doesn't use HTTPS, do not expose your device outside of your local network. If you flashed the device using serial-to-USB adapter (or it is a NodeMCU/D1 mini) you can take advantage of the existing connection and configure your device over the serial connection using Commands . First you will need a serial terminal program that connects to Tasmota console over the serial connection you used to flash it. Termite - simple terminal for windows Termie - open source clone of Termite Putty - popular client available on every platform Minicom - one of many Linux terminals Tip Enable local echo so that you can see what is typed and transmitted to the device. Enable Append CR+LF since every request needs to end with <CR><LF> . In this example Termite on Windows is used. Download Termite and extract the .exe file, no installation necessary. Connect your serial-to-USB adapter or NodeMCU/D1 mini to the computer. Open Termite and set it to the proper COM port ( Termite selects the first available port by default ). Set Baud rate to 115200 and Forward to none. Connect your device to the serial-to-USB adapter. You should see the initial boot output in Termite. If your screen is empty type status in the bottom command bar and hit enter. If you get a return message from your device similar to the one displayed under purple status you're all set. To configure Tasmota you need to issue commands, some commands will reboot your device and to avoid that we will use the Backlog command feature. Configure your Wi-Fi network and a secondary Wi-Fi network Backlog ssid1 <yourssid>; password1 <your_password>; ssid2 <your_ssid2>; password2 <your_password> Device will restart and connect to your network. It will display your devices newly assigned IP. Direct your web browser to that IP address to access the Web UI for further configuration and control. Configure MQTT broker address, MQTT credentials, unique device topic and OTA url to the latest official release Backlog mqtthost <yourhost>; mqttuser <user>; mqttpassword <password>; topic <unique_topic>; otaurl http://ota.tasmota.com/tasmota/release/tasmota.bin Commands and Backlog are powerful and in time you can learn to configure almost everything (NTP servers, longitude and latitude, custom device options, etc) with a few copy and paste moves. Tip Keep your personal configuration in a text file and simply copy and paste the backlog commands to a newly flashed device.","title":"Initial Configuration"},{"location":"Getting-Started/#after-configuration","text":"Your device running Tasmota is now ready to be controlled . Check out all the Tasmota features and ways to integrate it with other platforms. Warning If you experience power fluctuations in your power grid its best to immediately disable Power Cycle Recovery feature with command SetOption65 1 immediately or you might end up with firmware defaults on your device.","title":"After Configuration"},{"location":"Gitpod/","text":"Even though Tasmota offers several pre-compiled firmware variants, sometimes the ready-to-flash binaries aren't enough. If you need to enable or disable some features, or simply change some parameters, then you need to compile a firmware binary yourself. If you are not experienced enough or don't want to install an IDE (Integrated Development Environment) like PlatformIO or ATOM on your computer, compiling your own firmware is a breeze using Gitpod . Gitpod is a web browser based online IDE. All you need to use it is to link your GitHub account (or make a new one here ). Gitpod will take care of all the necessary software package dependencies for you. After you successfully sign in, you can start your personal project. The fastest way to load Tasmota into Gitpod is with one of the following links: Development Branch: https://gitpod.io#https://github.com/arendst/Tasmota/tree/development Master Release: https://gitpod.io#https://github.com/arendst/Tasmota/tree/master TasmoCompiler : https://gitpod.io/#https://github.com/benzino77/tasmocompiler Browser Extension Gitpod has a browser extension (Chrome and Firefox) which is handy to directly load a GitHub project into your personal Gitpod work-space. More information on the Gitpod browser extension . Using Gitpod ~ After Gitpod loads the project, you will be greeted by the main window. Gitpod will then automatically compile tasmota.bin . Wait for the compilation to complete. The display consists of three panels: Explorer Editor Terminal Customize Firmware Features and Settings ~ Warning The proper method of customizing firmware compilation options is to use the user_config_override.h file. You should not change the my_user_config.h file. To modify the stock configuration: Select the /tasmota folder in the Explorer (1) pane Create a new file called user_config_override.h In the Editor (2) pane, add, change, or remove anything you need in your configuration file to define your own settings. Refer to the user_config_override_sample.h file as well as my_user_config.h for #define options ( sample ). You can find a list of Tasmota features and settings listed here . Define the features you require in your configuration file. Click 'File' on the menu bar and 'Save' your edits. Prepare the IDE for Compilation ~ Open the platformio.ini file located in the /tasmota root directory (scroll to the bottom of the file Explorer (1) pane). In this file, removing a leading semicolon ; enables a statement. In the Editor (2) pane: If you are using your own user_config_override.h , you must tell the compiler to use it. Rename platformio_override_sample.ini to platformio_override.ini . Default Tasmota Arduino Core will be compiled. If you wish to use a different Core, find the [core_active] section in the file and enable the platform and build_flags lines for the desired Core. Then click 'File' on the menu bar and 'Save' your edits. Compile Your Firmware ~ This action is done in the Terminal pane (3) with simple commands. The simplest one is platformio run -e tasmota . With this command, Gitpod will compile the Tasmota firmware with the features you selected. If you need a different variant, you can specify this option on the command line: platformio run -e <variant-name> Examples: platformio run -e tasmota-sensors platformio run -e tasmota-DE Compilation normally takes only a couple of minutes. The time it takes is directly related to how many variants you build. When done, you will find the firmware file in the folder /Tasmota/build_output/firmware/<variant-name>.bin in the Explorer (1) pane. Download <variant-name>.bin to your computer by right-clicking on the file and selecting 'Download'. You are now ready to flash your device. Watch a livestream video by digiblurDIY of compiling Tasmota using Gitpod. Flash Your Device ~ OTA Flash ~ If you already have Tasmota flashed on your device, you can use the File Upload OTA method to load the new firmware binary file. Download tasmota-minimal.bin Make a backup of the device configuration using the web UI Configuration menu option. Upload tasmota-minimal.bin to your device using the web UI Firmware Upgrade selection. Choose Upgrade by file upload . After tasmota-minimal.bin is successfully loaded, select Firmware Upgrade once again and upload the firmware file compiled using Gitpod. Serial Flash ~ Follow the same procedure for flashing as you would any new device.","title":"Gitpod"},{"location":"Gitpod/#using-gitpod","text":"After Gitpod loads the project, you will be greeted by the main window. Gitpod will then automatically compile tasmota.bin . Wait for the compilation to complete. The display consists of three panels: Explorer Editor Terminal","title":"Using Gitpod"},{"location":"Gitpod/#customize-firmware-features-and-settings","text":"Warning The proper method of customizing firmware compilation options is to use the user_config_override.h file. You should not change the my_user_config.h file. To modify the stock configuration: Select the /tasmota folder in the Explorer (1) pane Create a new file called user_config_override.h In the Editor (2) pane, add, change, or remove anything you need in your configuration file to define your own settings. Refer to the user_config_override_sample.h file as well as my_user_config.h for #define options ( sample ). You can find a list of Tasmota features and settings listed here . Define the features you require in your configuration file. Click 'File' on the menu bar and 'Save' your edits.","title":"Customize Firmware Features and Settings"},{"location":"Gitpod/#prepare-the-ide-for-compilation","text":"Open the platformio.ini file located in the /tasmota root directory (scroll to the bottom of the file Explorer (1) pane). In this file, removing a leading semicolon ; enables a statement. In the Editor (2) pane: If you are using your own user_config_override.h , you must tell the compiler to use it. Rename platformio_override_sample.ini to platformio_override.ini . Default Tasmota Arduino Core will be compiled. If you wish to use a different Core, find the [core_active] section in the file and enable the platform and build_flags lines for the desired Core. Then click 'File' on the menu bar and 'Save' your edits.","title":"Prepare the IDE for Compilation"},{"location":"Gitpod/#compile-your-firmware","text":"This action is done in the Terminal pane (3) with simple commands. The simplest one is platformio run -e tasmota . With this command, Gitpod will compile the Tasmota firmware with the features you selected. If you need a different variant, you can specify this option on the command line: platformio run -e <variant-name> Examples: platformio run -e tasmota-sensors platformio run -e tasmota-DE Compilation normally takes only a couple of minutes. The time it takes is directly related to how many variants you build. When done, you will find the firmware file in the folder /Tasmota/build_output/firmware/<variant-name>.bin in the Explorer (1) pane. Download <variant-name>.bin to your computer by right-clicking on the file and selecting 'Download'. You are now ready to flash your device. Watch a livestream video by digiblurDIY of compiling Tasmota using Gitpod.","title":"Compile Your Firmware"},{"location":"Gitpod/#flash-your-device","text":"","title":"Flash Your Device"},{"location":"GladysAssistant/","text":"Tasmota supports Gladys Assistant MQTT for both relays and sensors. HTTP protocol incoming soon. Find below the procedure to configure Gladys Assistant and Tasmota. Prerequisites ~ The following servers should be made available: You have installed Gladys Assistant (embedded MQTT broker available) You have installed/access to a MQTT broker server and made contact with your Tasmota device Automatic Disovery ~ Gladys Assistant automatically discovers Tasmota devices (once all are connected on same MQTT broker). On Gladys Assistant application: Go to Integration page Look for Tasmota element, click on it Then, MQTT discover Save to add device Try on Gladys Assistant demonstration website .","title":"GladysAssistant"},{"location":"GladysAssistant/#automatic-disovery","text":"Gladys Assistant automatically discovers Tasmota devices (once all are connected on same MQTT broker). On Gladys Assistant application: Go to Integration page Look for Tasmota element, click on it Then, MQTT discover Save to add device Try on Gladys Assistant demonstration website .","title":"Automatic Disovery"},{"location":"HASPmota/","text":"HASPmota ~ This feature is experimental Tasmota is happy to support openHASP compatible format (named HASPmota), which allows to describe rich graphics interfaces using simple JSON templates. HASPmota support leverages the power of LVGL and the Berry language , but doesn't need to code nor learn the LVGL API. This feature is heavily inspired from @fvanroie's openHASP project . Minimal requirements ~ Hardware : HASPmota is supported on all ESP32 variants, and requires a display configured with universal display (using display.ini or autoconf ). You should see a splash screen at startup. Currently PSRAM is required to run HASPmota. The core engine is compiled and loaded in memory, which makes it unsuitable for ESP32 without PSRAM. Future versions Firmware : you need a tasmota firmware with LVGL support, like tasmota32-lvgl or a self-compiled version. Quick tour ~ You can see HASPmota in action in a couple of minutes. Upload in your ESP32 file system the following files, from: https://github.com/arendst/Tasmota/tree/development/tasmota/berry/haspmota haspmota_widgets.tapp (contains widgets for wifi, logging and general info) robotocondensed_latin1.tapp (contains additional fonts) haspmota.tapp (contains the core HASPmota engine) pages.jsonl (contains a sample definition) Restart and enjoy. You should see the following screen, and click on buttons to switch to the second screen: Understanding the template ~ HASPmota automatically loads the template from a file named pages.jsonl . This file contains JSON Lines, i.e. a single JSON document per line. Each line describes an element on the screen. Elements are groupes into pages. Page 0 contains objects that are displayed on all screens. They are typically used for headers and menus. The lines below define the header label (red background) and the clock and wifi widgets. { \"page\" : 0 , \"comment\" : \"---------- Upper stat line ----------\" } { \"id\" : 11 , \"obj\" : \"label\" , \"x\" : 0 , \"y\" : 0 , \"w\" : 320 , \"pad_right\" : 90 , \"h\" : 22 , \"bg_color\" : \"#D00000\" , \"bg_opa\" : 255 , \"radius\" : 0 , \"border_side\" : 0 , \"text\" : \"Tasmota\" , \"text_font\" : \"montserrat-20\" } { \"id\" : 15 , \"obj\" : \"lv_wifi_arcs\" , \"x\" : 291 , \"y\" : 0 , \"w\" : 29 , \"h\" : 22 , \"radius\" : 0 , \"border_side\" : 0 , \"bg_color\" : \"#000000\" , \"line_color\" : \"#FFFFFF\" } { \"id\" : 16 , \"obj\" : \"lv_clock\" , \"x\" : 232 , \"y\" : 3 , \"w\" : 55 , \"h\" : 16 , \"radius\" : 0 , \"border_side\" : 0 } The lines below describe the 3 buttons at the bottom, and their respective actions. { \"comment\" : \"---------- Bottom buttons - prev/home/next ----------\" } { \"id\" : 101 , \"obj\" : \"btn\" , \"x\" : 20 , \"y\" : 210 , \"w\" : 80 , \"h\" : 25 , \"action\" : \"prev\" , \"bg_color\" : \"#1fa3ec\" , \"radius\" : 10 , \"border_side\" : 1 , \"text\" : \"\\uF053\" , \"text_font\" : \"montserrat-20\" } { \"id\" : 102 , \"obj\" : \"btn\" , \"x\" : 120 , \"y\" : 210 , \"w\" : 80 , \"h\" : 25 , \"action\" : \"back\" , \"bg_color\" : \"#1fa3ec\" , \"radius\" : 10 , \"border_side\" : 1 , \"text\" : \"\\uF015\" , \"text_font\" : \"montserrat-20\" } { \"id\" : 103 , \"obj\" : \"btn\" , \"x\" : 220 , \"y\" : 210 , \"w\" : 80 , \"h\" : 25 , \"action\" : \"next\" , \"bg_color\" : \"#1fa3ec\" , \"radius\" : 10 , \"border_side\" : 1 , \"text\" : \"\\uF054\" , \"text_font\" : \"montserrat-20\" } Page 1 is the default page, and contains different widgets types: labels and arc. The values are changed at runtime via Tasmota's rule system, see below for details. { \"page\" : 1 , \"comment\" : \"---------- Page 1 ----------\" } { \"id\" : 0 , \"bg_color\" : \"#0000A0\" , \"bg_grad_color\" : \"#000000\" , \"bg_grad_dir\" : 1 , \"text_color\" : \"#FFFFFF\" } { \"id\" : 2 , \"obj\" : \"arc\" , \"x\" : 20 , \"y\" : 65 , \"w\" : 80 , \"h\" : 100 , \"border_side\" : 0 , \"type\" : 0 , \"rotation\" : 0 , \"start_angle\" : 180 , \"end_angle\" : 0 , \"start_angle1\" : 180 , \"value_font\" : 12 , \"value_ofs_x\" : 0 , \"value_ofs_y\" : -14 , \"bg_opa\" : 0 , \"text\" : \"--.-\u00b0C\" , \"min\" : 200 , \"max\" : 800 , \"val\" : 0 , \"val_rule\" : \"ESP32#Temperature\" , \"val_rule_formula\" : \"val * 10\" , \"text_rule\" : \"ESP32#Temperature\" , \"text_rule_format\" : \"%2.1f \u00b0C\" } { \"id\" : 5 , \"obj\" : \"label\" , \"x\" : 2 , \"y\" : 35 , \"w\" : 120 , \"text\" : \"Temperature\" , \"align\" : 1 } { \"id\" : 10 , \"obj\" : \"label\" , \"x\" : 172 , \"y\" : 35 , \"w\" : 140 , \"text\" : \"MPU\" , \"align\" : 0 } { \"id\" : 11 , \"obj\" : \"label\" , \"x\" : 172 , \"y\" : 55 , \"w\" : 140 , \"text\" : \"x=\" , \"align\" : 0 , \"text_rule\" : \"MPU9250#AX\" , \"text_rule_format\" : \"x=%6.3f\" , \"text_rule_formula\" : \"val / 1000\" } { \"id\" : 12 , \"obj\" : \"label\" , \"x\" : 172 , \"y\" : 75 , \"w\" : 140 , \"text\" : \"y=\" , \"align\" : 0 , \"text_rule\" : \"MPU9250#AY\" , \"text_rule_format\" : \"y=%6.3f\" , \"text_rule_formula\" : \"val / 1000\" } { \"id\" : 13 , \"obj\" : \"label\" , \"x\" : 172 , \"y\" : 95 , \"w\" : 140 , \"text\" : \"z=\" , \"align\" : 0 , \"text_rule\" : \"MPU9250#AZ\" , \"text_rule_format\" : \"z=%6.3f\" , \"text_rule_formula\" : \"val / 1000\" } Page 2 contains custom widgets as Berry code. These widgets are imported within haspmota_widgets.tapp { \"page\" : 2 , \"comment\" : \"---------- Page 2 ----------\" } { \"id\" : 0 , \"bg_color\" : \"#0000A0\" , \"bg_grad_color\" : \"#000000\" , \"bg_grad_dir\" : 1 , \"text_color\" : \"#FFFFFF\" } { \"comment\" : \"---------- Wifi status ----------\" } { \"id\" : 20 , \"obj\" : \"lv_wifi_graph\" , \"x\" : 257 , \"y\" : 25 , \"w\" : 60 , \"h\" : 40 , \"radius\" : 0 } { \"id\" : 21 , \"obj\" : \"lv_tasmota_info\" , \"x\" : 3 , \"y\" : 25 , \"w\" : 251 , \"h\" : 40 , \"radius\" : 0 } { \"id\" : 22 , \"obj\" : \"lv_tasmota_log\" , \"x\" : 3 , \"y\" : 68 , \"w\" : 314 , \"h\" : 90 , \"radius\" : 0 , \"text_font\" : 12 } Finally, the following line allows to run arbitrary Berry code. { \"comment\" : \"--- Trigger sensors every 2 seconds ---\" , \"berry_run\" : \"tasmota.add_cron('*/2 * * * * *', def () tasmota.publish_rule(tasmota.read_sensors()) end, 'oh_every_5_s')\" } The code trigger a read of sensors every 2 seconds and publish the JSON result to be parsed by the rule engine. tasmota . add_cron ( '*/2 * * * * *' , def () tasmota . publish_rule ( tasmota . read_sensors ()) end , 'oh_every_5_s' ) HASPmota reference ~ Integration to Berry ~ objects as p<x>b<y> ~ Each HASPmota widget is mapped to a global variable of name p<x>b<y> . Example: p1b10 . Such objects can be directly used via their attributes. Example: p1b10.x += 10 p1b10.text = \"Hello\" print(p1b10.w) pages as p<x> ~ Pages objects are mapped to a global variable of name p<x> . Changing pages can be done with p2.show() additional parsing ~ HASPmota parses all lines from the file pages.jsonl . You can dynamically add new objects as JSON with haspmota.parse(<json>) . This functions takes a single json line. It is highly recommended to specify the page id in the json, otherwise the object is added to the current page. Pages ~ Pages object are identified by object if 0 . Example: { \"page\" : 1 , \"id\" : 0 , \"bg_color\" : \"#0000A0\" , \"bg_grad_color\" : \"#000000\" , \"bg_grad_dir\" : 1 , \"text_color\" : \"#FFFFFF\" } Internally HASPmota pages are implemented with LVGL screens, i.e. a parent object. Page 0 is a special page that is displays over every screens. It is the perfect place to put navigation menus. It is implement as lv.layer_top() . Page 1 is always present and the default page. Attributes specific to page Details prev (int) target page number when pressing PREV button next (int) target page number when pressing NEXT button home (int) target page number when pressing HOME button And generally all object attributes Classes of widgets ~ Attribute \"obj\" can take the following values: HASPmota Class Embedded LVGL class obj lv.obj btn lv.btn switch lv.switch checkbox lv.checkbox label lv.label spinner lv.spinner line lv.line img lv.img dropdown lv.dropdown roller lv.roller btnmatrix lv.btnmatrix bar lv.bar slider lv.slider arc lv.arc textarea lv.textarea qrcode lv.qrcode You can also import custom widget as long as they inherit from lv.obj and the class name matches the module name. Example: \"obj\":\"lv_wifi_graph\" will trigger the followin: - import lv_wifi_graph - instanciation of lv_wifi_graph(parent) object - if successful, it can be used like a typical HASPmota object Attributes ~ Below are the standard attributes: Attribute name LVGL equivalent Details comment Ignored page 0 to 15 Parent screen object Page id for the current object. If not present, takes the value of the current page id 0..255 Id number of the object. Id 0 means the entire page. A global berry object is created with name p<page>b<id> (ex: p1b10 ) obj widget class Class of the widget (see above). If not present, the entire JSON line is ignored action \"next\" , \"prev\" , \"back\" or \"p<x>\" Switch to page when the object is touched x x X coordinate of top left corner y y Y coordinate of top left corner (Y is pointing down) h height Height in pixels w width Width in pixels hidden flag lv.OBJ_FLAG_HIDDEN Object is hidden (bool) enabled flag lv.OBJ_FLAG_CLICKABLE Object is touch/clickable (bool) click flag lv.OBJ_FLAG_CLICKABLE Synonym of enabled . Object is touch/clickable (bool) toggle flag lv.STATE_CHECKED When enabled, creates a toggle-on/toggle-off button. If false, creates a normal button. TODO check if bool or string radius style_radius Radius of rounded corners bg_opa style_bg_opa Opacity: 0 is transparent, 255 is opaque bg_color style_bg_color Color of background, format is #RRGGBB bg_grad_color style_bg_grad_color Color of background gradient bg_grad_dir style_bg_grad_dir Gradient direction 0 : none 1 : Vertical (top to bottom) gradient 2 : Horizontal (left to right) gradient border_side style_border_side Borders to be displayed (add all values) 0 : none 1 : bottom 2 : top 4 : left 8 : bottom 15 : full (all 4) border_width style_border_width Width of border in pixels border_color style_border_color line_color style_line_color Color of line line_width style_line_width line_width1 style_arc_width Sets the line width of an arc indicator part pad_left style_pad_left Left padding in pixels pad_right style_pad_right Right padding in pixels pad_top style_pad_top Top padding in pixels pad_bottom style_pad_bottom Bottom padding in pixels pad_all style_pad_all Sets all 4 padding values at once (Write-only) Attributes related to text content Attribute name LVGL equivalent Details text text Sets the inner text of the object. If the native LVGL object does not support text (like lv.btn ), a lv.label sub-object is automatically created. value_str text Synonym of text align style_text_align Set alignment for text 0 or \"left\" : lv.TEXT_ALIGN_LEFT 1 or \"center\" : lv.TEXT_ALIGN_CENTER 2 or \"right\" : lv.TEXT_ALIGN_RIGHT text_font style_text_font Sets the font name and size for the text. If int , the default font is robotocondensed_latin1 and the parameter sets the size If string , the font is in the form <font_name>-<font_size> , example: montserrat-20 or in the form A:<font_file> to load a binary font from the file-system. value_font style_text_font Synonym of text_font text_color style_text_color Sets the color of text value_color style_text_color Synonym of text_color value_ofs_x x of sub-label Sets the X offet in pixels within the object value_ofs_y y of sub-label Sets the Y offet in pixels within the object text_rule Link the text to a Tasmota rule, see below text_rule_formula Link the text to a Tasmota rule, see below text_rule_format Link the text to a Tasmota rule, see below Attributes related to values Attribute name LVGL equivalent Details min range Set the minimum value of range (int) max range Set the maximum value of range (int) val value Set the value (int) val_rule Link a value to a Tasmota rule, see below val_rule_formula Link a value to a Tasmota rule, see below Attributes specific to arc Attribute name LVGL equivalent Details start_angle bg_start_angle Start angle of the arc background. Angles are in degrees in [0;360] range. Zero degrees is at the middle right (3 o'clock) of the object and the degrees are increasing in clockwise direction. end_angle bg_end_angle End angle of the arc background. start_angle1 start_angle Start angle of the arc indicator. end_angle1 end_angle End angle of the arc indicator. rotation rotation Offset to the 0 degree position type mode Sets the arc mode 0 : lv.ARC_MODE_NORMAL 1 : lv.ARC_MODE_REVERSE 2 : lv.ARC_MODE_SYMMETRICAL pad_top2 style_pad_top Top padding for lv.PART_KNOB part pad_bottom2 style_pad_bottom Bottom padding for lv.PART_KNOB part pad_left2 style_pad_left Left padding for lv.PART_KNOB part pad_right2 style_pad_right Right padding for lv.PART_KNOB part pad_all2 style_pad_all Set all 4 padding for lv.PART_KNOB part (write-only) radius2 style_radius Radius for lv.PART_KNOB part Attributes specific to img Attribute name LVGL equivalent Details src src Path to the image in the file-system image_recolor style_image_recolor Color used to recolor the image image_recolor_opa style_image_recolor_opa Opacity of image recoloring angle angle Angle of the image, in 1/10th of degrees. Range 0..3600. Attributes specific to roller Attribute name LVGL equivalent Details text selected_text (read-only) Get the text of the currently selected item. The string is truncated to the first 256 bytes. Attributes specific to spinner Attribute name LVGL equivalent Details angle The length of the spinning segment in degrees - can be changed after initial value since v12.1.1.1 speed The time for 1 turn in ms - can be changed after initial value since v12.1.1.1 Attributes specific to qrcode Attribute name LVGL equivalent Details qr_size Size in pixels of the QRCode, always square (height = width). This cannot be changed once the object is created. qr_dark_color Color used for the dark pixels. This cannot be changed once the object is created. qr_light_color Color used for the light pixels. This cannot be changed once the object is created. qr_text (mandatory) String to encode as a QRCode, can be changed at any moment. Tasmota extensions ~ Update sensor value via rules ~ You can automatically adjust attributes val and text from sensor values via a simple rule engine. attribute description val_rule Rule pattern to trigger an update of the val attribute. Example: \"val_rule\":\"ESP32#Temperature\" val_rule_formula Optional expression (using Berry) to transform the value extracted from the rule to the value pushed to val . This typically allows to adjust ranges of values. Input value is always converted to float not int . The input value is named val . Example: \"val_rule_formula\":\"val / 1000\" Changing a text attribute from rules: attribute description text_rule Rule pattern to trigger an update of the text attribute. Example: \"text_rule\":\"ESP32#Temperature\" text_rule_formula Optional expression (using Berry) to transform the value extracted from the rule to the value pushed to val . This typically allows to adjust ranges of values. Input value is always converted to float not int . The input value is named val . Example: \"val_rule_formula\":\"val * 10\" text_rule_format String format of the result string. The format uses Berry's string.format() , which is a subset of printf format. Example: \"text_rule_format\":\"%2.1f \u00b0C\" React to user actions ~ Every time the user touches an active element on the screen, HASPmota publishes internal events you can listen and react to. For example if you press a button p1b10 , HASPmota publishes an event {\"hasp\":{\"p1b10\":{\"event\":\"up\"}} when the button is released. You can easily create a rule to react to this event. Example: tasmota . add_rule ( \"hasp#p1b10#event==up\" , / -> print ( \"Button p1b10 pressed\" )) Events with value changed indicate that the value of the widgets has changed. Events are only fired if the change in value comes from a screen interaction. No event is fired when the value was changed programatically. The new value is sent as val attribute, and for specific widgets (roller) a text attribute is sent for the label of the value. {\"hasp\":{\"p1b1\":{\"val\":3,\"text\":\"A3\",\"event\":\"changed\"}}} Example: tasmota . add_rule ( \"hasp#p1b1#text\" , / text -> print ( \"p1b1 text value=\" , text )) Run arbitrary Berry code ~ Inserting an attribute berry_run to any object will compile and run the embedded Berry code during widget initialization. One common use is to trigger sensors read every 2 seconds: { \"comment\" : \"--- Trigger sensors every 2 seconds ---\" , \"berry_run\" : \"tasmota.add_cron('*/2 * * * * *', def () tasmota.publish_rule(tasmota.read_sensors()) end, 'oh_every_5_s')\" }","title":"HASPmota"},{"location":"HASPmota/#haspmota","text":"This feature is experimental Tasmota is happy to support openHASP compatible format (named HASPmota), which allows to describe rich graphics interfaces using simple JSON templates. HASPmota support leverages the power of LVGL and the Berry language , but doesn't need to code nor learn the LVGL API. This feature is heavily inspired from @fvanroie's openHASP project .","title":"HASPmota "},{"location":"HASPmota/#minimal-requirements","text":"Hardware : HASPmota is supported on all ESP32 variants, and requires a display configured with universal display (using display.ini or autoconf ). You should see a splash screen at startup. Currently PSRAM is required to run HASPmota. The core engine is compiled and loaded in memory, which makes it unsuitable for ESP32 without PSRAM. Future versions Firmware : you need a tasmota firmware with LVGL support, like tasmota32-lvgl or a self-compiled version.","title":"Minimal requirements"},{"location":"HASPmota/#quick-tour","text":"You can see HASPmota in action in a couple of minutes. Upload in your ESP32 file system the following files, from: https://github.com/arendst/Tasmota/tree/development/tasmota/berry/haspmota haspmota_widgets.tapp (contains widgets for wifi, logging and general info) robotocondensed_latin1.tapp (contains additional fonts) haspmota.tapp (contains the core HASPmota engine) pages.jsonl (contains a sample definition) Restart and enjoy. You should see the following screen, and click on buttons to switch to the second screen:","title":"Quick tour"},{"location":"HASPmota/#understanding-the-template","text":"HASPmota automatically loads the template from a file named pages.jsonl . This file contains JSON Lines, i.e. a single JSON document per line. Each line describes an element on the screen. Elements are groupes into pages. Page 0 contains objects that are displayed on all screens. They are typically used for headers and menus. The lines below define the header label (red background) and the clock and wifi widgets. { \"page\" : 0 , \"comment\" : \"---------- Upper stat line ----------\" } { \"id\" : 11 , \"obj\" : \"label\" , \"x\" : 0 , \"y\" : 0 , \"w\" : 320 , \"pad_right\" : 90 , \"h\" : 22 , \"bg_color\" : \"#D00000\" , \"bg_opa\" : 255 , \"radius\" : 0 , \"border_side\" : 0 , \"text\" : \"Tasmota\" , \"text_font\" : \"montserrat-20\" } { \"id\" : 15 , \"obj\" : \"lv_wifi_arcs\" , \"x\" : 291 , \"y\" : 0 , \"w\" : 29 , \"h\" : 22 , \"radius\" : 0 , \"border_side\" : 0 , \"bg_color\" : \"#000000\" , \"line_color\" : \"#FFFFFF\" } { \"id\" : 16 , \"obj\" : \"lv_clock\" , \"x\" : 232 , \"y\" : 3 , \"w\" : 55 , \"h\" : 16 , \"radius\" : 0 , \"border_side\" : 0 } The lines below describe the 3 buttons at the bottom, and their respective actions. { \"comment\" : \"---------- Bottom buttons - prev/home/next ----------\" } { \"id\" : 101 , \"obj\" : \"btn\" , \"x\" : 20 , \"y\" : 210 , \"w\" : 80 , \"h\" : 25 , \"action\" : \"prev\" , \"bg_color\" : \"#1fa3ec\" , \"radius\" : 10 , \"border_side\" : 1 , \"text\" : \"\\uF053\" , \"text_font\" : \"montserrat-20\" } { \"id\" : 102 , \"obj\" : \"btn\" , \"x\" : 120 , \"y\" : 210 , \"w\" : 80 , \"h\" : 25 , \"action\" : \"back\" , \"bg_color\" : \"#1fa3ec\" , \"radius\" : 10 , \"border_side\" : 1 , \"text\" : \"\\uF015\" , \"text_font\" : \"montserrat-20\" } { \"id\" : 103 , \"obj\" : \"btn\" , \"x\" : 220 , \"y\" : 210 , \"w\" : 80 , \"h\" : 25 , \"action\" : \"next\" , \"bg_color\" : \"#1fa3ec\" , \"radius\" : 10 , \"border_side\" : 1 , \"text\" : \"\\uF054\" , \"text_font\" : \"montserrat-20\" } Page 1 is the default page, and contains different widgets types: labels and arc. The values are changed at runtime via Tasmota's rule system, see below for details. { \"page\" : 1 , \"comment\" : \"---------- Page 1 ----------\" } { \"id\" : 0 , \"bg_color\" : \"#0000A0\" , \"bg_grad_color\" : \"#000000\" , \"bg_grad_dir\" : 1 , \"text_color\" : \"#FFFFFF\" } { \"id\" : 2 , \"obj\" : \"arc\" , \"x\" : 20 , \"y\" : 65 , \"w\" : 80 , \"h\" : 100 , \"border_side\" : 0 , \"type\" : 0 , \"rotation\" : 0 , \"start_angle\" : 180 , \"end_angle\" : 0 , \"start_angle1\" : 180 , \"value_font\" : 12 , \"value_ofs_x\" : 0 , \"value_ofs_y\" : -14 , \"bg_opa\" : 0 , \"text\" : \"--.-\u00b0C\" , \"min\" : 200 , \"max\" : 800 , \"val\" : 0 , \"val_rule\" : \"ESP32#Temperature\" , \"val_rule_formula\" : \"val * 10\" , \"text_rule\" : \"ESP32#Temperature\" , \"text_rule_format\" : \"%2.1f \u00b0C\" } { \"id\" : 5 , \"obj\" : \"label\" , \"x\" : 2 , \"y\" : 35 , \"w\" : 120 , \"text\" : \"Temperature\" , \"align\" : 1 } { \"id\" : 10 , \"obj\" : \"label\" , \"x\" : 172 , \"y\" : 35 , \"w\" : 140 , \"text\" : \"MPU\" , \"align\" : 0 } { \"id\" : 11 , \"obj\" : \"label\" , \"x\" : 172 , \"y\" : 55 , \"w\" : 140 , \"text\" : \"x=\" , \"align\" : 0 , \"text_rule\" : \"MPU9250#AX\" , \"text_rule_format\" : \"x=%6.3f\" , \"text_rule_formula\" : \"val / 1000\" } { \"id\" : 12 , \"obj\" : \"label\" , \"x\" : 172 , \"y\" : 75 , \"w\" : 140 , \"text\" : \"y=\" , \"align\" : 0 , \"text_rule\" : \"MPU9250#AY\" , \"text_rule_format\" : \"y=%6.3f\" , \"text_rule_formula\" : \"val / 1000\" } { \"id\" : 13 , \"obj\" : \"label\" , \"x\" : 172 , \"y\" : 95 , \"w\" : 140 , \"text\" : \"z=\" , \"align\" : 0 , \"text_rule\" : \"MPU9250#AZ\" , \"text_rule_format\" : \"z=%6.3f\" , \"text_rule_formula\" : \"val / 1000\" } Page 2 contains custom widgets as Berry code. These widgets are imported within haspmota_widgets.tapp { \"page\" : 2 , \"comment\" : \"---------- Page 2 ----------\" } { \"id\" : 0 , \"bg_color\" : \"#0000A0\" , \"bg_grad_color\" : \"#000000\" , \"bg_grad_dir\" : 1 , \"text_color\" : \"#FFFFFF\" } { \"comment\" : \"---------- Wifi status ----------\" } { \"id\" : 20 , \"obj\" : \"lv_wifi_graph\" , \"x\" : 257 , \"y\" : 25 , \"w\" : 60 , \"h\" : 40 , \"radius\" : 0 } { \"id\" : 21 , \"obj\" : \"lv_tasmota_info\" , \"x\" : 3 , \"y\" : 25 , \"w\" : 251 , \"h\" : 40 , \"radius\" : 0 } { \"id\" : 22 , \"obj\" : \"lv_tasmota_log\" , \"x\" : 3 , \"y\" : 68 , \"w\" : 314 , \"h\" : 90 , \"radius\" : 0 , \"text_font\" : 12 } Finally, the following line allows to run arbitrary Berry code. { \"comment\" : \"--- Trigger sensors every 2 seconds ---\" , \"berry_run\" : \"tasmota.add_cron('*/2 * * * * *', def () tasmota.publish_rule(tasmota.read_sensors()) end, 'oh_every_5_s')\" } The code trigger a read of sensors every 2 seconds and publish the JSON result to be parsed by the rule engine. tasmota . add_cron ( '*/2 * * * * *' , def () tasmota . publish_rule ( tasmota . read_sensors ()) end , 'oh_every_5_s' )","title":"Understanding the template"},{"location":"HASPmota/#haspmota-reference","text":"","title":"HASPmota reference"},{"location":"HASPmota/#integration-to-berry","text":"","title":"Integration to Berry"},{"location":"HASPmota/#pages","text":"Pages object are identified by object if 0 . Example: { \"page\" : 1 , \"id\" : 0 , \"bg_color\" : \"#0000A0\" , \"bg_grad_color\" : \"#000000\" , \"bg_grad_dir\" : 1 , \"text_color\" : \"#FFFFFF\" } Internally HASPmota pages are implemented with LVGL screens, i.e. a parent object. Page 0 is a special page that is displays over every screens. It is the perfect place to put navigation menus. It is implement as lv.layer_top() . Page 1 is always present and the default page. Attributes specific to page Details prev (int) target page number when pressing PREV button next (int) target page number when pressing NEXT button home (int) target page number when pressing HOME button And generally all object attributes","title":"Pages"},{"location":"HASPmota/#classes-of-widgets","text":"Attribute \"obj\" can take the following values: HASPmota Class Embedded LVGL class obj lv.obj btn lv.btn switch lv.switch checkbox lv.checkbox label lv.label spinner lv.spinner line lv.line img lv.img dropdown lv.dropdown roller lv.roller btnmatrix lv.btnmatrix bar lv.bar slider lv.slider arc lv.arc textarea lv.textarea qrcode lv.qrcode You can also import custom widget as long as they inherit from lv.obj and the class name matches the module name. Example: \"obj\":\"lv_wifi_graph\" will trigger the followin: - import lv_wifi_graph - instanciation of lv_wifi_graph(parent) object - if successful, it can be used like a typical HASPmota object","title":"Classes of widgets"},{"location":"HASPmota/#attributes","text":"Below are the standard attributes: Attribute name LVGL equivalent Details comment Ignored page 0 to 15 Parent screen object Page id for the current object. If not present, takes the value of the current page id 0..255 Id number of the object. Id 0 means the entire page. A global berry object is created with name p<page>b<id> (ex: p1b10 ) obj widget class Class of the widget (see above). If not present, the entire JSON line is ignored action \"next\" , \"prev\" , \"back\" or \"p<x>\" Switch to page when the object is touched x x X coordinate of top left corner y y Y coordinate of top left corner (Y is pointing down) h height Height in pixels w width Width in pixels hidden flag lv.OBJ_FLAG_HIDDEN Object is hidden (bool) enabled flag lv.OBJ_FLAG_CLICKABLE Object is touch/clickable (bool) click flag lv.OBJ_FLAG_CLICKABLE Synonym of enabled . Object is touch/clickable (bool) toggle flag lv.STATE_CHECKED When enabled, creates a toggle-on/toggle-off button. If false, creates a normal button. TODO check if bool or string radius style_radius Radius of rounded corners bg_opa style_bg_opa Opacity: 0 is transparent, 255 is opaque bg_color style_bg_color Color of background, format is #RRGGBB bg_grad_color style_bg_grad_color Color of background gradient bg_grad_dir style_bg_grad_dir Gradient direction 0 : none 1 : Vertical (top to bottom) gradient 2 : Horizontal (left to right) gradient border_side style_border_side Borders to be displayed (add all values) 0 : none 1 : bottom 2 : top 4 : left 8 : bottom 15 : full (all 4) border_width style_border_width Width of border in pixels border_color style_border_color line_color style_line_color Color of line line_width style_line_width line_width1 style_arc_width Sets the line width of an arc indicator part pad_left style_pad_left Left padding in pixels pad_right style_pad_right Right padding in pixels pad_top style_pad_top Top padding in pixels pad_bottom style_pad_bottom Bottom padding in pixels pad_all style_pad_all Sets all 4 padding values at once (Write-only) Attributes related to text content Attribute name LVGL equivalent Details text text Sets the inner text of the object. If the native LVGL object does not support text (like lv.btn ), a lv.label sub-object is automatically created. value_str text Synonym of text align style_text_align Set alignment for text 0 or \"left\" : lv.TEXT_ALIGN_LEFT 1 or \"center\" : lv.TEXT_ALIGN_CENTER 2 or \"right\" : lv.TEXT_ALIGN_RIGHT text_font style_text_font Sets the font name and size for the text. If int , the default font is robotocondensed_latin1 and the parameter sets the size If string , the font is in the form <font_name>-<font_size> , example: montserrat-20 or in the form A:<font_file> to load a binary font from the file-system. value_font style_text_font Synonym of text_font text_color style_text_color Sets the color of text value_color style_text_color Synonym of text_color value_ofs_x x of sub-label Sets the X offet in pixels within the object value_ofs_y y of sub-label Sets the Y offet in pixels within the object text_rule Link the text to a Tasmota rule, see below text_rule_formula Link the text to a Tasmota rule, see below text_rule_format Link the text to a Tasmota rule, see below Attributes related to values Attribute name LVGL equivalent Details min range Set the minimum value of range (int) max range Set the maximum value of range (int) val value Set the value (int) val_rule Link a value to a Tasmota rule, see below val_rule_formula Link a value to a Tasmota rule, see below Attributes specific to arc Attribute name LVGL equivalent Details start_angle bg_start_angle Start angle of the arc background. Angles are in degrees in [0;360] range. Zero degrees is at the middle right (3 o'clock) of the object and the degrees are increasing in clockwise direction. end_angle bg_end_angle End angle of the arc background. start_angle1 start_angle Start angle of the arc indicator. end_angle1 end_angle End angle of the arc indicator. rotation rotation Offset to the 0 degree position type mode Sets the arc mode 0 : lv.ARC_MODE_NORMAL 1 : lv.ARC_MODE_REVERSE 2 : lv.ARC_MODE_SYMMETRICAL pad_top2 style_pad_top Top padding for lv.PART_KNOB part pad_bottom2 style_pad_bottom Bottom padding for lv.PART_KNOB part pad_left2 style_pad_left Left padding for lv.PART_KNOB part pad_right2 style_pad_right Right padding for lv.PART_KNOB part pad_all2 style_pad_all Set all 4 padding for lv.PART_KNOB part (write-only) radius2 style_radius Radius for lv.PART_KNOB part Attributes specific to img Attribute name LVGL equivalent Details src src Path to the image in the file-system image_recolor style_image_recolor Color used to recolor the image image_recolor_opa style_image_recolor_opa Opacity of image recoloring angle angle Angle of the image, in 1/10th of degrees. Range 0..3600. Attributes specific to roller Attribute name LVGL equivalent Details text selected_text (read-only) Get the text of the currently selected item. The string is truncated to the first 256 bytes. Attributes specific to spinner Attribute name LVGL equivalent Details angle The length of the spinning segment in degrees - can be changed after initial value since v12.1.1.1 speed The time for 1 turn in ms - can be changed after initial value since v12.1.1.1 Attributes specific to qrcode Attribute name LVGL equivalent Details qr_size Size in pixels of the QRCode, always square (height = width). This cannot be changed once the object is created. qr_dark_color Color used for the dark pixels. This cannot be changed once the object is created. qr_light_color Color used for the light pixels. This cannot be changed once the object is created. qr_text (mandatory) String to encode as a QRCode, can be changed at any moment.","title":"Attributes"},{"location":"HASPmota/#tasmota-extensions","text":"","title":"Tasmota extensions"},{"location":"HASPmota/#update-sensor-value-via-rules","text":"You can automatically adjust attributes val and text from sensor values via a simple rule engine. attribute description val_rule Rule pattern to trigger an update of the val attribute. Example: \"val_rule\":\"ESP32#Temperature\" val_rule_formula Optional expression (using Berry) to transform the value extracted from the rule to the value pushed to val . This typically allows to adjust ranges of values. Input value is always converted to float not int . The input value is named val . Example: \"val_rule_formula\":\"val / 1000\" Changing a text attribute from rules: attribute description text_rule Rule pattern to trigger an update of the text attribute. Example: \"text_rule\":\"ESP32#Temperature\" text_rule_formula Optional expression (using Berry) to transform the value extracted from the rule to the value pushed to val . This typically allows to adjust ranges of values. Input value is always converted to float not int . The input value is named val . Example: \"val_rule_formula\":\"val * 10\" text_rule_format String format of the result string. The format uses Berry's string.format() , which is a subset of printf format. Example: \"text_rule_format\":\"%2.1f \u00b0C\"","title":"Update sensor value via rules"},{"location":"HASPmota/#react-to-user-actions","text":"Every time the user touches an active element on the screen, HASPmota publishes internal events you can listen and react to. For example if you press a button p1b10 , HASPmota publishes an event {\"hasp\":{\"p1b10\":{\"event\":\"up\"}} when the button is released. You can easily create a rule to react to this event. Example: tasmota . add_rule ( \"hasp#p1b10#event==up\" , / -> print ( \"Button p1b10 pressed\" )) Events with value changed indicate that the value of the widgets has changed. Events are only fired if the change in value comes from a screen interaction. No event is fired when the value was changed programatically. The new value is sent as val attribute, and for specific widgets (roller) a text attribute is sent for the label of the value. {\"hasp\":{\"p1b1\":{\"val\":3,\"text\":\"A3\",\"event\":\"changed\"}}} Example: tasmota . add_rule ( \"hasp#p1b1#text\" , / text -> print ( \"p1b1 text value=\" , text ))","title":"React to user actions"},{"location":"HASPmota/#run-arbitrary-berry-code","text":"Inserting an attribute berry_run to any object will compile and run the embedded Berry code during widget initialization. One common use is to trigger sensors read every 2 seconds: { \"comment\" : \"--- Trigger sensors every 2 seconds ---\" , \"berry_run\" : \"tasmota.add_cron('*/2 * * * * *', def () tasmota.publish_rule(tasmota.read_sensors()) end, 'oh_every_5_s')\" }","title":"Run arbitrary Berry code"},{"location":"HC-SR04/","text":"HC-SR04 ultrasonic ranging sensor ~ This feature is included only in tasmota-sensors binary When compiling your build add the following to user_config_override.h : #ifndef USE_SR04 #define USE_SR04 // Add support for HC-SR04 ultrasonic devices (+1k code) #define SR04_MAX_SENSOR_DISTANCE 500 // Set sensor max detection distance #endif HC-SR04 (HC-SR04P and JSN-SR04T) is an ultrasonic ranging sensor. Provides 2cm to 300cm of non-contact measurement functionality with a ranging accuracy that can reach up to 3mm. Each HC-SR04 module includes an ultrasonic transmitter, a receiver and a control circuit. See HC-SR04 Ultrasonic Sensor for more information. Buy example: - AliExpress - Sparkfun The US-100 can also be use as a HC-SR04 if you remove the jumper at the back (check Adafruit documentation). Configuration ~ Wiring ~ HC-SR04 ESP Vcc 5V GND GND Trig GPIOx Echo use voltage divider! GPIOy The HC-SR04 operates at 5V and therefore the echo signal will be 5V as well. Connecting the echo pin via a voltage divider (see schematic) will divide the 5V to 3.3V, which is the operating voltage of an ESP8266. There is a variant of the HC-SR04, called HC-SR04P. It mainly operates at 3.3V and then it doesn't need the voltage divider but you will notice a range drop of about 1 meter. Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to SR04 Tri (69) GPIOy to SR04 Ech (70) Tasmota Main ~ After a reboot webUI displays the HC-SR04 distance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T22:42:35\" , \"SR04\" :{ \"Distance\" : 16.754 }}","title":"HC-SR04 ultrasonic ranging sensor"},{"location":"HC-SR04/#hc-sr04-ultrasonic-ranging-sensor","text":"This feature is included only in tasmota-sensors binary When compiling your build add the following to user_config_override.h : #ifndef USE_SR04 #define USE_SR04 // Add support for HC-SR04 ultrasonic devices (+1k code) #define SR04_MAX_SENSOR_DISTANCE 500 // Set sensor max detection distance #endif HC-SR04 (HC-SR04P and JSN-SR04T) is an ultrasonic ranging sensor. Provides 2cm to 300cm of non-contact measurement functionality with a ranging accuracy that can reach up to 3mm. Each HC-SR04 module includes an ultrasonic transmitter, a receiver and a control circuit. See HC-SR04 Ultrasonic Sensor for more information. Buy example: - AliExpress - Sparkfun The US-100 can also be use as a HC-SR04 if you remove the jumper at the back (check Adafruit documentation).","title":"HC-SR04 ultrasonic ranging sensor"},{"location":"HC-SR04/#configuration","text":"","title":"Configuration"},{"location":"HC-SR04/#wiring","text":"HC-SR04 ESP Vcc 5V GND GND Trig GPIOx Echo use voltage divider! GPIOy The HC-SR04 operates at 5V and therefore the echo signal will be 5V as well. Connecting the echo pin via a voltage divider (see schematic) will divide the 5V to 3.3V, which is the operating voltage of an ESP8266. There is a variant of the HC-SR04, called HC-SR04P. It mainly operates at 3.3V and then it doesn't need the voltage divider but you will notice a range drop of about 1 meter.","title":"Wiring"},{"location":"HC-SR04/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to SR04 Tri (69) GPIOy to SR04 Ech (70)","title":"Tasmota Settings"},{"location":"HC-SR04/#tasmota-main","text":"After a reboot webUI displays the HC-SR04 distance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T22:42:35\" , \"SR04\" :{ \"Distance\" : 16.754 }}","title":"Tasmota Main"},{"location":"HM-10/","text":"HM-10 Bluetooth module ~ This feature is included only in tasmota-sensors When compiling your build add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support BLE sensor bridge (+5k1 code) #endif #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-10 is a Bluetooth BLE V4.0 module based on TI CC254x chip. Originally manufactured by Jinan Huamao but there are many clones in the market ( MLT-BT05, CC41-A , JDY-08 , AT-09, ...) While they look similar and utilize the same CC254x Bluetooth chip, the firmware on them is different. In order to get any type of module to work work Tasmota it is mandatory to flash the original firmware on it . Use the newest V710 firmware but at least V609 is required to work with the Tasmota driver. Tip It is possible to do this without soldering by directly sticking male jumper wire connectors through the plastic foil on some boards or using some removable adhesives (bluetack). Configuration ~ Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (preferably HMSoft V707 ). Only when you're sure everything is ok proceed with the configuration. Wiring ~ HM-10 ESP GND GND VCC 3.3V TX GPIOx RX GPIOy You can use TX and RX pins for GPIOx, GPIOy. Tasmota Settings for BLE sensors ~ In the Configuration -> Configure Module page assign: GPIOx to HM10 TX (195) GPIOy to HM10 RX (194) If you have the proper firmware, webUI in the Main Menu should show (in this case V707 is the flashed firmware version): If you have supported Bluetooth devices in range, they will soon be discovered and start to populate the webUI with data as it is transmitted: Warning Most of the self-flashed modules will still have their factory default settings with baud rate of 9600 but Tasmota requires 115200. To fix try commands from Tasmota console: HM10Baud 9600 (sets 9600 baud rate on Tasmota side) then HM10AT RENEW (reset HM10 to factory settings which should use 115200 baud rate on newer firmware) and reboot Tasmota. If that doesn't solve it you will have to connect to the HM-10 with serial-to-USB adapter and set the baudrate in a terminal using commands AT+RENEW then AT+BAUD? . If the output is 4 baudrate is properly set to 115200, if not use AT+BAUD4 For a complete overview of supported devices, commands and features read the Bluetooth article Tasmota Settings for iBeacon ~ In the Configuration -> Configure Module page assign: GPIOx to iBeacon TX (168) GPIOy to iBeacon RX (169) When first connected HM-10 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article Breakout Boards ~","title":"HM-10 Bluetooth module"},{"location":"HM-10/#hm-10-bluetooth-module","text":"This feature is included only in tasmota-sensors When compiling your build add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support BLE sensor bridge (+5k1 code) #endif #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-10 is a Bluetooth BLE V4.0 module based on TI CC254x chip. Originally manufactured by Jinan Huamao but there are many clones in the market ( MLT-BT05, CC41-A , JDY-08 , AT-09, ...) While they look similar and utilize the same CC254x Bluetooth chip, the firmware on them is different. In order to get any type of module to work work Tasmota it is mandatory to flash the original firmware on it . Use the newest V710 firmware but at least V609 is required to work with the Tasmota driver. Tip It is possible to do this without soldering by directly sticking male jumper wire connectors through the plastic foil on some boards or using some removable adhesives (bluetack).","title":"HM-10 Bluetooth module"},{"location":"HM-10/#configuration","text":"Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (preferably HMSoft V707 ). Only when you're sure everything is ok proceed with the configuration.","title":"Configuration"},{"location":"HM-10/#wiring","text":"HM-10 ESP GND GND VCC 3.3V TX GPIOx RX GPIOy You can use TX and RX pins for GPIOx, GPIOy.","title":"Wiring"},{"location":"HM-10/#tasmota-settings-for-ble-sensors","text":"In the Configuration -> Configure Module page assign: GPIOx to HM10 TX (195) GPIOy to HM10 RX (194) If you have the proper firmware, webUI in the Main Menu should show (in this case V707 is the flashed firmware version): If you have supported Bluetooth devices in range, they will soon be discovered and start to populate the webUI with data as it is transmitted: Warning Most of the self-flashed modules will still have their factory default settings with baud rate of 9600 but Tasmota requires 115200. To fix try commands from Tasmota console: HM10Baud 9600 (sets 9600 baud rate on Tasmota side) then HM10AT RENEW (reset HM10 to factory settings which should use 115200 baud rate on newer firmware) and reboot Tasmota. If that doesn't solve it you will have to connect to the HM-10 with serial-to-USB adapter and set the baudrate in a terminal using commands AT+RENEW then AT+BAUD? . If the output is 4 baudrate is properly set to 115200, if not use AT+BAUD4 For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for BLE sensors"},{"location":"HM-10/#tasmota-settings-for-ibeacon","text":"In the Configuration -> Configure Module page assign: GPIOx to iBeacon TX (168) GPIOy to iBeacon RX (169) When first connected HM-10 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for iBeacon"},{"location":"HM-10/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"HM-17/","text":"HM-17 Bluetooth module ~ This feature is included only in tasmota-sensors When compiling your build add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support BLE sensor bridge (+5k1 code) #endif #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-17 and HM-16 are a Bluetooth BLE V4.1 module based on TI CC2640R2f chip. Manufactured by Jinan Huamao Configuration ~ Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (firmware V120 or V110). Only when you're sure everything is ok proceed with the configuration. Wiring ~ HM-16/17 ESP GND GND VCC 3.3V TX GPIOx RX GPIOy Tasmota Settings for iBeacon ~ In the Configuration -> Configure Module page assign: GPIOx to iBeacon TX (168) GPIOy to iBeacon RX (169) When first connected HM-16/17 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article Breakout Boards ~","title":"HM-17 Bluetooth module"},{"location":"HM-17/#hm-17-bluetooth-module","text":"This feature is included only in tasmota-sensors When compiling your build add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support BLE sensor bridge (+5k1 code) #endif #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-17 and HM-16 are a Bluetooth BLE V4.1 module based on TI CC2640R2f chip. Manufactured by Jinan Huamao","title":"HM-17 Bluetooth module"},{"location":"HM-17/#configuration","text":"Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (firmware V120 or V110). Only when you're sure everything is ok proceed with the configuration.","title":"Configuration"},{"location":"HM-17/#wiring","text":"HM-16/17 ESP GND GND VCC 3.3V TX GPIOx RX GPIOy","title":"Wiring"},{"location":"HM-17/#tasmota-settings-for-ibeacon","text":"In the Configuration -> Configure Module page assign: GPIOx to iBeacon TX (168) GPIOy to iBeacon RX (169) When first connected HM-16/17 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for iBeacon"},{"location":"HM-17/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"HRG15/","text":"Hydreon RG-15 Solid State Rain Sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_HRG15 #define USE_HRG15 // Add support for Hydreon RG-15 Solid State Rain sensor (+1k5 code) #endif The Hydreon RG-15 Solid State Tipping Bucket is a rainfall measuring device intended to replace conventional tipping buckets. The RG-15 uses beams of infrared light within a plastic lens about the size of a tennis ball. The round surface of the lens discourages collection of debris, and the RG-15 has no moving parts to stick, and no water-pathways to clog. The device features an open-collector output that emulates a conventional tipping bucket, as well as serial communications that provide more detailed data and allow for configuration of the device. Find out more on the manufacturer's website . Configuration ~ Wiring ~ HRG15 ESP GND (1) GND V+ 3.3V (8) 3.3V RS232 Out (4) GPIOx RS232 In (5) GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to HRG15 Rx GPIOy to HRG15 Tx Commands ~ Sensor90 can be used to configure the rain sensor Tasmota Display ~ After a reboot the driver will detect the sensor and show the sensor data. An example is given below: Item Value RG-15 Active 0.01 mm RG-15 Event 0.13 mm RG-15 Total 26.8 mm RG-15 FlowRate 0.32 mm.h This data is also part of the tele/%topic%/SENSOR payload: { \"Time\" : \"2021-08-25T17:15:45\" , \"RG-15\" : { \"Active\" : 0.01 , \"Event\" : 0.13 , \"Total\" : 26.80 , \"FlowRate\" : 0.32 }, \"TempUnit\" : \"C\" } MQTT ~ The sensor data is made available over MQTT as per the configured TelePeriod . Additionally, instant telemetry messages are sent during active rainfall events. The sensor will report additional accumulation every 5-60 seconds. The driver resets the Active and FlowRate values to 0 if no additional accumuatlion is detected after 60 seconds.","title":"Hydreon RG-15 Solid State Rain Sensor"},{"location":"HRG15/#hydreon-rg-15-solid-state-rain-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_HRG15 #define USE_HRG15 // Add support for Hydreon RG-15 Solid State Rain sensor (+1k5 code) #endif The Hydreon RG-15 Solid State Tipping Bucket is a rainfall measuring device intended to replace conventional tipping buckets. The RG-15 uses beams of infrared light within a plastic lens about the size of a tennis ball. The round surface of the lens discourages collection of debris, and the RG-15 has no moving parts to stick, and no water-pathways to clog. The device features an open-collector output that emulates a conventional tipping bucket, as well as serial communications that provide more detailed data and allow for configuration of the device. Find out more on the manufacturer's website .","title":"Hydreon RG-15 Solid State Rain Sensor"},{"location":"HRG15/#configuration","text":"","title":"Configuration"},{"location":"HRG15/#wiring","text":"HRG15 ESP GND (1) GND V+ 3.3V (8) 3.3V RS232 Out (4) GPIOx RS232 In (5) GPIOy","title":"Wiring"},{"location":"HRG15/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to HRG15 Rx GPIOy to HRG15 Tx","title":"Tasmota Settings"},{"location":"HRG15/#commands","text":"Sensor90 can be used to configure the rain sensor","title":"Commands"},{"location":"HRG15/#tasmota-display","text":"After a reboot the driver will detect the sensor and show the sensor data. An example is given below: Item Value RG-15 Active 0.01 mm RG-15 Event 0.13 mm RG-15 Total 26.8 mm RG-15 FlowRate 0.32 mm.h This data is also part of the tele/%topic%/SENSOR payload: { \"Time\" : \"2021-08-25T17:15:45\" , \"RG-15\" : { \"Active\" : 0.01 , \"Event\" : 0.13 , \"Total\" : 26.80 , \"FlowRate\" : 0.32 }, \"TempUnit\" : \"C\" }","title":"Tasmota Display"},{"location":"HRG15/#mqtt","text":"The sensor data is made available over MQTT as per the configured TelePeriod . Additionally, instant telemetry messages are sent during active rainfall events. The sensor will report additional accumulation every 5-60 seconds. The driver resets the Active and FlowRate values to 0 if no additional accumuatlion is detected after 60 seconds.","title":"MQTT"},{"location":"Home-Assistant/","text":"Home Assistant ~ Home Assistant is an open source home automation solution that puts local control and privacy first. Tasmota communicates with Home Assistant using MQTT. Before going any further, make sure MQTT is properly set up in Home Assistant and Tasmota . Home Assistant can add Tasmota devices using: Official Tasmota integration - preferred and automatic instant discovery of entities Manual configuration by editing configuration.yaml - recommended for marginal use cases, f.e. TuyaMCU fan devices Tasmota Integration ~ Once you configure the Home Assistant integration every new Tasmota device with SetOption19 0 set will be discovered automatically. All Tasmota devices will be listed in their own Tasmota card in Configuration - Integrations menu in Home Assistant. Warning Do not change the FullTopic in order to use this feature. Leave it as default. Tasmota uses DeviceName to name the device in Tasmota integration and FriendlyName<x> to name power outputs (switch or light entities in HA). Use templates to change the Module name Setting the template name will change the Module name as well which will be reflected in Home Assistant. This helps in identifying when dealing with a large number of devices. Its nicer than having 10 Sonoff S31's or a bunch of TuyaMCU's\" Bug If you are using Home Assistant OS MQTT add-on add the following to the ACL file (user section or general section): topic write tasmota/discovery/# to give Tasmota devices write access to the discovery topic. Supported Entities ~ Lights as light entities. Single channel Dimmers, RGB lights, RGB lights with Color Temperature control and RGB lights with White control are supported. Relays as switch entities With SetOption30 1 all relays one the device will be added as light entities instead Sensors as sensor entities Switches as binary_sensor entities or automation triggers depending on SwitchMode used when SetOption114 1 Buttons as automation triggers when SetOption73 is enabled Shutters as cover entities. Currently only shutter modes 1 to 4 are supported. Shutter mode 5 and Tuya shutters are not supported. Devices configured as iFan02 or iFan03 as fan entities. TuyaMCU fans are not supported. Each discovered device will by default add 8 disabled sensors. Enable the ones you need. You cannot delete them, they will simply be re-added on a restart. Types of devices not listed above still require manual configuration Zigbee and Bluetooth devices paired in Tasmota will NOT be discovered in Home Assistant Removing devices ~ You cannot as long as Home Assistant support is enabled in your Tasmota binary. Disable the device in Home Assistant instead. Deleting them from Home Assistant while Tasmota device is still active will eventually rediscover all the entities. Supplemental Custom Discovery Message ~ You can use MQTT Discovery in HA to add sensors and other entities that are not discovered through Tasmota integration and associate them with an already discovered device. When creating the MQTT discovery JSON add this device identifier ,\"device\":{\"connections\":[[\"mac\",\"%macaddr%\"]]} where %macaddr% is the mac address of the device without : . When used in a rule variable %macaddr% will be replaced automatically. There are Home Assistant Blueprints for specific device types to create needed entities at out blueprints GitHub. Look for the icon in templates to one-click import the configuration automation. Examples of creating custom discovery messages: RFID Tag PIR sensor TuyaMCU Air Fryer TuyaMCU Heater Editing configuration.yaml ~ Adding devices manually is done by editing the configuration.yaml file and adding appropriate blocks of yaml code to the corresponding section. After every change to the configuration.yaml file you'll need to restart the MANUALL CONFIGURED MQTT ENTITES in Server Controls to apply the changes. The advantage of manually configuring a device is that you maintain control of all aspects of the configuration. All the configurations are just examples. You need to be familiar with Home Assistant's configuration structure and procedures. Straight copy paste of the given examples into configuration.yaml will probably not work for you. If you are using a localized (non-english) version be sure to check the correct spelling and cases for values: 'payload_available' 'payload_not_available' 'payload_on' 'payload_off' Tip If you want the power states to be persistent in Tasmota and Home Assistant set PowerRetain 1 instead of using retain: true in Home Assistant When using unique_id: make sure its unique to each entity When unique_id is set, Home Assistant will allow some entity customization from the UI such as changing the name or icon. Switches ~ Add in Home Assistant using the MQTT Switch integration. Required Commands SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands for faster updates Single Switch If SetOption26 is enabled, use POWER1 instead of POWER mqtt : switch : - unique_id : tasmota_switch name : \"Tasmota Switch\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/tasmota/POWER\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" Multiple Switches When a device has more than one POWER output (multiple relays or a mix of relays and lights) use corresponding POWER<x> ( POWER1 , POWER2 , etc) mqtt : switch : - unique_id : tas_switch_1 name : \"Tasmota Switch 1\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER1 }}\" command_topic : \"cmnd/tasmota/POWER1\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" - unique_id : tas_switch_2 name : \"Tasmota Switch 2\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER2 }}\" command_topic : \"cmnd/tasmota/POWER2\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" - unique_id : tas_switch_3 name : \"Tasmota Switch 3\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER3 }}\" command_topic : \"cmnd/tasmota/POWER3\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" Tip If you are using a switch device to control a light you may want to use MQTT Light integration instead. Simply replace switch: with light: in the configuration keeping everything else the same. Lights ~ Add in Home Assistant using the MQTT Light integration. All configurations require SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Optional Commands Fade on - makes transitions smoother Speed 5 - set transition speed Dimmer Used for dimmers and dimmable lights (single channel lights). mqtt : light : - name : \"Dimmer\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" RGB Light Should also be used with lights using White Blend Mode SetOption17 1 - enables color status in decimals mqtt : light : - name : \"RGB Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" RGB+W Light In this configuration RGB and white cannot be on at the same time. See Lights for options. SetOption17 1 - enables color status in decimals mqtt : light : - name : \"RGB+W Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" white_value_state_topic : \"tele/tasmota/STATE\" white_value_command_topic : \"cmnd/tasmota/White\" white_value_scale : 100 white_value_template : \"{{ value_json.White }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{value_json.Scheme}}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" RGB+CCT Light Also called RGBWW, RGBCW or 5 channel lights SetOption17 1 - enables color status in decimals mqtt : light : - name : \"RGBCCT Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" color_temp_command_topic : \"cmnd/tasmota/CT\" color_temp_state_topic : \"tele/tasmota/STATE\" color_temp_value_template : \"{{ value_json.CT }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" Addressable LED Applies only to WS281x lights. mqtt : light : - name : \"Addressable LED\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"stat/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"stat/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"stat/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB with hex values If you don't want to use SetOption17 1 with decimal values and use default hex values, change: rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_command_template : \"{{ '%02X%02X%02X' | format(red, green, blue)}}\" rgb_value_template : \"{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}\" Control RGB and White independently Using color picker will keep white light on. If you use the white slider RGB light will get turned off. White value and dimmer value are connected, to have more granular control you will have to split the lights . Replace rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_command_template : \"{{ '%02X%02X%02X=' | format(red, green, blue)}}\" rgb_value_template : \"{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}\" The key is the = after color string in hex. It will retain current white value while changing color. Using schema: template light Thorough explanation of template: schema lights and its features on blakadder.com Sensors ~ Add in Home Assistant using the MQTT Sensor integration. A sensor will send its data in set intervals defined by TelePeriod (default every 5 minutes). Temperature sensor Check your sensor name in Tasmota console and change accordingly. This example uses the DHT22 sensor. mqtt : sensor : - name : \"Tasmota Temperature\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Temperature }}\" unit_of_measurement : \"\u00b0C\" # \"F\" if using Fahrenheit availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : temperature Humidity sensor Check your sensor name in Tasmota and change accordingly. This example uses the DHT22 sensor. mqtt : sensor : - ame : \"Tasmota Humidity\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Humidity }}\" unit_of_measurement : \"%\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : humidity Pressure sensor Check your sensor name in Tasmota and change accordingly. This example uses the BMP280 sensor. mqtt : sensor : - name : \"Tasmota Pressure\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json.BMP280.Pressure }}\" unit_of_measurement : \"hPa\" device_class : pressure Change unit_of_measurement to \"mmHg\" if SetOption24 1 Wi-Fi Signal Quality Monitor the relative Wi-Fi signal quality of a device. sensor : - platform : mqtt name : \"Tasmota Wi-Fi Quality\" state_topic : \"tele/tasmota/STATE\" unit_of_measurement : \"%\" value_template : \"{{value_json['Wifi'].RSSI }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : signal_strength entity_category : diagnostic # moves the entity to the Diagnostic section on the Device Card Power Monitoring ~ Add in Home Assistant using the MQTT Sensor integration. Power monitoring sensors will send their data in set intervals defined by TelePeriod (default every 5 minutes). To get all the data in Home Assistant requires multiple sensors which you can later group to your liking in Lovelace UI Power Monitoring mqtt : sensor : - name : \"Energy Today\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" device_class : energy state_class : measurement - name : \"Power\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" device_class : power state_class : measurement - name : \"Voltage\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" device_class : voltage state_class : measurement - name : \"Current\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Current\"] }}' unit_of_measurement : \"A\" device_class : current state_class : measurement Tip For additional sensors use \"Total\";\"Yesterday\";\"Period\",\"ApparentPower\",\"ReactivePower\";\"Factor\" in value_template string Video tutorial on a power monitoring plug setup by Digiblur Binary Sensors ~ Add in Home Assistant using the MQTT Binary Sensor integration. PIR Sensor Used for a configured PIR Sensor and requires correct SwitchMode with ON/OFF states and this rule: Required Commands Rule1 on Switch1#State=1 do Publish stat/%topic%/MOTION ON endon on Switch1#State=0 do Publish stat/%topic%/MOTION OFF endon Rule1 1 mqtt : binary_sensor : - unique_id : motion_sensor name : \"Tasmota Motion Sensor\" state_topic : \"stat/tasmota/MOTION\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : motion Door Sensor Requires a reed switch configured in Tasmota. Make sure correct SwitchMode is set Required Commands Rule1 on Switch1#State=1 do Publish stat/%topic%/DOOR ON endon on Switch1#State=0 do Publish stat/%topic%/DOOR OFF endon Rule1 1 mqtt : binary_sensor : - unique_id : door_sensor name : \"Tasmota Door Sensor\" state_topic : \"stat/tasmota/GARAGE\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : door # also possible: window, garage_door or opening RF Bridge An RF door sensor configured with an RF receiver in Tasmota. mqtt : binary_sensor : - platform : mqtt name : \"RF bridge rfkey\" payload_on : \"1\" payload_off : \"0\" device_class : opening state_topic : \"tele/tasmota/RESULT\" value_template : '{{ value_json.RfReceived.RfKey }}' Fans ~ Add in Home Assistant using the MQTT Fan integration. Fan Derived from #2839 by @kbickar and @finity69x2 mqtt : fan : - unique_id : tasmota_fan name : \"Tasmota Fan\" command_topic : \"cmnd/tasmota/FanSpeed\" speed_command_topic : \"cmnd/tasmota/FanSpeed\" state_topic : \"stat/tasmota/RESULT\" speed_state_topic : \"stat/tasmota/RESULT\" state_value_template : > {% if value_json.FanSpeed is defined %} {% if value_json.FanSpeed == 0 -%}0{%- elif value_json.FanSpeed > 0 -%}4{%- endif %} {% else %} {% if states.fan.tasmota.state == 'off' -%}0{%- elif states.fan.tasmota.state == 'on' -%}4{%- endif %} {% endif %} speed_value_template : \"{{ value_json.FanSpeed }}\" availability_topic : tele/tasmota/LWT payload_off : \"0\" payload_on : \"4\" payload_low_speed : \"1\" payload_medium_speed : \"2\" payload_high_speed : \"3\" payload_available : \"Online\" payload_not_available : \"Offline\" speeds : - \"off\" - \"low\" - \"medium\" - \"high\" Covers ~ Add in Home Assistant using the MQTT Cover integration. TuyaMCU Curtain/Shade Motor Requires SetOption66 1 . In this example dpId1 is for open/close/stop of the motor, dpId2 sets position and dpId3 displays the current position. # Example configuration.yaml entry mqtt : cover : - unique_id : tuya_curtain name : \"Tuya Curtain\" command_topic : \"cmnd/tasmota/TuyaSend4\" payload_open : \"1,0\" payload_close : \"1,2\" payload_stop : \"1,1\" position_open : 0 position_closed : 100 position_topic : \"tele/tasmota/RESULT\" position_template : >- {% if value_json.TuyaReceived.DpType2Id3 is defined %} {{ value_json.TuyaReceived.DpType2Id3 }} {% else %} {{ state_attr('cover.tuya_curtain','current_position') | int }} {% endif %} set_position_topic : \"cmnd/tasmota/TuyaSend2\" set_position_template : '2,{{ position }}' availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" If you change name: make sure to reflect that change in the value_template cover name! Climate ~ Detailed guide when using MQTT Climate or Generic Thermostat in Home Assistant Device Specific ~ Covers For shutter position to persist in Home Assistant through device reboots, execute PowerRetain 1 . These sample configurations should allow the shutter work in Home Assistant. This is only an example and may need further modification to work in your environment. This example uses a new configuration for roller shutters with options for positioning. It assumes that %prefix%/%topic%/ is configured in the Tasmota Full Topic MQTT parameter. mqtt : cover : - name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : stat/%topic%/Shutter1 position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 Check Issue 130 for more information about this configuration. Another integration example: mqtt : cover : - name : \"Test\" availability_topic : \"tele/%topic%/LWT\" state_topic : \"stat/%topic%/RESULT\" command_topic : \"cmnd/%topic%/Backlog\" value_template : '{{ value | int }}' qos : 1 retain : false payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" state_open : \"ON\" state_closed : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" optimistic : false tilt_command_topic : 'cmnd/%topic%/ShutterPosition1' tilt_status_topic : 'cmnd/%topic%/ShutterPosition1' set_position_topic : 'cmnd/%topic%/ShutterPosition1' position_topic : \"stat/%topic%/SHUTTER1\" tilt_min : 0 tilt_max : 100 tilt_closed_value : 0 tilt_opened_value : 100 Integration example with position updated during movement (Tasmota versions >= v8.1.0.5): mqtt : cover : - name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : \"stat/%topic%/RESULT\" position_template : > {% if ('Shutter1' in value_json) and ('Position' in value_json.Shutter1) %} {{ value_json.Shutter1.Position }} {% else %} {% if is_state('cover.balcony_blinds', 'unknown') %} 50 {% else %} {{ state_attr('cover.balcony_blinds','current_position') }} {% endif %} {% endif %} position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" In addition, add to your home assistant start up automation a query for the current shutter position: - alias : \"Power state on HA start-up\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/%shutters grouptopic%/shutterposition\" payload : \"\" Zigbee Devices ~ Warning The following Zigbee examples assume SetOption83 , SetOption89 , SetOption100 , SetOption112 , SetOption118 , SetOption119 are all set to 0 . Setting any of these to 1 will change topic and/or payload structure from that used in the examples. Dimmable Light This configuration is for a dimmable light reporting on 0xE1F9 using endpoint 1, cluster 8 for brightness. ZbRead part in the template is needed to always update the brightness values. # Example configuration.yaml entry mqtt : light : - schema : template name : \"Fire Light\" command_topic : \"cmnd/zigbee-gateway/Backlog\" state_topic : \"tele/zigbee-gateway/SENSOR\" command_on_template : > {%- if brightness is defined -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Dimmer\":{{ brightness }} } }; ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- else -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- endif -%} command_off_template : 'ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":false} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 }' state_template : > {% if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Power is defined %} {% if value_json.ZbReceived['0xE1F9'].Power == true %} on {% else %} off {% endif %} {% else %} {{ states('light.fire_light') }} {% endif %} brightness_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Dimmer is defined -%} {{ value_json['ZbReceived']['0xE1F9'].Dimmer | int }} {%- else -%} {{ state_attr('light.fire_light', 'brightness') | int }} {%- endif -%} Water Leak Sensor This specific configuration is for Xiaomi Aqara Water Leak sensor reporting on 0x099F . # Example configuration.yaml entry mqtt : binary_sensor : - name : \"Water Leak\" state_topic : \"tele/zigbee-gateway/SENSOR\" value_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0x099F'] is defined -%} {%- if value_json.ZbReceived['0x099F']['0500!00'] == '010000FF0000' -%} ON {% else %} OFF {% endif %} {% else %} {{ states('binary_sensor.water_leak') }} {% endif %} availability_topic : \"tele/zigbee-gateway/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : moisture Enable join button mqtt : button : - unique_id : z2t_enable_join name : \"Zigbee2Tasmota enable join\" command_topic : \"cmnd/zigbee-gateway/ZbPermitJoin\" payload_press : \"1\" availability_topic : \"tele/zigbee-gateway/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" entity_category : \"default\" device_class : \"restart\" Useful Automations ~ Extended device information Wi-Fi signal quality can be added as a parameter to any previous configuration by appending this section to the existing configuration yaml json_attributes_topic : \"tele/tasmota/STATE\" json_attributes_template : \"{{ value_json.Wifi | tojson }}\" Sync Power State When MQTT broker or Home Assistant is restarted, or there is a WiFi outage, Tasmota device states may not be synced with Home Assistant. Use this automation to keep your devices in sync, including power state, immediately after Home Assistant is started. automation : - id : Sync Tasmota states alias : Sync Tasmota states initial_state : true trigger : platform : homeassistant event : start action : # sync state for devices with default fulltopics - service : mqtt.publish data : topic : cmnd/tasmotas/state payload : '' # sync state for pre8.2 autodiscovery devices - service : mqtt.publish data : topic : tasmotas/cmnd/state payload : '' To sync a single TuyaMCU device states add this block with your %topic% to the automation. !!! bug You could use tasmotas but SerialSend might cause issues on other devices so proceed with caution. - service : mqtt.publish data : topic : cmnd/%topic%/serialsend5 payload : 55aa0001000000 Sync Zigbee device states. Add this block with your %topic% and your Zigbee device name, endpoint and cluster. Example for a dimmable light - service : mqtt.publish data : topic : cmnd/zigbee-gateway/Backlog payload : ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":6, \"read\":0 }; delay 5; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } Report Firmware Version Add a sensor like below for each Tasmota device whose firmware version you want to track. mqtt : sensor : - platform : mqtt name : \"Tasmota\" state_topic : \"stat/tasmota/STATUS2\" value_template : \"{{value_json['StatusFWR'].Version }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" Automation to have each device report firmware version on Home Assistant reboot. You can manually trigger this automation from Home Assistant UI. automation : - alias : \"Tasmota Firmware Version Check\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/tasmotas/STATUS\" payload : \"2\" Tip If you want all your devices to switch to autodiscovery method go through Developer tools - MQTT by publishing to grouptopic cmnd/tasmotas/SetOption19 with payload 1 Get most recent Tasmota firmware version number from github mqtt : sensor : - platform : command_line name : \"Tasmota (latest version)\" command : 'curl -s https://api.github.com/repos/arendst/Tasmota/tags | grep \"name\" | sort --version-sort -r | head -n 1 | sed -E \"s/\\s*\\\"name\\\": \\\"(.*)\\\",*/\\1/g\"' scan_interval : 86400 # check once every day MQTT Discovery REMOVED ~ Home Assistant MQTT Discovery is removed from all builds of Tasmota and development of this feature is halted! Home Assistant has a feature called MQTT discovery . With MQTT discovery no user interaction or configuration file editing is needed to add new devices in Home Assistant. Most of the changes will be updated in HA automatically. Enable Autodiscovery ~ Enable autodiscovery on a device with the command: SetOption19 1 After the automatic discovery feature is enabled a retained MQTT message starting with topic \"homeassistant/\" is sent to the broker. That message contains your device configuration which will be picked up and used by Home Assistant to automatically add your device to MQTT integrations. Tasmota uses DeviceName to identify the device in Home Assistant MQTT integration and FriendlyName<x> to identify power outputs (switch or light entities in HA). When changing some settings you might need a reboot or use SetOption19 1 again to see the new changes under Home Assistant. Special settings for each device type: Finalising Setup ~ All automatically discovered entities will show up under Configuration -> Integrations -> MQTT card. The entities are grouped under a device defined by DeviceName and identified by Tasmota as the \"manufacturer\": Overview of a Tasmota device in Home Assistant integration compared to Configuration -> Configure Other : For every device an informative sensor will be created automatically: This sensor will update on TelePeriod which is 5 minutes by default It will show as \"Unavailable\" until the first TelePeriod MQTT message You can further customise your device in Home Assistant by clicking on the entity name. Enabling discovery will automatically change some SetOptions to suit the new configuration SetOption4 to 0 : Return MQTT response always as RESULT and not as %COMMAND% topic SetOption17 to 1 : Show Color as a comma-separated decimal string instead of hexadecimal SetOption59 to 1 : Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands State , Power and any command causing a light to be turned on. Supported Entities ~ Buttons Lights Relays Sensors Switches Announced to Home Assistant as Automation Trigger . To have buttons discovered SetOption73 must be set to 1 and it will automatically start to listen and publish using /stat/%topic%/BUTTON<x>T topic. Discovery will follow all the possible combinations made using SetOption1, SetOption11 and Setoption13. Announced to Home Assistant as MQTT Light . Discovery supports single channel Dimmer as well as multi-channel RGB, RGBW, RGBCCT and CCT lights. To have multi-channel PWM instead of a single light entity under Home Assistant use SetOption68 1 . If you have a light with 4 or 5 channels (RGB+W or RGB+CCT) you can split them into two separate lights, first one for RGB and second for White/CT. Note Tasmota will no longer switch %prefix% and %topic% and will keep the default topic structure. This could lead to a very long topic for a light and autodiscovery could fail to parse the necessary code for Home Assistant. In this case a warning will be shown in the logs and Tasmota Console. To avoid this issue keep your Topic and/or FriendlyName as short as possible. Alternatively you can configure it manually using Light integration. Warning Pay attention to the order of the relays when used in conjunction with lights. The relays have priority over the lights, an incorrect order could lead to an erroneous light control. Add them starting from relay1. Entities for relays and lights will not be available in Home Assistant until the configuration will be updated. Announced to Home Assistant as MQTT Switch . To make a relay discovered as \"light\" in Home Assistant use command SetOption30 1 Alternatively you can configure it manually using Light Switch integration. Warning Pay attention to the order of the relays when used in conjunction with lights. The relays have priority over the lights, an incorrect order could lead to an erroneous light control. Add them starting from relay1. Entities for relays and lights will not be available in Home Assistant until the configuration will be updated. Announced to Home Assistant as MQTT Sensor . When discovery is enabled Tasmota will send all the sensors information to Home Assistant. For each sensor present, entities will be created in numbers equal to the items present below him. Example: An AM2301 sensor will generate one entity for Temperature, one for Humidity and one for Dew point. Warning Please be advised that not all sensors can be correctly rendered under Home Assistant. In those cases a fallback function will be used to create a generic sensor and the correct operation is not guaranteed. Announced to Home Assistant as MQTT Binary Sensor and/or as an Automation Trigger . To have switches discovered SwitchTopic must be set to a custom name and it will automatically start to listen and publish using stat/%topic%/SWITCH<x> (binary sensor) or stat/%topic%/SWITCH<x>T (trigger) topics. Depending by the SwitchMode used, a switch can be a Trigger ( TOGGLE or HOLD ), a Binary Sensor ( ON / OFF ) or both at the same time. Example: When using with SwitchMode 0 Tasmota will create just one Trigger for TOGGLE . When using with SwitchMode 1 Tasmota will create a Binary Sensor with ON and OFF Payloads. When using with Switchmode 5 Tasmota will create a Binary Sensor with ON and OFF Payloads and a Trigger for TOGGLE . All switchmodes are supported with the sole exception of SwitchMode11 and SwitchMode12 able to generate just a TOGGLE trigger. When a switch is set to a different topic than 0 is not possible to use Switch#State as a trigger for rules. Types of devices not listed above (covers, etc) require manual configuration Troubleshooting ~ Test if Tasmota and Home Assistant can communicate properly. Click on the above button or in your Home Assistant web UI go to Configuration - Integrations , locate MQTT card and click on CONFIGURE . Subscribe to tele/%topic%/STATE and click START LISTENING . You should see a JSON response from your device inside 5 minutes. To test control of a relay or light, as Publish a packet topic enter cmnd/%topic%/POWER with payload toggle or 2 . When you click PUBLISH your device should switch state and a JSON resc","title":"Home Assistant"},{"location":"Home-Assistant/#home-assistant","text":"Home Assistant is an open source home automation solution that puts local control and privacy first. Tasmota communicates with Home Assistant using MQTT. Before going any further, make sure MQTT is properly set up in Home Assistant and Tasmota . Home Assistant can add Tasmota devices using: Official Tasmota integration - preferred and automatic instant discovery of entities Manual configuration by editing configuration.yaml - recommended for marginal use cases, f.e. TuyaMCU fan devices","title":"Home Assistant"},{"location":"Home-Assistant/#tasmota-integration","text":"Once you configure the Home Assistant integration every new Tasmota device with SetOption19 0 set will be discovered automatically. All Tasmota devices will be listed in their own Tasmota card in Configuration - Integrations menu in Home Assistant. Warning Do not change the FullTopic in order to use this feature. Leave it as default. Tasmota uses DeviceName to name the device in Tasmota integration and FriendlyName<x> to name power outputs (switch or light entities in HA). Use templates to change the Module name Setting the template name will change the Module name as well which will be reflected in Home Assistant. This helps in identifying when dealing with a large number of devices. Its nicer than having 10 Sonoff S31's or a bunch of TuyaMCU's\" Bug If you are using Home Assistant OS MQTT add-on add the following to the ACL file (user section or general section): topic write tasmota/discovery/# to give Tasmota devices write access to the discovery topic.","title":"Tasmota Integration"},{"location":"Home-Assistant/#supported-entities","text":"Lights as light entities. Single channel Dimmers, RGB lights, RGB lights with Color Temperature control and RGB lights with White control are supported. Relays as switch entities With SetOption30 1 all relays one the device will be added as light entities instead Sensors as sensor entities Switches as binary_sensor entities or automation triggers depending on SwitchMode used when SetOption114 1 Buttons as automation triggers when SetOption73 is enabled Shutters as cover entities. Currently only shutter modes 1 to 4 are supported. Shutter mode 5 and Tuya shutters are not supported. Devices configured as iFan02 or iFan03 as fan entities. TuyaMCU fans are not supported. Each discovered device will by default add 8 disabled sensors. Enable the ones you need. You cannot delete them, they will simply be re-added on a restart. Types of devices not listed above still require manual configuration Zigbee and Bluetooth devices paired in Tasmota will NOT be discovered in Home Assistant","title":"Supported Entities"},{"location":"Home-Assistant/#removing-devices","text":"You cannot as long as Home Assistant support is enabled in your Tasmota binary. Disable the device in Home Assistant instead. Deleting them from Home Assistant while Tasmota device is still active will eventually rediscover all the entities.","title":"Removing devices"},{"location":"Home-Assistant/#supplemental-custom-discovery-message","text":"You can use MQTT Discovery in HA to add sensors and other entities that are not discovered through Tasmota integration and associate them with an already discovered device. When creating the MQTT discovery JSON add this device identifier ,\"device\":{\"connections\":[[\"mac\",\"%macaddr%\"]]} where %macaddr% is the mac address of the device without : . When used in a rule variable %macaddr% will be replaced automatically. There are Home Assistant Blueprints for specific device types to create needed entities at out blueprints GitHub. Look for the icon in templates to one-click import the configuration automation. Examples of creating custom discovery messages: RFID Tag PIR sensor TuyaMCU Air Fryer TuyaMCU Heater","title":"Supplemental Custom Discovery Message"},{"location":"Home-Assistant/#editing-configurationyaml","text":"Adding devices manually is done by editing the configuration.yaml file and adding appropriate blocks of yaml code to the corresponding section. After every change to the configuration.yaml file you'll need to restart the MANUALL CONFIGURED MQTT ENTITES in Server Controls to apply the changes. The advantage of manually configuring a device is that you maintain control of all aspects of the configuration. All the configurations are just examples. You need to be familiar with Home Assistant's configuration structure and procedures. Straight copy paste of the given examples into configuration.yaml will probably not work for you. If you are using a localized (non-english) version be sure to check the correct spelling and cases for values: 'payload_available' 'payload_not_available' 'payload_on' 'payload_off' Tip If you want the power states to be persistent in Tasmota and Home Assistant set PowerRetain 1 instead of using retain: true in Home Assistant When using unique_id: make sure its unique to each entity When unique_id is set, Home Assistant will allow some entity customization from the UI such as changing the name or icon.","title":"Editing configuration.yaml"},{"location":"Home-Assistant/#switches","text":"Add in Home Assistant using the MQTT Switch integration. Required Commands SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands for faster updates Single Switch If SetOption26 is enabled, use POWER1 instead of POWER mqtt : switch : - unique_id : tasmota_switch name : \"Tasmota Switch\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/tasmota/POWER\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" Multiple Switches When a device has more than one POWER output (multiple relays or a mix of relays and lights) use corresponding POWER<x> ( POWER1 , POWER2 , etc) mqtt : switch : - unique_id : tas_switch_1 name : \"Tasmota Switch 1\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER1 }}\" command_topic : \"cmnd/tasmota/POWER1\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" - unique_id : tas_switch_2 name : \"Tasmota Switch 2\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER2 }}\" command_topic : \"cmnd/tasmota/POWER2\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" - unique_id : tas_switch_3 name : \"Tasmota Switch 3\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER3 }}\" command_topic : \"cmnd/tasmota/POWER3\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" Tip If you are using a switch device to control a light you may want to use MQTT Light integration instead. Simply replace switch: with light: in the configuration keeping everything else the same.","title":"Switches"},{"location":"Home-Assistant/#lights","text":"Add in Home Assistant using the MQTT Light integration. All configurations require SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Optional Commands Fade on - makes transitions smoother Speed 5 - set transition speed Dimmer Used for dimmers and dimmable lights (single channel lights). mqtt : light : - name : \"Dimmer\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" RGB Light Should also be used with lights using White Blend Mode SetOption17 1 - enables color status in decimals mqtt : light : - name : \"RGB Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" RGB+W Light In this configuration RGB and white cannot be on at the same time. See Lights for options. SetOption17 1 - enables color status in decimals mqtt : light : - name : \"RGB+W Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" white_value_state_topic : \"tele/tasmota/STATE\" white_value_command_topic : \"cmnd/tasmota/White\" white_value_scale : 100 white_value_template : \"{{ value_json.White }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{value_json.Scheme}}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" RGB+CCT Light Also called RGBWW, RGBCW or 5 channel lights SetOption17 1 - enables color status in decimals mqtt : light : - name : \"RGBCCT Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" color_temp_command_topic : \"cmnd/tasmota/CT\" color_temp_state_topic : \"tele/tasmota/STATE\" color_temp_value_template : \"{{ value_json.CT }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" Addressable LED Applies only to WS281x lights. mqtt : light : - name : \"Addressable LED\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"stat/tasmota/STATE\" state_value_template : \"{{ value_json.POWER }}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"stat/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{ value_json.Dimmer }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{ value_json.Color.split(',')[0:3]|join(',') }}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"stat/tasmota/STATE\" effect_value_template : \"{{ value_json.Scheme }}\" effect_list : - 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB with hex values If you don't want to use SetOption17 1 with decimal values and use default hex values, change: rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_command_template : \"{{ '%02X%02X%02X' | format(red, green, blue)}}\" rgb_value_template : \"{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}\" Control RGB and White independently Using color picker will keep white light on. If you use the white slider RGB light will get turned off. White value and dimmer value are connected, to have more granular control you will have to split the lights . Replace rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_command_template : \"{{ '%02X%02X%02X=' | format(red, green, blue)}}\" rgb_value_template : \"{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}\" The key is the = after color string in hex. It will retain current white value while changing color. Using schema: template light Thorough explanation of template: schema lights and its features on blakadder.com","title":"Lights"},{"location":"Home-Assistant/#sensors","text":"Add in Home Assistant using the MQTT Sensor integration. A sensor will send its data in set intervals defined by TelePeriod (default every 5 minutes). Temperature sensor Check your sensor name in Tasmota console and change accordingly. This example uses the DHT22 sensor. mqtt : sensor : - name : \"Tasmota Temperature\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Temperature }}\" unit_of_measurement : \"\u00b0C\" # \"F\" if using Fahrenheit availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : temperature Humidity sensor Check your sensor name in Tasmota and change accordingly. This example uses the DHT22 sensor. mqtt : sensor : - ame : \"Tasmota Humidity\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Humidity }}\" unit_of_measurement : \"%\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : humidity Pressure sensor Check your sensor name in Tasmota and change accordingly. This example uses the BMP280 sensor. mqtt : sensor : - name : \"Tasmota Pressure\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json.BMP280.Pressure }}\" unit_of_measurement : \"hPa\" device_class : pressure Change unit_of_measurement to \"mmHg\" if SetOption24 1 Wi-Fi Signal Quality Monitor the relative Wi-Fi signal quality of a device. sensor : - platform : mqtt name : \"Tasmota Wi-Fi Quality\" state_topic : \"tele/tasmota/STATE\" unit_of_measurement : \"%\" value_template : \"{{value_json['Wifi'].RSSI }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : signal_strength entity_category : diagnostic # moves the entity to the Diagnostic section on the Device Card","title":"Sensors"},{"location":"Home-Assistant/#power-monitoring","text":"Add in Home Assistant using the MQTT Sensor integration. Power monitoring sensors will send their data in set intervals defined by TelePeriod (default every 5 minutes). To get all the data in Home Assistant requires multiple sensors which you can later group to your liking in Lovelace UI Power Monitoring mqtt : sensor : - name : \"Energy Today\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" device_class : energy state_class : measurement - name : \"Power\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" device_class : power state_class : measurement - name : \"Voltage\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" device_class : voltage state_class : measurement - name : \"Current\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Current\"] }}' unit_of_measurement : \"A\" device_class : current state_class : measurement Tip For additional sensors use \"Total\";\"Yesterday\";\"Period\",\"ApparentPower\",\"ReactivePower\";\"Factor\" in value_template string Video tutorial on a power monitoring plug setup by Digiblur","title":"Power Monitoring"},{"location":"Home-Assistant/#binary-sensors","text":"Add in Home Assistant using the MQTT Binary Sensor integration. PIR Sensor Used for a configured PIR Sensor and requires correct SwitchMode with ON/OFF states and this rule: Required Commands Rule1 on Switch1#State=1 do Publish stat/%topic%/MOTION ON endon on Switch1#State=0 do Publish stat/%topic%/MOTION OFF endon Rule1 1 mqtt : binary_sensor : - unique_id : motion_sensor name : \"Tasmota Motion Sensor\" state_topic : \"stat/tasmota/MOTION\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : motion Door Sensor Requires a reed switch configured in Tasmota. Make sure correct SwitchMode is set Required Commands Rule1 on Switch1#State=1 do Publish stat/%topic%/DOOR ON endon on Switch1#State=0 do Publish stat/%topic%/DOOR OFF endon Rule1 1 mqtt : binary_sensor : - unique_id : door_sensor name : \"Tasmota Door Sensor\" state_topic : \"stat/tasmota/GARAGE\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : door # also possible: window, garage_door or opening RF Bridge An RF door sensor configured with an RF receiver in Tasmota. mqtt : binary_sensor : - platform : mqtt name : \"RF bridge rfkey\" payload_on : \"1\" payload_off : \"0\" device_class : opening state_topic : \"tele/tasmota/RESULT\" value_template : '{{ value_json.RfReceived.RfKey }}'","title":"Binary Sensors"},{"location":"Home-Assistant/#fans","text":"Add in Home Assistant using the MQTT Fan integration. Fan Derived from #2839 by @kbickar and @finity69x2 mqtt : fan : - unique_id : tasmota_fan name : \"Tasmota Fan\" command_topic : \"cmnd/tasmota/FanSpeed\" speed_command_topic : \"cmnd/tasmota/FanSpeed\" state_topic : \"stat/tasmota/RESULT\" speed_state_topic : \"stat/tasmota/RESULT\" state_value_template : > {% if value_json.FanSpeed is defined %} {% if value_json.FanSpeed == 0 -%}0{%- elif value_json.FanSpeed > 0 -%}4{%- endif %} {% else %} {% if states.fan.tasmota.state == 'off' -%}0{%- elif states.fan.tasmota.state == 'on' -%}4{%- endif %} {% endif %} speed_value_template : \"{{ value_json.FanSpeed }}\" availability_topic : tele/tasmota/LWT payload_off : \"0\" payload_on : \"4\" payload_low_speed : \"1\" payload_medium_speed : \"2\" payload_high_speed : \"3\" payload_available : \"Online\" payload_not_available : \"Offline\" speeds : - \"off\" - \"low\" - \"medium\" - \"high\"","title":"Fans"},{"location":"Home-Assistant/#covers","text":"Add in Home Assistant using the MQTT Cover integration. TuyaMCU Curtain/Shade Motor Requires SetOption66 1 . In this example dpId1 is for open/close/stop of the motor, dpId2 sets position and dpId3 displays the current position. # Example configuration.yaml entry mqtt : cover : - unique_id : tuya_curtain name : \"Tuya Curtain\" command_topic : \"cmnd/tasmota/TuyaSend4\" payload_open : \"1,0\" payload_close : \"1,2\" payload_stop : \"1,1\" position_open : 0 position_closed : 100 position_topic : \"tele/tasmota/RESULT\" position_template : >- {% if value_json.TuyaReceived.DpType2Id3 is defined %} {{ value_json.TuyaReceived.DpType2Id3 }} {% else %} {{ state_attr('cover.tuya_curtain','current_position') | int }} {% endif %} set_position_topic : \"cmnd/tasmota/TuyaSend2\" set_position_template : '2,{{ position }}' availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" If you change name: make sure to reflect that change in the value_template cover name!","title":"Covers"},{"location":"Home-Assistant/#climate","text":"Detailed guide when using MQTT Climate or Generic Thermostat in Home Assistant","title":"Climate"},{"location":"Home-Assistant/#device-specific","text":"Covers For shutter position to persist in Home Assistant through device reboots, execute PowerRetain 1 . These sample configurations should allow the shutter work in Home Assistant. This is only an example and may need further modification to work in your environment. This example uses a new configuration for roller shutters with options for positioning. It assumes that %prefix%/%topic%/ is configured in the Tasmota Full Topic MQTT parameter. mqtt : cover : - name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : stat/%topic%/Shutter1 position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 Check Issue 130 for more information about this configuration. Another integration example: mqtt : cover : - name : \"Test\" availability_topic : \"tele/%topic%/LWT\" state_topic : \"stat/%topic%/RESULT\" command_topic : \"cmnd/%topic%/Backlog\" value_template : '{{ value | int }}' qos : 1 retain : false payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" state_open : \"ON\" state_closed : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" optimistic : false tilt_command_topic : 'cmnd/%topic%/ShutterPosition1' tilt_status_topic : 'cmnd/%topic%/ShutterPosition1' set_position_topic : 'cmnd/%topic%/ShutterPosition1' position_topic : \"stat/%topic%/SHUTTER1\" tilt_min : 0 tilt_max : 100 tilt_closed_value : 0 tilt_opened_value : 100 Integration example with position updated during movement (Tasmota versions >= v8.1.0.5): mqtt : cover : - name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : \"stat/%topic%/RESULT\" position_template : > {% if ('Shutter1' in value_json) and ('Position' in value_json.Shutter1) %} {{ value_json.Shutter1.Position }} {% else %} {% if is_state('cover.balcony_blinds', 'unknown') %} 50 {% else %} {{ state_attr('cover.balcony_blinds','current_position') }} {% endif %} {% endif %} position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" In addition, add to your home assistant start up automation a query for the current shutter position: - alias : \"Power state on HA start-up\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/%shutters grouptopic%/shutterposition\" payload : \"\"","title":"Device Specific"},{"location":"Home-Assistant/#zigbee-devices","text":"Warning The following Zigbee examples assume SetOption83 , SetOption89 , SetOption100 , SetOption112 , SetOption118 , SetOption119 are all set to 0 . Setting any of these to 1 will change topic and/or payload structure from that used in the examples. Dimmable Light This configuration is for a dimmable light reporting on 0xE1F9 using endpoint 1, cluster 8 for brightness. ZbRead part in the template is needed to always update the brightness values. # Example configuration.yaml entry mqtt : light : - schema : template name : \"Fire Light\" command_topic : \"cmnd/zigbee-gateway/Backlog\" state_topic : \"tele/zigbee-gateway/SENSOR\" command_on_template : > {%- if brightness is defined -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Dimmer\":{{ brightness }} } }; ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- else -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- endif -%} command_off_template : 'ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":false} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 }' state_template : > {% if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Power is defined %} {% if value_json.ZbReceived['0xE1F9'].Power == true %} on {% else %} off {% endif %} {% else %} {{ states('light.fire_light') }} {% endif %} brightness_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Dimmer is defined -%} {{ value_json['ZbReceived']['0xE1F9'].Dimmer | int }} {%- else -%} {{ state_attr('light.fire_light', 'brightness') | int }} {%- endif -%} Water Leak Sensor This specific configuration is for Xiaomi Aqara Water Leak sensor reporting on 0x099F . # Example configuration.yaml entry mqtt : binary_sensor : - name : \"Water Leak\" state_topic : \"tele/zigbee-gateway/SENSOR\" value_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0x099F'] is defined -%} {%- if value_json.ZbReceived['0x099F']['0500!00'] == '010000FF0000' -%} ON {% else %} OFF {% endif %} {% else %} {{ states('binary_sensor.water_leak') }} {% endif %} availability_topic : \"tele/zigbee-gateway/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : moisture Enable join button mqtt : button : - unique_id : z2t_enable_join name : \"Zigbee2Tasmota enable join\" command_topic : \"cmnd/zigbee-gateway/ZbPermitJoin\" payload_press : \"1\" availability_topic : \"tele/zigbee-gateway/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" entity_category : \"default\" device_class : \"restart\"","title":"Zigbee Devices"},{"location":"Home-Assistant/#useful-automations","text":"Extended device information Wi-Fi signal quality can be added as a parameter to any previous configuration by appending this section to the existing configuration yaml json_attributes_topic : \"tele/tasmota/STATE\" json_attributes_template : \"{{ value_json.Wifi | tojson }}\" Sync Power State When MQTT broker or Home Assistant is restarted, or there is a WiFi outage, Tasmota device states may not be synced with Home Assistant. Use this automation to keep your devices in sync, including power state, immediately after Home Assistant is started. automation : - id : Sync Tasmota states alias : Sync Tasmota states initial_state : true trigger : platform : homeassistant event : start action : # sync state for devices with default fulltopics - service : mqtt.publish data : topic : cmnd/tasmotas/state payload : '' # sync state for pre8.2 autodiscovery devices - service : mqtt.publish data : topic : tasmotas/cmnd/state payload : '' To sync a single TuyaMCU device states add this block with your %topic% to the automation. !!! bug You could use tasmotas but SerialSend might cause issues on other devices so proceed with caution. - service : mqtt.publish data : topic : cmnd/%topic%/serialsend5 payload : 55aa0001000000 Sync Zigbee device states. Add this block with your %topic% and your Zigbee device name, endpoint and cluster. Example for a dimmable light - service : mqtt.publish data : topic : cmnd/zigbee-gateway/Backlog payload : ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":6, \"read\":0 }; delay 5; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } Report Firmware Version Add a sensor like below for each Tasmota device whose firmware version you want to track. mqtt : sensor : - platform : mqtt name : \"Tasmota\" state_topic : \"stat/tasmota/STATUS2\" value_template : \"{{value_json['StatusFWR'].Version }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" Automation to have each device report firmware version on Home Assistant reboot. You can manually trigger this automation from Home Assistant UI. automation : - alias : \"Tasmota Firmware Version Check\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/tasmotas/STATUS\" payload : \"2\" Tip If you want all your devices to switch to autodiscovery method go through Developer tools - MQTT by publishing to grouptopic cmnd/tasmotas/SetOption19 with payload 1 Get most recent Tasmota firmware version number from github mqtt : sensor : - platform : command_line name : \"Tasmota (latest version)\" command : 'curl -s https://api.github.com/repos/arendst/Tasmota/tags | grep \"name\" | sort --version-sort -r | head -n 1 | sed -E \"s/\\s*\\\"name\\\": \\\"(.*)\\\",*/\\1/g\"' scan_interval : 86400 # check once every day","title":"Useful Automations"},{"location":"Home-Assistant/#mqtt-discovery-removed","text":"Home Assistant MQTT Discovery is removed from all builds of Tasmota and development of this feature is halted! Home Assistant has a feature called MQTT discovery . With MQTT discovery no user interaction or configuration file editing is needed to add new devices in Home Assistant. Most of the changes will be updated in HA automatically.","title":"MQTT Discovery REMOVED"},{"location":"Home-Assistant/#troubleshooting","text":"Test if Tasmota and Home Assistant can communicate properly. Click on the above button or in your Home Assistant web UI go to Configuration - Integrations , locate MQTT card and click on CONFIGURE . Subscribe to tele/%topic%/STATE and click START LISTENING . You should see a JSON response from your device inside 5 minutes. To test control of a relay or light, as Publish a packet topic enter cmnd/%topic%/POWER with payload toggle or 2 . When you click PUBLISH your device should switch state and a JSON resc","title":"Troubleshooting"},{"location":"HomeSeer/","text":"For those knowing more about HomeSeer please update this page. About HomeSeer HS3 is the industry standard for flexible, powerful, home automation software. A wide selection of software drivers (plug-ins) is available for use with scores of home automation technologies and products. The following forum link provides a guide to upload Tasmota to an S20 using SonOTA and integrate it with HomeSeer HS3 using the mcsMQTT plugin. Here is a guide for integrating HomeSeer HS3 with the Sonoff 4CH Pro and Tasmota firmware as a Garage Door controller using the mcsMQTT plugin. Requirements for HomeSeer HS3 and Tasmota devices: * HomeSeer HS3 * MQTT server * A MQTT plugin for HS3 Currently there are two plugins, both free: \"MQTT\" and \"mcsMQTT\". The former is more intuitive but hasn't been updated for a while, the latter is newer and constantly updated. If you use \"MQTT\" plugin you need to synch the virtual device to reflect the status of the physical button, this can be done with a plugin: * EasyTrigger plugin - costs 25$ (used to synchronise the status of the virtual device in HomeSeer when the Sonoff Tasmota module is operated from the physical button) If you use \"mcsMQTT\", starting from ver 3.0.3+ it allows to create a device that both report and control the status of the Sonoff. More info here: https://forums.homeseer.com/showthread.php?t=192675 Tasmota Plug-in If your interested in a FREE specific plug-in for Sonoff + Tasmota, then Instructions are HERE and you can install it from the Homeseer Plug-ins Manager, in Primary Technology as TasMQTT. This plug-in takes care of two-way updates so wall switches update Homseer devices and homeseer changes update Sonoff devices. The plug-in also takes care of monitoring sonoff availability and optionally flags homeseer devices as offline so events can take that into consideration before making changes. When devices come back online Homeseer is updated with the current status of the devices. The plug-in also supports Tasmota Sensors such as the Sonoff TH1 etc. The plug-in has so far been tested extensively with the entire Sonoff Portfolio and as new devices become available we'll test those too. This plug-in has been in beta for 6 months and has now reached production. Beta's will continue to be released to support any new Tasmota enabled devices.","title":"HomeSeer"},{"location":"Homebridge/","text":"Homebridge is a NodeJS server which emulates the iOS HomeKit API to enable support for non-native devices (like Sonoff and Magichome devices). Tasmota compatible plugins have been developed by macwyznawca and arachnetech as well as others to add support for these devices in Apple's Home app and through iCloud for automation (iPad, HomePod/Apple TV 4 or newer required). Note these plugins are not necessarily specific to Sonoff devices. The homebridge-mqttthing package has support for many types of devices and is quite flexible with different options especially for RGB/RGBW LED strips. As of 1.0.11 homebridge-mqttthing supports the following Homekit device types: Light bulb Switch Outlet Motion Sensor Occupancy Sensor Light Sensor Contact Sensor Doorbell Security System Smoke Sensor Temperature Sensor Humidity Sensor Stateless Programmable Switch Garage Door Garage Door Opener Check out macwyznawca's packages for supported functions, each in a separate package. To use Homebridge with Tasmota you need to have an existing MQTT broker set up ( see wiki article ) and each of your Sonoff devices should have a unique topic set. Example screenshot from Apple Home.app","title":"Homebridge"},{"location":"Honeywell-HIH/","text":"Honeywell HIH temperature and humidity sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_HIH6 #define USE_HIH6 // Enable Honeywell HIH (I2C address 0x27) (+0k6) #endif Honeywell HumidIcon\u2122 Digital Humidity and Temperature Sensors HIH Series Configuration ~ Wiring ~ Get the 4 pin SIP version if possible, as this will be easier to solder than the 8 pin SMD version. Looking at the side of the sensor with a filter: * Pin 1 VDD 1. connect via 0.22 uF to ground 1. connect to 3v3 on the ESP * Pin 2 GND 1. connect to GND on the ESP * Pin 3 SCL 1. connect via 2k2 resistor to 3v3 1. connect to TX on the ESP * Pin 4 SDA 1. connect via 2k2 resistor to 3v3 1. connect to RX on the ESP Remember to peel off the white sticker over the filter before use. I have tested several of these without the 0.22 uF capacitor and without the pull-up resistors, and I haven't seen any difference in the readings. The cap is probably more important that the resistors, since the internal pull-ups in the ESP8266 will work. That said, if I was installing these in a hard-to-service location, I would follow the wiring diagram exactly. I have noticed that temperature readings tend to be a degree or so high if the sensor is wired directly to the ESP: Soldering a 1-2\" piece of wire between the ESP and the HIH7121 fixes this issue: Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIO RX to I2C SDA 2. GPIO TX to I2C SCL After a reboot the driver will detect the HIHxxxx automatically and display sensor data. <--- if you have an LCD display also configured, run I2CDriver3 0 More documentation on this is in the I2CDEVICES.md file. Why the Honeywell HIH series sensors? ~ The go-to humidity sensor for the DIY Arduino/ESP8266 community is the DHT22. Unfortunately, this sensor has a tendency to collect condensation and give false readings (usually 99.9% RH) in wet environments like a bathroom or outside. Not being able to use a humidity sensor in a wet area (IMHO) defeats the point of a humidity sensor, so I set about looking for alternatives. After looking at several options, I found the Honeywell HIHxxxx sensors. Different models of the HIH line have different features and work over different ranges of humidity, but most of them use the same I2C protocol, which is now supported in Tasmota. Check the datasheets to compare sensors. One of the most critical features to look for is a hydrophobic filter which allows humid air through, but blocks water droplets from entering the sensor. This is listed on the datasheets as \"with filter,condensation resistant\". Also keep in mind the humidity range you'll be measuring. For my purposes (bathroom humidity sensor), there was a clear choice in the HIH7121-021 ( datasheet , non-affiliate direct link to product on Mouser , which works over a range of 0-100% RH, supports I2C, is accurate to within 3%, and has a hydrophobic filter. The article focuses on that sensor, but I suspect much of the information will be applicable to other HIHxxxx sensors. by @thepotoo","title":"Honeywell HIH temperature and humidity sensor"},{"location":"Honeywell-HIH/#honeywell-hih-temperature-and-humidity-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_HIH6 #define USE_HIH6 // Enable Honeywell HIH (I2C address 0x27) (+0k6) #endif Honeywell HumidIcon\u2122 Digital Humidity and Temperature Sensors HIH Series","title":"Honeywell HIH temperature and humidity sensor"},{"location":"Honeywell-HIH/#configuration","text":"","title":"Configuration"},{"location":"Honeywell-HIH/#wiring","text":"Get the 4 pin SIP version if possible, as this will be easier to solder than the 8 pin SMD version. Looking at the side of the sensor with a filter: * Pin 1 VDD 1. connect via 0.22 uF to ground 1. connect to 3v3 on the ESP * Pin 2 GND 1. connect to GND on the ESP * Pin 3 SCL 1. connect via 2k2 resistor to 3v3 1. connect to TX on the ESP * Pin 4 SDA 1. connect via 2k2 resistor to 3v3 1. connect to RX on the ESP Remember to peel off the white sticker over the filter before use. I have tested several of these without the 0.22 uF capacitor and without the pull-up resistors, and I haven't seen any difference in the readings. The cap is probably more important that the resistors, since the internal pull-ups in the ESP8266 will work. That said, if I was installing these in a hard-to-service location, I would follow the wiring diagram exactly. I have noticed that temperature readings tend to be a degree or so high if the sensor is wired directly to the ESP: Soldering a 1-2\" piece of wire between the ESP and the HIH7121 fixes this issue:","title":"Wiring"},{"location":"Honeywell-HIH/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIO RX to I2C SDA 2. GPIO TX to I2C SCL After a reboot the driver will detect the HIHxxxx automatically and display sensor data. <--- if you have an LCD display also configured, run I2CDriver3 0 More documentation on this is in the I2CDEVICES.md file.","title":"Tasmota Settings"},{"location":"Honeywell-HIH/#why-the-honeywell-hih-series-sensors","text":"The go-to humidity sensor for the DIY Arduino/ESP8266 community is the DHT22. Unfortunately, this sensor has a tendency to collect condensation and give false readings (usually 99.9% RH) in wet environments like a bathroom or outside. Not being able to use a humidity sensor in a wet area (IMHO) defeats the point of a humidity sensor, so I set about looking for alternatives. After looking at several options, I found the Honeywell HIHxxxx sensors. Different models of the HIH line have different features and work over different ranges of humidity, but most of them use the same I2C protocol, which is now supported in Tasmota. Check the datasheets to compare sensors. One of the most critical features to look for is a hydrophobic filter which allows humid air through, but blocks water droplets from entering the sensor. This is listed on the datasheets as \"with filter,condensation resistant\". Also keep in mind the humidity range you'll be measuring. For my purposes (bathroom humidity sensor), there was a clear choice in the HIH7121-021 ( datasheet , non-affiliate direct link to product on Mouser , which works over a range of 0-100% RH, supports I2C, is accurate to within 3%, and has a hydrophobic filter. The article focuses on that sensor, but I suspect much of the information will be applicable to other HIHxxxx sensors. by @thepotoo","title":"Why the Honeywell HIH series sensors?"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/","text":"Heya, In this memo I'll describe how to expand the flash of a sonoff basic from 1MB to 4MB. The advantage for this change is, to avoid to double flash with the minimal and then with the normal firmware and to use more features like Webserver and SSL encryption. It was hard to find those information, I'll give credits to some users from the german CreationX Forum. Because to unsolder the flash isn't that easy as just solder in pins, this is only for advanced users . Don't forget, it's at your own risk and the device could be damaged permanently. The Hardware ~ Soldering iron Tin Tweezers The Flash ~ The origin flash block is a XTX PN25F08B 1725XDG. We exchange it with a WINBOND W25Q32FVSIG 1416. You can find the WINBOND Flash on eBay ( another ebay ) or AliExpress Those China flash memory ICs are cheap productions, means the chance to solder in a new defect not working flash block is high! Be ready to re-do the operation if the upload fails. If you want to test the flash block, build yourself a test module, something like this for easy soldering in a flash and test it before soldering it in another sonoff basics board. The Operation ~ You will notice that the LED is in the way. Get a pen and mark on of its Pin with the board, so you can solder it in back later in the correct Position. Its a Red-Green LED, if you solder it in the wrong way, it will light up in red. After the LED is out of the way, you give some tin on the pins from the flash block and connect all 4 pins in a row together with tin. This way it will be easier to desolder it, because you need to melt all pins at the same time. Now get a thin object between the flash and the board, try to gently lift the flash up and at the same time melt both rows of the flash pins tin rotatory. If you got enough space between the board and the flash change to the tweezers and finally take the flash block off. Now refresh the contacts on the board for the new flash block with a lil bit of fresh tin. Don't forget to give a lil bit tin to the new pins of the flash block, too! Now put it on the contacts on the board and try to lock it with the tweezers. Next take the solder iron and head just one pin and try to arrange the flashblock in the center now. Finally, heat and solder the other pins to the board. You can also use a hot air rework station, this would be much safer, but also more expensive ( Amazon ). Be sure to protect the rest of the board if using the heat gun! Good job, you are done :) Flashing ~ The next step is to tell Atom (i did not do it with Arduino IDE, sry) to use the whole new 4MB Flash. Note: You can only use 3MB, because 1MB is needed for SPIFFS. To do this, you need to edit the platformio.ini file. Search for your prefered language Block and copy the whole Block. Rename it to e.g. Sonoff-DE-4M Now change the following line build_flags = -Wl,-Tesp8266.flash.1m0.ld -DMY_LANGUAGE=de-DE to build_flags = -Wl,-Tesp8266.flash.4m1m.ld -DMY_LANGUAGE=de-DE Now scroll back to the top and enter a new default environment with the name of your newly created block env_default = sonoff-DE-4M You are done with the preparations, connect the Sonoff with the 4MB Flash in flash mode (hold button while powering it up), click clean, click build, click upload. Result ~ On the Information Page on the tasmota web interface you can now see the 4MB flash :)","title":"How to Expand Sonoff Basic to 4MB Flash"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-hardware","text":"Soldering iron Tin Tweezers","title":"The Hardware"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-flash","text":"The origin flash block is a XTX PN25F08B 1725XDG. We exchange it with a WINBOND W25Q32FVSIG 1416. You can find the WINBOND Flash on eBay ( another ebay ) or AliExpress Those China flash memory ICs are cheap productions, means the chance to solder in a new defect not working flash block is high! Be ready to re-do the operation if the upload fails. If you want to test the flash block, build yourself a test module, something like this for easy soldering in a flash and test it before soldering it in another sonoff basics board.","title":"The Flash"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-operation","text":"You will notice that the LED is in the way. Get a pen and mark on of its Pin with the board, so you can solder it in back later in the correct Position. Its a Red-Green LED, if you solder it in the wrong way, it will light up in red. After the LED is out of the way, you give some tin on the pins from the flash block and connect all 4 pins in a row together with tin. This way it will be easier to desolder it, because you need to melt all pins at the same time. Now get a thin object between the flash and the board, try to gently lift the flash up and at the same time melt both rows of the flash pins tin rotatory. If you got enough space between the board and the flash change to the tweezers and finally take the flash block off. Now refresh the contacts on the board for the new flash block with a lil bit of fresh tin. Don't forget to give a lil bit tin to the new pins of the flash block, too! Now put it on the contacts on the board and try to lock it with the tweezers. Next take the solder iron and head just one pin and try to arrange the flashblock in the center now. Finally, heat and solder the other pins to the board. You can also use a hot air rework station, this would be much safer, but also more expensive ( Amazon ). Be sure to protect the rest of the board if using the heat gun! Good job, you are done :)","title":"The Operation"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#flashing","text":"The next step is to tell Atom (i did not do it with Arduino IDE, sry) to use the whole new 4MB Flash. Note: You can only use 3MB, because 1MB is needed for SPIFFS. To do this, you need to edit the platformio.ini file. Search for your prefered language Block and copy the whole Block. Rename it to e.g. Sonoff-DE-4M Now change the following line build_flags = -Wl,-Tesp8266.flash.1m0.ld -DMY_LANGUAGE=de-DE to build_flags = -Wl,-Tesp8266.flash.4m1m.ld -DMY_LANGUAGE=de-DE Now scroll back to the top and enter a new default environment with the name of your newly created block env_default = sonoff-DE-4M You are done with the preparations, connect the Sonoff with the 4MB Flash in flash mode (hold button while powering it up), click clean, click build, click upload.","title":"Flashing"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#result","text":"On the Information Page on the tasmota web interface you can now see the 4MB flash :)","title":"Result"},{"location":"I2CDEVICES/","text":"I2C devices ~ Tasmota supports several I2C devices. To use them I2C and the device need to be enabled at compile time. I2C and some devices are supported also in the official releases. Devices can be de/-actived on runtime to solve possible address conflicts. (e.g. address 0x27 is used by multiple devices) Using command I2cDriver individual drivers can be enabled or disabled at runtime allowing duplicate I2C addresses at compile time. Use the Index from the table below to control I2C drivers like I2cDriver10 0 for disabling BMP support. Supported I2C devices ~ The following table lists the supported I2C devices Index Define Driver Device Address(es) Description 1 USE_PCA9685 xdrv_15 PCA9685 0x40 - 0x47 16-channel 12-bit pwm driver 2 USE_PCF8574 xdrv_28 PCF8574 0x20 - 0x26 8-bit I/O expander 2 USE_PCF8574 xdrv_28 PCF8574A 0x39 - 0x3F 8-bit I/O expander 3 USE_DISPLAY_LCD xdsp_01 0x27, 0x3F LCD display 4 USE_DISPLAY_SSD1306 xdsp_02 SSD1306 0x3C - 0x3D Oled display 5 USE_DISPLAY_MATRIX xdsp_03 HT16K33 0x70 - 0x77 8x8 led matrix 6 USE_DISPLAY_SH1106 xdsp_07 SH1106 0x3C - 0x3D Oled display 7 USE_ADE7953 xnrg_07 ADE7953 0x38 Energy monitor 8 USE_SHT xsns_07 SHT1X Any Temperature and Humidity sensor 9 USE_HTU xsns_08 HTU21 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7013 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7020 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7021 0x40 Temperature and Humidity sensor 10 USE_BMP xsns_09 BMP085 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BMP180 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BMP280 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BME280 0x76 - 0x77 Pressure, temperature and humidity sensor 10 USE_BMP xsns_09 BME680 0x76 - 0x77 Pressure, temperature, humidity and gas sensor 11 USE_BH1750 xsns_10 BH1750 0x23, 0x5C Ambient light intensity sensor 12 USE_VEML6070 xsns_11 VEML6070 0x38 - 0x39 Ultra violet light intensity sensor 13 USE_ADS1115 xsns_12 ADS1115 0x48 - 0x4B 4-channel 16-bit A/D converter 14 USE_INA219 xsns_13 INA219 0x40 - 0x41, 0x44 - 0x45 Low voltage current sensor 15 USE_SHT3X xsns_14 SHT3X 0x44 - 0x45 Temperature and Humidity sensor 15 USE_SHT3X xsns_14 SHT4X 0x44 - 0x45 Temperature and Humidity sensor 15 USE_SHT3X xsns_14 SHTCX 0x70 Temperature and Humidity sensor 16 USE_TSL2561 xsns_16 TSL2561 0x29, 0x39, 0x49 Light intensity sensor 17 USE_MGS xsns_19 Grove 0x04 Multichannel gas sensor 18 USE_SGP30 xsns_21 SGP30 0x58 Gas (TVOC) and air quality sensor 19 USE_SI1145 xsns_24 SI1145 0x60 Ultra violet index and light sensor 19 USE_SI1145 xsns_24 SI1146 0x60 Ultra violet index and light sensor 19 USE_SI1145 xsns_24 SI1147 0x60 Ultra violet index and light sensor 20 USE_LM75AD xsns_26 LM75AD 0x48 - 0x4F Temperature sensor 21 USE_APDS9960 xsns_27 APDS9960 0x39 Proximity ambient light RGB and gesture sensor 22 USE_MCP230xx xsns_29 MCP23008 0x20 - 0x26 8-bit I/O expander 22 USE_MCP230xx xsns_29 MCP23017 0x20 - 0x26 16-bit I/O expander 23 USE_MPR121 xsns_30 MPR121 0x5A - 0x5D Proximity capacitive touch sensor 24 USE_CCS811 xsns_31 CCS811 0x5A Gas (TVOC) and air quality sensor 25 USE_MPU6050 xsns_32 MPU6050 0x68 - 0x69 3-axis gyroscope and temperature sensor 26 USE_DS3231 xsns_33 DS3231 0x68 Real time clock 27 USE_MGC3130 xsns_36 MGC3130 0x42 Electric field sensor 28 USE_MAX44009 xsns_41 MAX44009 0x4A - 0x4B Ambient light intensity sensor 29 USE_SCD30 xsns_42 SCD30 0x61 CO2 sensor 30 USE_SPS30 xsns_44 SPS30 0x69 Particle sensor 31 USE_VL53L0X xsns_45 VL53L0X 0x29 Time-of-flight (ToF) distance sensor 32 USE_MLX90614 xsns_46 MLX90614 0x5A Infra red temperature sensor 33 USE_CHIRP xsns_48 CHIRP 0x20 Soil moisture sensor 34 USE_PAJ7620 xsns_50 PAJ7620 0x73 Gesture sensor 35 USE_INA226 xsns_54 INA226 0x40 - 0x41, 0x44 - 0x45 Low voltage current sensor 36 USE_HIH6 xsns_55 HIH6130 0x27 Temperature and Humidity sensor 37 USE_24C256 xdrv_10 24C256 0x50 Scripter EEPROM storage 38 USE_DISPLAY_ILI9488 xdsp_08 FT6236 0x38 Touch panel controller 39 USE_DISPLAY_RA8876 xdsp_10 FT5316 0x38 Touch panel controller 40 USE_TSL2591 xsns_57 TLS2591 0x29 Light intensity sensor 41 USE_DHT12 xsns_58 DHT12 0x5C Temperature and humidity sensor 42 USE_DS1624 xsns_59 DS1621 0x48 - 0x4F Temperature sensor 42 USE_DS1624 xsns_59 DS1624 0x48 - 0x4F Temperature sensor 43 USE_AHT1x xsns_63 AHT10/15 0x38 - 0x39 Temperature and humidity sensor 43 USE_AHT2x xsns_63 AHT20 0x38 Temperature and humidity sensor 43 USE_AHT2x xsns_63 AM2301B 0x38 Temperature and humidity sensor 44 USE_WEMOS_MOTOR_V1 xdrv_34 0x2D - 0x30 WEMOS motor shield v1.0.0 (6612FNG) 45 USE_HDC1080 xsns_65 HDC1080 0x40 Temperature and Humidity sensor 46 USE_IAQ xsns_66 IAQ 0x5a Air quality sensor 47 USE_DISPLAY_SEVENSEG xdsp_11 HT16K33 0x70 - 0x77 Seven segment LED 48 USE_AS3935 xsns_67 AS3935 0x03 Franklin Lightning Sensor 49 USE_VEML6075 xsns_70 VEML6075 0x10 UVA/UVB/UVINDEX Sensor 50 USE_VEML7700 xsns_71 VEML7700 0x10 Ambient light intensity sensor 51 USE_MCP9808 xsns_72 MCP9808 0x18 - 0x1F Temperature sensor 52 USE_HP303B xsns_73 HP303B 0x76 - 0x77 Pressure and temperature sensor 53 USE_MLX90640 xdrv_43 MLX90640 0x33 IR array temperature sensor 54 USE_VL53L1X xsns_77 VL53L1X 0x29 Time-of-flight (ToF) distance sensor 55 USE_EZOPH xsns_78 EZOPH 0x61 - 0x70 pH sensor 55 USE_EZOORP xsns_78 EZOORP 0x61 - 0x70 ORP sensor 55 USE_EZORTD xsns_78 EZORTD 0x61 - 0x70 Temperature sensor 55 USE_EZOHUM xsns_78 EZOHUM 0x61 - 0x70 Humidity sensor 55 USE_EZOEC xsns_78 EZOEC 0x61 - 0x70 Electric conductivity sensor 55 USE_EZOCO2 xsns_78 EZOCO2 0x61 - 0x70 CO2 sensor 55 USE_EZOO2 xsns_78 EZOO2 0x61 - 0x70 O2 sensor 55 USE_EZOPRS xsns_78 EZOPRS 0x61 - 0x70 Pressure sensor 55 USE_EZOFLO xsns_78 EZOFLO 0x61 - 0x70 Flow meter sensor 55 USE_EZODO xsns_78 EZODO 0x61 - 0x70 Disolved Oxygen sensor 55 USE_EZORGB xsns_78 EZORGB 0x61 - 0x70 Color sensor 55 USE_EZOPMP xsns_78 EZOPMP 0x61 - 0x70 Peristaltic Pump 56 USE_SEESAW_SOIL xsns_81 SEESOIL 0x36 - 0x39 Adafruit seesaw soil moisture sensor 57 USE_TOF10120 xsns_84 TOF10120 0x52 Time-of-flight (ToF) distance sensor 58 USE_MPU_ACCEL xsns_85 MPU_ACCEL 0x68 MPU6886/MPU9250 6-axis MotionTracking sensor from M5Stack 59 USE_BM8563 xdrv_56 BM8563 0x51 BM8563 RTC from M5Stack 60 USE_AM2320 xsns_88 AM2320 0x5C Temperature and Humidity sensor 61 USE_T67XX xsns_89 T67XX 0x15 CO2 sensor 62 USE_SCD40 xsns_92 SCD40 0x62 CO2 sensor Sensirion SCD40/SCD41 63 USE_HM330X xsns_93 HM330X 0x40 Particule sensor 64 USE_HDC2010 xsns_94 HDC2010 0x40 Temperature and Humidity sensor 65 USE_ADE7880 xnrg_23 ADE7880 0x38 Energy monitor 66 USE_PCF85363 xsns_99 PCF85363 0x51 Real time clock 67 USE_DS3502 xdrv_61 DS3502 0x28 - 0x2B Digital potentiometer 68 USE_HYT xsns_97 HYTxxx 0x28 Temperature and Humidity sensor","title":"I2C Devices"},{"location":"I2CDEVICES/#i2c-devices","text":"Tasmota supports several I2C devices. To use them I2C and the device need to be enabled at compile time. I2C and some devices are supported also in the official releases. Devices can be de/-actived on runtime to solve possible address conflicts. (e.g. address 0x27 is used by multiple devices) Using command I2cDriver individual drivers can be enabled or disabled at runtime allowing duplicate I2C addresses at compile time. Use the Index from the table below to control I2C drivers like I2cDriver10 0 for disabling BMP support.","title":"I2C devices"},{"location":"I2CDEVICES/#supported-i2c-devices","text":"The following table lists the supported I2C devices Index Define Driver Device Address(es) Description 1 USE_PCA9685 xdrv_15 PCA9685 0x40 - 0x47 16-channel 12-bit pwm driver 2 USE_PCF8574 xdrv_28 PCF8574 0x20 - 0x26 8-bit I/O expander 2 USE_PCF8574 xdrv_28 PCF8574A 0x39 - 0x3F 8-bit I/O expander 3 USE_DISPLAY_LCD xdsp_01 0x27, 0x3F LCD display 4 USE_DISPLAY_SSD1306 xdsp_02 SSD1306 0x3C - 0x3D Oled display 5 USE_DISPLAY_MATRIX xdsp_03 HT16K33 0x70 - 0x77 8x8 led matrix 6 USE_DISPLAY_SH1106 xdsp_07 SH1106 0x3C - 0x3D Oled display 7 USE_ADE7953 xnrg_07 ADE7953 0x38 Energy monitor 8 USE_SHT xsns_07 SHT1X Any Temperature and Humidity sensor 9 USE_HTU xsns_08 HTU21 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7013 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7020 0x40 Temperature and Humidity sensor 9 USE_HTU xsns_08 SI7021 0x40 Temperature and Humidity sensor 10 USE_BMP xsns_09 BMP085 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BMP180 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BMP280 0x76 - 0x77 Pressure and temperature sensor 10 USE_BMP xsns_09 BME280 0x76 - 0x77 Pressure, temperature and humidity sensor 10 USE_BMP xsns_09 BME680 0x76 - 0x77 Pressure, temperature, humidity and gas sensor 11 USE_BH1750 xsns_10 BH1750 0x23, 0x5C Ambient light intensity sensor 12 USE_VEML6070 xsns_11 VEML6070 0x38 - 0x39 Ultra violet light intensity sensor 13 USE_ADS1115 xsns_12 ADS1115 0x48 - 0x4B 4-channel 16-bit A/D converter 14 USE_INA219 xsns_13 INA219 0x40 - 0x41, 0x44 - 0x45 Low voltage current sensor 15 USE_SHT3X xsns_14 SHT3X 0x44 - 0x45 Temperature and Humidity sensor 15 USE_SHT3X xsns_14 SHT4X 0x44 - 0x45 Temperature and Humidity sensor 15 USE_SHT3X xsns_14 SHTCX 0x70 Temperature and Humidity sensor 16 USE_TSL2561 xsns_16 TSL2561 0x29, 0x39, 0x49 Light intensity sensor 17 USE_MGS xsns_19 Grove 0x04 Multichannel gas sensor 18 USE_SGP30 xsns_21 SGP30 0x58 Gas (TVOC) and air quality sensor 19 USE_SI1145 xsns_24 SI1145 0x60 Ultra violet index and light sensor 19 USE_SI1145 xsns_24 SI1146 0x60 Ultra violet index and light sensor 19 USE_SI1145 xsns_24 SI1147 0x60 Ultra violet index and light sensor 20 USE_LM75AD xsns_26 LM75AD 0x48 - 0x4F Temperature sensor 21 USE_APDS9960 xsns_27 APDS9960 0x39 Proximity ambient light RGB and gesture sensor 22 USE_MCP230xx xsns_29 MCP23008 0x20 - 0x26 8-bit I/O expander 22 USE_MCP230xx xsns_29 MCP23017 0x20 - 0x26 16-bit I/O expander 23 USE_MPR121 xsns_30 MPR121 0x5A - 0x5D Proximity capacitive touch sensor 24 USE_CCS811 xsns_31 CCS811 0x5A Gas (TVOC) and air quality sensor 25 USE_MPU6050 xsns_32 MPU6050 0x68 - 0x69 3-axis gyroscope and temperature sensor 26 USE_DS3231 xsns_33 DS3231 0x68 Real time clock 27 USE_MGC3130 xsns_36 MGC3130 0x42 Electric field sensor 28 USE_MAX44009 xsns_41 MAX44009 0x4A - 0x4B Ambient light intensity sensor 29 USE_SCD30 xsns_42 SCD30 0x61 CO2 sensor 30 USE_SPS30 xsns_44 SPS30 0x69 Particle sensor 31 USE_VL53L0X xsns_45 VL53L0X 0x29 Time-of-flight (ToF) distance sensor 32 USE_MLX90614 xsns_46 MLX90614 0x5A Infra red temperature sensor 33 USE_CHIRP xsns_48 CHIRP 0x20 Soil moisture sensor 34 USE_PAJ7620 xsns_50 PAJ7620 0x73 Gesture sensor 35 USE_INA226 xsns_54 INA226 0x40 - 0x41, 0x44 - 0x45 Low voltage current sensor 36 USE_HIH6 xsns_55 HIH6130 0x27 Temperature and Humidity sensor 37 USE_24C256 xdrv_10 24C256 0x50 Scripter EEPROM storage 38 USE_DISPLAY_ILI9488 xdsp_08 FT6236 0x38 Touch panel controller 39 USE_DISPLAY_RA8876 xdsp_10 FT5316 0x38 Touch panel controller 40 USE_TSL2591 xsns_57 TLS2591 0x29 Light intensity sensor 41 USE_DHT12 xsns_58 DHT12 0x5C Temperature and humidity sensor 42 USE_DS1624 xsns_59 DS1621 0x48 - 0x4F Temperature sensor 42 USE_DS1624 xsns_59 DS1624 0x48 - 0x4F Temperature sensor 43 USE_AHT1x xsns_63 AHT10/15 0x38 - 0x39 Temperature and humidity sensor 43 USE_AHT2x xsns_63 AHT20 0x38 Temperature and humidity sensor 43 USE_AHT2x xsns_63 AM2301B 0x38 Temperature and humidity sensor 44 USE_WEMOS_MOTOR_V1 xdrv_34 0x2D - 0x30 WEMOS motor shield v1.0.0 (6612FNG) 45 USE_HDC1080 xsns_65 HDC1080 0x40 Temperature and Humidity sensor 46 USE_IAQ xsns_66 IAQ 0x5a Air quality sensor 47 USE_DISPLAY_SEVENSEG xdsp_11 HT16K33 0x70 - 0x77 Seven segment LED 48 USE_AS3935 xsns_67 AS3935 0x03 Franklin Lightning Sensor 49 USE_VEML6075 xsns_70 VEML6075 0x10 UVA/UVB/UVINDEX Sensor 50 USE_VEML7700 xsns_71 VEML7700 0x10 Ambient light intensity sensor 51 USE_MCP9808 xsns_72 MCP9808 0x18 - 0x1F Temperature sensor 52 USE_HP303B xsns_73 HP303B 0x76 - 0x77 Pressure and temperature sensor 53 USE_MLX90640 xdrv_43 MLX90640 0x33 IR array temperature sensor 54 USE_VL53L1X xsns_77 VL53L1X 0x29 Time-of-flight (ToF) distance sensor 55 USE_EZOPH xsns_78 EZOPH 0x61 - 0x70 pH sensor 55 USE_EZOORP xsns_78 EZOORP 0x61 - 0x70 ORP sensor 55 USE_EZORTD xsns_78 EZORTD 0x61 - 0x70 Temperature sensor 55 USE_EZOHUM xsns_78 EZOHUM 0x61 - 0x70 Humidity sensor 55 USE_EZOEC xsns_78 EZOEC 0x61 - 0x70 Electric conductivity sensor 55 USE_EZOCO2 xsns_78 EZOCO2 0x61 - 0x70 CO2 sensor 55 USE_EZOO2 xsns_78 EZOO2 0x61 - 0x70 O2 sensor 55 USE_EZOPRS xsns_78 EZOPRS 0x61 - 0x70 Pressure sensor 55 USE_EZOFLO xsns_78 EZOFLO 0x61 - 0x70 Flow meter sensor 55 USE_EZODO xsns_78 EZODO 0x61 - 0x70 Disolved Oxygen sensor 55 USE_EZORGB xsns_78 EZORGB 0x61 - 0x70 Color sensor 55 USE_EZOPMP xsns_78 EZOPMP 0x61 - 0x70 Peristaltic Pump 56 USE_SEESAW_SOIL xsns_81 SEESOIL 0x36 - 0x39 Adafruit seesaw soil moisture sensor 57 USE_TOF10120 xsns_84 TOF10120 0x52 Time-of-flight (ToF) distance sensor 58 USE_MPU_ACCEL xsns_85 MPU_ACCEL 0x68 MPU6886/MPU9250 6-axis MotionTracking sensor from M5Stack 59 USE_BM8563 xdrv_56 BM8563 0x51 BM8563 RTC from M5Stack 60 USE_AM2320 xsns_88 AM2320 0x5C Temperature and Humidity sensor 61 USE_T67XX xsns_89 T67XX 0x15 CO2 sensor 62 USE_SCD40 xsns_92 SCD40 0x62 CO2 sensor Sensirion SCD40/SCD41 63 USE_HM330X xsns_93 HM330X 0x40 Particule sensor 64 USE_HDC2010 xsns_94 HDC2010 0x40 Temperature and Humidity sensor 65 USE_ADE7880 xnrg_23 ADE7880 0x38 Energy monitor 66 USE_PCF85363 xsns_99 PCF85363 0x51 Real time clock 67 USE_DS3502 xdrv_61 DS3502 0x28 - 0x2B Digital potentiometer 68 USE_HYT xsns_97 HYTxxx 0x28 Temperature and Humidity sensor","title":"Supported I2C devices"},{"location":"I2S-Audio/","text":"I2S Audio ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_I2S_AUDIO #define USE_I2S_AUDIO // Add support for I2S audio output #endif #ifndef USE_I2S_MIC #define USE_I2S_MIC // in case you want to use a microphone #endif // in case you want to use a microphone with mp3 encoding, this also requires PSRAM #ifndef USE_SHINE #define USE_SHINE // use mp3 encoding #endif remark: USE_M5STACK_CORE2, USE_TTGO_WATCH and ESP32S3_BOX automatically include i2s audio Only supported on ESP32 chips (except ESP32-C3) Hardware Required ~ Audio Output ~ For audio output an I2S DAC Audio breakout must be provided. There are several brands available Audio Input ~ For microphone input an I2S microphone must be provided. There are also several brands available. Connecting the I2S hardware to an ESP32 ~ I2SDAC ESP32-GPIO BCLK I2S_BCLK LRC I2S_WS DIN I2S_DOUT SD nc GAIN nc VIN 3.3-5V GND Ground I2S micro ESP32-GPIO SCK I2S_BCLK WS I2S_WS SD I2S_DIN L/R Ground VDD 3.3V GND Ground Tasmota Commands ~ CMD ADC action i2splay /file.mp3 = plays an mp3 audio file from the file system, the systems blocks until sound is played i2splay +/file.mp3 = plays an mp3 audio file from the file system, sound is played in a separate task not blocking the system i2sgain 0..100 = sets the loudness of the audio signal i2ssay text = speaks the text you typed (only English language supported) i2stime tells current time, (only if #define USE_I2S_SAY_TIME is defined CMD micro action i2srec /file.mp3 = starts recording an mp3 audio file to the file system, no blocking i2srec stops recording -? = shows how many seconds already recorded i2smgain 1..50 = sets the gain factor of the microphone Web Radio Support ~ (PSRAM needed) #ifndef USE_I2S_WEBRADIO #define USE_I2S_WEBRADIO // Add support mp3 webradio streaming #endif CMD WR action i2swr url = starts playing an mp3 audio radio stream, no blocking i2swr stops playing MP3 Streaming Support ~ Starts an mp3 streaming server on port 81 which can stream microphone audio to a browser (PSRAM needed) http://IP:81/stream.mp3 #ifndef MP3_MIC_STREAM #define MP3_MIC_STREAM // Add support for mp3 audio streaming #endif #define MP3_STREAM_PORT 81 // if defined overwrites the default 81 I2S Audio Bridge Support ~ Starts an UDP audio service to connect 2 ESP32 devices as an audio intercom. Needs audio output and microphone on 2 devices (no PSRAM needed) #ifndef I2S_BRIDGE #define I2S_BRIDGE // Add support for udp pcm audio bridge #endif #define I2S_BRIDGE_PORT 6970 // if defined overwrites the default 6970 CMD bridge action i2sbridge ip = sets the IP of the slave device i2sbridge Sets microphone swap 6 = swapped 7 = not swapped i2sbridge Sets master mode 4 = master 5 = slave i2sbridge pN p<x> = sets the push to talk button to GPIO pin number <x> i2sbridge Starts the bridge in write or read mode 1 = read 2 = write 3 = loopback 0 = stop If a push to talk button is defined: the bridge goes to write mode if the button is pushed and to read mode if the button is released","title":"I2S Audio"},{"location":"I2S-Audio/#i2s-audio","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_I2S_AUDIO #define USE_I2S_AUDIO // Add support for I2S audio output #endif #ifndef USE_I2S_MIC #define USE_I2S_MIC // in case you want to use a microphone #endif // in case you want to use a microphone with mp3 encoding, this also requires PSRAM #ifndef USE_SHINE #define USE_SHINE // use mp3 encoding #endif remark: USE_M5STACK_CORE2, USE_TTGO_WATCH and ESP32S3_BOX automatically include i2s audio Only supported on ESP32 chips (except ESP32-C3)","title":"I2S Audio "},{"location":"I2S-Audio/#hardware-required","text":"","title":"Hardware Required"},{"location":"I2S-Audio/#connecting-the-i2s-hardware-to-an-esp32","text":"I2SDAC ESP32-GPIO BCLK I2S_BCLK LRC I2S_WS DIN I2S_DOUT SD nc GAIN nc VIN 3.3-5V GND Ground I2S micro ESP32-GPIO SCK I2S_BCLK WS I2S_WS SD I2S_DIN L/R Ground VDD 3.3V GND Ground","title":"Connecting the I2S hardware to an ESP32"},{"location":"I2S-Audio/#tasmota-commands","text":"CMD ADC action i2splay /file.mp3 = plays an mp3 audio file from the file system, the systems blocks until sound is played i2splay +/file.mp3 = plays an mp3 audio file from the file system, sound is played in a separate task not blocking the system i2sgain 0..100 = sets the loudness of the audio signal i2ssay text = speaks the text you typed (only English language supported) i2stime tells current time, (only if #define USE_I2S_SAY_TIME is defined CMD micro action i2srec /file.mp3 = starts recording an mp3 audio file to the file system, no blocking i2srec stops recording -? = shows how many seconds already recorded i2smgain 1..50 = sets the gain factor of the microphone","title":"Tasmota Commands"},{"location":"I2S-Audio/#web-radio-support","text":"(PSRAM needed) #ifndef USE_I2S_WEBRADIO #define USE_I2S_WEBRADIO // Add support mp3 webradio streaming #endif CMD WR action i2swr url = starts playing an mp3 audio radio stream, no blocking i2swr stops playing","title":"Web Radio Support"},{"location":"I2S-Audio/#mp3-streaming-support","text":"Starts an mp3 streaming server on port 81 which can stream microphone audio to a browser (PSRAM needed) http://IP:81/stream.mp3 #ifndef MP3_MIC_STREAM #define MP3_MIC_STREAM // Add support for mp3 audio streaming #endif #define MP3_STREAM_PORT 81 // if defined overwrites the default 81","title":"MP3 Streaming Support"},{"location":"I2S-Audio/#i2s-audio-bridge-support","text":"Starts an UDP audio service to connect 2 ESP32 devices as an audio intercom. Needs audio output and microphone on 2 devices (no PSRAM needed) #ifndef I2S_BRIDGE #define I2S_BRIDGE // Add support for udp pcm audio bridge #endif #define I2S_BRIDGE_PORT 6970 // if defined overwrites the default 6970 CMD bridge action i2sbridge ip = sets the IP of the slave device i2sbridge Sets microphone swap 6 = swapped 7 = not swapped i2sbridge Sets master mode 4 = master 5 = slave i2sbridge pN p<x> = sets the push to talk button to GPIO pin number <x> i2sbridge Starts the bridge in write or read mode 1 = read 2 = write 3 = loopback 0 = stop If a push to talk button is defined: the bridge goes to write mode if the button is pushed and to read mode if the button is released","title":"I2S Audio Bridge Support"},{"location":"IAQ/","text":"iAQ-Core indoor air quality sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_IAQ #define USE_IAQ // [I2cDriver46] Enable iAQ-core air quality sensor (I2C address 0x5a) (+0k6 code) #endif The iAQ-core indoor air quality module is a low-cost, ultra compact solution for detecting poor air quality. This module uses micro-machined metal oxide semiconductor (MOS) technology to detect a broad range of VOCs while correlating directly with CO 2 and TVOC levels in the room. Warning All testing and driver programming has been done using iAQ-Core C sensor model. We don't know whether iAQ-Core P will work with this driver. Configuration ~ Wiring ~ Follow datasheet for required pull-ups when connecting the bare sensor module directly to ESP8266. Wemos and NodeMCU board include the required pull-up. Breakout ESP VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After configuring the GPIO's the driver will detect iAQ-Core automatically. On every power on sensor will run in Warm up mode for 5 minutes to calibrate. During this webUI shows: and console displays iAQ: Error 10 When warm-up is finished, sensor will show readings in web UI: and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"IAQ\":{\"eCO2\":450,\"TVOC\":125,\"Resistance\":76827}} Usage ~ Typical sensor reading should be around 450 ppm eCO 2 and 125 ppb TVOC. Resistance is sensor's gas resistance in Ohm and is the baseline reading from which eCO 2 and TVOC are calculated from If you see error messages in console, take appropriate action: iAQ: Error 1 During use, a message iAQ: Error 1 will randomly appear. This is normal, it's a skipped reading due to sensor still taking environment data during polling. iAQ: Error 80 If this error persists, the sensor is broken and should be replaced. iAQ: Error ff General connection error. Check your wiring and if the power supply supplies enough power to the sensor. Run I2CScan to check if the sensor can be found on 0x5a I 2 C address. Breakout Boards ~ Where to get ~ AliExpress sensor module Aliexpress breakout board Mouser DigiKey iAQ-Core Datasheet","title":"iAQ-Core indoor air quality sensor"},{"location":"IAQ/#iaq-core-indoor-air-quality-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_IAQ #define USE_IAQ // [I2cDriver46] Enable iAQ-core air quality sensor (I2C address 0x5a) (+0k6 code) #endif The iAQ-core indoor air quality module is a low-cost, ultra compact solution for detecting poor air quality. This module uses micro-machined metal oxide semiconductor (MOS) technology to detect a broad range of VOCs while correlating directly with CO 2 and TVOC levels in the room. Warning All testing and driver programming has been done using iAQ-Core C sensor model. We don't know whether iAQ-Core P will work with this driver.","title":"iAQ-Core indoor air quality sensor"},{"location":"IAQ/#configuration","text":"","title":"Configuration"},{"location":"IAQ/#usage","text":"Typical sensor reading should be around 450 ppm eCO 2 and 125 ppb TVOC. Resistance is sensor's gas resistance in Ohm and is the baseline reading from which eCO 2 and TVOC are calculated from If you see error messages in console, take appropriate action: iAQ: Error 1 During use, a message iAQ: Error 1 will randomly appear. This is normal, it's a skipped reading due to sensor still taking environment data during polling. iAQ: Error 80 If this error persists, the sensor is broken and should be replaced. iAQ: Error ff General connection error. Check your wiring and if the power supply supplies enough power to the sensor. Run I2CScan to check if the sensor can be found on 0x5a I 2 C address.","title":"Usage"},{"location":"IAQ/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"IP-Symcon/","text":"For users knowing more about integrating Tasmota with IP-Symcon please update this page. The Tasmota IP-Symcon interface can be found at https://github.com/Schnittcher/IPS-Tasmota There are currently two modules for IP Symcon Conditions ~ Mosquitto Broker MQTT Client - currently a modified version of IPS_MQTT by thomasf68 IP-Symcon version 4.1 or higher IPS-TasmotaConfigurator ~ With the configurator it is possible to generate automatically the IP Symcon instances for the Tasmota devices. IPS-Tasmota ~ With this Module it is possible to map devices that contain standard functions of the Tasmota firmware. For example: Sonoff Switch, Sonoff POW, Sonoff 4CH, Sonoff TH IPS-TasmotaLED ~ With the IPS-TasmotaLED module it is possible to map the LED modules that run with the Tasmota firmware. For example: WS2812, AiLight, Sonoff Led, B1, BN-SZ01, H801 and MagicHome Installation ~ Github Repositorys in IP Symcon via Core Instances -> Modules -> Add IPS-KS-MQTT Client: ~ https://github.com/Schnittcher/IPS-KS-MQTT.git IPS-Tasmota: ~ https://github.com/Schnittcher/IPS-Tasmota.git","title":"IP Symcon"},{"location":"IP-Symcon/#conditions","text":"Mosquitto Broker MQTT Client - currently a modified version of IPS_MQTT by thomasf68 IP-Symcon version 4.1 or higher","title":"Conditions"},{"location":"IP-Symcon/#ips-tasmotaconfigurator","text":"With the configurator it is possible to generate automatically the IP Symcon instances for the Tasmota devices.","title":"IPS-TasmotaConfigurator"},{"location":"IP-Symcon/#ips-tasmota","text":"With this Module it is possible to map devices that contain standard functions of the Tasmota firmware. For example: Sonoff Switch, Sonoff POW, Sonoff 4CH, Sonoff TH","title":"IPS-Tasmota"},{"location":"IP-Symcon/#ips-tasmotaled","text":"With the IPS-TasmotaLED module it is possible to map the LED modules that run with the Tasmota firmware. For example: WS2812, AiLight, Sonoff Led, B1, BN-SZ01, H801 and MagicHome","title":"IPS-TasmotaLED"},{"location":"IP-Symcon/#installation","text":"Github Repositorys in IP Symcon via Core Instances -> Modules -> Add","title":"Installation"},{"location":"IP-Symcon/#ips-ks-mqtt-client","text":"https://github.com/Schnittcher/IPS-KS-MQTT.git","title":"IPS-KS-MQTT Client:"},{"location":"IP-Symcon/#ips-tasmota_1","text":"https://github.com/Schnittcher/IPS-Tasmota.git","title":"IPS-Tasmota:"},{"location":"IR-Remote/","text":"IR Remote driver enables sending IR codes through an IR transmitter and receiving them through an IR receiver via IRremoteESP8266 library . Most builds support only the common IR protocols, but tasmota-ir.bin supports almost all protocols available in the IRremoteESP8266 library. IR Transmitter ~ Common transmitter modules in the market have a weak IR LED, thus effective transmit distance is really short. If you need range it is best to build your own . For the LED we recommend TSAL6400 for best performance. YT-IRTM transmitter/receiver board is serial only and does not work with this driver (its also limited to only NEC IR protocol). Wiring ~ IR w/ 2N222 ESP data GPIOx + 3.3v/5v - GND Tasmota ~ In the Configuration -> Configure Module page assign: GPIOx to IRsend (8) See IR commands for use. IR Receiver ~ IR Receiver is used to capture IR codes. Those codes can be sent using IRSend or used as a rule trigger. Example uses the widely available KY-022 breakout board. Wiring ~ KY-022 ESP S GPIOx + 5v - GND Tasmota ~ In the Configuration -> Configure Module page assign: GPIOx to IRrecv (51) On a captured code IR receiver sends a tele/%topic%/RESULT JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"IrReceived\" : { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF00FF\" } } Further Reading ~ This covers only the basic IR protocols. Read Complete IR Remote Protocols for more advanced applications. IR Send RAW configuration and use User maintained codes database for IR Linux Infrared Remote Control (LIRC) for more information. Related Projects ~ Automate Things IR Bridge Sonoff Basic IR \"hat\" Example circuit with transmitter and receiver:","title":"IR Remote"},{"location":"IR-Remote/#ir-transmitter","text":"Common transmitter modules in the market have a weak IR LED, thus effective transmit distance is really short. If you need range it is best to build your own . For the LED we recommend TSAL6400 for best performance. YT-IRTM transmitter/receiver board is serial only and does not work with this driver (its also limited to only NEC IR protocol).","title":"IR Transmitter"},{"location":"IR-Remote/#wiring","text":"IR w/ 2N222 ESP data GPIOx + 3.3v/5v - GND","title":"Wiring"},{"location":"IR-Remote/#tasmota","text":"In the Configuration -> Configure Module page assign: GPIOx to IRsend (8) See IR commands for use.","title":"Tasmota"},{"location":"IR-Remote/#ir-receiver","text":"IR Receiver is used to capture IR codes. Those codes can be sent using IRSend or used as a rule trigger. Example uses the widely available KY-022 breakout board.","title":"IR Receiver"},{"location":"IR-Remote/#wiring_1","text":"KY-022 ESP S GPIOx + 5v - GND","title":"Wiring"},{"location":"IR-Remote/#tasmota_1","text":"In the Configuration -> Configure Module page assign: GPIOx to IRrecv (51) On a captured code IR receiver sends a tele/%topic%/RESULT JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"IrReceived\" : { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF00FF\" } }","title":"Tasmota"},{"location":"IR-Remote/#further-reading","text":"This covers only the basic IR protocols. Read Complete IR Remote Protocols for more advanced applications. IR Send RAW configuration and use User maintained codes database for IR Linux Infrared Remote Control (LIRC) for more information.","title":"Further Reading"},{"location":"IR-Remote/#related-projects","text":"Automate Things IR Bridge Sonoff Basic IR \"hat\" Example circuit with transmitter and receiver:","title":"Related Projects"},{"location":"IRSend-RAW-Encoding/","text":"New IR Raw compact encoding ~ (available since v9.0.0.1) We had numerous requests from users to expand the buffer sizes because many IR codes would exceed the MQTT/Web/Serial buffer size. Instead, we changed the IR Raw encoding to shrink the size necessary to encode almost any IR code. Before (buffer overflow): {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0,\"RawData\":[8574,4224,574,1558,572,502,570,1562,570,502,572,502,570,1562,570,502,570,1562,572,500,572,1560,572,500,572,1560,572,1560,570,504,568,1560,570,502,572,502,570,1562,570,502,570,1560,570,502,572,500,570,502,572,502,570,1560,570,504,572,1558,572,502,570,1564,568,1562,570,1560,572,1560,572,25258,8574,4222,572,1560,570,502,572,1558,572,502,570,502,572,1558,572,500,570,1560,570,502,570,1560,570,502,570,1560,570,1560,570,504,570,1560,572,502,570,502,570,1560,572,502,570,1560,570,502,570,502,570,502,570,502,570,1560,570,502,570,1560,572,502,570 ... Now (no overflow): {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0,\"RawData\":[+8570-4240+550-1580C-510+565-1565F-505Fh+570gFhIdChIgFeFgFgIhFgIhF-525C-1560IhIkI-520ChFhFhFgFhIkIhIgIgIkIkI-25270A-4225IkIhIgIhIhIkFhIkFjCgIhIkIkI-500IkIhIhIkFhIgIl+545hIhIoIgIhIkFhFgIkIgFgI],\"RawDataInfo\":[135,135,0]}} The new format still encodes timings for High/low pulses. First the timings are rounded to the closest 5 microsec value. Instead of using commas, values are prefixed with + if it's a HIGH signal, or - if it's a LOW signal. Each new timing value is assigned a letter starting with 'A' If a timing value matches a previously found value, it is replaced with the letter, in uppercase for a HIGH signal, or lowercase for a LOW signal. Ex: +8570-4240+550-1580C-510+565-1565F-505Fh \\__/ \\__/ \\_/ \\__/C \\_/ \\_/ \\__/F \\_/Fh A B C D E F G H Which translates to: +8570-4240+550-1580+550-510+565-1565+565-505+565-505 or 8570,4240,550,1580,550,510,565,1565,565,505,565,505 If you need to transform the compact format in the legacy format, you can use the online tool: https://tasmota.hadinger.fr/util IRSend for raw IR ~ There are two command syntax forms for sending a remote control code in RAW format with IRsend : IRSend<x> <frequency>,<rawdata1>,<rawdata2>,..,<rawdataN> e.g., IRsend 0,926,844,958,832,1798,868,902,848,900,870,900,852,908,918,958,794,934,874,928,1738,934,856,1764 or IRSend 0,+8570-4240+550-1580C-510+565-1565F-505Fh+570gFhIdChIgFeFgFgIhFgIhF-525C-1560IhIkI-520ChFhFhFgFhIkIhIgIgIkIkI-25270A-4225IkIhIgIhIhIkFhIkFjCgIhIkIkI-500IkIhIhIkFhIgIl+545hIhIoIgIhIkFhFgIkIgFgI IRSend<x> raw,<frequency>[,<header_mark>,<header_space>,<bit_mark>],<zero_space>[, [<one_multiple>] | <one_space>],<bit_stream> Where Parameter Description <frequency> carrier frequency (default 0 = 38kHz) <header_mark> ** header mark duration (\u00b5s) (optional for some protocols) <header_space> ** header space duration (\u00b5s) (optional for some protocols) <bit_mark> bit mark duration (\u00b5s) (optional for some protocols) <zero_space> zero space duration (\u00b5s) <one_multiple> used to specify the one space duration if the one space duration is an integral multiple of the zero space duration. This parameter may be omitted if the multiple is 2. Use of this parameter is mutually exclusive with the <one_space> parameter <one_space> one space duration (\u00b5s). Use this parameter if the one space duration is not an integral multiple of <zero_space> Use of this parameter is mutually exclusive with the <one_multiple> parameter <bit_stream> bit stream data (stream of ones and zeroes) ** If header_mark and header_space are specified, the gap will be computed as (header_mark + header_space) * 3 with a high limit of 65ms (65,000\u00b5s) to avoid 16 bits overflow. If header_mark and header_space are not specified, the gap will be 40ms (40,000\u00b5s). This command syntax version makes use of the output of the raw IR decoder from ToniA/Raw-IR-decoder-for-Arduino Examples for bitstream command syntax ~ rawirdecode output: ~ Number of symbols: 75 Symbols: Hh010101101000111011001110000000001100110000000001100000000000000010001100 Bytes: 00: 0101|0110 | 6A | 01101010 01: 1000|1110 | 71 | 01110001 02: 1100|1110 | 73 | 01110011 03: 0000|0000 | 00 | 00000000 04: 1100|1100 | 33 | 00110011 05: 0000|0001 | 80 | 10000000 06: 1000|0000 | 01 | 00000001 07: 0000|0000 | 00 | 00000000 08: 1000|1100 | 31 | 00110001 6A,71,73,00,33,80,01,00,31 Timings (in us): PAUSE SPACE: 0 HEADER MARK: 8620 HEADER SPACE: 4260 BIT MARK: 544 ZERO SPACE: 411 ONE SPACE: 1496 Decoding known protocols... Unknown protocol Bytecount: 9 Corresponding command: IRSend<x> raw,0,8620,4260,544,411,1496,010101101000111011001110000000001100110000000001100000000000000010001100 Gree air conditioner Power On ~ {8956, 4560, 546, 1710, 588, 616, 584, 618, 584, 1712, 586, 1712, 588, 614, 586, 614, 586, 618, 586, 1706, 590, 616 , 586, 1708, 590, 616, 588, 610, 590, 612, 590, 612, 590, 618, 584, 618, 584, 616, 586, 614, 588, 612, 590, 612, 590, 1712, 586 , 616, 588, 612, 590, 614, 588, 614, 586, 618, 586, 616, 586, 1710, 588, 614, 586, 1708, 590, 610, 592, 612, 590, 1708, 588, 614 , 588, 20084, 548, 612, 590, 614, 588, 614, 588, 616, 586, 654, 546, 616, 586, 616, 586, 614, 588, 612, 588, 610, 592, 612, 590 , 612, 590, 614, 586, 1712, 586, 616, 586, 612, 588, 614, 588, 614, 586, 616, 586, 612, 590, 614, 588, 610, 590, 616, 586, 614 , 588, 612, 590, 612, 590, 614, 588, 614, 588, 614, 588, 1708, 590, 612, 590, 1708, 590} Arrange the data into pairs: MARK SPACE BIT 8956 4560 (header) 546 1710 1 588 616 0 584 618 0 584 1712 1 586 1712 1 588 614 0 586 614 0 ... 590 612 0 590 614 0 588 614 0 588 614 0 588 1708 1 590 612 0 590 1708 1 590 (ignore) The header is always the first pair, the zeroes have the shortest space duration and the ones have the longest space duration. header mark is 8956 header space is 4560 bit mark, get the average, say 590 zero space, say 615 one space, say 1710 Corresponding command: IRSend<x> raw,0,8956,4560,590,615,1710,1001100 ... 0000101 Understanding IR encoding ~ Below are several topics that may help you decoding and understanding what your IR remotes are sending (ex: HVAC) or convert from popular IR formats like PRONTO or Broadlink. First, have a look at the excellent article from Elektor IR Remote Control Codes Decoding IR codes by hand ~ From discussion with @johan1111 on Discord. Let's suppose you have an unsupported HVAL and record the following raw IR codes using Tasmota: [3094,3062,3092,4442,576,1652,578,528,576,1650,580,528,576,528,576,1650,...] IR messages typically start with a long Mark (IR on), followed by a long Space (IR off). Here we see a double sequence of Mark (3094 \u00b5s) - Space (3062 \u00b5s) - Mark (3092 \u00b5s) - Space (4442 \u00b5s). The actual bitstream is 576,1652,578,528,576,1650,580,528,576,528,576,1650,... . You need to take timing by pairs, again the first value is Mark (IR on), the second Space (IR off). The Mark is typically of constant time, and the space will vary from short (~528 \u00b5s) for bit 0 to long (~1650 \u00b5s) for bit 1 . So the first bits of the bitstream are: 101001... Pioneer IR enconding ~ Pioneer IR encoding is very similar to NEC encoding for the bitstream. When capturing IR codes, they will easily be recognized as NEC codes. But they have subtle differences. First, the Frequency if 40KHz for Pioneer vs 38KHz for NEC. The number of IR pulses are the same, so all Pioneer timings are 5% shorter than Nec equivalent. Most Pioneer will tolerate the difference, but some won't. If you have a Pioneer device, prefer the Pioneer encoding. Second, Pioneer introduced 64 bits messages vs 32 bits for NEC. Most simple Pioneer commands still use 32 bits, but newer require 64 bits. 64 bits messages are actually sent as 2x 32 bits messages with a very short pause in between. Example, Pioneer Vol+ is 32 bits message and must be sent twice. You can either send the same message 0xA55A50AF twice with IRSend2 or send a 64 bits message with twice the same 32 payload: 0xA55A50AFA55A50AF . IRSend2 {\"Protocol\":\"PIONEER\",\"Bits\":32,\"Data\":\"0xA55A50AF\"} or IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\"} Example 2: Pioneer Stereo: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AF906A55A03FC\"} How to convert Pioneer codes to Tasmota ~ Pioneer kindly publishes all IR Codes online on its website. Let's take a Pioneer Receiver like VSX-820. Choose the right Excel file and navigate in the corresponding tab. Pioneer codes are in short format. For example \"TV / SAT\" code is A59B+A5CD . You now need to convert these short codes into 64 bits IRRemote8266 codes. Steps: 1. Take the first byte: 0xA5 or 0b10100101 . Pioneer codes are LSB, but we need MSB. So read backwards all bits to 0b10100101 and back to hex A5 . Your first byte is A5 . Note: You can see here that 0xA5 is a palindrome. 2. Invert all bits of previous byte: 0b01011010 . Your second byte is 5A . 3. Take the second byte 0x9B or 0b10011011 . Read backwards all bits giving 0b11011001. Your third byte is D9 . 4. Invert all bits from previous byte: 0b00100110 . Your fourth byte is 26 . Do the same with the second sequence A5CD , you should find the following sequence: A55AB3CD . The final sequence is: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD926A55AB3CD\"} Converting Pronto IR codes to Tasmota ~ Pronto is a very common and early format to describe raw IR codes. It is fully described in this excellent series of articles The Pronto's IR Code Format If you don't want to manually convert the pronto IR codes, you can use the Tasmota-IR-Code-Converter site to do it for you. Pronto is commonly represented as a series of 4-digits HEX numbers in unsigned 16-bits format. Example, from Foxtel Vol+: Vol + 0000 0073 0000 0012 000F 000A 0006 000A 0006 0016 0006 000A 0006 0010 0006 0016 0006 0016 0006 000A 0006 000A 0006 000A 0006 0016 0006 0010 0006 0016 0006 000A 0006 0010 0006 000A 0006 000A 0006 0CA0 To convert from Pronto to IRSend by hand it requires extra work. Ignore first 0000 0073 is the IR frequency, compute as \"Frequency = 1000000/(N * .241246)\". So for 0x73 (115), this gives 36KHz. First value for IRSend is 36 . 0000 is the length of the One Time Burst. There is no one time burst 0012 - Decimal 18 is the length of the repeat burst. There are 18 bits (Burst pairs) in this code. Next pulses are measured in pulses of the IR clock, so it depends on the frequency. With 36KHz, each pulse is (1000/36) 27.7 microseconds So you need to multiply by 27.7 for Tasmota to get actual \u00b5s 000F 000A - becomes 415,277 0006 000A - becomes 166,277 And so on... In the end, it will look like: IRSend 36,415,277,166,277,... Converting Broadlink IR codes to Tasmota ~ Broadlink is another popular device to send and receive IR/RF codes. Unfortunately, it does not run ESP8266, so it cannot be Tasmotized. Broadlink codes come either in Base64 format or in Hex format. Below will use Hex format which is easier to work by hand. Example: \"Code\": \"2600700000015692171117111612171116121612161117111735173517361636161117351735173517111636161216121611171116121612163616111735173517351735173517351700053D0001554916000C4E0001554916000C4E0001564817000C4D0001564917000C4C0001564917000D050000000000000000\", \"Base64\": \"JgBwAAABVpIXERcRFhIXERYSFhIWERcRFzUXNRc2FjYWERc1FzUXNRcRFjYWEhYSFhEXERYSFhIWNhYRFzUXNRc1FzUXNRc1FwAFPQABVUkWAAxOAAFVSRYADE4AAVZIFwAMTQABVkkXAAxMAAFWSRcADQUAAAAAAAAAAA== The Broadling protocol is described here: Broadlink RM2 network protocol Here is a copy of the part specifically describing Offset Contents 0x00 0x26 = IR, 0xb2 for RF 433Mhz, 0xd7 for RF 315Mhz 0x01 repeat count, (0 = no repeat, 1 send twice, .....) 0x02-0x03 Length of the following data in little endian 0x04 .... Pulse lengths in 2^-15 s units (\u00b5s * 269 / 8192 works very well) .... 0x0d 0x05 at the end for IR only Each value is represented by one byte. If the length exceeds one byte then it is stored big endian with a leading 0. Example: The header for an Optoma projector is 8920 4450 8920 * 269 / 8192 = 0x124 4450 * 269 / 8192 = 0x92 ... which would be encoded as 0x00 0x1 0x24 0x92 in broalink format. You have all the needed information to convert from Broadlink to Tasmota... See broadlink-ir-converter for a complete implementation example (in JavaScript) which is also available as a package on the NPM registry .","title":"IRSend RAW Encoding"},{"location":"IRSend-RAW-Encoding/#new-ir-raw-compact-encoding","text":"(available since v9.0.0.1) We had numerous requests from users to expand the buffer sizes because many IR codes would exceed the MQTT/Web/Serial buffer size. Instead, we changed the IR Raw encoding to shrink the size necessary to encode almost any IR code. Before (buffer overflow): {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0,\"RawData\":[8574,4224,574,1558,572,502,570,1562,570,502,572,502,570,1562,570,502,570,1562,572,500,572,1560,572,500,572,1560,572,1560,570,504,568,1560,570,502,572,502,570,1562,570,502,570,1560,570,502,572,500,570,502,572,502,570,1560,570,504,572,1558,572,502,570,1564,568,1562,570,1560,572,1560,572,25258,8574,4222,572,1560,570,502,572,1558,572,502,570,502,572,1558,572,500,570,1560,570,502,570,1560,570,502,570,1560,570,1560,570,504,570,1560,572,502,570,502,570,1560,572,502,570,1560,570,502,570,502,570,502,570,502,570,1560,570,502,570,1560,572,502,570 ... Now (no overflow): {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0,\"RawData\":[+8570-4240+550-1580C-510+565-1565F-505Fh+570gFhIdChIgFeFgFgIhFgIhF-525C-1560IhIkI-520ChFhFhFgFhIkIhIgIgIkIkI-25270A-4225IkIhIgIhIhIkFhIkFjCgIhIkIkI-500IkIhIhIkFhIgIl+545hIhIoIgIhIkFhFgIkIgFgI],\"RawDataInfo\":[135,135,0]}} The new format still encodes timings for High/low pulses. First the timings are rounded to the closest 5 microsec value. Instead of using commas, values are prefixed with + if it's a HIGH signal, or - if it's a LOW signal. Each new timing value is assigned a letter starting with 'A' If a timing value matches a previously found value, it is replaced with the letter, in uppercase for a HIGH signal, or lowercase for a LOW signal. Ex: +8570-4240+550-1580C-510+565-1565F-505Fh \\__/ \\__/ \\_/ \\__/C \\_/ \\_/ \\__/F \\_/Fh A B C D E F G H Which translates to: +8570-4240+550-1580+550-510+565-1565+565-505+565-505 or 8570,4240,550,1580,550,510,565,1565,565,505,565,505 If you need to transform the compact format in the legacy format, you can use the online tool: https://tasmota.hadinger.fr/util","title":"New IR Raw compact encoding"},{"location":"IRSend-RAW-Encoding/#irsend-for-raw-ir","text":"There are two command syntax forms for sending a remote control code in RAW format with IRsend : IRSend<x> <frequency>,<rawdata1>,<rawdata2>,..,<rawdataN> e.g., IRsend 0,926,844,958,832,1798,868,902,848,900,870,900,852,908,918,958,794,934,874,928,1738,934,856,1764 or IRSend 0,+8570-4240+550-1580C-510+565-1565F-505Fh+570gFhIdChIgFeFgFgIhFgIhF-525C-1560IhIkI-520ChFhFhFgFhIkIhIgIgIkIkI-25270A-4225IkIhIgIhIhIkFhIkFjCgIhIkIkI-500IkIhIhIkFhIgIl+545hIhIoIgIhIkFhFgIkIgFgI IRSend<x> raw,<frequency>[,<header_mark>,<header_space>,<bit_mark>],<zero_space>[, [<one_multiple>] | <one_space>],<bit_stream> Where Parameter Description <frequency> carrier frequency (default 0 = 38kHz) <header_mark> ** header mark duration (\u00b5s) (optional for some protocols) <header_space> ** header space duration (\u00b5s) (optional for some protocols) <bit_mark> bit mark duration (\u00b5s) (optional for some protocols) <zero_space> zero space duration (\u00b5s) <one_multiple> used to specify the one space duration if the one space duration is an integral multiple of the zero space duration. This parameter may be omitted if the multiple is 2. Use of this parameter is mutually exclusive with the <one_space> parameter <one_space> one space duration (\u00b5s). Use this parameter if the one space duration is not an integral multiple of <zero_space> Use of this parameter is mutually exclusive with the <one_multiple> parameter <bit_stream> bit stream data (stream of ones and zeroes) ** If header_mark and header_space are specified, the gap will be computed as (header_mark + header_space) * 3 with a high limit of 65ms (65,000\u00b5s) to avoid 16 bits overflow. If header_mark and header_space are not specified, the gap will be 40ms (40,000\u00b5s). This command syntax version makes use of the output of the raw IR decoder from ToniA/Raw-IR-decoder-for-Arduino","title":"IRSend for raw IR"},{"location":"IRSend-RAW-Encoding/#examples-for-bitstream-command-syntax","text":"","title":"Examples for bitstream command syntax"},{"location":"IRSend-RAW-Encoding/#rawirdecode-output","text":"Number of symbols: 75 Symbols: Hh010101101000111011001110000000001100110000000001100000000000000010001100 Bytes: 00: 0101|0110 | 6A | 01101010 01: 1000|1110 | 71 | 01110001 02: 1100|1110 | 73 | 01110011 03: 0000|0000 | 00 | 00000000 04: 1100|1100 | 33 | 00110011 05: 0000|0001 | 80 | 10000000 06: 1000|0000 | 01 | 00000001 07: 0000|0000 | 00 | 00000000 08: 1000|1100 | 31 | 00110001 6A,71,73,00,33,80,01,00,31 Timings (in us): PAUSE SPACE: 0 HEADER MARK: 8620 HEADER SPACE: 4260 BIT MARK: 544 ZERO SPACE: 411 ONE SPACE: 1496 Decoding known protocols... Unknown protocol Bytecount: 9 Corresponding command: IRSend<x> raw,0,8620,4260,544,411,1496,010101101000111011001110000000001100110000000001100000000000000010001100","title":"rawirdecode output:"},{"location":"IRSend-RAW-Encoding/#gree-air-conditioner-power-on","text":"{8956, 4560, 546, 1710, 588, 616, 584, 618, 584, 1712, 586, 1712, 588, 614, 586, 614, 586, 618, 586, 1706, 590, 616 , 586, 1708, 590, 616, 588, 610, 590, 612, 590, 612, 590, 618, 584, 618, 584, 616, 586, 614, 588, 612, 590, 612, 590, 1712, 586 , 616, 588, 612, 590, 614, 588, 614, 586, 618, 586, 616, 586, 1710, 588, 614, 586, 1708, 590, 610, 592, 612, 590, 1708, 588, 614 , 588, 20084, 548, 612, 590, 614, 588, 614, 588, 616, 586, 654, 546, 616, 586, 616, 586, 614, 588, 612, 588, 610, 592, 612, 590 , 612, 590, 614, 586, 1712, 586, 616, 586, 612, 588, 614, 588, 614, 586, 616, 586, 612, 590, 614, 588, 610, 590, 616, 586, 614 , 588, 612, 590, 612, 590, 614, 588, 614, 588, 614, 588, 1708, 590, 612, 590, 1708, 590} Arrange the data into pairs: MARK SPACE BIT 8956 4560 (header) 546 1710 1 588 616 0 584 618 0 584 1712 1 586 1712 1 588 614 0 586 614 0 ... 590 612 0 590 614 0 588 614 0 588 614 0 588 1708 1 590 612 0 590 1708 1 590 (ignore) The header is always the first pair, the zeroes have the shortest space duration and the ones have the longest space duration. header mark is 8956 header space is 4560 bit mark, get the average, say 590 zero space, say 615 one space, say 1710 Corresponding command: IRSend<x> raw,0,8956,4560,590,615,1710,1001100 ... 0000101","title":"Gree air conditioner Power On"},{"location":"IRSend-RAW-Encoding/#understanding-ir-encoding","text":"Below are several topics that may help you decoding and understanding what your IR remotes are sending (ex: HVAC) or convert from popular IR formats like PRONTO or Broadlink. First, have a look at the excellent article from Elektor IR Remote Control Codes","title":"Understanding IR encoding"},{"location":"IRSend-RAW-Encoding/#decoding-ir-codes-by-hand","text":"From discussion with @johan1111 on Discord. Let's suppose you have an unsupported HVAL and record the following raw IR codes using Tasmota: [3094,3062,3092,4442,576,1652,578,528,576,1650,580,528,576,528,576,1650,...] IR messages typically start with a long Mark (IR on), followed by a long Space (IR off). Here we see a double sequence of Mark (3094 \u00b5s) - Space (3062 \u00b5s) - Mark (3092 \u00b5s) - Space (4442 \u00b5s). The actual bitstream is 576,1652,578,528,576,1650,580,528,576,528,576,1650,... . You need to take timing by pairs, again the first value is Mark (IR on), the second Space (IR off). The Mark is typically of constant time, and the space will vary from short (~528 \u00b5s) for bit 0 to long (~1650 \u00b5s) for bit 1 . So the first bits of the bitstream are: 101001...","title":"Decoding IR codes by hand"},{"location":"IRSend-RAW-Encoding/#pioneer-ir-enconding","text":"Pioneer IR encoding is very similar to NEC encoding for the bitstream. When capturing IR codes, they will easily be recognized as NEC codes. But they have subtle differences. First, the Frequency if 40KHz for Pioneer vs 38KHz for NEC. The number of IR pulses are the same, so all Pioneer timings are 5% shorter than Nec equivalent. Most Pioneer will tolerate the difference, but some won't. If you have a Pioneer device, prefer the Pioneer encoding. Second, Pioneer introduced 64 bits messages vs 32 bits for NEC. Most simple Pioneer commands still use 32 bits, but newer require 64 bits. 64 bits messages are actually sent as 2x 32 bits messages with a very short pause in between. Example, Pioneer Vol+ is 32 bits message and must be sent twice. You can either send the same message 0xA55A50AF twice with IRSend2 or send a 64 bits message with twice the same 32 payload: 0xA55A50AFA55A50AF . IRSend2 {\"Protocol\":\"PIONEER\",\"Bits\":32,\"Data\":\"0xA55A50AF\"} or IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\"} Example 2: Pioneer Stereo: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AF906A55A03FC\"}","title":"Pioneer IR enconding"},{"location":"IRSend-RAW-Encoding/#how-to-convert-pioneer-codes-to-tasmota","text":"Pioneer kindly publishes all IR Codes online on its website. Let's take a Pioneer Receiver like VSX-820. Choose the right Excel file and navigate in the corresponding tab. Pioneer codes are in short format. For example \"TV / SAT\" code is A59B+A5CD . You now need to convert these short codes into 64 bits IRRemote8266 codes. Steps: 1. Take the first byte: 0xA5 or 0b10100101 . Pioneer codes are LSB, but we need MSB. So read backwards all bits to 0b10100101 and back to hex A5 . Your first byte is A5 . Note: You can see here that 0xA5 is a palindrome. 2. Invert all bits of previous byte: 0b01011010 . Your second byte is 5A . 3. Take the second byte 0x9B or 0b10011011 . Read backwards all bits giving 0b11011001. Your third byte is D9 . 4. Invert all bits from previous byte: 0b00100110 . Your fourth byte is 26 . Do the same with the second sequence A5CD , you should find the following sequence: A55AB3CD . The final sequence is: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD926A55AB3CD\"}","title":"How to convert Pioneer codes to Tasmota"},{"location":"IRSend-RAW-Encoding/#converting-pronto-ir-codes-to-tasmota","text":"Pronto is a very common and early format to describe raw IR codes. It is fully described in this excellent series of articles The Pronto's IR Code Format If you don't want to manually convert the pronto IR codes, you can use the Tasmota-IR-Code-Converter site to do it for you. Pronto is commonly represented as a series of 4-digits HEX numbers in unsigned 16-bits format. Example, from Foxtel Vol+: Vol + 0000 0073 0000 0012 000F 000A 0006 000A 0006 0016 0006 000A 0006 0010 0006 0016 0006 0016 0006 000A 0006 000A 0006 000A 0006 0016 0006 0010 0006 0016 0006 000A 0006 0010 0006 000A 0006 000A 0006 0CA0 To convert from Pronto to IRSend by hand it requires extra work. Ignore first 0000 0073 is the IR frequency, compute as \"Frequency = 1000000/(N * .241246)\". So for 0x73 (115), this gives 36KHz. First value for IRSend is 36 . 0000 is the length of the One Time Burst. There is no one time burst 0012 - Decimal 18 is the length of the repeat burst. There are 18 bits (Burst pairs) in this code. Next pulses are measured in pulses of the IR clock, so it depends on the frequency. With 36KHz, each pulse is (1000/36) 27.7 microseconds So you need to multiply by 27.7 for Tasmota to get actual \u00b5s 000F 000A - becomes 415,277 0006 000A - becomes 166,277 And so on... In the end, it will look like: IRSend 36,415,277,166,277,...","title":"Converting Pronto IR codes to Tasmota"},{"location":"IRSend-RAW-Encoding/#converting-broadlink-ir-codes-to-tasmota","text":"Broadlink is another popular device to send and receive IR/RF codes. Unfortunately, it does not run ESP8266, so it cannot be Tasmotized. Broadlink codes come either in Base64 format or in Hex format. Below will use Hex format which is easier to work by hand. Example: \"Code\": \"2600700000015692171117111612171116121612161117111735173517361636161117351735173517111636161216121611171116121612163616111735173517351735173517351700053D0001554916000C4E0001554916000C4E0001564817000C4D0001564917000C4C0001564917000D050000000000000000\", \"Base64\": \"JgBwAAABVpIXERcRFhIXERYSFhIWERcRFzUXNRc2FjYWERc1FzUXNRcRFjYWEhYSFhEXERYSFhIWNhYRFzUXNRc1FzUXNRc1FwAFPQABVUkWAAxOAAFVSRYADE4AAVZIFwAMTQABVkkXAAxMAAFWSRcADQUAAAAAAAAAAA== The Broadling protocol is described here: Broadlink RM2 network protocol Here is a copy of the part specifically describing Offset Contents 0x00 0x26 = IR, 0xb2 for RF 433Mhz, 0xd7 for RF 315Mhz 0x01 repeat count, (0 = no repeat, 1 send twice, .....) 0x02-0x03 Length of the following data in little endian 0x04 .... Pulse lengths in 2^-15 s units (\u00b5s * 269 / 8192 works very well) .... 0x0d 0x05 at the end for IR only Each value is represented by one byte. If the length exceeds one byte then it is stored big endian with a leading 0. Example: The header for an Optoma projector is 8920 4450 8920 * 269 / 8192 = 0x124 4450 * 269 / 8192 = 0x92 ... which would be encoded as 0x00 0x1 0x24 0x92 in broalink format. You have all the needed information to convert from Broadlink to Tasmota... See broadlink-ir-converter for a complete implementation example (in JavaScript) which is also available as a package on the NPM registry .","title":"Converting Broadlink IR codes to Tasmota"},{"location":"Integrations/","text":"Introduction ~ Tasmota easily integrates with many home automation solutions reporting status and sensor data and allowing complete control.","title":"Introduction"},{"location":"Integrations/#introduction","text":"Tasmota easily integrates with many home automation solutions reporting status and sensor data and allowing complete control.","title":"Introduction"},{"location":"JSON-Status-Responses/","text":"JSON Changes ~ temp note: for now (6.0.0a) the statetext overwrites the json power result (e.g. \"ON\" => \"AN\" or any other statetext the users enter) Basic Response ~ { \"Status\": { \"Module\": 1, \"FriendlyName\": \"XXX\", \"Topic\": \"sonoff\", \"ButtonTopic\": \"0\", \"Power\": 0, \"PowerOnState\": 0, \"LedState\": 1, \"SaveData\": 0, \"SaveState\": 1, \"ButtonRetain\": 0, \"PowerRetain\": 0 }, \"StatusPRM\": { \"Baudrate\": 115200, \"GroupTopic\": \"sonoffs\", \"OtaUrl\": \"XXX\", \"Uptime\": \"1 02:33:26\", \"Sleep\": 150, \"BootCount\": 32, \"SaveCount\": 72, \"SaveAddress\": \"FB000\" }, \"StatusFWR\": { \"Version\": \"5.12.0a\", \"BuildDateTime\": \"2018.02.11 16:15:40\", \"Boot\": 31, \"Core\": \"2_4_0\", \"SDK\": \"2.1.0(deb1901)\" }, \"StatusLOG\": { \"SerialLog\": 0, \"WebLog\": 4, \"SysLog\": 0, \"LogHost\": \"domus1\", \"LogPort\": 514, \"SSId1\": \"XXX\", \"SSId2\": \"XXX\", \"TelePeriod\": 300, \"SetOption\": \"00000001\" }, \"StatusMEM\": { \"ProgramSize\": 457, \"Free\": 544, \"Heap\": 23, \"ProgramFlashSize\": 1024, \"FlashSize\": 1024, \"FlashMode\": 3 }, \"StatusNET\": { \"Hostname\": \"XXX\", \"IPAddress\": \"192.168.178.XX\", \"Gateway\": \"192.168.178.XX\", \"Subnetmask\": \"255.255.255.XX\", \"DNSServer\": \"192.168.178.XX\", \"Mac\": \"2C:3A:E8:XX:XX:XX\", \"Webserver\": 2, \"WifiConfig\": 4 }, \"StatusTIM\": { \"UTC\": \"Thu Feb 15 00:00:50 2018\", \"Local\": \"Thu Feb 15 01:00:50 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"StatusSNS\": { \"Time\": \"2018.02.15 01:00:50\", \"Switch1\": \"OFF\" }, \"StatusSTS\": { \"Time\": \"2018.02.15 01:00:50\", \"Uptime\": \"1 02:33:26\", \"Vcc\": 3.504, \"POWER\": \"OFF\", \"Wifi\": { \"AP\": 1, \"SSId\": \"XXX\", \"RSSI\": 100, \"APMac\": \"34:31:C4:XX:XX:XX\" } } } MQTT ~ After StatusNET \"StatusMQT\": { \"MqttHost\": \"192.168.XXX.XX\", \"MqttPort\": 1883, \"MqttClientMask\": \"DVES_%06X\", \"MqttClient\": \"DVES_4AXXXX\", \"MqttUser\": \"admin\", \"MAX_PACKET_SIZE\": 1000, \"KEEPALIVE\": 15 }, Domoticz ~ idx, nvalue, svalue without array ...\"StatusTIM\": { \"UTC\": \"Thu Feb 01 20:29:40 2018\", \"Local\": \"Thu Feb 01 21:29:40 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"idx\": 286, \"nvalue\": 0, \"svalue\": \"19.7\", \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, \"StatusSTS\": { ... POW ~ After StatusTIM \"StatusPTH\": { \"PowerLow\": 0, \"PowerHigh\": 0, \"VoltageLow\": 0, \"VoltageHigh\": 0, \"CurrentLow\": 0, \"CurrentHigh\": 0 }, \"StatusSNS\": { \"Time\": \"2018.02.04 23:17:01\", \"ENERGY\": { \"Total\": 3.185, \"Yesterday\": 3.058, \"Today\": 0.127, \"Power\": 0, \"Factor\": 0.00, \"Voltage\": 221, \"Current\": 0.000 } }, Sensors ~ AM2301 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 22:52:09\", \"AM2301\": { \"Temperature\": 15.5, \"Humidity\": 50.6 }, \"TempUnit\": \"C\" }, BMP280 ~ { \"StatusSNS\": { \"Time\": \"2018-02-10T22:46:34\", \"BMP280\": { \"Temperature\": 80.9, \"Pressure\": 984.4 } } } DHT11 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 22:48:39\", \"DHT11\": { \"Temperature\": 12.0, \"Humidity\": 42.0 }, \"TempUnit\": \"C\" }, DS18B20 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, SHT3X (and DHT11, multiple Sensor example) ~ { \"StatusSNS\": { \"Time\": \"2018-02-07T20:16:19\", \"DHT11\": { \"Temperature\": 78.8, \"Humidity\": 27.0 }, \"SHT3X\": { \"Temperature\": 74.8, \"Humidity\": 18.9 }, \"TempUnit\": \"F\" } } Sonoff SC ~ \"StatusSNS\": { \"Time\": \"2018-02-16T16:18:49\", \"Temperature\": 25, \"Humidity\": 83, \"Light\": 10, \"Noise\": 20, \"AirQuality\": 100, \"TempUnit\": \"C\" }, PMS5003 and HTU21 ~ \"StatusSNS\": { \"Time\": \"2018-02-16T16:22:12\", \"HTU21\": { \"Temperature\": 24.7, \"Humidity\": 32.1 }, \"PMS5003\": { \"CF1\": 1, \"CF2.5\": 2, \"CF10\": 2, \"PM1\": 1, \"PM2.5\": 2, \"PM10\": 2, \"PB0.3\": 423, \"PB0.5\": 116, \"PB1\": 17, \"PB2.5\": 1, \"PB5\": 0, \"PB10\": 0 }, \"TempUnit\": \"C\" },","title":"JSON Status Responses"},{"location":"JSON-Status-Responses/#json-changes","text":"temp note: for now (6.0.0a) the statetext overwrites the json power result (e.g. \"ON\" => \"AN\" or any other statetext the users enter)","title":"JSON Changes"},{"location":"JSON-Status-Responses/#basic-response","text":"{ \"Status\": { \"Module\": 1, \"FriendlyName\": \"XXX\", \"Topic\": \"sonoff\", \"ButtonTopic\": \"0\", \"Power\": 0, \"PowerOnState\": 0, \"LedState\": 1, \"SaveData\": 0, \"SaveState\": 1, \"ButtonRetain\": 0, \"PowerRetain\": 0 }, \"StatusPRM\": { \"Baudrate\": 115200, \"GroupTopic\": \"sonoffs\", \"OtaUrl\": \"XXX\", \"Uptime\": \"1 02:33:26\", \"Sleep\": 150, \"BootCount\": 32, \"SaveCount\": 72, \"SaveAddress\": \"FB000\" }, \"StatusFWR\": { \"Version\": \"5.12.0a\", \"BuildDateTime\": \"2018.02.11 16:15:40\", \"Boot\": 31, \"Core\": \"2_4_0\", \"SDK\": \"2.1.0(deb1901)\" }, \"StatusLOG\": { \"SerialLog\": 0, \"WebLog\": 4, \"SysLog\": 0, \"LogHost\": \"domus1\", \"LogPort\": 514, \"SSId1\": \"XXX\", \"SSId2\": \"XXX\", \"TelePeriod\": 300, \"SetOption\": \"00000001\" }, \"StatusMEM\": { \"ProgramSize\": 457, \"Free\": 544, \"Heap\": 23, \"ProgramFlashSize\": 1024, \"FlashSize\": 1024, \"FlashMode\": 3 }, \"StatusNET\": { \"Hostname\": \"XXX\", \"IPAddress\": \"192.168.178.XX\", \"Gateway\": \"192.168.178.XX\", \"Subnetmask\": \"255.255.255.XX\", \"DNSServer\": \"192.168.178.XX\", \"Mac\": \"2C:3A:E8:XX:XX:XX\", \"Webserver\": 2, \"WifiConfig\": 4 }, \"StatusTIM\": { \"UTC\": \"Thu Feb 15 00:00:50 2018\", \"Local\": \"Thu Feb 15 01:00:50 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"StatusSNS\": { \"Time\": \"2018.02.15 01:00:50\", \"Switch1\": \"OFF\" }, \"StatusSTS\": { \"Time\": \"2018.02.15 01:00:50\", \"Uptime\": \"1 02:33:26\", \"Vcc\": 3.504, \"POWER\": \"OFF\", \"Wifi\": { \"AP\": 1, \"SSId\": \"XXX\", \"RSSI\": 100, \"APMac\": \"34:31:C4:XX:XX:XX\" } } }","title":"Basic Response"},{"location":"JSON-Status-Responses/#mqtt","text":"After StatusNET \"StatusMQT\": { \"MqttHost\": \"192.168.XXX.XX\", \"MqttPort\": 1883, \"MqttClientMask\": \"DVES_%06X\", \"MqttClient\": \"DVES_4AXXXX\", \"MqttUser\": \"admin\", \"MAX_PACKET_SIZE\": 1000, \"KEEPALIVE\": 15 },","title":"MQTT"},{"location":"JSON-Status-Responses/#domoticz","text":"idx, nvalue, svalue without array ...\"StatusTIM\": { \"UTC\": \"Thu Feb 01 20:29:40 2018\", \"Local\": \"Thu Feb 01 21:29:40 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"idx\": 286, \"nvalue\": 0, \"svalue\": \"19.7\", \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, \"StatusSTS\": { ...","title":"Domoticz"},{"location":"JSON-Status-Responses/#pow","text":"After StatusTIM \"StatusPTH\": { \"PowerLow\": 0, \"PowerHigh\": 0, \"VoltageLow\": 0, \"VoltageHigh\": 0, \"CurrentLow\": 0, \"CurrentHigh\": 0 }, \"StatusSNS\": { \"Time\": \"2018.02.04 23:17:01\", \"ENERGY\": { \"Total\": 3.185, \"Yesterday\": 3.058, \"Today\": 0.127, \"Power\": 0, \"Factor\": 0.00, \"Voltage\": 221, \"Current\": 0.000 } },","title":"POW"},{"location":"JSON-Status-Responses/#sensors","text":"","title":"Sensors"},{"location":"JSON-Status-Responses/#am2301","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 22:52:09\", \"AM2301\": { \"Temperature\": 15.5, \"Humidity\": 50.6 }, \"TempUnit\": \"C\" },","title":"AM2301"},{"location":"JSON-Status-Responses/#bmp280","text":"{ \"StatusSNS\": { \"Time\": \"2018-02-10T22:46:34\", \"BMP280\": { \"Temperature\": 80.9, \"Pressure\": 984.4 } } }","title":"BMP280"},{"location":"JSON-Status-Responses/#dht11","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 22:48:39\", \"DHT11\": { \"Temperature\": 12.0, \"Humidity\": 42.0 }, \"TempUnit\": \"C\" },","title":"DHT11"},{"location":"JSON-Status-Responses/#ds18b20","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" },","title":"DS18B20"},{"location":"JSON-Status-Responses/#sht3x-and-dht11-multiple-sensor-example","text":"{ \"StatusSNS\": { \"Time\": \"2018-02-07T20:16:19\", \"DHT11\": { \"Temperature\": 78.8, \"Humidity\": 27.0 }, \"SHT3X\": { \"Temperature\": 74.8, \"Humidity\": 18.9 }, \"TempUnit\": \"F\" } }","title":"SHT3X (and DHT11, multiple Sensor example)"},{"location":"JSON-Status-Responses/#sonoff-sc","text":"\"StatusSNS\": { \"Time\": \"2018-02-16T16:18:49\", \"Temperature\": 25, \"Humidity\": 83, \"Light\": 10, \"Noise\": 20, \"AirQuality\": 100, \"TempUnit\": \"C\" },","title":"Sonoff SC"},{"location":"JSON-Status-Responses/#pms5003-and-htu21","text":"\"StatusSNS\": { \"Time\": \"2018-02-16T16:22:12\", \"HTU21\": { \"Temperature\": 24.7, \"Humidity\": 32.1 }, \"PMS5003\": { \"CF1\": 1, \"CF2.5\": 2, \"CF10\": 2, \"PM1\": 1, \"PM2.5\": 2, \"PM10\": 2, \"PB0.3\": 423, \"PB0.5\": 116, \"PB1\": 17, \"PB2.5\": 1, \"PB5\": 0, \"PB10\": 0 }, \"TempUnit\": \"C\" },","title":"PMS5003 and HTU21"},{"location":"KNX/","text":"This feature is included in ESP32 builds, but for ESP8266 it is included only in tasmota-knx build When compiling your build add the following to user_config_override.h : #ifndef USE_KNX #define USE_KNX // Enable KNX IP Protocol Support (+9.4k code, +3k7 mem) #endif What is KNX? ~ The KNX IP Protocol is an international open standard for smart homes and smart buildings automation. It is a decentralized system. Each device can talk directly to each other without the need of a central controller or server. Any panel or server is just for telesupervision and for sending requests. KNX IP Protocol uses a UDP multicast on 224.0.23.12 : 3671 , so there is no need for a KNX Router unless you want to communicate to KNX Devices that are not in the WIFI Network (Twisted Pair, RF, Powerline). Each device has a physical address (like a fixed IP) as 1 . 1 . 0 and that address is used for configuration purposes. Each device can be configured with group addresses as 2 / 2 / 1 and that address can be used for sending/receiving commands. So, for example, if 2 devices that are configured with the 2 / 2 / 1 for turning on/off their outputs, and other device send Turn ON command to 2 / 2 / 1 , both devices will turn on their outputs. Integration ~ Several home automation systems have KNX support. For example, Home Assistant has a XKNX Python Library to connect to KNX devices using a KNX Router. If you don't have a KNX Router , you can use a Software KNX Router like KNXd on the same Raspberry Pi than Home Assistant. KNXd is used by Home Assistant for reading this UDP Multicast, although KNXd has other cool features that need extra hardware like connect to KNX devices by Twister Pair, Power Line or RF. If using the Home Assistant distribution called Hassio , everything for KNX is already included by default. If you use the ETS (KNX Configurator Software) you can add any TasmotaTasmota KNX as a dummy device. If the Tasmotadevice is connecting to a Wifi Repeater you might experience some issues receiving KNX Telegrams. This also applies to mDNS and Emulation features. Implemented Features ~ The implemented features, up to now, in KNX for Tasmota are: General: buttons (just push) relays (on/off/toggle) lights (led strips, etc. but just on/off) Sensor lists that you can use in KNX is (only one sensor per type): Temperature Humidity Energy (v, i, power) For using rules: send KNX command (on/off) receive KNX command (on/off) send values by KNX (any float type, temperature for example) receive a KNX read request send and receive SCENE commands Usage Examples ~ There are multiple possible configurations. Here are explained just a few as example. The options for selecting relays, buttons, sensors, etc. are only available if were configured on Configure Module Menu . To configure KNX, enter on the Configuration Menu of Tasmota and select Configure KNX. Note on KNX communication enhancement option: As Wifi Multicast communication is not reliable in some wifi router due to IGMP problems or Snooping, an enhancement was implemented. This option increase the reliability by reducing the chances of losing telegrams, sending the same telegram 3 times. In practice it works really good and it is enough for normal home use. When this option is on, Tasmota will ignore toggle commands by KNX if those are sent more than 1 toggle per second. Just 1 toggle per second is working fine. 1) Setting Several Tasmota to be controlled as one by a Home Automation System: ~ We can set one of the group address to be the same in all the devices so as to turn them on or off at the same time. In this case, so as to inform the status of all the relays to the Automation System, just one of the devices have to be configured as the responder. If you use the same Group Address for sending and receiving, you have to take into account not to make loops. DEVICE 1 DEVICE 2 2) Setting 2 Tasmota to be linked as stair lights: ~ We can set one device to send the status of its output and another to read that and follow. And the second device can send the status of its button and the first device will toggle. With this configuration we can avoid to make a loop. DEVICE 1 DEVICE 2 3) Setting a button as initiator of a scene: ~ Just setting one device to send the push of a button, and the rest just use that value to turn them on. In this case, there is no toggle. Every time the button is pushed, the turn on command is sent. DEVICE 1 DEVICE 2 4) Setting a Temperature sensor: ~ We can configure to send the value of temperature or humidity every teleperiod. This teleperiod can be configured. See TasmotaTasmota docs . It is recommended also to set the reply temperature address. 5) Using rules: ~ More functionality can be added to Tasmota using rules. In the KNX Menu, can be set a Group Address to send data or commands by rules, as KNX TX1 to KNX TX5 In rules we can use the command KnxTx_Cmnd1 1 to send an ON state command to the group address set in KNX TX1 slot of the KNX menu. Also, we can use the command KnxTx_Val1 15 to send a 15 value to the group address set in KNX TX1 slot of the KNX menu. In the KNX Menu can be set a Group Address to receive commands by rules as KNX RX1 to KNX RX5 In rules we can use the events to catch the reception of COMMANDS from KNX to those RX Slots. Example: rule on event#knxrx_cmnd1 do var1 %value% endon to store the command received in the variable VAR1 In rules we can use the events to catch the reception of VALUES from KNX to those RX Slots. Example: rule on event#knxrx_val1 do var1 %value% endon to store the value received in the variable VAR1 Also, if a Read request is received from KNX Network, we can use that in a rule as for example: rule on event#knxrx_req1 do knxtx_val1 %var3% endon NOTE: KnxTX_valn command, KNXRX_Reqn trigger and sensors' telegrams, uses KNX DPT14 (32 bits float) since 9.1.0.2 . Old versions use DPT9 (16 bits float). Old and new versions can not send values between each other. Only commands. It is recommended to have all devices on the same version. SCENES For using the KNX Scenes Feature, you need to add a rule with the behaviour you want for that scene like: Rule1 on EVENT#KNX_SCENE=0 do power1 1 endon on EVENT#KNX_SCENE=1 do power1 0 endon 6) Rule to send KNX Telegram with BH1750 Sensor Data: ~ If you want to send your sensor values by KNX every teleperiod time to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on tele-BH1750#Illuminance do knxtx_val1 %value% endon If you want to send your sensor values by KNX only when it changes in a delta of 10 lx to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on system#boot do backlog var1 0; var2 0 endon on BH1750#Illuminance>%var1% do backlog var1 %value%; knxtx_val1 %value%; var2 %value%; add1 5; sub2 5 endon on BH1750#Illuminance<%var2% do backlog var2 %value%; knxtx_val1 %value%; var1 %value%; add1 5; sub2 5 endon","title":"KNX"},{"location":"KNX/#what-is-knx","text":"The KNX IP Protocol is an international open standard for smart homes and smart buildings automation. It is a decentralized system. Each device can talk directly to each other without the need of a central controller or server. Any panel or server is just for telesupervision and for sending requests. KNX IP Protocol uses a UDP multicast on 224.0.23.12 : 3671 , so there is no need for a KNX Router unless you want to communicate to KNX Devices that are not in the WIFI Network (Twisted Pair, RF, Powerline). Each device has a physical address (like a fixed IP) as 1 . 1 . 0 and that address is used for configuration purposes. Each device can be configured with group addresses as 2 / 2 / 1 and that address can be used for sending/receiving commands. So, for example, if 2 devices that are configured with the 2 / 2 / 1 for turning on/off their outputs, and other device send Turn ON command to 2 / 2 / 1 , both devices will turn on their outputs.","title":"What is KNX?"},{"location":"KNX/#integration","text":"Several home automation systems have KNX support. For example, Home Assistant has a XKNX Python Library to connect to KNX devices using a KNX Router. If you don't have a KNX Router , you can use a Software KNX Router like KNXd on the same Raspberry Pi than Home Assistant. KNXd is used by Home Assistant for reading this UDP Multicast, although KNXd has other cool features that need extra hardware like connect to KNX devices by Twister Pair, Power Line or RF. If using the Home Assistant distribution called Hassio , everything for KNX is already included by default. If you use the ETS (KNX Configurator Software) you can add any TasmotaTasmota KNX as a dummy device. If the Tasmotadevice is connecting to a Wifi Repeater you might experience some issues receiving KNX Telegrams. This also applies to mDNS and Emulation features.","title":"Integration"},{"location":"KNX/#implemented-features","text":"The implemented features, up to now, in KNX for Tasmota are: General: buttons (just push) relays (on/off/toggle) lights (led strips, etc. but just on/off) Sensor lists that you can use in KNX is (only one sensor per type): Temperature Humidity Energy (v, i, power) For using rules: send KNX command (on/off) receive KNX command (on/off) send values by KNX (any float type, temperature for example) receive a KNX read request send and receive SCENE commands","title":"Implemented Features"},{"location":"KNX/#usage-examples","text":"There are multiple possible configurations. Here are explained just a few as example. The options for selecting relays, buttons, sensors, etc. are only available if were configured on Configure Module Menu . To configure KNX, enter on the Configuration Menu of Tasmota and select Configure KNX. Note on KNX communication enhancement option: As Wifi Multicast communication is not reliable in some wifi router due to IGMP problems or Snooping, an enhancement was implemented. This option increase the reliability by reducing the chances of losing telegrams, sending the same telegram 3 times. In practice it works really good and it is enough for normal home use. When this option is on, Tasmota will ignore toggle commands by KNX if those are sent more than 1 toggle per second. Just 1 toggle per second is working fine.","title":"Usage Examples"},{"location":"KNX/#1-setting-several-tasmota-to-be-controlled-as-one-by-a-home-automation-system","text":"We can set one of the group address to be the same in all the devices so as to turn them on or off at the same time. In this case, so as to inform the status of all the relays to the Automation System, just one of the devices have to be configured as the responder. If you use the same Group Address for sending and receiving, you have to take into account not to make loops. DEVICE 1 DEVICE 2","title":"1) Setting Several Tasmota to be controlled as one by a Home Automation System:"},{"location":"KNX/#2-setting-2-tasmota-to-be-linked-as-stair-lights","text":"We can set one device to send the status of its output and another to read that and follow. And the second device can send the status of its button and the first device will toggle. With this configuration we can avoid to make a loop. DEVICE 1 DEVICE 2","title":"2) Setting 2 Tasmota to be linked as stair lights:"},{"location":"KNX/#3-setting-a-button-as-initiator-of-a-scene","text":"Just setting one device to send the push of a button, and the rest just use that value to turn them on. In this case, there is no toggle. Every time the button is pushed, the turn on command is sent. DEVICE 1 DEVICE 2","title":"3) Setting a button as initiator of a scene:"},{"location":"KNX/#4-setting-a-temperature-sensor","text":"We can configure to send the value of temperature or humidity every teleperiod. This teleperiod can be configured. See TasmotaTasmota docs . It is recommended also to set the reply temperature address.","title":"4) Setting a Temperature sensor:"},{"location":"KNX/#5-using-rules","text":"More functionality can be added to Tasmota using rules. In the KNX Menu, can be set a Group Address to send data or commands by rules, as KNX TX1 to KNX TX5 In rules we can use the command KnxTx_Cmnd1 1 to send an ON state command to the group address set in KNX TX1 slot of the KNX menu. Also, we can use the command KnxTx_Val1 15 to send a 15 value to the group address set in KNX TX1 slot of the KNX menu. In the KNX Menu can be set a Group Address to receive commands by rules as KNX RX1 to KNX RX5 In rules we can use the events to catch the reception of COMMANDS from KNX to those RX Slots. Example: rule on event#knxrx_cmnd1 do var1 %value% endon to store the command received in the variable VAR1 In rules we can use the events to catch the reception of VALUES from KNX to those RX Slots. Example: rule on event#knxrx_val1 do var1 %value% endon to store the value received in the variable VAR1 Also, if a Read request is received from KNX Network, we can use that in a rule as for example: rule on event#knxrx_req1 do knxtx_val1 %var3% endon NOTE: KnxTX_valn command, KNXRX_Reqn trigger and sensors' telegrams, uses KNX DPT14 (32 bits float) since 9.1.0.2 . Old versions use DPT9 (16 bits float). Old and new versions can not send values between each other. Only commands. It is recommended to have all devices on the same version. SCENES For using the KNX Scenes Feature, you need to add a rule with the behaviour you want for that scene like: Rule1 on EVENT#KNX_SCENE=0 do power1 1 endon on EVENT#KNX_SCENE=1 do power1 0 endon","title":"5) Using rules:"},{"location":"KNX/#6-rule-to-send-knx-telegram-with-bh1750-sensor-data","text":"If you want to send your sensor values by KNX every teleperiod time to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on tele-BH1750#Illuminance do knxtx_val1 %value% endon If you want to send your sensor values by KNX only when it changes in a delta of 10 lx to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on system#boot do backlog var1 0; var2 0 endon on BH1750#Illuminance>%var1% do backlog var1 %value%; knxtx_val1 %value%; var2 %value%; add1 5; sub2 5 endon on BH1750#Illuminance<%var2% do backlog var2 %value%; knxtx_val1 %value%; var1 %value%; add1 5; sub2 5 endon","title":"6) Rule to send KNX Telegram with BH1750 Sensor Data:"},{"location":"LM75AD/","text":"LM75AD temperature sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_LM75AD #define USE_LM75AD // [I2cDriver20] Enable LM75AD sensor (I2C addresses 0x48 - 0x4F) (+0k5 code) #endif The LM75AD is an I 2 C temperature sensor that converts temperature directly to digital signals from -55\u00b0C to +125\u00b0C and achieves an accuracy of 0.125\u00b0C Some features of the LM75A chip not implemented in this driver: - Programmable temperature threshold and hysteresis set points - Stand-alone operation as thermostat at power-up LM75A Datasheet Configuration ~ Wiring ~ LM75AD ESP VCC 3.3V GND GND SDA GPIOx SCL GPIOy OS not used The driver currently only allows the use of a single LM75AD sensor on any of the addresses configurable through pins A0, A1 and A2. These are conveniently broken out on the breakout board either as pins or as solderable joints as can be seen on the example breakout board. These pins need to be tied down to either GND or VCC (3.3V) and the resulting I 2 C address will be set during power-up according to the table: Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect LM75AD automatically and display Temperature. Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Breakout Boards ~ Can also be used standalone if soldered to a board given the diagram is used R1 and R2 are pull-up resistors which are required by the I 2 C bus to operate properly. If you have other I 2 C sensors with pull-up resistors connected to the same I 2 C bus it's probably not necessary to have them.","title":"LM75AD temperature sensor"},{"location":"LM75AD/#lm75ad-temperature-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_LM75AD #define USE_LM75AD // [I2cDriver20] Enable LM75AD sensor (I2C addresses 0x48 - 0x4F) (+0k5 code) #endif The LM75AD is an I 2 C temperature sensor that converts temperature directly to digital signals from -55\u00b0C to +125\u00b0C and achieves an accuracy of 0.125\u00b0C Some features of the LM75A chip not implemented in this driver: - Programmable temperature threshold and hysteresis set points - Stand-alone operation as thermostat at power-up LM75A Datasheet","title":"LM75AD temperature sensor"},{"location":"LM75AD/#configuration","text":"","title":"Configuration"},{"location":"LM75AD/#wiring","text":"LM75AD ESP VCC 3.3V GND GND SDA GPIOx SCL GPIOy OS not used The driver currently only allows the use of a single LM75AD sensor on any of the addresses configurable through pins A0, A1 and A2. These are conveniently broken out on the breakout board either as pins or as solderable joints as can be seen on the example breakout board. These pins need to be tied down to either GND or VCC (3.3V) and the resulting I 2 C address will be set during power-up according to the table:","title":"Wiring"},{"location":"LM75AD/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect LM75AD automatically and display Temperature.","title":"Tasmota Settings"},{"location":"LM75AD/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"LM75AD/#breakout-boards","text":"Can also be used standalone if soldered to a board given the diagram is used R1 and R2 are pull-up resistors which are required by the I 2 C bus to operate properly. If you have other I 2 C sensors with pull-up resistors connected to the same I 2 C bus it's probably not necessary to have them.","title":"Breakout Boards"},{"location":"LMT01/","text":"LMT01 temperature sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_LMT01 #define USE_LMT01 // Add support for TI LMT01 temperature sensor, count pulses on single GPIO (+0k5 code) #endif The Texas Instruments LMT01 is 2-pin digital output temperature sensor that converts temperature directly to a sequence of digital pulses, reading a range from -50\u00b0C to +150\u00b0C with up to 0.5\u00b0C accuracy. It is available in a DIY-friendly small TO-92 package. Connection is by a single GPIO to count the pulses, which needs a driver transistor to convert the small current changes into logic level voltage swings. LMT01 data sheet LMT01 product page with links to evaluation board and training video and sample code . Limitations of current implementation : Only the simple linear conversion is used. The datasheet suggests the use of a look-up table to improve the accuracy at the edges of the range, this is not yet implemented. The sensor code only supports one LMT01 instance. Configuration ~ Choose a pin GPIOx. The GPIO can be connected to the LMT01 via a NPN transistor, so current pulses pull the GPIO line low: see Figure 32 in the LMT01 datasheet. In the Configuration -> Configure Module page assign: GPIOx to LMT01 Pulse After a reboot the sensor will be detected and displayed. If the connection is not working, the pulse counting will timeout and you will see null displayed for the temperature.","title":"LMT01 temperature sensor"},{"location":"LMT01/#lmt01-temperature-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_LMT01 #define USE_LMT01 // Add support for TI LMT01 temperature sensor, count pulses on single GPIO (+0k5 code) #endif The Texas Instruments LMT01 is 2-pin digital output temperature sensor that converts temperature directly to a sequence of digital pulses, reading a range from -50\u00b0C to +150\u00b0C with up to 0.5\u00b0C accuracy. It is available in a DIY-friendly small TO-92 package. Connection is by a single GPIO to count the pulses, which needs a driver transistor to convert the small current changes into logic level voltage swings. LMT01 data sheet LMT01 product page with links to evaluation board and training video and sample code . Limitations of current implementation : Only the simple linear conversion is used. The datasheet suggests the use of a look-up table to improve the accuracy at the edges of the range, this is not yet implemented. The sensor code only supports one LMT01 instance.","title":"LMT01 temperature sensor"},{"location":"LMT01/#configuration","text":"Choose a pin GPIOx. The GPIO can be connected to the LMT01 via a NPN transistor, so current pulses pull the GPIO line low: see Figure 32 in the LMT01 datasheet. In the Configuration -> Configure Module page assign: GPIOx to LMT01 Pulse After a reboot the sensor will be detected and displayed. If the connection is not working, the pulse counting will timeout and you will see null displayed for the temperature.","title":"Configuration"},{"location":"LVGL/","text":"Light and Versatile Embedded Graphics Library ~ Tasmota now supports openHASP-compatible templates - named HASPmota - which makes it much easier to start with LVGL. Check the HASPmota documentation. This feature is included in tasmota32-lvgl.bin Supported version: LVGL v8.3.0, LodePNG v20201017, Freetype 2.10.4 LVGL ( Light and Versatile Graphics Library ) is Tasmota's next generation display. It is powerful, lightweight and simple to use. It combines: LVGL's powerful graphics and GUI library for embedded Tasmota's stability, richness of features and frugality on resources Berry's powerful language similar to MicroPython LVGL is an open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint. Berry is a ultra-lightweight dynamically typed embedded scripting language. It is designed for lower-performance embedded devices After compiling Tasmota with LVGL support and configuring uDisplay (see below), you can start using LVGL through the Berry console. Using LVGL ~ This example uses the M5Stack Fire device. Use the following template to define the relevant SPI GPIOs. Also set one of the unsued GPIOs to Option A3 . The complete configuration for M5Stack Fire is: Templa te { \"NAME\" : \"M5stack Fire\" , \"GPIO\" :[ 6210 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 768 , 1 , 1 , 1 , 736 , 672 , 0 , 640 , 608 , 704 , 0 , 3872 , 3872 , 800 , 0 , 0 , 0 , 0 , 992 , 1024 , 1 , 0 , 0 , 34 , 33 , 32 ], \"FLAG\" : 0 , \"BASE\" : 1 , \"CMND\" : \"Module 0\" } Save the following file as display.ini in the file system: :H,ILI9341,320,240,16,SPI,1,*,*,*,*,*,*,*,40 :B,60,1 :I EF,3,03,80,02 CF,3,00,C1,30 ED,4,64,03,12,81 E8,3,85,00,78 CB,5,39,2C,00,34,02 F7,1,20 EA,2,00,00 C0,1,23 C1,1,10 C5,2,3e,28 C7,1,86 36,1,48 37,1,00 3A,1,55 B1,2,00,18 B6,3,08,82,27 F2,1,00 26,1,01 E0,0F,0F,31,2B,0C,0E,08,4E,F1,37,07,10,03,0E,09,00 E1,0F,00,0E,14,03,11,07,31,C1,48,08,0F,0C,31,36,0F 11,80 29,80 :o,28 :O,29 :A,2A,2B,2C :R,36 :0,08,00,00,00 :1,68,00,00,01 :2,C8,00,00,02 :3,A8,00,00,03 # Then open the Berry console and copy/paste the following: (alternatively create an autoexec.be file with this content): #- start LVGL and init environment -# lv . start () hres = lv . get_hor_res () # should be 320 vres = lv . get_ver_res () # should be 240 scr = lv . scr_act () # default screan object f20 = lv . montserrat_font ( 20 ) # load embedded Montserrat 20 #- Background with a gradient from black #000000 (bottom) to dark blue #0000A0 (top) -# scr . set_style_bg_color ( lv . color ( 0x0000A0 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_color ( lv . color ( 0x000000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_dir ( lv . GRAD_DIR_VER , lv . PART_MAIN | lv . STATE_DEFAULT ) #- Upper state line -# stat_line = lv . label ( scr ) if f20 != nil stat_line . set_style_text_font ( f20 , lv . PART_MAIN | lv . STATE_DEFAULT ) end stat_line . set_long_mode ( lv . LABEL_LONG_SCROLL ) # auto scrolling if text does not fit stat_line . set_width ( hres ) stat_line . set_align ( lv . TEXT_ALIGN_LEFT ) # align text left stat_line . set_style_bg_color ( lv . color ( 0xD00000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) # background #000088 stat_line . set_style_bg_opa ( lv . OPA_COVER , lv . PART_MAIN | lv . STATE_DEFAULT ) # 100% background opacity stat_line . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) # text color #FFFFFF stat_line . set_text ( \"Tasmota\" ) stat_line . refr_size () # new in LVGL8 stat_line . refr_pos () # new in LVGL8 #- display wifi strength indicator icon (for professionals ;) -# wifi_icon = lv_wifi_arcs_icon ( stat_line ) # the widget takes care of positioning and driver stuff clock_icon = lv_clock_icon ( stat_line ) #- create a style for the buttons -# btn_style = lv . style () btn_style . set_radius ( 10 ) # radius of rounded corners btn_style . set_bg_opa ( lv . OPA_COVER ) # 100% backgrond opacity if f20 != nil btn_style . set_text_font ( f20 ) end # set font to Montserrat 20 btn_style . set_bg_color ( lv . color ( 0x1fa3ec )) # background color #1FA3EC (Tasmota Blue) btn_style . set_border_color ( lv . color ( 0x0000FF )) # border color #0000FF btn_style . set_text_color ( lv . color ( 0xFFFFFF )) # text color white #FFFFFF #- create buttons -# prev_btn = lv . btn ( scr ) # create button with main screen as parent prev_btn . set_pos ( 20 , vres - 40 ) # position of button prev_btn . set_size ( 80 , 30 ) # size of button prev_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) # style of button prev_label = lv . label ( prev_btn ) # create a label as sub-object prev_label . set_text ( \"<\" ) # set label text prev_label . center () next_btn = lv . btn ( scr ) # right button next_btn . set_pos ( 220 , vres - 40 ) next_btn . set_size ( 80 , 30 ) next_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) next_label = lv . label ( next_btn ) next_label . set_text ( \">\" ) next_label . center () home_btn = lv . btn ( scr ) # center button home_btn . set_pos ( 120 , vres - 40 ) home_btn . set_size ( 80 , 30 ) home_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) home_label = lv . label ( home_btn ) home_label . set_text ( lv . SYMBOL_OK ) # set text as Home icon home_label . center () #- callback function when a button is pressed, react to EVENT_CLICKED event -# def btn_clicked_cb ( obj , event ) var btn = \"Unknown\" if obj == prev_btn btn = \"Prev\" elif obj == next_btn btn = \"Next\" elif obj == home_btn btn = \"Home\" end print ( btn , \"button pressed\" ) end prev_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) next_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) home_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) You should see this: Setting an input device is simple, we are now configuring the three buttons as the equivalent of a rotary encoder: left/ok/right. To control focus, you need to create a group, put the focusable items in the group, and assign the input device to the group: g = lv . group () g . add_obj ( prev_btn ) g . add_obj ( home_btn ) g . add_obj ( next_btn ) rotary = lv . register_button_encoder ( true ) #- buttons are inverted -# rotary . set_group ( g ) Touch Screen Support ~ Touch screen are supported natively via Universal Display driver. Example: colp = lv . colorwheel ( scr , false ) colp . set_size ( 130 , 130 ) colp . set_pos ( 10 , 30 ) Let's go into the details of this example. Starting LVGL ~ Start LVGL lv . start () Note: when you create an LVGL object, you need to use the lv module. For example, creating a label object is done with lv.lv_label . As a convenience, classes can also be named with a shorter name lv.label which is equivalent to lv.lv_label . The internal class name is still lv_label . Use lv.montserrat_font(<size>) to load a pre-defined montserrat font. Embedded sizes are: 10, 14, 20, 28. You can also load a font from the file-system but you need to convert them first. See: https://docs.lvgl.io/latest/en/html/overview/font.html hres = lv . get_hor_res () # should be 320 vres = lv . get_ver_res () # should be 240 scr = lv . scr_act () # default screan object f20 = lv . montserrat_font ( 20 ) # load embedded Montserrat 20 Set the background color ~ #- Background with a gradient from black #000000 (bottom) to dark blue #0000A0 (top) -# scr . set_style_bg_color ( lv . color ( 0x0000A0 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_color ( lv . color ( 0x000000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_dir ( lv . GRAD_DIR_VER , lv . PART_MAIN | lv . STATE_DEFAULT ) The display is composed of a virtual screen object scr . To change the background you need to change the style of this object. You can either create a full style object or change the style inside the object. This is what we do here. Hence methods: set_style_<xxx> In this example we do a vertical color gradient from dark blue (up) to black (down). Colors ~ Color are created via lv.color(<int>) with 0xRRGGBB as 24 bits color. Internally the color is converted to the display color depth so rounding errors may happen: > lv.color(0x808080) lv_color(0x838183 - native:0x1084) The line above shows the internal color converted back to 24 bits RGB (rounding errors occur) and the native 15 bits RGB internal color. Create the upper text line ~ #- Upper state line -# stat_line = lv . label ( scr ) if f20 != nil stat_line . set_style_text_font ( f20 , lv . PART_MAIN | lv . STATE_DEFAULT ) end stat_line . set_long_mode ( lv . LABEL_LONG_SCROLL ) # auto scrolling if text does not fit stat_line . set_width ( hres ) stat_line . set_align ( lv . TEXT_ALIGN_LEFT ) # align text left stat_line . set_style_bg_color ( lv . color ( 0xD00000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) # background #000088 stat_line . set_style_bg_opa ( lv . OPA_COVER , lv . PART_MAIN | lv . STATE_DEFAULT ) # 100% background opacity stat_line . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) # text color #FFFFFF stat_line . set_text ( \"Tasmota\" ) stat_line . refr_size () # new in LVGL8 stat_line . refr_pos () # new in LVGL8 Let's decompose: stat_line = lv . label ( scr ) Creates an object of type lv_label with parent scr (screen). if f20 != nil stat_line . set_style_text_font ( f20 , lv . PART_MAIN | lv . STATE_DEFAULT ) end If f20 is correctly loaded, set the font to Montserrat 20. Styles are associated to parts of objects and to states. Here we associate to the main part for state default. stat_line . set_long_mode ( lv . LABEL_LONG_SCROLL ) # auto scrolling if text does not fit Set the label to auto roll from right to left and vice versa if the text does not fit in the display. stat_line . set_width ( hres ) stat_line . set_align ( lv . TEXT_ALIGN_LEFT ) # align text left Set the width to full screen resolution, and align text to the left. stat_line . set_style_bg_color ( lv . color ( 0xD00000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) # background #000088 stat_line . set_style_bg_opa ( lv . OPA_COVER , lv . PART_MAIN | lv . STATE_DEFAULT ) # 100% background opacity stat_line . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) # text color #FFFFFF Set background color to red, text color to white, opacity to 100%. stat_line . set_text ( \"Tasmota\" ) Set the text of the label. stat_line . refr_size () # new in LVGL8 stat_line . refr_pos () # new in LVGL8 The latter is new in LVGL8 and tells the widget to update its size and position, that we will use right after to position other widgets. Please note that the actual display is asynchronous. We describe the objects, in whatever order, they will be all displayed at once. Create a style ~ #- create a style for the buttons -# btn_style = lv . style () btn_style . set_radius ( 10 ) # radius of rounded corners btn_style . set_bg_opa ( lv . OPA_COVER ) # 100% backgrond opacity if f20 != nil btn_style . set_text_font ( f20 ) end # set font to Montserrat 20 btn_style . set_bg_color ( lv . color ( 0x1fa3ec )) # background color #1FA3EC (Tasmota Blue) btn_style . set_border_color ( lv . color ( 0x0000FF )) # border color #0000FF btn_style . set_text_color ( lv . color ( 0xFFFFFF )) # text color white #FFFFFF We create a lv_style object and associate some attributes. This works similarly to CSS styles. This style sets background color to Tasmota button blue, text to white, opacity to 100%, font to Montserrat 20 and corner rounding to 1 pixel (10 decipixels). Create the buttons ~ home_btn = lv . btn ( scr ) # center button home_btn . set_pos ( 120 , vres - 40 ) home_btn . set_size ( 80 , 30 ) home_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) home_label = lv . label ( home_btn ) home_label . set_text ( lv . SYMBOL_OK ) # set text as Home icon home_label . center () Finally create a lv_btn object with parent scr , set its size and position, add the previously defined style and set its text. LVGL provides some pre-defined symbols like lv.SYMBOL_OK . Advanced features and extensions ~ Screenshot ~ Tasmota includes an easy way to take screenshots. Just use lv.screenshot() and a BMP file will be stored in the file system. Example: > lv . screenshot () /screenshot-1642356919.bmp Then download the file to your local computer. The file format is uncompressed BMP with 16 bits per pixel. It is highly recommended to then compress the image to PNG or JPG with the software of your choice. Warning: due to internal implementation limitations, the image is stored upside down. Don't forget to vertically revert the image. PNG Image support ~ Support for PNG decoding depends on #define USE_LVGL_PNG_DECODER - which is enabled by default in Tasmota32-lvgl. You need to first store images on the file system, and simply load them through LVGL standard way. PNG identification depends on the .png extension. Example: store the following image as Sunrise320.png sunrise = lv . img ( scr ) # create an empty image object in the current screen sunrise . set_src ( \"A:/Sunrise320.png\" ) # load \"Sunrise320.png\", the default drive letter is 'A:' sunrise . move_background () # move the image to the background Freetype fonts support ~ Support for Freetype fonts depends on #define USE_LVGL_FREETYPE - which is NOT enabled by default in Tasmota32-lvgl. Bitmat fonts typically consume significant flash size because you need to embed the font at different size. Using FreeType vector fonts can bring more flexibility and options. You need to first upload the desired fonts on the Tasmota file system. To create the lv_font object, use lv.load_freetype_font(name:string, size:int, type:int) -> nil or lv_font . If the font is not found, the call returns nil . type can be 0 or lv.FT_FONT_STYLE_NORMAL , or a combination of lv.FT_FONT_STYLE_ITALIC and lv.FT_FONT_STYLE_BOLD . Example (after loading lvgl_demo.be ) using sketchbook.ttf font: sb120 = lv . load_freetype_font ( \"sketchbook.ttf\" , 120 , 0 ) tt = lv . label ( scr ) tt . set_style_bg_opa ( lv . OPA_0 , lv . PART_MAIN | lv . STATE_DEFAULT ) tt . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) tt . set_text ( \"MQTT\" ) tt . set_pos ( 10 , 40 ) tt . set_size ( 300 , 150 ) if sb120 != nil tt . set_style_text_font ( sb120 , lv . PART_MAIN | lv . STATE_DEFAULT ) end What's implemented and what's not? ~ What's implemented currently: All standard LVGL widgets are available, most of extras Styles File-system Fonts, currently Montserrat fonts are embedded at sizes 10, 14 (default), 20 and 28 (compressed - smaller and slower) External Fonts in file-system, either in LVGL's binary format of TrueType fonts via the FreeType library (requires #defined USE_LVGL_FREETYPE ) Images in file-system, either in LVGL's binary format or PNG Most of the high-level LVGL APIs via the lv Berry object SPI displays with 16 bits per pixels Animations via Berry code Touch Screen support SPI DMA Callbacks on LVGL objects to react on events Ability to define custom widgets in Berry What will probably not be implemented Native LVGL animation engine Styles garbage collection is not done, which means that creating lots of styles leads to memoly leak multi-screens display - I don't know of a single ESP32 based device with multi-screens Bidirectional fonts - unless there is strong demand LVGL tasks - Berry provides all the necessary tools for task scheduling Converting C LVGL to Berry ~ Simply speaking, you can convert most constants from their C equivalent to berry by just changing the LV_ prefix to lv. . Example: LV_SYMBOL_OK becomes lv.SYMBOL_OK Berry provides an object model to lv_object and sub-classes for widhets like lv_btn , lv_label ... To create an object, just instantiate the class: lv_btn(parent) lv_style is created independently. lv_color takes an 24 bits 0xRRGGB as parameter, or a pre-defined color like lv.BLUE Compiling for LVLG ~ In my_user_config.h or in your config override, add: #define USE_LVGL #define USE_DISPLAY #define USE_DISPLAY_LVGL_ONLY #define USE_XPT2046 #define USE_UNIVERSAL_DISPLAY #undef USE_DISPLAY_MODES1TO5 #undef USE_DISPLAY_LCD #undef USE_DISPLAY_SSD1306 #undef USE_DISPLAY_MATRIX #undef USE_DISPLAY_SEVENSEG Be aware that it adds 440Kb to you firmware, so make sure you have a partition with enough program Flash space. Preferably use esp32_partition_app1856k_spiffs320k.csv partition file. Goodies ~ Tasmota Logo ~ Get a Tasmota logo: # start the display lv . start () # set background color to blue scr = lv . scr_act () scr . set_style_bg_color ( lv . color ( lv . COLOR_BLUE ), lv . PART_MAIN | lv . STATE_DEFAULT ) # create a lv_img object and set it to Tasmota logo logo = lv . img ( scr ) logo . set_tasmota_logo () logo . center () The logo is black, with anti-aliasing and transparency. You can now manipulate the logo: change zoom, rotate or recolor. # recolor logo to white logo . set_style_img_recolor_opa ( 255 , lv . PART_MAIN | lv . STATE_DEFAULT ) logo . set_style_img_recolor ( lv . color ( lv . COLOR_WHITE ), lv . PART_MAIN | lv . STATE_DEFAULT ) # zoom by 125% - 100% is 256, so 125% is 320 logo . set_zoom ( 300 ) # rotate by 30 degrees - or 300 deci-degrees logo . set_angle ( 300 ) Example of animation: cur_zoom = 200 cur_incr = 5 def animate_logo() cur_zoom += cur_incr if cur_zoom > 300 cur_incr = - cur_incr end if cur_zoom < 200 cur_incr = - cur_incr end logo.set_zoom(cur_zoom) tasmota.set_timer(100, animate_logo) end animate_logo() Calibrate a resitive Touch Screen ~ Some touchscreens like Lolin TFT 2.4 Touch Shields use a resistive touchscreen controlled by XPT2046 . Contrary to capacitive touchscreens, resistive touchscreens needs a per-device calibration. You can download DisplayCalibrate.tapp Tasmota Application which allows for easy calibration. In only a few steps, it will generate the universal display line :M with calibration information. First download DisplayCalibrate.tapp application and upload it in the file system, and restart. Make sure you are in orientation DisplayRotate 0 In the console, type the command DisplayCalibrate You will see the following screens. Click on all 4 crosses near corners. Note: measures are taken every 50 ms and are averaged, and requires at least 3 measures (150ms). If everything went well, you will see the following screen. After reboot, your touchscreen is ready and calibrate. If the geometry is wrong, you will see the following screen and no change is done to display.ini Cookbook ~ Measuring user inactivity ~ LVGL has a notion of screen inactivity, i.e. how long did the user not interact with the screen. This can be use to dim the display or turn it off after a moment of inactivity (like a screen saver). The time is in milliseconds. Full doc here: https://docs.lvgl.io/8/overview/display.html#inactivity # time of inactivity in ms lv . disp () . get_inactive_time () Technical Details ~ The code size impact is quite significant, so you probably need partitions with code at least set to 1856KB. Doing so leaves 320KB for file system on 4MB flash. With the Safeboot partition layout , default code partition size for 4MB of flash is 2880KB. Most of Berry code is solidified in Flash, so the initial RAM footprint is very low (a few KB).","title":"LVGL"},{"location":"LVGL/#light-and-versatile-embedded-graphics-library","text":"Tasmota now supports openHASP-compatible templates - named HASPmota - which makes it much easier to start with LVGL. Check the HASPmota documentation. This feature is included in tasmota32-lvgl.bin Supported version: LVGL v8.3.0, LodePNG v20201017, Freetype 2.10.4 LVGL ( Light and Versatile Graphics Library ) is Tasmota's next generation display. It is powerful, lightweight and simple to use. It combines: LVGL's powerful graphics and GUI library for embedded Tasmota's stability, richness of features and frugality on resources Berry's powerful language similar to MicroPython LVGL is an open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint. Berry is a ultra-lightweight dynamically typed embedded scripting language. It is designed for lower-performance embedded devices After compiling Tasmota with LVGL support and configuring uDisplay (see below), you can start using LVGL through the Berry console.","title":"Light and Versatile Embedded Graphics Library "},{"location":"LVGL/#using-lvgl","text":"This example uses the M5Stack Fire device. Use the following template to define the relevant SPI GPIOs. Also set one of the unsued GPIOs to Option A3 . The complete configuration for M5Stack Fire is: Templa te { \"NAME\" : \"M5stack Fire\" , \"GPIO\" :[ 6210 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 768 , 1 , 1 , 1 , 736 , 672 , 0 , 640 , 608 , 704 , 0 , 3872 , 3872 , 800 , 0 , 0 , 0 , 0 , 992 , 1024 , 1 , 0 , 0 , 34 , 33 , 32 ], \"FLAG\" : 0 , \"BASE\" : 1 , \"CMND\" : \"Module 0\" } Save the following file as display.ini in the file system: :H,ILI9341,320,240,16,SPI,1,*,*,*,*,*,*,*,40 :B,60,1 :I EF,3,03,80,02 CF,3,00,C1,30 ED,4,64,03,12,81 E8,3,85,00,78 CB,5,39,2C,00,34,02 F7,1,20 EA,2,00,00 C0,1,23 C1,1,10 C5,2,3e,28 C7,1,86 36,1,48 37,1,00 3A,1,55 B1,2,00,18 B6,3,08,82,27 F2,1,00 26,1,01 E0,0F,0F,31,2B,0C,0E,08,4E,F1,37,07,10,03,0E,09,00 E1,0F,00,0E,14,03,11,07,31,C1,48,08,0F,0C,31,36,0F 11,80 29,80 :o,28 :O,29 :A,2A,2B,2C :R,36 :0,08,00,00,00 :1,68,00,00,01 :2,C8,00,00,02 :3,A8,00,00,03 # Then open the Berry console and copy/paste the following: (alternatively create an autoexec.be file with this content): #- start LVGL and init environment -# lv . start () hres = lv . get_hor_res () # should be 320 vres = lv . get_ver_res () # should be 240 scr = lv . scr_act () # default screan object f20 = lv . montserrat_font ( 20 ) # load embedded Montserrat 20 #- Background with a gradient from black #000000 (bottom) to dark blue #0000A0 (top) -# scr . set_style_bg_color ( lv . color ( 0x0000A0 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_color ( lv . color ( 0x000000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_dir ( lv . GRAD_DIR_VER , lv . PART_MAIN | lv . STATE_DEFAULT ) #- Upper state line -# stat_line = lv . label ( scr ) if f20 != nil stat_line . set_style_text_font ( f20 , lv . PART_MAIN | lv . STATE_DEFAULT ) end stat_line . set_long_mode ( lv . LABEL_LONG_SCROLL ) # auto scrolling if text does not fit stat_line . set_width ( hres ) stat_line . set_align ( lv . TEXT_ALIGN_LEFT ) # align text left stat_line . set_style_bg_color ( lv . color ( 0xD00000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) # background #000088 stat_line . set_style_bg_opa ( lv . OPA_COVER , lv . PART_MAIN | lv . STATE_DEFAULT ) # 100% background opacity stat_line . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) # text color #FFFFFF stat_line . set_text ( \"Tasmota\" ) stat_line . refr_size () # new in LVGL8 stat_line . refr_pos () # new in LVGL8 #- display wifi strength indicator icon (for professionals ;) -# wifi_icon = lv_wifi_arcs_icon ( stat_line ) # the widget takes care of positioning and driver stuff clock_icon = lv_clock_icon ( stat_line ) #- create a style for the buttons -# btn_style = lv . style () btn_style . set_radius ( 10 ) # radius of rounded corners btn_style . set_bg_opa ( lv . OPA_COVER ) # 100% backgrond opacity if f20 != nil btn_style . set_text_font ( f20 ) end # set font to Montserrat 20 btn_style . set_bg_color ( lv . color ( 0x1fa3ec )) # background color #1FA3EC (Tasmota Blue) btn_style . set_border_color ( lv . color ( 0x0000FF )) # border color #0000FF btn_style . set_text_color ( lv . color ( 0xFFFFFF )) # text color white #FFFFFF #- create buttons -# prev_btn = lv . btn ( scr ) # create button with main screen as parent prev_btn . set_pos ( 20 , vres - 40 ) # position of button prev_btn . set_size ( 80 , 30 ) # size of button prev_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) # style of button prev_label = lv . label ( prev_btn ) # create a label as sub-object prev_label . set_text ( \"<\" ) # set label text prev_label . center () next_btn = lv . btn ( scr ) # right button next_btn . set_pos ( 220 , vres - 40 ) next_btn . set_size ( 80 , 30 ) next_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) next_label = lv . label ( next_btn ) next_label . set_text ( \">\" ) next_label . center () home_btn = lv . btn ( scr ) # center button home_btn . set_pos ( 120 , vres - 40 ) home_btn . set_size ( 80 , 30 ) home_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) home_label = lv . label ( home_btn ) home_label . set_text ( lv . SYMBOL_OK ) # set text as Home icon home_label . center () #- callback function when a button is pressed, react to EVENT_CLICKED event -# def btn_clicked_cb ( obj , event ) var btn = \"Unknown\" if obj == prev_btn btn = \"Prev\" elif obj == next_btn btn = \"Next\" elif obj == home_btn btn = \"Home\" end print ( btn , \"button pressed\" ) end prev_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) next_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) home_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) You should see this: Setting an input device is simple, we are now configuring the three buttons as the equivalent of a rotary encoder: left/ok/right. To control focus, you need to create a group, put the focusable items in the group, and assign the input device to the group: g = lv . group () g . add_obj ( prev_btn ) g . add_obj ( home_btn ) g . add_obj ( next_btn ) rotary = lv . register_button_encoder ( true ) #- buttons are inverted -# rotary . set_group ( g )","title":"Using LVGL"},{"location":"LVGL/#touch-screen-support","text":"Touch screen are supported natively via Universal Display driver. Example: colp = lv . colorwheel ( scr , false ) colp . set_size ( 130 , 130 ) colp . set_pos ( 10 , 30 ) Let's go into the details of this example.","title":"Touch Screen Support"},{"location":"LVGL/#starting-lvgl","text":"Start LVGL lv . start () Note: when you create an LVGL object, you need to use the lv module. For example, creating a label object is done with lv.lv_label . As a convenience, classes can also be named with a shorter name lv.label which is equivalent to lv.lv_label . The internal class name is still lv_label . Use lv.montserrat_font(<size>) to load a pre-defined montserrat font. Embedded sizes are: 10, 14, 20, 28. You can also load a font from the file-system but you need to convert them first. See: https://docs.lvgl.io/latest/en/html/overview/font.html hres = lv . get_hor_res () # should be 320 vres = lv . get_ver_res () # should be 240 scr = lv . scr_act () # default screan object f20 = lv . montserrat_font ( 20 ) # load embedded Montserrat 20","title":"Starting LVGL"},{"location":"LVGL/#set-the-background-color","text":"#- Background with a gradient from black #000000 (bottom) to dark blue #0000A0 (top) -# scr . set_style_bg_color ( lv . color ( 0x0000A0 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_color ( lv . color ( 0x000000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_dir ( lv . GRAD_DIR_VER , lv . PART_MAIN | lv . STATE_DEFAULT ) The display is composed of a virtual screen object scr . To change the background you need to change the style of this object. You can either create a full style object or change the style inside the object. This is what we do here. Hence methods: set_style_<xxx> In this example we do a vertical color gradient from dark blue (up) to black (down).","title":"Set the background color"},{"location":"LVGL/#colors","text":"Color are created via lv.color(<int>) with 0xRRGGBB as 24 bits color. Internally the color is converted to the display color depth so rounding errors may happen: > lv.color(0x808080) lv_color(0x838183 - native:0x1084) The line above shows the internal color converted back to 24 bits RGB (rounding errors occur) and the native 15 bits RGB internal color.","title":"Colors"},{"location":"LVGL/#create-the-upper-text-line","text":"#- Upper state line -# stat_line = lv . label ( scr ) if f20 != nil stat_line . set_style_text_font ( f20 , lv . PART_MAIN | lv . STATE_DEFAULT ) end stat_line . set_long_mode ( lv . LABEL_LONG_SCROLL ) # auto scrolling if text does not fit stat_line . set_width ( hres ) stat_line . set_align ( lv . TEXT_ALIGN_LEFT ) # align text left stat_line . set_style_bg_color ( lv . color ( 0xD00000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) # background #000088 stat_line . set_style_bg_opa ( lv . OPA_COVER , lv . PART_MAIN | lv . STATE_DEFAULT ) # 100% background opacity stat_line . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) # text color #FFFFFF stat_line . set_text ( \"Tasmota\" ) stat_line . refr_size () # new in LVGL8 stat_line . refr_pos () # new in LVGL8 Let's decompose: stat_line = lv . label ( scr ) Creates an object of type lv_label with parent scr (screen). if f20 != nil stat_line . set_style_text_font ( f20 , lv . PART_MAIN | lv . STATE_DEFAULT ) end If f20 is correctly loaded, set the font to Montserrat 20. Styles are associated to parts of objects and to states. Here we associate to the main part for state default. stat_line . set_long_mode ( lv . LABEL_LONG_SCROLL ) # auto scrolling if text does not fit Set the label to auto roll from right to left and vice versa if the text does not fit in the display. stat_line . set_width ( hres ) stat_line . set_align ( lv . TEXT_ALIGN_LEFT ) # align text left Set the width to full screen resolution, and align text to the left. stat_line . set_style_bg_color ( lv . color ( 0xD00000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) # background #000088 stat_line . set_style_bg_opa ( lv . OPA_COVER , lv . PART_MAIN | lv . STATE_DEFAULT ) # 100% background opacity stat_line . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) # text color #FFFFFF Set background color to red, text color to white, opacity to 100%. stat_line . set_text ( \"Tasmota\" ) Set the text of the label. stat_line . refr_size () # new in LVGL8 stat_line . refr_pos () # new in LVGL8 The latter is new in LVGL8 and tells the widget to update its size and position, that we will use right after to position other widgets. Please note that the actual display is asynchronous. We describe the objects, in whatever order, they will be all displayed at once.","title":"Create the upper text line"},{"location":"LVGL/#create-a-style","text":"#- create a style for the buttons -# btn_style = lv . style () btn_style . set_radius ( 10 ) # radius of rounded corners btn_style . set_bg_opa ( lv . OPA_COVER ) # 100% backgrond opacity if f20 != nil btn_style . set_text_font ( f20 ) end # set font to Montserrat 20 btn_style . set_bg_color ( lv . color ( 0x1fa3ec )) # background color #1FA3EC (Tasmota Blue) btn_style . set_border_color ( lv . color ( 0x0000FF )) # border color #0000FF btn_style . set_text_color ( lv . color ( 0xFFFFFF )) # text color white #FFFFFF We create a lv_style object and associate some attributes. This works similarly to CSS styles. This style sets background color to Tasmota button blue, text to white, opacity to 100%, font to Montserrat 20 and corner rounding to 1 pixel (10 decipixels).","title":"Create a style"},{"location":"LVGL/#create-the-buttons","text":"home_btn = lv . btn ( scr ) # center button home_btn . set_pos ( 120 , vres - 40 ) home_btn . set_size ( 80 , 30 ) home_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) home_label = lv . label ( home_btn ) home_label . set_text ( lv . SYMBOL_OK ) # set text as Home icon home_label . center () Finally create a lv_btn object with parent scr , set its size and position, add the previously defined style and set its text. LVGL provides some pre-defined symbols like lv.SYMBOL_OK .","title":"Create the buttons"},{"location":"LVGL/#advanced-features-and-extensions","text":"","title":"Advanced features and extensions"},{"location":"LVGL/#screenshot","text":"Tasmota includes an easy way to take screenshots. Just use lv.screenshot() and a BMP file will be stored in the file system. Example: > lv . screenshot () /screenshot-1642356919.bmp Then download the file to your local computer. The file format is uncompressed BMP with 16 bits per pixel. It is highly recommended to then compress the image to PNG or JPG with the software of your choice. Warning: due to internal implementation limitations, the image is stored upside down. Don't forget to vertically revert the image.","title":"Screenshot"},{"location":"LVGL/#png-image-support","text":"Support for PNG decoding depends on #define USE_LVGL_PNG_DECODER - which is enabled by default in Tasmota32-lvgl. You need to first store images on the file system, and simply load them through LVGL standard way. PNG identification depends on the .png extension. Example: store the following image as Sunrise320.png sunrise = lv . img ( scr ) # create an empty image object in the current screen sunrise . set_src ( \"A:/Sunrise320.png\" ) # load \"Sunrise320.png\", the default drive letter is 'A:' sunrise . move_background () # move the image to the background","title":"PNG Image support"},{"location":"LVGL/#freetype-fonts-support","text":"Support for Freetype fonts depends on #define USE_LVGL_FREETYPE - which is NOT enabled by default in Tasmota32-lvgl. Bitmat fonts typically consume significant flash size because you need to embed the font at different size. Using FreeType vector fonts can bring more flexibility and options. You need to first upload the desired fonts on the Tasmota file system. To create the lv_font object, use lv.load_freetype_font(name:string, size:int, type:int) -> nil or lv_font . If the font is not found, the call returns nil . type can be 0 or lv.FT_FONT_STYLE_NORMAL , or a combination of lv.FT_FONT_STYLE_ITALIC and lv.FT_FONT_STYLE_BOLD . Example (after loading lvgl_demo.be ) using sketchbook.ttf font: sb120 = lv . load_freetype_font ( \"sketchbook.ttf\" , 120 , 0 ) tt = lv . label ( scr ) tt . set_style_bg_opa ( lv . OPA_0 , lv . PART_MAIN | lv . STATE_DEFAULT ) tt . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) tt . set_text ( \"MQTT\" ) tt . set_pos ( 10 , 40 ) tt . set_size ( 300 , 150 ) if sb120 != nil tt . set_style_text_font ( sb120 , lv . PART_MAIN | lv . STATE_DEFAULT ) end","title":"Freetype fonts support"},{"location":"LVGL/#whats-implemented-and-whats-not","text":"What's implemented currently: All standard LVGL widgets are available, most of extras Styles File-system Fonts, currently Montserrat fonts are embedded at sizes 10, 14 (default), 20 and 28 (compressed - smaller and slower) External Fonts in file-system, either in LVGL's binary format of TrueType fonts via the FreeType library (requires #defined USE_LVGL_FREETYPE ) Images in file-system, either in LVGL's binary format or PNG Most of the high-level LVGL APIs via the lv Berry object SPI displays with 16 bits per pixels Animations via Berry code Touch Screen support SPI DMA Callbacks on LVGL objects to react on events Ability to define custom widgets in Berry What will probably not be implemented Native LVGL animation engine Styles garbage collection is not done, which means that creating lots of styles leads to memoly leak multi-screens display - I don't know of a single ESP32 based device with multi-screens Bidirectional fonts - unless there is strong demand LVGL tasks - Berry provides all the necessary tools for task scheduling","title":"What's implemented and what's not?"},{"location":"LVGL/#converting-c-lvgl-to-berry","text":"Simply speaking, you can convert most constants from their C equivalent to berry by just changing the LV_ prefix to lv. . Example: LV_SYMBOL_OK becomes lv.SYMBOL_OK Berry provides an object model to lv_object and sub-classes for widhets like lv_btn , lv_label ... To create an object, just instantiate the class: lv_btn(parent) lv_style is created independently. lv_color takes an 24 bits 0xRRGGB as parameter, or a pre-defined color like lv.BLUE","title":"Converting C LVGL to Berry"},{"location":"LVGL/#compiling-for-lvlg","text":"In my_user_config.h or in your config override, add: #define USE_LVGL #define USE_DISPLAY #define USE_DISPLAY_LVGL_ONLY #define USE_XPT2046 #define USE_UNIVERSAL_DISPLAY #undef USE_DISPLAY_MODES1TO5 #undef USE_DISPLAY_LCD #undef USE_DISPLAY_SSD1306 #undef USE_DISPLAY_MATRIX #undef USE_DISPLAY_SEVENSEG Be aware that it adds 440Kb to you firmware, so make sure you have a partition with enough program Flash space. Preferably use esp32_partition_app1856k_spiffs320k.csv partition file.","title":"Compiling for LVLG"},{"location":"LVGL/#goodies","text":"","title":"Goodies"},{"location":"LVGL/#tasmota-logo","text":"Get a Tasmota logo: # start the display lv . start () # set background color to blue scr = lv . scr_act () scr . set_style_bg_color ( lv . color ( lv . COLOR_BLUE ), lv . PART_MAIN | lv . STATE_DEFAULT ) # create a lv_img object and set it to Tasmota logo logo = lv . img ( scr ) logo . set_tasmota_logo () logo . center () The logo is black, with anti-aliasing and transparency. You can now manipulate the logo: change zoom, rotate or recolor. # recolor logo to white logo . set_style_img_recolor_opa ( 255 , lv . PART_MAIN | lv . STATE_DEFAULT ) logo . set_style_img_recolor ( lv . color ( lv . COLOR_WHITE ), lv . PART_MAIN | lv . STATE_DEFAULT ) # zoom by 125% - 100% is 256, so 125% is 320 logo . set_zoom ( 300 ) # rotate by 30 degrees - or 300 deci-degrees logo . set_angle ( 300 ) Example of animation: cur_zoom = 200 cur_incr = 5 def animate_logo() cur_zoom += cur_incr if cur_zoom > 300 cur_incr = - cur_incr end if cur_zoom < 200 cur_incr = - cur_incr end logo.set_zoom(cur_zoom) tasmota.set_timer(100, animate_logo) end animate_logo()","title":"Tasmota Logo"},{"location":"LVGL/#calibrate-a-resitive-touch-screen","text":"Some touchscreens like Lolin TFT 2.4 Touch Shields use a resistive touchscreen controlled by XPT2046 . Contrary to capacitive touchscreens, resistive touchscreens needs a per-device calibration. You can download DisplayCalibrate.tapp Tasmota Application which allows for easy calibration. In only a few steps, it will generate the universal display line :M with calibration information. First download DisplayCalibrate.tapp application and upload it in the file system, and restart. Make sure you are in orientation DisplayRotate 0 In the console, type the command DisplayCalibrate You will see the following screens. Click on all 4 crosses near corners. Note: measures are taken every 50 ms and are averaged, and requires at least 3 measures (150ms). If everything went well, you will see the following screen. After reboot, your touchscreen is ready and calibrate. If the geometry is wrong, you will see the following screen and no change is done to display.ini","title":"Calibrate a resitive Touch Screen"},{"location":"LVGL/#cookbook","text":"","title":"Cookbook"},{"location":"LVGL/#measuring-user-inactivity","text":"LVGL has a notion of screen inactivity, i.e. how long did the user not interact with the screen. This can be use to dim the display or turn it off after a moment of inactivity (like a screen saver). The time is in milliseconds. Full doc here: https://docs.lvgl.io/8/overview/display.html#inactivity # time of inactivity in ms lv . disp () . get_inactive_time ()","title":"Measuring user inactivity"},{"location":"LVGL/#technical-details","text":"The code size impact is quite significant, so you probably need partitions with code at least set to 1856KB. Doing so leaves 320KB for file system on 4MB flash. With the Safeboot partition layout , default code partition size for 4MB of flash is 2880KB. Most of Berry code is solidified in Flash, so the initial RAM footprint is very low (a few KB).","title":"Technical Details"},{"location":"LVGL_Internals/","text":"LVGL - Internals ~ Below are notes about the LVGL-Berry mapping in Tasmota. You will find information for curious people and maintainers. Build system ~ Berry mapping to LVGL is entirely automated. Most of the components are generated C code from the LVGL's C source code, similar to MicroPython approach. Phase 1: Parse LVGL source This first phase parses most C headers from the LVGL source tree and generates two files: - lv_enum.h containing all the enum values from LVGL (constants) - lv_funcs.h containing all the functions of the LVGL API normalized to 1 function per line, and with cleaned argument signature. (in folder Tasmota/lib/libesp32_lvgl/lv_berry/tools) \u276f python3 preprocessor.py (no output) Phase 2: Generate automatic Berry mapping From the two files created in the previous step, all the requires C files are created for the Berry mapping. (in folder Tasmota/lib/libesp32_lvgl/lv_berry/tools) > python3 convert.py | callback types['lv_group_focus_cb', 'lv_event_cb', 'lv_constructor_cb', 'lv_layout_update_cb', 'lv_obj_tree_walk_cb', 'lv_theme_apply_cb', 'lv_color_filter_cb'] The output should look as above, and indicates the C function that have been ignored (if any) if their return type is listed above. It also lists the callback types supported. Phase 3: Generate the Berry pre-compiled stubs This phase is specific to Berry pre-compiled modules and classes. (in folder Tasmota/lib/libesp32/berry) > ./gen.sh (no output) Phase 4: compile Tasmota using platform.io as usual lv module ~ Tasmota automatically and implicitly imports lv module if compiled with LVGL. import lv The lv module is solidified in Flash, so to make it extensible, there is a trick applied to it. When you do import lv the first time, a hidden lv_new module is created in memory (writable) and a member function is added so that all members requested that are not part of lv_new are diverted to lv . Concretely, this means that the new lv module is a facade to the read-only solidified lv module, but you can still add methods. This is how it is done internally: lv = module ( \"lv\" ) # rename `lv` to `lv_ntv` and replace `lv` with `lv_tasmota` def lv_module_init ( lv_solidified ) var lv_new = module ( \"lv\" ) # create a dynamic module lv_new . member = lv_solidified . member # lv_new.lv_solidified = lv_solidified return lv_new end lv . init = lv_module_init def lv0_member_ntv () end lv . member = lv0_member_ntv return lv Tasmota then does import lv_tasmota to add all Tasmota specific extensions to module lv . Constants ~ The lv module is a placeholder for all LVGL constants, the equivalent of C enums. As a rule of thumb, all C constants are mapped with a similar name. Just replace LV_<name> with lv.<name> . Example: C API LV_LABEL_ALIGN_LEFT becomes in Berry lv.LABEL_ALIGN_LEFT Implementation ~ The C enum constants are all compiled in a single file tools/lv_berry/lv_module.h . Only names are listed, the actual values are retrieved by the C compiler at runtime (which avoids many mistakes). Internally constants are handled by a virtual member in lvgl module. The module lvgl has a member() function that is called when the Berry runtime does not know the member name. The search happens in lv0_member() which first searches for a static member name, and if not found, looks for a widget class name. Constants are put in a C table in lib/libesp32/Berry/default/be_lv_lvgl_module.c as lv0_constants[] . The table is sorted by member name to allow for fast binary search (dichotomy). const be_constint_t lv0_constants [] = { { \"ALIGN_CENTER\" , LV_ALIGN_CENTER }, { \"ALIGN_IN_BOTTOM_LEFT\" , LV_ALIGN_IN_BOTTOM_LEFT }, [...] { \"WIN_PART_SCROLLBAR\" , LV_WIN_PART_SCROLLBAR }, { \"YELLOW\" , 16776960 }, }; Colors ~ An exception for LVGL colors, they are defined as 32 bits RGB values as follows, and not based on their C representation: COLOR_WHITE = 0xFFFFFF COLOR_SILVER = 0xC0C0C0 COLOR_GRAY = 0x808080 COLOR_BLACK = 0x000000 COLOR_RED = 0xFF0000 COLOR_MAROON = 0x800000 COLOR_YELLOW = 0xFFFF00 COLOR_OLIVE = 0x808000 COLOR_LIME = 0x00FF00 COLOR_GREEN = 0x008000 COLOR_CYAN = 0x00FFFF COLOR_AQUA = 0x00FFFF COLOR_TEAL = 0x008080 COLOR_BLUE = 0x0000FF COLOR_NAVY = 0x000080 COLOR_MAGENTA = 0xFF00FF COLOR_PURPLE = 0x800080 Example: lv.COLOR_RED Widgets classes ~ Although LVGL is C code and is not formally object oriented, LVGL widget follow an inheritance model. Each widget is a virtual subclass of lv_obj structure. Berry builds an actual Object Oriented class system, with a base class lv_obj and subclasses. The class names supported are defined in convert.py and are currently: 'lv_arc', 'lv_bar', 'lv_btn', 'lv_btnmatrix', 'lv_calendar', 'lv_canvas', 'lv_chart', 'lv_checkbox', 'lv_cont', 'lv_cpicker', 'lv_dropdown', 'lv_gauge', 'lv_img', 'lv_imgbtn', 'lv_keyboard', 'lv_label', 'lv_led', 'lv_line', 'lv_linemeter', 'lv_list', 'lv_msgbox', 'lv_objmask', 'lv_templ', 'lv_page', 'lv_roller', 'lv_slider', 'lv_spinbox', 'lv_spinner', 'lv_switch', 'lv_table', 'lv_tabview', 'lv_textarea', 'lv_tileview', 'lv_win' Additional 'special' classes are (they do not inherit from lv_obj ): 'lv_obj', 'lv_group', 'lv_style', 'lv_indev' Parsing ~ The parsing is done by convert.py which parses tools/lv_berry/lv_widgets.h . This file contains all the C function signatures as single lines. convert.py checks if the types are supported and converts it as a Berry signature. The resulting signatures are used to generate class stubs for all Berry classes in lib/libesp32/Berry/default/be_lvgl_widgets_lib.c and the Berry signatures are in tasmota/lvgl_berry/be_lv_c_mapping.h Example: The C signature: bool lv_obj_area_is_visible(const lv_obj_t * obj, lv_area_t * area); is recognized to be part of lv_obj class (by prefix) and has the following signature: { \"area_is_visible\", (void*) &lv_obj_area_is_visible, \"b\", \"(lv_obj)(lv_area)\" }, Decomposed as: - \"area_is_visible\": name of the Berry method - (void*) &lv_obj_area_is_visible: pointer to the C implementation - \"b\": return type, here boolean - \"(lv_obj)(lv_area)\": input types, 2 arguments of classes lv_obj and lv_area Other example: void lv_btnmatrix_set_align(lv_obj_t * btnm, lv_label_align_t align); { \"set_align\", (void*) &lv_btnmatrix_set_align, \"\", \"(lv_obj)i\" }, The parsing of the signature is done in be_check_arg_type() Input and output types are: \"b\": boolean \"s\": string \"i\": int (signed 32 bits)- \".\": any type \"& \": where n is a digit, Berry callback by class (see below) \"(lv_ )\": an instance of lv_ . Note if you pass 0 (NULL) to a class argmunent it is accepted without warning. Note: any missing argument or nil argument is converted to 0 . In case of an argument mismatch, a warning is printed but the call is still proceed. Warning : you can easily crash Tasmota if you send wrong types arguments. Widgets instanciation ~ Instanciation of a widget is marked as a specific signature. The return type is prefixed with + : lv_obj_t * lv_canvas_create(lv_obj_t * par, const lv_obj_t * copy); { \"create\", (void*) &lv_canvas_create, \"+lv_canvas\", \"(lv_obj)(lv_obj)\" }, All widgets constructor always take 2 arguments, the first is the parent object, the second is the copy object (generally null or ignored) Example: scr = lv.scr_act() log = lv_label(scr) # scr is parent object of log Internally, widget constructors call lvx_init_2() . LVGL object are allocated by LVGL, the Berry object only contains a reference to the C structure (a pointer). These objects can be garbage collected without any impact. lv_obj and widget constructors also accept a specific form: log2 = lv_label(-1, log) which just creates a second reference to the same LVGL object - it is mostly used internally to dynamically create an instance from a returned C pointed. Callbacks ~ Callbacks are a challenge in Berry. A callback is only a C pointer to a function and does not natively hold any other information. However we would like to match a single C address to multiple Berry closures. We take into account the fact that the first argument of any LVGL callback has always an instance as first argument, from the type list: 'lv_group_focus_cb', 'lv_event_cb', 'lv_signal_cb', 'lv_design_cb', 'lv_gauge_format_cb' We define 5 different C functions with 5 distinct addresses, one for each callback type. Then we use the first argument to dispatch the call to the appropriate Berry closure. Here is the call used at startup: import lvgl as lv # for each callback type, mapping between first argument and closure _lvgl_cb = [ {}, {}, {}, {}, {}, {} ] # for each callback type, mapping between first argument and the actual Berry object with the correct type (C arguments are not explicitly typed) _lvgl_cb_obj = [ {}, {}, {}, {}, {}, {} ] def _lvgl_cb_dispatch ( idx , obj , v1 , v2 , v3 , v4 ) var func = _lvgl_cb [ idx ] . find ( obj ) var inst = _lvgl_cb_obj [ idx ] . find ( obj ) if func != nil return func ( inst , v1 , v2 , v3 , v4 ) end return nil end Styles ~ lv_style is not a subclass of lv_obj but uses a similar mechanism to map the members. Main difference, it uses a distinct constructor lvs_init() . Note: lv_style needs to allocate memory and must not be garbage collected. For this reason lv_style allocates static memory which is never freed. Be aware that it may be a cause of memory leak (although not very likely). Colors ~ lv_color is a simple class that maps RGB 32 bits colors (as 32 bits int) to the internal representation of colors (usually 16 bits). Don't be surprised that getting back a value is the 16 bits color converted to 32 bits - rounding errors may occur: [Berry Console] > c = lv_color(0x808080) > c lv_color(0xff838183 - native:0x1084) Note: 0xff838183 - is the 32 bits color, with alpha channel (opaque) 0x1084 - is the native internal representation as 16 bits color with swapped bytes Groups ~ lv_group behaves like lv_obj but does not inherit from it. Indev ~ Indev or 'Input Device' is a simple class wrapper to handle touch screens and input buttons. It is similar to lv_obj but uses a simple constructor lv0_init() that just wraps the C pointer into the Berry instance.","title":"LVGL - Internals"},{"location":"LVGL_Internals/#lvgl-internals","text":"Below are notes about the LVGL-Berry mapping in Tasmota. You will find information for curious people and maintainers.","title":"LVGL - Internals"},{"location":"LVGL_Internals/#build-system","text":"Berry mapping to LVGL is entirely automated. Most of the components are generated C code from the LVGL's C source code, similar to MicroPython approach. Phase 1: Parse LVGL source This first phase parses most C headers from the LVGL source tree and generates two files: - lv_enum.h containing all the enum values from LVGL (constants) - lv_funcs.h containing all the functions of the LVGL API normalized to 1 function per line, and with cleaned argument signature. (in folder Tasmota/lib/libesp32_lvgl/lv_berry/tools) \u276f python3 preprocessor.py (no output) Phase 2: Generate automatic Berry mapping From the two files created in the previous step, all the requires C files are created for the Berry mapping. (in folder Tasmota/lib/libesp32_lvgl/lv_berry/tools) > python3 convert.py | callback types['lv_group_focus_cb', 'lv_event_cb', 'lv_constructor_cb', 'lv_layout_update_cb', 'lv_obj_tree_walk_cb', 'lv_theme_apply_cb', 'lv_color_filter_cb'] The output should look as above, and indicates the C function that have been ignored (if any) if their return type is listed above. It also lists the callback types supported. Phase 3: Generate the Berry pre-compiled stubs This phase is specific to Berry pre-compiled modules and classes. (in folder Tasmota/lib/libesp32/berry) > ./gen.sh (no output) Phase 4: compile Tasmota using platform.io as usual","title":"Build system"},{"location":"LVGL_Internals/#lv-module","text":"Tasmota automatically and implicitly imports lv module if compiled with LVGL. import lv The lv module is solidified in Flash, so to make it extensible, there is a trick applied to it. When you do import lv the first time, a hidden lv_new module is created in memory (writable) and a member function is added so that all members requested that are not part of lv_new are diverted to lv . Concretely, this means that the new lv module is a facade to the read-only solidified lv module, but you can still add methods. This is how it is done internally: lv = module ( \"lv\" ) # rename `lv` to `lv_ntv` and replace `lv` with `lv_tasmota` def lv_module_init ( lv_solidified ) var lv_new = module ( \"lv\" ) # create a dynamic module lv_new . member = lv_solidified . member # lv_new.lv_solidified = lv_solidified return lv_new end lv . init = lv_module_init def lv0_member_ntv () end lv . member = lv0_member_ntv return lv Tasmota then does import lv_tasmota to add all Tasmota specific extensions to module lv .","title":"lv module"},{"location":"LVGL_Internals/#constants","text":"The lv module is a placeholder for all LVGL constants, the equivalent of C enums. As a rule of thumb, all C constants are mapped with a similar name. Just replace LV_<name> with lv.<name> . Example: C API LV_LABEL_ALIGN_LEFT becomes in Berry lv.LABEL_ALIGN_LEFT","title":"Constants"},{"location":"LVGL_Internals/#implementation","text":"The C enum constants are all compiled in a single file tools/lv_berry/lv_module.h . Only names are listed, the actual values are retrieved by the C compiler at runtime (which avoids many mistakes). Internally constants are handled by a virtual member in lvgl module. The module lvgl has a member() function that is called when the Berry runtime does not know the member name. The search happens in lv0_member() which first searches for a static member name, and if not found, looks for a widget class name. Constants are put in a C table in lib/libesp32/Berry/default/be_lv_lvgl_module.c as lv0_constants[] . The table is sorted by member name to allow for fast binary search (dichotomy). const be_constint_t lv0_constants [] = { { \"ALIGN_CENTER\" , LV_ALIGN_CENTER }, { \"ALIGN_IN_BOTTOM_LEFT\" , LV_ALIGN_IN_BOTTOM_LEFT }, [...] { \"WIN_PART_SCROLLBAR\" , LV_WIN_PART_SCROLLBAR }, { \"YELLOW\" , 16776960 }, };","title":"Implementation"},{"location":"LVGL_Internals/#colors","text":"An exception for LVGL colors, they are defined as 32 bits RGB values as follows, and not based on their C representation: COLOR_WHITE = 0xFFFFFF COLOR_SILVER = 0xC0C0C0 COLOR_GRAY = 0x808080 COLOR_BLACK = 0x000000 COLOR_RED = 0xFF0000 COLOR_MAROON = 0x800000 COLOR_YELLOW = 0xFFFF00 COLOR_OLIVE = 0x808000 COLOR_LIME = 0x00FF00 COLOR_GREEN = 0x008000 COLOR_CYAN = 0x00FFFF COLOR_AQUA = 0x00FFFF COLOR_TEAL = 0x008080 COLOR_BLUE = 0x0000FF COLOR_NAVY = 0x000080 COLOR_MAGENTA = 0xFF00FF COLOR_PURPLE = 0x800080 Example: lv.COLOR_RED","title":"Colors"},{"location":"LVGL_Internals/#widgets-classes","text":"Although LVGL is C code and is not formally object oriented, LVGL widget follow an inheritance model. Each widget is a virtual subclass of lv_obj structure. Berry builds an actual Object Oriented class system, with a base class lv_obj and subclasses. The class names supported are defined in convert.py and are currently: 'lv_arc', 'lv_bar', 'lv_btn', 'lv_btnmatrix', 'lv_calendar', 'lv_canvas', 'lv_chart', 'lv_checkbox', 'lv_cont', 'lv_cpicker', 'lv_dropdown', 'lv_gauge', 'lv_img', 'lv_imgbtn', 'lv_keyboard', 'lv_label', 'lv_led', 'lv_line', 'lv_linemeter', 'lv_list', 'lv_msgbox', 'lv_objmask', 'lv_templ', 'lv_page', 'lv_roller', 'lv_slider', 'lv_spinbox', 'lv_spinner', 'lv_switch', 'lv_table', 'lv_tabview', 'lv_textarea', 'lv_tileview', 'lv_win' Additional 'special' classes are (they do not inherit from lv_obj ): 'lv_obj', 'lv_group', 'lv_style', 'lv_indev'","title":"Widgets classes"},{"location":"LVGL_Internals/#parsing","text":"The parsing is done by convert.py which parses tools/lv_berry/lv_widgets.h . This file contains all the C function signatures as single lines. convert.py checks if the types are supported and converts it as a Berry signature. The resulting signatures are used to generate class stubs for all Berry classes in lib/libesp32/Berry/default/be_lvgl_widgets_lib.c and the Berry signatures are in tasmota/lvgl_berry/be_lv_c_mapping.h Example: The C signature: bool lv_obj_area_is_visible(const lv_obj_t * obj, lv_area_t * area); is recognized to be part of lv_obj class (by prefix) and has the following signature: { \"area_is_visible\", (void*) &lv_obj_area_is_visible, \"b\", \"(lv_obj)(lv_area)\" }, Decomposed as: - \"area_is_visible\": name of the Berry method - (void*) &lv_obj_area_is_visible: pointer to the C implementation - \"b\": return type, here boolean - \"(lv_obj)(lv_area)\": input types, 2 arguments of classes lv_obj and lv_area Other example: void lv_btnmatrix_set_align(lv_obj_t * btnm, lv_label_align_t align); { \"set_align\", (void*) &lv_btnmatrix_set_align, \"\", \"(lv_obj)i\" }, The parsing of the signature is done in be_check_arg_type() Input and output types are: \"b\": boolean \"s\": string \"i\": int (signed 32 bits)- \".\": any type \"& \": where n is a digit, Berry callback by class (see below) \"(lv_ )\": an instance of lv_ . Note if you pass 0 (NULL) to a class argmunent it is accepted without warning. Note: any missing argument or nil argument is converted to 0 . In case of an argument mismatch, a warning is printed but the call is still proceed. Warning : you can easily crash Tasmota if you send wrong types arguments.","title":"Parsing"},{"location":"LVGL_Internals/#widgets-instanciation","text":"Instanciation of a widget is marked as a specific signature. The return type is prefixed with + : lv_obj_t * lv_canvas_create(lv_obj_t * par, const lv_obj_t * copy); { \"create\", (void*) &lv_canvas_create, \"+lv_canvas\", \"(lv_obj)(lv_obj)\" }, All widgets constructor always take 2 arguments, the first is the parent object, the second is the copy object (generally null or ignored) Example: scr = lv.scr_act() log = lv_label(scr) # scr is parent object of log Internally, widget constructors call lvx_init_2() . LVGL object are allocated by LVGL, the Berry object only contains a reference to the C structure (a pointer). These objects can be garbage collected without any impact. lv_obj and widget constructors also accept a specific form: log2 = lv_label(-1, log) which just creates a second reference to the same LVGL object - it is mostly used internally to dynamically create an instance from a returned C pointed.","title":"Widgets instanciation"},{"location":"LVGL_Internals/#callbacks","text":"Callbacks are a challenge in Berry. A callback is only a C pointer to a function and does not natively hold any other information. However we would like to match a single C address to multiple Berry closures. We take into account the fact that the first argument of any LVGL callback has always an instance as first argument, from the type list: 'lv_group_focus_cb', 'lv_event_cb', 'lv_signal_cb', 'lv_design_cb', 'lv_gauge_format_cb' We define 5 different C functions with 5 distinct addresses, one for each callback type. Then we use the first argument to dispatch the call to the appropriate Berry closure. Here is the call used at startup: import lvgl as lv # for each callback type, mapping between first argument and closure _lvgl_cb = [ {}, {}, {}, {}, {}, {} ] # for each callback type, mapping between first argument and the actual Berry object with the correct type (C arguments are not explicitly typed) _lvgl_cb_obj = [ {}, {}, {}, {}, {}, {} ] def _lvgl_cb_dispatch ( idx , obj , v1 , v2 , v3 , v4 ) var func = _lvgl_cb [ idx ] . find ( obj ) var inst = _lvgl_cb_obj [ idx ] . find ( obj ) if func != nil return func ( inst , v1 , v2 , v3 , v4 ) end return nil end","title":"Callbacks"},{"location":"LVGL_Internals/#styles","text":"lv_style is not a subclass of lv_obj but uses a similar mechanism to map the members. Main difference, it uses a distinct constructor lvs_init() . Note: lv_style needs to allocate memory and must not be garbage collected. For this reason lv_style allocates static memory which is never freed. Be aware that it may be a cause of memory leak (although not very likely).","title":"Styles"},{"location":"LVGL_Internals/#colors_1","text":"lv_color is a simple class that maps RGB 32 bits colors (as 32 bits int) to the internal representation of colors (usually 16 bits). Don't be surprised that getting back a value is the 16 bits color converted to 32 bits - rounding errors may occur: [Berry Console] > c = lv_color(0x808080) > c lv_color(0xff838183 - native:0x1084) Note: 0xff838183 - is the 32 bits color, with alpha channel (opaque) 0x1084 - is the native internal representation as 16 bits color with swapped bytes","title":"Colors"},{"location":"LVGL_Internals/#groups","text":"lv_group behaves like lv_obj but does not inherit from it.","title":"Groups"},{"location":"LVGL_Internals/#indev","text":"Indev or 'Input Device' is a simple class wrapper to handle touch screens and input buttons. It is similar to lv_obj but uses a simple constructor lv0_init() that just wraps the C pointer into the Berry instance.","title":"Indev"},{"location":"LVGL_in_10_minutes/","text":"LVGL in less than 10 minutes with Tasmota ~ In 2021, Tasmota added full support of LVGL for ESP32 based devices. It also introduced the Berry scripting language , a small-footprint language similar to Python and fully integrated in Tasmota. A comprehensive mapping of LVGL in Berry language is available, similar to the mapping of Micropython. The tutorial below illustrates how to install Tasmota on M5Stack devices (based on ESP32) and run your first LVGL application in Berry - all in less than 10 minutes. We will use nice M5Stack devices that integrate ESP32 and a 320x240 display, with touchscreen or physical buttons depending on the device. Flash Tasmota-lvgl on the device ~ We have packaged an easy to use Web Flasher for ESP32. If this method fails or if you prefer local client method, have a look at Getting Started on Tasmota documentation. Connect your M5Stack device via a USB Cable. Connect to the Tasmota Web Installer Scroll down in Development section and select Tasmota32 LVGL Click Connect and select the appropriate Serial Port. It should connect in a couple of second. Click Install Development Tasmota32 Lvgl (English) Check Erase Device if it's the first time you install Tasmota, or you may experience unwanted behavior. Click Next Click Install It should take a little more to Erase and Flash You can now close the Web Flasher and proceed to the Wifi configuration Configure Tasmota Wifi ~ The next step can be done with a phone or a computer. Connect to temporary the wifi access point with a name starting with tasmota-... You should be automatically brought to the Wifi configuration page. If not, try connecting to 192.168.4.1 Select your wifi network (yes, my wifi is named Tasmota ...), enter the password and hit Save . If all goes well, you should see the IP address of Tasmota and be redirected to it. You should now see the Tasmota main screen. Configure Tasmota for M5Stack ~ Tasmota is based on general purpose firmwares, you now need to configure specifically for your M5Stack device. We provide two templates, one for M5Stack Basic/Gray/GO/Fire and one for M5Stack Core2 . Go to Tasmota main screen and click on Configuration Then click on Auto-configuration . You are now on the Auto-configuration page. Select M5Stack Fire or M5Stack Core2 . Then click on Apply configuration . The device restarts and you should be back to Tasmota main page. The screen should have been configured (you should see a short flash on the screen). Try a LVGL demo app ~ In this last step, we will try to run a small LVGL application written in Berry. Go to Tasmota Main Screen and click Consoles then Manage File System Click on Create and edit new file , enter the filename autoexec.be and copy the following code in the text pane: #- start LVGL and init environment -# lv . start () tasmota . cmd ( \"DisplayDimmer 50\" ) hres = lv . get_hor_res () # should be 320 vres = lv . get_ver_res () # should be 240 scr = lv . scr_act () # default screean object f20 = lv . montserrat_font ( 20 ) # load embedded Montserrat 20 #- Background with a gradient from black #000000 (bottom) to dark blue #0000A0 (top) -# scr . set_style_bg_color ( lv . color ( 0x0000A0 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_color ( lv . color ( 0x000000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_dir ( lv . GRAD_DIR_VER , lv . PART_MAIN | lv . STATE_DEFAULT ) #- Upper state line -# stat_line = lv . label ( scr ) if f20 != nil stat_line . set_style_text_font ( f20 , lv . PART_MAIN | lv . STATE_DEFAULT ) end stat_line . set_long_mode ( lv . LABEL_LONG_SCROLL ) # auto scrolling if text does not fit stat_line . set_width ( hres ) stat_line . set_align ( lv . TEXT_ALIGN_LEFT ) # align text left stat_line . set_style_bg_color ( lv . color ( 0xD00000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) # background #000088 stat_line . set_style_bg_opa ( lv . OPA_COVER , lv . PART_MAIN | lv . STATE_DEFAULT ) # 100% background opacity stat_line . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) # text color #FFFFFF stat_line . set_text ( \"Tasmota\" ) stat_line . refr_size () # new in LVGL8 stat_line . refr_pos () # new in LVGL8 #- display wifi strength indicator icon (for professionals ;) -# wifi_icon = lv_wifi_arcs_icon ( stat_line ) # the widget takes care of positioning and driver stuff clock_icon = lv_clock_icon ( stat_line ) #- create a style for the buttons -# btn_style = lv . style () btn_style . set_radius ( 10 ) # radius of rounded corners btn_style . set_bg_opa ( lv . OPA_COVER ) # 100% backgrond opacity if f20 != nil btn_style . set_text_font ( f20 ) end # set font to Montserrat 20 btn_style . set_bg_color ( lv . color ( 0x1fa3ec )) # background color #1FA3EC (Tasmota Blue) btn_style . set_border_color ( lv . color ( 0x0000FF )) # border color #0000FF btn_style . set_text_color ( lv . color ( 0xFFFFFF )) # text color white #FFFFFF #- create buttons -# prev_btn = lv . btn ( scr ) # create button with main screen as parent prev_btn . set_pos ( 20 , vres - 40 ) # position of button prev_btn . set_size ( 80 , 30 ) # size of button prev_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) # style of button prev_label = lv . label ( prev_btn ) # create a label as sub-object prev_label . set_text ( \"<\" ) # set label text prev_label . center () next_btn = lv . btn ( scr ) # right button next_btn . set_pos ( 220 , vres - 40 ) next_btn . set_size ( 80 , 30 ) next_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) next_label = lv . label ( next_btn ) next_label . set_text ( \">\" ) next_label . center () home_btn = lv . btn ( scr ) # center button home_btn . set_pos ( 120 , vres - 40 ) home_btn . set_size ( 80 , 30 ) home_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) home_label = lv . label ( home_btn ) home_label . set_text ( lv . SYMBOL_OK ) # set text as Home icon home_label . center () #- callback function when a button is pressed, react to EVENT_CLICKED event -# def btn_clicked_cb ( obj , event ) var btn = \"Unknown\" if obj == prev_btn btn = \"Prev\" elif obj == next_btn btn = \"Next\" elif obj == home_btn btn = \"Home\" end print ( btn , \"button pressed\" ) end prev_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) next_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) home_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) Click Save and restart the device. You should now see this on the M5Stack screen: You will find more information on LVGL-Tasmota-Berry mapping .","title":"LVGL in less than 10 minutes with Tasmota"},{"location":"LVGL_in_10_minutes/#lvgl-in-less-than-10-minutes-with-tasmota","text":"In 2021, Tasmota added full support of LVGL for ESP32 based devices. It also introduced the Berry scripting language , a small-footprint language similar to Python and fully integrated in Tasmota. A comprehensive mapping of LVGL in Berry language is available, similar to the mapping of Micropython. The tutorial below illustrates how to install Tasmota on M5Stack devices (based on ESP32) and run your first LVGL application in Berry - all in less than 10 minutes. We will use nice M5Stack devices that integrate ESP32 and a 320x240 display, with touchscreen or physical buttons depending on the device.","title":"LVGL in less than 10 minutes with Tasmota"},{"location":"LVGL_in_10_minutes/#flash-tasmota-lvgl-on-the-device","text":"We have packaged an easy to use Web Flasher for ESP32. If this method fails or if you prefer local client method, have a look at Getting Started on Tasmota documentation. Connect your M5Stack device via a USB Cable. Connect to the Tasmota Web Installer Scroll down in Development section and select Tasmota32 LVGL Click Connect and select the appropriate Serial Port. It should connect in a couple of second. Click Install Development Tasmota32 Lvgl (English) Check Erase Device if it's the first time you install Tasmota, or you may experience unwanted behavior. Click Next Click Install It should take a little more to Erase and Flash You can now close the Web Flasher and proceed to the Wifi configuration","title":"Flash Tasmota-lvgl on the device"},{"location":"LVGL_in_10_minutes/#configure-tasmota-wifi","text":"The next step can be done with a phone or a computer. Connect to temporary the wifi access point with a name starting with tasmota-... You should be automatically brought to the Wifi configuration page. If not, try connecting to 192.168.4.1 Select your wifi network (yes, my wifi is named Tasmota ...), enter the password and hit Save . If all goes well, you should see the IP address of Tasmota and be redirected to it. You should now see the Tasmota main screen.","title":"Configure Tasmota Wifi"},{"location":"LVGL_in_10_minutes/#configure-tasmota-for-m5stack","text":"Tasmota is based on general purpose firmwares, you now need to configure specifically for your M5Stack device. We provide two templates, one for M5Stack Basic/Gray/GO/Fire and one for M5Stack Core2 . Go to Tasmota main screen and click on Configuration Then click on Auto-configuration . You are now on the Auto-configuration page. Select M5Stack Fire or M5Stack Core2 . Then click on Apply configuration . The device restarts and you should be back to Tasmota main page. The screen should have been configured (you should see a short flash on the screen).","title":"Configure Tasmota for M5Stack"},{"location":"LVGL_in_10_minutes/#try-a-lvgl-demo-app","text":"In this last step, we will try to run a small LVGL application written in Berry. Go to Tasmota Main Screen and click Consoles then Manage File System Click on Create and edit new file , enter the filename autoexec.be and copy the following code in the text pane: #- start LVGL and init environment -# lv . start () tasmota . cmd ( \"DisplayDimmer 50\" ) hres = lv . get_hor_res () # should be 320 vres = lv . get_ver_res () # should be 240 scr = lv . scr_act () # default screean object f20 = lv . montserrat_font ( 20 ) # load embedded Montserrat 20 #- Background with a gradient from black #000000 (bottom) to dark blue #0000A0 (top) -# scr . set_style_bg_color ( lv . color ( 0x0000A0 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_color ( lv . color ( 0x000000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) scr . set_style_bg_grad_dir ( lv . GRAD_DIR_VER , lv . PART_MAIN | lv . STATE_DEFAULT ) #- Upper state line -# stat_line = lv . label ( scr ) if f20 != nil stat_line . set_style_text_font ( f20 , lv . PART_MAIN | lv . STATE_DEFAULT ) end stat_line . set_long_mode ( lv . LABEL_LONG_SCROLL ) # auto scrolling if text does not fit stat_line . set_width ( hres ) stat_line . set_align ( lv . TEXT_ALIGN_LEFT ) # align text left stat_line . set_style_bg_color ( lv . color ( 0xD00000 ), lv . PART_MAIN | lv . STATE_DEFAULT ) # background #000088 stat_line . set_style_bg_opa ( lv . OPA_COVER , lv . PART_MAIN | lv . STATE_DEFAULT ) # 100% background opacity stat_line . set_style_text_color ( lv . color ( 0xFFFFFF ), lv . PART_MAIN | lv . STATE_DEFAULT ) # text color #FFFFFF stat_line . set_text ( \"Tasmota\" ) stat_line . refr_size () # new in LVGL8 stat_line . refr_pos () # new in LVGL8 #- display wifi strength indicator icon (for professionals ;) -# wifi_icon = lv_wifi_arcs_icon ( stat_line ) # the widget takes care of positioning and driver stuff clock_icon = lv_clock_icon ( stat_line ) #- create a style for the buttons -# btn_style = lv . style () btn_style . set_radius ( 10 ) # radius of rounded corners btn_style . set_bg_opa ( lv . OPA_COVER ) # 100% backgrond opacity if f20 != nil btn_style . set_text_font ( f20 ) end # set font to Montserrat 20 btn_style . set_bg_color ( lv . color ( 0x1fa3ec )) # background color #1FA3EC (Tasmota Blue) btn_style . set_border_color ( lv . color ( 0x0000FF )) # border color #0000FF btn_style . set_text_color ( lv . color ( 0xFFFFFF )) # text color white #FFFFFF #- create buttons -# prev_btn = lv . btn ( scr ) # create button with main screen as parent prev_btn . set_pos ( 20 , vres - 40 ) # position of button prev_btn . set_size ( 80 , 30 ) # size of button prev_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) # style of button prev_label = lv . label ( prev_btn ) # create a label as sub-object prev_label . set_text ( \"<\" ) # set label text prev_label . center () next_btn = lv . btn ( scr ) # right button next_btn . set_pos ( 220 , vres - 40 ) next_btn . set_size ( 80 , 30 ) next_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) next_label = lv . label ( next_btn ) next_label . set_text ( \">\" ) next_label . center () home_btn = lv . btn ( scr ) # center button home_btn . set_pos ( 120 , vres - 40 ) home_btn . set_size ( 80 , 30 ) home_btn . add_style ( btn_style , lv . PART_MAIN | lv . STATE_DEFAULT ) home_label = lv . label ( home_btn ) home_label . set_text ( lv . SYMBOL_OK ) # set text as Home icon home_label . center () #- callback function when a button is pressed, react to EVENT_CLICKED event -# def btn_clicked_cb ( obj , event ) var btn = \"Unknown\" if obj == prev_btn btn = \"Prev\" elif obj == next_btn btn = \"Next\" elif obj == home_btn btn = \"Home\" end print ( btn , \"button pressed\" ) end prev_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) next_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) home_btn . add_event_cb ( btn_clicked_cb , lv . EVENT_CLICKED , 0 ) Click Save and restart the device. You should now see this on the M5Stack screen: You will find more information on LVGL-Tasmota-Berry mapping .","title":"Try a LVGL demo app"},{"location":"LedMask/","text":"LedMask command allows setting a bitmask which specifies which relays control the LED indicator used to display whether a relay is latched/powered. The order of the <bitmask> is from most significant bit (MSB) to least significant bit (LSB). Bit 15 (MSB) masks Relay16 through bit 0 (LSB) which masks Relay1, respectively. For each relay to be included in controlling the power LED, set its corresponding bit in the <bitmask> to 1 . <bitmask> bits without corresponding configured relay components have no effect and can be ignored. <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. Examples: `LedMask 0xFFFD` Every relay, except Relay2, controls the power LED (0xFFFD = 1111 1111 1111 1101) `LedMask 0x0002` Only Relay 2 controls the power LED (0x0002 = 0000 0000 0000 0010)","title":"LedMask"},{"location":"Lights/","text":"You know what lights do.... Right? \ud83d\udca1 Control Lights ~ with WebUI ~ Tasmota webUI displays Brightness , CT , White , Color Picker , Color Saturation or PWM Level sliders depending on the light component, the number of PWM channels configured and SetOptions used. Tasmota uses a HSB color model, which besides other more subtile differences compared to HSL means, that the color must be desaturated to reach complete black or white. Control Range Commands and details Brightness 0..100 (percent) Dimmer , HSBColor3 : Brightness of the light Hue 0..359 (degrees) HSBColor1 : Color as an angle in the color wheel Sat 0..100 (percent) HSBColor2 : saturation of the color, 0=grey/white, 100=pure color CT 153..500 (mireds) CT : white color temperature, from 153 (Cold White) to 500(Warm White) with Commands ~ See light commands for how to control lights. Light Types ~ Switched Lights aka Relays ~ Switched or On/Off lights are controlled through Relay GPIOs. If you define multiple relays, they are controlled with Power<x> starting at x=1 . Alexa : you can use Wemo emulation, your device will appear as a switch. You can change it to a light in the Alexa app. Alexa : if you have one or multiple relays, you can use Philips Hue emulation. All devices will appear as On/Off lights, and named accordingly to FriendlyName . Note: if you have only Echo Spot 2nd generation, your light will have a dummy dimmer. Configuration (see below) Commands Power Configuration none 1 Channel - Dimmable Light ~ 1 channel lights are often white lights with On/Off controls and Dimmer. Alexa : you can use Philips Hue emulation, the light will appear as White light with Dimmer. Leading edge dimmer You can also configure a leading edge dimmer on 230V with the 1 Channel configuration. In this case you need a TRIAC and a zero-Cross detection that give a pulse with every crossing of the 0V of the sinus curve. This is currently ONLY supported on ESP8266. A working ESP32 is \"work in progress\". Robotdyn AC Dimmer example: Define a COUNTER with the same number as the PWM (e.g. COUNTER1 & PWM1). You will need to connect the output of PWM1 to an input as COUNTER1. Connect zero-Crossing to GPIO of COUNTER4 Configuration (see below) Dimmer1 PWM1, COUNTER1 Dimmer2 PWM2, COUNTER2 (optional) Dimmer3 PWM3, COUNTER3 (optional) Zero-Cross PIN COUNTER4 (mandatory example schematic: example Config: Preferably before connecting the ZC & PWM perform the following commands: SETOPTION99 1 -> to enable detection of the raising edge of the zero-crossing. PWMFREQUENCY 100 -> (50hz) or 120 (60hz) depending on the frequency of the main in your country. LEDTABLE 0 -> for normal lamps or motors. Configuration (see below) Commands Power , Dimmer , Channel , Fade , Speed Options Auto Power On , PWM Channel Configuration , Gamma Correction 2 Channels - CCT Light ~ 2 channels lights are white lights with correlated color temperature (CCT) controls from Cold White (CT=153) to Warm White (CT=500). Alexa : you can use Philips Hue emulation, the light will appear as White light with Color Temperature. Control through the Alexa app is limited to the CT range 199..383 . Configuration (see below) Commands Power , Dimmer , Color , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , PWM CT 3 Channels - RGB Lights ~ 3 channel lights are RGB color lights. You can set color either via RGB or HSB ( not HSL ). Alexa support also allows XY color, but that is not supported through commands. Alexa : you can use Philips Hue emulation, the light will appear as Color light. Configuration (see below) Commands Power , Dimmer , Color , HSBColor Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping 4 Channels - RGBW Lights ~ 4 channel lights are RGBW, i.e. RGB light and an additional White light. White can be either Warm White or Cold White depending on the manufacturer. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. The CT control is only present to force pure white instead of RGB white. Changin CT will have no effect. There is no White only slider in the UI for 4 channel lights Use White commands or set up White Blend Mode or RGB and White Split . Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split Danger Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels to be on using Color or RGB and White Split . 5 Channels - RGBCCT Lights ~ 5 channel lights are RGBCCT - a 3 channel RGB light and an additional 2 channel CCT light. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split Danger Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels via Color or RGB and White Split Independent PWM Channels ~ Any combination of Relays and PWMs, when enabling SetOption68 1 . Splits off the light into individually controlled Channels (Useful when connecting multiple 1 channel strips to a single controller) Configuration (see below) Commands Power , Channel , Color Options Auto Power On , PWM Channel Configuration , Gamma Correction Light Options ~ Gamma Correction ~ Gamma Correction is enabled by default in Tasmota ( LedTable 1 ). Human eye perception of brightness is non linear, bringing back linearity needs a trick called Gamma Correction . Some lights have hardware gamma correction (f.e. Sonoff B1)., in which case software gamma correction should be disabled with LedTable 0 . The curve used: orange=ideal, blue=tasmota. How do I know if I have hardware gamma correction? If you find your light very dark even with Dimmer 40 , it can mean either you have hardware PWM, disable it with LedTable 0 , or you need to apply a minimum PWM value, use DimmerRange 40,100 (adapt to the best value). Internally Tasmota uses 10 bits resolution PWM to get smoother levels at low brightness. White Blend Mode ~ White Blend Mode mixes in the white channel with RGB colors while controlling the RGB light which results in a better and brighter color output. It is used only with 4 channel (RGBW) and 5 channel (RGBCCT) lights. Enable it with SetOption105 1 . For Tasmota versions before 8.5 use command RGBWWTable 255,255,255,0 instead. Calibration (optional) ~ Generally white LEDs are brighter than RGB LEDs. If you want to keep the same brightness, you need to calibrate the white level. In this mode, any white component will be removed from RGB LEDs and sent to the white LEDs. This makes whites look much better. Example Color 30508000 will be converted to Color 0020503000 (0x30 is subtracted from RGB channels and added to the White channel) To calibrate a RGBW light: Color FFFFFF00 RGBWWTable 255,255,255,255,255 - reset to RGB mode RGBWWTable 255,255,255,<n>,0 - (begin the calibration process with <n> == 150) If too bright, decrease <n> . If too dim, increase <n> Go back to step 2 and iterate until satisfied with the color intensities. Calibration examples for specific devices: Sonoff B1: RGBWWTable 255,255,255,35,0 Teckin SB50: RGBWWTable 255,255,255,80,0 RGB and White Split ~ SetOption37 128 By default RGBW and RGBCCT lights can only be controlled in single mode, either RGB or White (f.e. Turning on CT lights turns off RGB lights and vice versa). Use SetOption37 128 to split RGB and White into 2 independent lights. If you are already using Channel Remapping, just add 128 to the value of SetOption37 . Channel Remapping ~ SetOption37 Read More Disable Auto Power On ~ Lights are always powered on when a light command or a webUI slider is used and automatically powered off when color is set to black or Dimmer is set to 0 . When enabling SetOption20 1 any change to webUI sliders or using commands CT , Dimmer , HSBColor3 , Color or Channel will not automatically power on the light if it is off. PWM CT ~ Module 48 or SetOption92 1 Some CCT lights use PWM1 for brightness and PWM2 for color temperature (instead of PWM1 for Cold White and PWM2 for Warm White). For these lights, use Module 48 aka Philips Xiaomi mode, or SetOption92 1 (supported since v.8.2.0.5) Virtual CT ~ this feature is experimental and will probably not give brilliant results Used with 4 channel RGBW lights to simulate the missing white channel (cold or warm) using RGB channels. Enable Virtual CT with SetOption106 1 then choose which type of white you're simulating with SetOption107 where 0 is warm white and 1 is cold white Light Categories ~ Lights come in various shapes (bulb, strips, ceiling lights, ...) but in Tasmota they are separated in 3 categories: Channel Controlled LEDs Addressable LEDs Status LEDs Channel Controlled Lights ~ PWM Lights ~ Lights controlled using up to 5 channels (red, green, blue, cold white, warm white). Channels are controlled using PWM or APDM. PWM (Pulse Width Modulation) is the most common method of controlling LED lights. These lights are configured by assigning PWM1(i) through PWM5(i) components to their GPIOs; PWM<x>i means PWM is inverted. Depending on the number of used PWMs Tasmota will recognize the light as Channels PWM1 PWM2 PWM3 PWM4 PWM5 1 Brightness 2 Cold White Warm White 3 Red Green Blue 4 Red Green Blue White 5 Red Green Blue Cold White Warm White MY92xx ~ MY92xx family of drivers uses Adaptive Pulse Density Modulation. Configured in Tasmota by assigning MY92x1 DI and MY92x DCKI components to their GPIOs (some devices might have more than one MY92xx controller) Channel mapping for such devices is dependent on the controllers but is easily remapped using SetOption37 . SM16716 ~ SM16716 LEDs, sometimes mislabelled as WS2801. Configured in Tasmota by assigning SM16716 CLK , SM16716 DAT and SM16716 PWR component to their GPIOs. Some SM16716 bulbs have BGR order and need SetOption37 54 to work properly. PWM Dimmer Switches ~ Specific module (requires a custom binary) for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches. Brightness of the load for these dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a power status LED, five brightness LEDs and another status LED. Read more... Addressable LEDs ~ Lights where each LED is individually controlled. In these lights it is possible to adjust each LEDs power, color and brightness, all just with the use of a single GPIO pin. WebUI shows hue, saturation and brightness sliders and power toggle for these lights. Red and green color may be mixed up (observed for clone of Wemos RGB shield ). WS2812 ~ These are also commonly called Neopixel lights. Configured in Tasmota by assigning WS2812 (7) component to its GPIO. For wiring, see instructions for LED strip or Wemos RGB shield . SK6812 ~ SK6812 RGBW LEDs are not supported in standard binaries and need custom compiled firmware. See instructions . Status LEDs ~ Status LEDs are the LEDs on the device used to display device information Those LEDs are defined in a template or module using Led1 , Led2 , Led3 or Led4 (or Led1i , Led2i , Led3i or Led4i ) and additionally using LedLink or LedLinki ( LedLink was introduced in version 6.5.0.12). It is not recommended to assign Led<x> and Led<x>i with the same <x> number. Prior to version 6.5.0.12, Tasmota only supported up to two LED components to indicate the power state of the relay(s), and the Wi-Fi/MQTT connectivity status. It is possible to wire in your own LED and assign it as any of the above mentioned but that's outside the scope of this article If only one LED is configured, it serves both purposes; the link status LED and/or the LED that indicates the power state of the relay(s). If more than one LED component is defined, Led1 / Led1i will act as the Wi-Fi/MQTT status LED and the next defined LED (e.g., Led2 / Led2i ) will act as the LED that indicates the power state of the relay(s). This is the default behavior . Configuring a GPIO as an LEDLink / LEDLinki component changes this behavior. For example, on a Sonoff Basic the green LED is used as the link status LED. Once the device connects, the LED is used to indicate the relay's power status. Link status LED ~ Link status LED shows the network state, more specifically the Wi-Fi and MQTT connection status. It blinks if the device is not connected to your Wi-Fi AP and MQTT broker (if MQTT is enabled). You can change this behaviour with LedState or turn it off with SetOption31 . Power status LED ~ Power status LED shows the power status of relay component(s). LedMask determines which relay(s) are associated with the power status LED. This behavior can be modified with the LedState command. The LED is turned off by default when the relay is OFF and turned on when the relay switches ON. Note Depending on the device design, some LEDs are connected to the same GPIO as the relay. Those cannot be independently controlled since they have to follow the relay state. If you have more than one LED wired independently and you want it to show the power state of the relay, you must assign an LedLink GPIO. PWM LED Mode ~ Using LedPwmMode you can change the LED display mode from simple on/off to a PWM controlled LED which will enable you to f.e. display a brighter LED when the relay is on and a dimmer LED when its OFF so you can locate the switch in the dark but not have it obnoxiously bright. LedPwmOff and LedPwmOn control the preset LED brightness in their respective states. LedPower Command ~ When you use LedPower you take over control of that particular LED and it stops being linked to its corresponding relay and being its power status LED. Using LedLink ~ LedLink / LedLinki is used to assign the link status LED. If your device does not have an LED for link status (or you want to use that LED for a different purpose), you can assign LedLink to an available free GPIO. When LedLink(i) is assigned, other LEDs are automatically linked to their corresponding relay and serve as that relay's power status LED - i.e., Led<x>(i) links to Relay<x>(i)","title":"Lights"},{"location":"Lights/#control-lights","text":"","title":"Control Lights"},{"location":"Lights/#with-webui","text":"Tasmota webUI displays Brightness , CT , White , Color Picker , Color Saturation or PWM Level sliders depending on the light component, the number of PWM channels configured and SetOptions used. Tasmota uses a HSB color model, which besides other more subtile differences compared to HSL means, that the color must be desaturated to reach complete black or white. Control Range Commands and details Brightness 0..100 (percent) Dimmer , HSBColor3 : Brightness of the light Hue 0..359 (degrees) HSBColor1 : Color as an angle in the color wheel Sat 0..100 (percent) HSBColor2 : saturation of the color, 0=grey/white, 100=pure color CT 153..500 (mireds) CT : white color temperature, from 153 (Cold White) to 500(Warm White)","title":"with WebUI"},{"location":"Lights/#with-commands","text":"See light commands for how to control lights.","title":"with Commands"},{"location":"Lights/#light-types","text":"","title":"Light Types"},{"location":"Lights/#switched-lights-aka-relays","text":"Switched or On/Off lights are controlled through Relay GPIOs. If you define multiple relays, they are controlled with Power<x> starting at x=1 . Alexa : you can use Wemo emulation, your device will appear as a switch. You can change it to a light in the Alexa app. Alexa : if you have one or multiple relays, you can use Philips Hue emulation. All devices will appear as On/Off lights, and named accordingly to FriendlyName . Note: if you have only Echo Spot 2nd generation, your light will have a dummy dimmer. Configuration (see below) Commands Power Configuration none","title":"Switched Lights aka Relays"},{"location":"Lights/#1-channel-dimmable-light","text":"1 channel lights are often white lights with On/Off controls and Dimmer. Alexa : you can use Philips Hue emulation, the light will appear as White light with Dimmer. Leading edge dimmer You can also configure a leading edge dimmer on 230V with the 1 Channel configuration. In this case you need a TRIAC and a zero-Cross detection that give a pulse with every crossing of the 0V of the sinus curve. This is currently ONLY supported on ESP8266. A working ESP32 is \"work in progress\". Robotdyn AC Dimmer example: Define a COUNTER with the same number as the PWM (e.g. COUNTER1 & PWM1). You will need to connect the output of PWM1 to an input as COUNTER1. Connect zero-Crossing to GPIO of COUNTER4 Configuration (see below) Dimmer1 PWM1, COUNTER1 Dimmer2 PWM2, COUNTER2 (optional) Dimmer3 PWM3, COUNTER3 (optional) Zero-Cross PIN COUNTER4 (mandatory example schematic: example Config: Preferably before connecting the ZC & PWM perform the following commands: SETOPTION99 1 -> to enable detection of the raising edge of the zero-crossing. PWMFREQUENCY 100 -> (50hz) or 120 (60hz) depending on the frequency of the main in your country. LEDTABLE 0 -> for normal lamps or motors. Configuration (see below) Commands Power , Dimmer , Channel , Fade , Speed Options Auto Power On , PWM Channel Configuration , Gamma Correction","title":"1 Channel - Dimmable Light"},{"location":"Lights/#2-channels-cct-light","text":"2 channels lights are white lights with correlated color temperature (CCT) controls from Cold White (CT=153) to Warm White (CT=500). Alexa : you can use Philips Hue emulation, the light will appear as White light with Color Temperature. Control through the Alexa app is limited to the CT range 199..383 . Configuration (see below) Commands Power , Dimmer , Color , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , PWM CT","title":"2 Channels - CCT Light"},{"location":"Lights/#3-channels-rgb-lights","text":"3 channel lights are RGB color lights. You can set color either via RGB or HSB ( not HSL ). Alexa support also allows XY color, but that is not supported through commands. Alexa : you can use Philips Hue emulation, the light will appear as Color light. Configuration (see below) Commands Power , Dimmer , Color , HSBColor Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping","title":"3 Channels - RGB Lights"},{"location":"Lights/#4-channels-rgbw-lights","text":"4 channel lights are RGBW, i.e. RGB light and an additional White light. White can be either Warm White or Cold White depending on the manufacturer. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. The CT control is only present to force pure white instead of RGB white. Changin CT will have no effect. There is no White only slider in the UI for 4 channel lights Use White commands or set up White Blend Mode or RGB and White Split . Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split Danger Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels to be on using Color or RGB and White Split .","title":"4 Channels - RGBW Lights"},{"location":"Lights/#5-channels-rgbcct-lights","text":"5 channel lights are RGBCCT - a 3 channel RGB light and an additional 2 channel CCT light. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split Danger Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels via Color or RGB and White Split","title":"5 Channels - RGBCCT Lights"},{"location":"Lights/#independent-pwm-channels","text":"Any combination of Relays and PWMs, when enabling SetOption68 1 . Splits off the light into individually controlled Channels (Useful when connecting multiple 1 channel strips to a single controller) Configuration (see below) Commands Power , Channel , Color Options Auto Power On , PWM Channel Configuration , Gamma Correction","title":"Independent PWM Channels"},{"location":"Lights/#light-options","text":"","title":"Light Options"},{"location":"Lights/#gamma-correction","text":"Gamma Correction is enabled by default in Tasmota ( LedTable 1 ). Human eye perception of brightness is non linear, bringing back linearity needs a trick called Gamma Correction . Some lights have hardware gamma correction (f.e. Sonoff B1)., in which case software gamma correction should be disabled with LedTable 0 . The curve used: orange=ideal, blue=tasmota. How do I know if I have hardware gamma correction? If you find your light very dark even with Dimmer 40 , it can mean either you have hardware PWM, disable it with LedTable 0 , or you need to apply a minimum PWM value, use DimmerRange 40,100 (adapt to the best value). Internally Tasmota uses 10 bits resolution PWM to get smoother levels at low brightness.","title":"Gamma Correction"},{"location":"Lights/#white-blend-mode","text":"White Blend Mode mixes in the white channel with RGB colors while controlling the RGB light which results in a better and brighter color output. It is used only with 4 channel (RGBW) and 5 channel (RGBCCT) lights. Enable it with SetOption105 1 . For Tasmota versions before 8.5 use command RGBWWTable 255,255,255,0 instead.","title":"White Blend Mode"},{"location":"Lights/#rgb-and-white-split","text":"SetOption37 128 By default RGBW and RGBCCT lights can only be controlled in single mode, either RGB or White (f.e. Turning on CT lights turns off RGB lights and vice versa). Use SetOption37 128 to split RGB and White into 2 independent lights. If you are already using Channel Remapping, just add 128 to the value of SetOption37 .","title":"RGB and White Split"},{"location":"Lights/#channel-remapping","text":"SetOption37 Read More","title":"Channel Remapping"},{"location":"Lights/#disable-auto-power-on","text":"Lights are always powered on when a light command or a webUI slider is used and automatically powered off when color is set to black or Dimmer is set to 0 . When enabling SetOption20 1 any change to webUI sliders or using commands CT , Dimmer , HSBColor3 , Color or Channel will not automatically power on the light if it is off.","title":"Disable Auto Power On"},{"location":"Lights/#pwm-ct","text":"Module 48 or SetOption92 1 Some CCT lights use PWM1 for brightness and PWM2 for color temperature (instead of PWM1 for Cold White and PWM2 for Warm White). For these lights, use Module 48 aka Philips Xiaomi mode, or SetOption92 1 (supported since v.8.2.0.5)","title":"PWM CT"},{"location":"Lights/#virtual-ct","text":"this feature is experimental and will probably not give brilliant results Used with 4 channel RGBW lights to simulate the missing white channel (cold or warm) using RGB channels. Enable Virtual CT with SetOption106 1 then choose which type of white you're simulating with SetOption107 where 0 is warm white and 1 is cold white","title":"Virtual CT"},{"location":"Lights/#light-categories","text":"Lights come in various shapes (bulb, strips, ceiling lights, ...) but in Tasmota they are separated in 3 categories: Channel Controlled LEDs Addressable LEDs Status LEDs","title":"Light Categories"},{"location":"Lights/#channel-controlled-lights","text":"","title":"Channel Controlled Lights"},{"location":"Lights/#pwm-dimmer-switches","text":"Specific module (requires a custom binary) for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches. Brightness of the load for these dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a power status LED, five brightness LEDs and another status LED. Read more...","title":"PWM Dimmer Switches"},{"location":"Lights/#addressable-leds","text":"Lights where each LED is individually controlled. In these lights it is possible to adjust each LEDs power, color and brightness, all just with the use of a single GPIO pin. WebUI shows hue, saturation and brightness sliders and power toggle for these lights. Red and green color may be mixed up (observed for clone of Wemos RGB shield ).","title":"Addressable LEDs"},{"location":"Lights/#status-leds","text":"Status LEDs are the LEDs on the device used to display device information Those LEDs are defined in a template or module using Led1 , Led2 , Led3 or Led4 (or Led1i , Led2i , Led3i or Led4i ) and additionally using LedLink or LedLinki ( LedLink was introduced in version 6.5.0.12). It is not recommended to assign Led<x> and Led<x>i with the same <x> number. Prior to version 6.5.0.12, Tasmota only supported up to two LED components to indicate the power state of the relay(s), and the Wi-Fi/MQTT connectivity status. It is possible to wire in your own LED and assign it as any of the above mentioned but that's outside the scope of this article If only one LED is configured, it serves both purposes; the link status LED and/or the LED that indicates the power state of the relay(s). If more than one LED component is defined, Led1 / Led1i will act as the Wi-Fi/MQTT status LED and the next defined LED (e.g., Led2 / Led2i ) will act as the LED that indicates the power state of the relay(s). This is the default behavior . Configuring a GPIO as an LEDLink / LEDLinki component changes this behavior. For example, on a Sonoff Basic the green LED is used as the link status LED. Once the device connects, the LED is used to indicate the relay's power status.","title":"Status LEDs"},{"location":"MCP230xx/","text":"MCP23008 / MCP23017 GPIO Expander ~ Technical Data from the manufacturer: * Microchip MCP23008 * Microchip MCP23017 Generally available breakout boards for the MCP23017 look similar to this: The MCP23008 has 8 IO pins which the MCP230xx driver uses as D0 - D7. The MCP23017 has 16 IO pins which the MCP230xx driver uses as D0 - D15. This is visualized in the circuit diagram below but it's important to note that the MCP23017 actually differentiates between PORTA (being A0 to A7) and PORTB (being B0 to B7) - The MCP230xx driver combines the two ports in sequence to translate to pins represented as D0 through D15 for the MCP23017. The chip can be connected quite easily, especially if you can source the DIP version of the chip. Here's a basic outline of what a typical circuit would require to be functional: You will need to pick an I2C address in either of the above scenario's using the address mapping according to pin A0, A1, and A2 as from the datasheet as follows: You will need to define the address you are using in user_config_override.h for the driver to know on which address the MCP23008/MCP23017 is expected to be found. #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 chips allow for both INPUT and OUTPUT - Most of the functionality of the driver is focused on INPUT mode - especially since they allow interrupt reporting and are 5V tolerant. OUTPUT functionality is however available as pinmode 5 (Documented later in this Wiki) as an additional option for those who want to use the OUTPUT functionality using the Sensor29 command which consumes ~1Kbyte of flash. The driver is disabled by default in the Tasmota firmware so the only way to gain its use would be to perform a manual compilation of your own firmware. There are three different levels in which functionality may be enabled, in the following order, by adding these lines in user_config_override.h : #define USE_MCP230xx // Enable INPUT mode (pinmode 1 through 4) #define USE_MCP230xx_OUTPUT // Enable OUTPUT mode (pinmode 5) #define USE_MCP230xx_DISPLAYOUTPUT // Display state of OUTPUT pins on main Tasmota web interface The ESP8266 will automatically detect whether you have connected an MCP23008 (8 input) or MCP23017 (16 input) and will provide telemetry data in accordance with how the device was configured from within the Tasmota firmware. If OUTPUT is enabled, telemetry data for the current state of OUTPUT pins will also be provided by telemetry. MCP23008 / MCP23017 Pin numbers in Tasmota compared to datasheets ~ The table below outlines how the pins of the MCP23008/MCP23017 are assigned: Usage of the driver ~ The MCP230xx chip (or breakout board) must be connected to the ESP8266 and the I2C pins must be configured for the module similar to the following: One that is complete you may want to confirm that the Tasmota firmware is finding your MCP23008/MCP23017 chip by sending the command through serial or MQTT: I2Cscan You should see a response giving you an address within the range of the MCP23008/MCP23017 chip (0x20 through 0x27) which may look as follows MQT: stat/tasmota/RESULT = {\"I2CScan\":\"Device(s) found at 0x20\"} If the extender is not detected, check your wiring and pin configuration. The configuration of MCP23008/MCP23017 by using Sensor29 commands via the Console or MQTT messages. In order to use the MCP23008/MCP23017, add the following two lines in your user_config_override.h as the MCP chip support is not enabled by default. #define USE_MCP230xx #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 supports I 2 C address range of 0x20 through 0x27. Take care that you are not using an address which is already used by another device (e.g., 0x27 is a known address for some I 2 C Liquid Crystal Displays). Device Configuration ~ The behavior of all pins on the MCP23008/MCP23017 can be reset to a specific setting/mode globally to simplify the initial configuration as follows Command Parameters Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup\\|outstate{,repmode}} pin = the I/O pin on the MCP230xx chip 0..7 for MCP23008 0..15 for the MCP23017) pinmode = operational mode of the pin ( ?, 0..5 ) ? = query pin configuration 0 = Disabled (deprecated, but will be default for previously unconfigured devices) 1 = INPUT (Floating - only telemetry data will be sent according to configuration TelePeriod intervals) 2 = INPUT with INTERRUPT on CHANGE (will send an MQTT output on state change from LOW to HIGH and HIGH to LOW) 3 = INPUT with INTERRUPT on CHANGE to LOW (will send an MQTT output on state change only from HIGH to LOW) 4 = INPUT with INTERRUPT on CHANGE to HIGH (will send an MQTT output on state change only from LOW to HIGH) 5 = OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) intpullup (pinmode 1..4 ) . Pull-up resistors are disabled by default for pin mode 1 whilst enabled by default for pin modes 2..4 (because they are interrupt enabled pins and we do not want signal bounce). The internal pull-up on these pins may be disabled if necessary if you are biasing them externally. 0 = weak internal pull-up disabled (default for pinmode 1 ) 1 = weak internal pull-up enabled (default for pinmode 2..4 ) outstate (pinmode 5..6 ) = set the default state of an OUTPUT pin on reset/power-up. If your device is configured to save state ( SetOption0 = 1 ), the outstate setting will be ignored and the last known state of the pin will be applied during power-up/reset. 0/off = set output pin to OFF 1/on = set output pin state to ON 2/device = keep the value stored on the MCP230xx device repmode = reporting mode (optional). Applicable only for pinmode 2..4 . Reporting mode is disabled for pinmode 1 and for output pinmodes ( 5..6 ) 0 = interrupt using Event and report using telemetry (default) 1 = interrupt using Event only (no telemetry reported) 2 = report using telemetry only (no Event triggered) Examples: Sensor29 Reset1 MQT: stat/tasmota/RESULT = {\"Sensor29_D99\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"\"}} Pin and State is reported as 99 because it is set across all pins. Mode should correspond with the reset pinmode option used. Sensor29 0,? MQT: stat/tasmota/RESULT = {\"Sensor29_D0\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"ON\"}} Confirming that the pin is in pinmode 1 and that the pull-up resistor is not enabled. INT_MODE indicates the interrupt mode for pins which are interrupt enabled (pinmode 2 through 4) - In the example above it is disabled for pin mode 1 (INPUT without INTERRUPT) The current STATE of the pin as ON or OFF is reported as at the time the command is issued is also reported. IMPORTANT NOTICE ON USE OF INTERRUPTS ~ Only use interrupts on pins which are either explicitly pulled down GND or up to VCC externally as floating pins may cause unintended MQTT responses for pins which are floating. So unless your connected wire/device explicitly pulls the pin to GND or VCC only when conditions of an interrupt would be met it is recommended that you either do not set a pin for an interrupt mode or at least enable pull-up resistors for the unused pins with pullup = 1 when you perform your sensor29 pin,pinmode,pullup command. Examples of some pin configuration options: sensor29 4,1,0 - Will enable D4 for INPUT without internal pull-up resistor sensor29 3,1,1 - Will enable D3 for INPUT with the internal pull-up resistor ENABLED sensor29 5,2,1 - Will enable D5 for INPUT and report on change state from LOW to HIGH and HIGH to LOW via MQTT sensor29 6,3,1 - Will enable D6 for INPUT and report on change state from HIGH to LOW (note pull-up is also enabled) sensor29 2,4,0 - Will enable D2 for INPUT and report on change state from LOW to HIGH (note pull-up is not enabled) Pull-up resistor support is valid for all modes from 1 through 4 Default telemetry logging will occur for all pins as per the configured logging interval of the ESP8266 as configured in the Tasmota firmware options. The telemetry logging will push out to log and MQTT a JSON as follows: tele/tasmota/SENSOR = {\"Time\":\"2018-08-18T16:13:47\",\"MCP230XX\": \"D0\":0,\"D1\":0,\"D2\":1,\"D3\":0,\"D4\":0,\"D5\":0,\"D6\":0,\"D7\":1}} Again, this will depend on whether an MCP23008 or MCP23017 is used insofar that the number of pins/bits reported will be 8 (0 to 7) or 16 (0 to 15) respectively. INTERRUPT MODES AND USAGE ~ Interrupts will report for individual pins as and when the conditions which were configured are met and will look something like this: Interrupt message on HIGH for input pin 0 MQT: stat/tasmota/RESULT = {\"Time\":\"2018-08-19T16:04:50\",\"MCP230XX_INT\":{\"D0\":1,\"MS\":301}} Interrupt message on LOW for input pin 1 MQT: stat/tasmota/RESULT = {\"Time\":\"2018-08-19T16:04:50\",\"MCP230XX_INT\":{\"D1\":0,\"MS\":519}} The state of the pin captured during the interrupt is reported as Dx=y where x is the pin number and y is the state of the pin. In addition the number of milliseconds since the last interrupt occurred for the particular pin is also reported as MS=xx where xx is the number of milliseconds recorded. In addition to the MQTT message the driver will also execute an event command in the following format: event MCPINT_Dxx=y Where xx = the pin number from 0 through 7 (MCP23008) or 0 through 15 (MCP23017) and y the state of the pin as it was captured by the interrupt register of the MCP23008/MCP23017 chip. The complete output for an interrupt enabled pin would look like this: MQT: stat/tasmota/RESULT = {\"Time\":\"2018-08-19T16:08:28\",\"MCP230XX_INT\":{\"D0\":0,\"MS\":217353}} SRC: Rule RSL: Group 0, Index 1, Command EVENT, Data MCPINT_D0=0 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} MQT: stat/tasmota/RESULT = {\"Time\":\"2018-08-19T16:08:46\",\"MCP230XX_INT\":{\"D0\":1,\"MS\":18101}} SRC: Rule RSL: Group 0, Index 1, Command EVENT, Data MCPINT_D0=1 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} The latter makes it possible to integrate interrupt responses with rules for example: rule on event#MCPINT_D0=1 do power on endon on event#MCPINT_D0=0 do power off endon In the example above the rule would respond to an interrupt of HIGH on pin 0 of the MCP by executing command \"power on\" and respond to an interrupt of LOW on pin 0 with the command \"power off\" See the Wiki on Using Rules for more information on how this can be helpful to your requirements. If you require only one of the two reporting methods you may use the sensor29 command to configure the interrupt behavior according to your requirements using command: sensor29 pin,pinmode,pullup,intmode The intmode parameter is optional for pin modes 2 through 4 (those that support interrupts) and may be configured according to the table below depending on your requirements: Keep in mind that the MCP23008/MCP23017 chip will only store the last interrupt registered in the interrupt register and capture register - Because the interrupt register is only checked every 50 milliseconds by the Tasmota firmware you may experience missed interrupts if your incoming signals fluctuate/change faster than 20 times per second. HOME ASSISTANT TIPS ~ You can use SetOption59 1 in order to get extra SENSOR status telemetry messages in addition to event-triggered RESULT messages. This allows very good integration with Home Assistant because it needs to monitor only one payload for both periodic and instant messages using binary_sensor : - platform: mqtt name: \"MCP23017 Teszt D0 SENSOR\" state_topic: \"tele/tasmota/SENSOR\" value_template: \"{{ value_json['MCP230XX'].D0 }}\" payload_on: \"1\" payload_off: \"0\" availability_topic: \"tele/tasmota/LWT\" payload_available: \"Online\" payload_not_available: \"Offline\" qos: 0 device_class: door ADVANCED FUNCTIONS ~ Several advanced functions have been added to extend the flexibility and interoperability of the MCP23008/MCP23017 with specific focus on adding functionality which is not present on the hardware's built-in GPIO pins and offloading some of the functionality that would normally be performed by rules or counters on the Tasmota device into the driver of the MCP23008/MCP23017. These include the following * INTPRI - Interrupt Priority, being able to control the rate at which the MCP23008/MCP23017 is polled to see if any interrupts has occurred since the previous poll. * INTDEF - Interrupt Deffer, being able to control the number of interrupts that are ignored on a specific pin before reporting would occur via telemetry and/or EVENT. * INTTIMER - Interrupt Timer which allows for time based counter reporting, specifically reporting the number of times an interrupt has occurred on interrupt enabled pins. * INTCNT - Works with INTTIMER to enable/disable counting for a specific pin. * INTRETAIN - Keep track of whether an interrupt occurred or not and defer reporting to next telemetry message. The above additions are described in further detail below. ADVANCED FUNCTION #1 - INTERRUPT PRIORITY (INTPRI) ~ The maximum interrupt polling rate is once per approximately 50 milliseconds - This is what the Tasmota firmware allows as a maximum and how it is configured in the MCP23008/MCP23017 driver by default. If you want to reduce the number of interrupt polls per second you may use the INTPRI command parameter as follows: sensor29 intpri Will give you the current setting via JSON response as follows: MQT: stat/tasmota/RESULT = {\"MCP230xx_INTPRI\":{\"D_99\":0}} To change the value you may use command as follows: sensor29 intpri,x Where x is the number of 50ms cycles (between 0 and 20) which will be skipped before the MCP23008/MCP23017 chip is polled for interrupt. The last interrupt recorded by the MCP23008/MCP23017 will be reported via the configured method. For example, lets assume you only want the interrupt polling to occur every 500ms (i.e. twice per second) you could do command: sensor29 intpri,10 // interrupt polled every 10*50 milliseconds, approximated ADVANCED FUNCTION #2 - INTERRUPT DEFER (INTDEF) ~ This setting is useful if you need to defer the reporting of an interrupt by event or telemetry until it has occurred at least X number of times. Syntax: sensor29 intdef,pin // Will provide current setting of pin sensor29 intdef,pin,x // Will set new deffer value to x (0-15) Examples: sensor29 intdef,pin,5 // Will only report interrupt when it occurs 5 times sensor29 intdef,pin,10 // Will only report interrupt when it has occured 10 times Interrupts occurring a number of times prior to the setting will be counted but ignored for reporting purposes. ADVANCED FUNCTION #3 - INTERRUPT TIMER (INTTIMER) ~ This function is used in conjunction with INTCOUNT (Documented below) It allows a timer to be configured over which period the number of interrupts will be counted. Syntax: sensor29 inttimer // Will provide the current amount of seconds for timer sensor29 inttimer,x // Allows setting number of seconds (x) for timer interval ADVANCED FUNCTION #4 - INTERRUPT COUNTER ENABLE (INTCNT) ~ Enable interrupt counting for a particular pin. This functionality works in conjunction with INTTIMER (Documented above) Syntax: sensor29 intcnt,pin // Readback current setting of interrupt counting for pin (0=OFF/1=ON) sensor29 intcnt,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) Use case example could be if you want to count the number of times an interrupt occurred on a D0 over a period of 60 seconds. For this we will need the following: sensor29 inttimer,60 // Enable interrupt timer for 60 second interval sensor29 intcnt,0,1 // Enable interrupt counter for pin D0 The above will result in the number of interrupts that occur within the 60 second period configured to be counted and then reported via telemetry at the end of the 60 second time. A use case for this would be to determine the RPM of something, or perhaps the number of pulses received from an energy meter within a 60 second period to determine energy usage on a per minute bases... or wind speed from impulses received from an anemometer. ADVANCED FUNCTION #5 - INTERRUPT RETAIN (INTRETAIN) ~ This functionality disables immediate even and/or telemetry reporting for a specific pin that has been configured for any of the interrupt modes listed above. If this is enabled for a particular pin and the pin has an interrupt mode configured the fact that an interrupt condition was met will be remembered (but not reported immediately) and will be reported in a MQTT message when the next telemetry period occurs in the following format: {\"Time\":\"2018-12-06T23:59:26\",\"MCP_INTRETAIN\": {\"D0\":1,\"D1\":0,\"D2\":1,\"D3\":1,\"D4\":0,\"Value\":13}} In the example above it means that an interrupt occurred at some point during the previous telemetry period for pins D0, D2, and D3 as indicated by the 1's present for each pin - Pins with a value of 0 means that although the pin was configured for interrupt retain that no interrupt occurred during the previous telemetry period for that particular pin. For the sake of handling bit-wise operations within your home automation software the decimal value of the respective bits are also aggregated into the Value output included in the telemetry message. Syntax: sensor29 intretain,pin // Readback current setting of interrupt retain for a pin (0=OFF/1=ON) sensor29 intretain,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) OUTPUT FUNCTIONS (PIN MODES 5 AND 6) ~ Enable OUTPUT support by removing the comment (#) for the following compiler directive to your user_config_override.h #define USE_MCP230xx_OUTPUT This will extend the sensor29 command enabling pinmode 5 and 6 (inverted) for output, for example (nb. the output state will only be used/set with setoption0 = 0): sensor29 0,5,0 // Configure pin 0 as OUTPUT and default to OFF on reset/power-up sensor29 0,5,1 // Configure pin 0 as OUTPUT and default to ON on reset/power-up sensor29 0,5,2 // Configure pin 0 as OUTPUT and default to the value read from the MCP230xx on reset/power-up sensor29 0,6,0 // Configure pin 0 as INVERTED OUTPUT and default to ON on reset/power-up sensor29 0,6,1 // Configure pin 0 as INVERTED OUTPUT and default to OFF on reset/power-up sensor29 0,6,2 // Configure pin 0 as INVERTED OUTPUT and default to the value read from the MCP230xx on reset/power-up Confirmation will be sent using MQT, for example: MQT: stat/tasmota/RESULT = {\"Sensor29_D2\":{\"MODE\":5,\"START_UP\":\"OFF\",\"STATE\":\"OFF\"}} The only difference between pinmode 5 and pinmode 6 is that pinmode 5 will result in normal output state, i.e. pin will be LOW when OFF whereas pinmode 6 will cause the pin to be HIGH when OFF. This is useful when using relays which have inverted inputs. If SAVE_STATE / setoption0 is enabled in your firmware configuration then the last known state of the pin will be used on power-up/reset thereby ignoring the pull-up parameter in the commands above. To change the state of an output pin you may use: sensor29 0,ON // Turn pin ON (HIGH if pinmode 5 or LOW if pinmode 6(inverted)) sensor29 0,OFF // Turn pin OFF (LOW if pinmode 5 or HIGH if pinmode 6(inverted)) sensor29 0,T // Toggle the current state of pin from ON to OFF, or OFF to ON Additionally all OUTPUT pins will be exposed as RELAYS and ordered behind the normal GPIO based RELAYS. Instead of the above sensor command you can also use the POWERxx command like for any RELAY. If you define INTERLOCK and/or INTERLOCK groups these will also take care about the out pins. The numbering of the RELAY's is following the standard tasmota behavior. Counting from D0 any defined OUT pin will add a new RELAY. Example: D0, D2, D3, D7 are out pins, then D0=POWER1, D2=POWER2, D3=POWER3 and D7=POWER4. Same behavior you can expect when defining PULSETIME for RELAYS. Telemetry response will be provided accordingly, for example: MQT: stat/tasmota/RESULT = {\"S29cmnd_D0\":{\"COMMAND\":\"ON\",\"STATE\":\"ON\"}} MQT: stat/tasmota/RESULT = {\"S29cmnd_D0\":{\"COMMAND\":\"OFF\",\"STATE\":\"OFF\"}} MQT: stat/tasmota/RESULT = {\"S29cmnd_D0\":{\"COMMAND\":\"TOGGLE\",\"STATE\":\"ON\"}} COMMAND = Command which was sent STATE = New state after execution of command Telemetry data is provided for pins which are enabled for output. For example, if pin 0 was enabled for OUTPUT the following additional telemetry message will be sent by MQTT at the same time as the normal telemetry interval occurs which reports the current states of pins. Additionally you can also use the standard POWERxx reporting. MQT: tele/tasmota/SENSOR = {\"Time\":\"2018-08-18T16:41:20\",\"MCP230XX\":{\"D0\":0,\"D1\":0,\"D2\":1,\"D3\":0,\"D4\":0,\"D5\":0,\"D6\":0,\"D7\":0},\"MCP230_OUT\": {\"OUT_D4\":\"OFF\",\"END\":1}} Note the MCP230XX telemetry which provides the current logic state of all the pins and then the second MQT telemetry as MCP230_OUT which indicates the current state of pins configured for OUTPUT - In this case pin 4 or D4 Remember to adhere to the current limitations of OUTPUT pins when using the device for switching external devices such as LED's. That being said most readily available relay pc boards available from vendors are optically isolated from the input so these will work perfectly.","title":"MCP23008 / MCP23017 GPIO Expander"},{"location":"MCP230xx/#mcp23008-mcp23017-gpio-expander","text":"Technical Data from the manufacturer: * Microchip MCP23008 * Microchip MCP23017 Generally available breakout boards for the MCP23017 look similar to this: The MCP23008 has 8 IO pins which the MCP230xx driver uses as D0 - D7. The MCP23017 has 16 IO pins which the MCP230xx driver uses as D0 - D15. This is visualized in the circuit diagram below but it's important to note that the MCP23017 actually differentiates between PORTA (being A0 to A7) and PORTB (being B0 to B7) - The MCP230xx driver combines the two ports in sequence to translate to pins represented as D0 through D15 for the MCP23017. The chip can be connected quite easily, especially if you can source the DIP version of the chip. Here's a basic outline of what a typical circuit would require to be functional: You will need to pick an I2C address in either of the above scenario's using the address mapping according to pin A0, A1, and A2 as from the datasheet as follows: You will need to define the address you are using in user_config_override.h for the driver to know on which address the MCP23008/MCP23017 is expected to be found. #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 chips allow for both INPUT and OUTPUT - Most of the functionality of the driver is focused on INPUT mode - especially since they allow interrupt reporting and are 5V tolerant. OUTPUT functionality is however available as pinmode 5 (Documented later in this Wiki) as an additional option for those who want to use the OUTPUT functionality using the Sensor29 command which consumes ~1Kbyte of flash. The driver is disabled by default in the Tasmota firmware so the only way to gain its use would be to perform a manual compilation of your own firmware. There are three different levels in which functionality may be enabled, in the following order, by adding these lines in user_config_override.h : #define USE_MCP230xx // Enable INPUT mode (pinmode 1 through 4) #define USE_MCP230xx_OUTPUT // Enable OUTPUT mode (pinmode 5) #define USE_MCP230xx_DISPLAYOUTPUT // Display state of OUTPUT pins on main Tasmota web interface The ESP8266 will automatically detect whether you have connected an MCP23008 (8 input) or MCP23017 (16 input) and will provide telemetry data in accordance with how the device was configured from within the Tasmota firmware. If OUTPUT is enabled, telemetry data for the current state of OUTPUT pins will also be provided by telemetry.","title":"MCP23008 / MCP23017 GPIO Expander"},{"location":"MCP230xx/#mcp23008-mcp23017-pin-numbers-in-tasmota-compared-to-datasheets","text":"The table below outlines how the pins of the MCP23008/MCP23017 are assigned:","title":"MCP23008 / MCP23017 Pin numbers in Tasmota compared to datasheets"},{"location":"MCP230xx/#usage-of-the-driver","text":"The MCP230xx chip (or breakout board) must be connected to the ESP8266 and the I2C pins must be configured for the module similar to the following: One that is complete you may want to confirm that the Tasmota firmware is finding your MCP23008/MCP23017 chip by sending the command through serial or MQTT: I2Cscan You should see a response giving you an address within the range of the MCP23008/MCP23017 chip (0x20 through 0x27) which may look as follows MQT: stat/tasmota/RESULT = {\"I2CScan\":\"Device(s) found at 0x20\"} If the extender is not detected, check your wiring and pin configuration. The configuration of MCP23008/MCP23017 by using Sensor29 commands via the Console or MQTT messages. In order to use the MCP23008/MCP23017, add the following two lines in your user_config_override.h as the MCP chip support is not enabled by default. #define USE_MCP230xx #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 supports I 2 C address range of 0x20 through 0x27. Take care that you are not using an address which is already used by another device (e.g., 0x27 is a known address for some I 2 C Liquid Crystal Displays).","title":"Usage of the driver"},{"location":"MCP230xx/#device-configuration","text":"The behavior of all pins on the MCP23008/MCP23017 can be reset to a specific setting/mode globally to simplify the initial configuration as follows Command Parameters Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup\\|outstate{,repmode}} pin = the I/O pin on the MCP230xx chip 0..7 for MCP23008 0..15 for the MCP23017) pinmode = operational mode of the pin ( ?, 0..5 ) ? = query pin configuration 0 = Disabled (deprecated, but will be default for previously unconfigured devices) 1 = INPUT (Floating - only telemetry data will be sent according to configuration TelePeriod intervals) 2 = INPUT with INTERRUPT on CHANGE (will send an MQTT output on state change from LOW to HIGH and HIGH to LOW) 3 = INPUT with INTERRUPT on CHANGE to LOW (will send an MQTT output on state change only from HIGH to LOW) 4 = INPUT with INTERRUPT on CHANGE to HIGH (will send an MQTT output on state change only from LOW to HIGH) 5 = OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) intpullup (pinmode 1..4 ) . Pull-up resistors are disabled by default for pin mode 1 whilst enabled by default for pin modes 2..4 (because they are interrupt enabled pins and we do not want signal bounce). The internal pull-up on these pins may be disabled if necessary if you are biasing them externally. 0 = weak internal pull-up disabled (default for pinmode 1 ) 1 = weak internal pull-up enabled (default for pinmode 2..4 ) outstate (pinmode 5..6 ) = set the default state of an OUTPUT pin on reset/power-up. If your device is configured to save state ( SetOption0 = 1 ), the outstate setting will be ignored and the last known state of the pin will be applied during power-up/reset. 0/off = set output pin to OFF 1/on = set output pin state to ON 2/device = keep the value stored on the MCP230xx device repmode = reporting mode (optional). Applicable only for pinmode 2..4 . Reporting mode is disabled for pinmode 1 and for output pinmodes ( 5..6 ) 0 = interrupt using Event and report using telemetry (default) 1 = interrupt using Event only (no telemetry reported) 2 = report using telemetry only (no Event triggered) Examples: Sensor29 Reset1 MQT: stat/tasmota/RESULT = {\"Sensor29_D99\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"\"}} Pin and State is reported as 99 because it is set across all pins. Mode should correspond with the reset pinmode option used. Sensor29 0,? MQT: stat/tasmota/RESULT = {\"Sensor29_D0\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"ON\"}} Confirming that the pin is in pinmode 1 and that the pull-up resistor is not enabled. INT_MODE indicates the interrupt mode for pins which are interrupt enabled (pinmode 2 through 4) - In the example above it is disabled for pin mode 1 (INPUT without INTERRUPT) The current STATE of the pin as ON or OFF is reported as at the time the command is issued is also reported.","title":"Device Configuration"},{"location":"MCP230xx/#important-notice-on-use-of-interrupts","text":"Only use interrupts on pins which are either explicitly pulled down GND or up to VCC externally as floating pins may cause unintended MQTT responses for pins which are floating. So unless your connected wire/device explicitly pulls the pin to GND or VCC only when conditions of an interrupt would be met it is recommended that you either do not set a pin for an interrupt mode or at least enable pull-up resistors for the unused pins with pullup = 1 when you perform your sensor29 pin,pinmode,pullup command. Examples of some pin configuration options: sensor29 4,1,0 - Will enable D4 for INPUT without internal pull-up resistor sensor29 3,1,1 - Will enable D3 for INPUT with the internal pull-up resistor ENABLED sensor29 5,2,1 - Will enable D5 for INPUT and report on change state from LOW to HIGH and HIGH to LOW via MQTT sensor29 6,3,1 - Will enable D6 for INPUT and report on change state from HIGH to LOW (note pull-up is also enabled) sensor29 2,4,0 - Will enable D2 for INPUT and report on change state from LOW to HIGH (note pull-up is not enabled) Pull-up resistor support is valid for all modes from 1 through 4 Default telemetry logging will occur for all pins as per the configured logging interval of the ESP8266 as configured in the Tasmota firmware options. The telemetry logging will push out to log and MQTT a JSON as follows: tele/tasmota/SENSOR = {\"Time\":\"2018-08-18T16:13:47\",\"MCP230XX\": \"D0\":0,\"D1\":0,\"D2\":1,\"D3\":0,\"D4\":0,\"D5\":0,\"D6\":0,\"D7\":1}} Again, this will depend on whether an MCP23008 or MCP23017 is used insofar that the number of pins/bits reported will be 8 (0 to 7) or 16 (0 to 15) respectively.","title":"IMPORTANT NOTICE ON USE OF INTERRUPTS"},{"location":"MCP230xx/#interrupt-modes-and-usage","text":"Interrupts will report for individual pins as and when the conditions which were configured are met and will look something like this: Interrupt message on HIGH for input pin 0 MQT: stat/tasmota/RESULT = {\"Time\":\"2018-08-19T16:04:50\",\"MCP230XX_INT\":{\"D0\":1,\"MS\":301}} Interrupt message on LOW for input pin 1 MQT: stat/tasmota/RESULT = {\"Time\":\"2018-08-19T16:04:50\",\"MCP230XX_INT\":{\"D1\":0,\"MS\":519}} The state of the pin captured during the interrupt is reported as Dx=y where x is the pin number and y is the state of the pin. In addition the number of milliseconds since the last interrupt occurred for the particular pin is also reported as MS=xx where xx is the number of milliseconds recorded. In addition to the MQTT message the driver will also execute an event command in the following format: event MCPINT_Dxx=y Where xx = the pin number from 0 through 7 (MCP23008) or 0 through 15 (MCP23017) and y the state of the pin as it was captured by the interrupt register of the MCP23008/MCP23017 chip. The complete output for an interrupt enabled pin would look like this: MQT: stat/tasmota/RESULT = {\"Time\":\"2018-08-19T16:08:28\",\"MCP230XX_INT\":{\"D0\":0,\"MS\":217353}} SRC: Rule RSL: Group 0, Index 1, Command EVENT, Data MCPINT_D0=0 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} MQT: stat/tasmota/RESULT = {\"Time\":\"2018-08-19T16:08:46\",\"MCP230XX_INT\":{\"D0\":1,\"MS\":18101}} SRC: Rule RSL: Group 0, Index 1, Command EVENT, Data MCPINT_D0=1 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} The latter makes it possible to integrate interrupt responses with rules for example: rule on event#MCPINT_D0=1 do power on endon on event#MCPINT_D0=0 do power off endon In the example above the rule would respond to an interrupt of HIGH on pin 0 of the MCP by executing command \"power on\" and respond to an interrupt of LOW on pin 0 with the command \"power off\" See the Wiki on Using Rules for more information on how this can be helpful to your requirements. If you require only one of the two reporting methods you may use the sensor29 command to configure the interrupt behavior according to your requirements using command: sensor29 pin,pinmode,pullup,intmode The intmode parameter is optional for pin modes 2 through 4 (those that support interrupts) and may be configured according to the table below depending on your requirements: Keep in mind that the MCP23008/MCP23017 chip will only store the last interrupt registered in the interrupt register and capture register - Because the interrupt register is only checked every 50 milliseconds by the Tasmota firmware you may experience missed interrupts if your incoming signals fluctuate/change faster than 20 times per second.","title":"INTERRUPT MODES AND USAGE"},{"location":"MCP230xx/#home-assistant-tips","text":"You can use SetOption59 1 in order to get extra SENSOR status telemetry messages in addition to event-triggered RESULT messages. This allows very good integration with Home Assistant because it needs to monitor only one payload for both periodic and instant messages using binary_sensor : - platform: mqtt name: \"MCP23017 Teszt D0 SENSOR\" state_topic: \"tele/tasmota/SENSOR\" value_template: \"{{ value_json['MCP230XX'].D0 }}\" payload_on: \"1\" payload_off: \"0\" availability_topic: \"tele/tasmota/LWT\" payload_available: \"Online\" payload_not_available: \"Offline\" qos: 0 device_class: door","title":"HOME ASSISTANT TIPS"},{"location":"MCP230xx/#advanced-functions","text":"Several advanced functions have been added to extend the flexibility and interoperability of the MCP23008/MCP23017 with specific focus on adding functionality which is not present on the hardware's built-in GPIO pins and offloading some of the functionality that would normally be performed by rules or counters on the Tasmota device into the driver of the MCP23008/MCP23017. These include the following * INTPRI - Interrupt Priority, being able to control the rate at which the MCP23008/MCP23017 is polled to see if any interrupts has occurred since the previous poll. * INTDEF - Interrupt Deffer, being able to control the number of interrupts that are ignored on a specific pin before reporting would occur via telemetry and/or EVENT. * INTTIMER - Interrupt Timer which allows for time based counter reporting, specifically reporting the number of times an interrupt has occurred on interrupt enabled pins. * INTCNT - Works with INTTIMER to enable/disable counting for a specific pin. * INTRETAIN - Keep track of whether an interrupt occurred or not and defer reporting to next telemetry message. The above additions are described in further detail below.","title":"ADVANCED FUNCTIONS"},{"location":"MCP230xx/#advanced-function-1-interrupt-priority-intpri","text":"The maximum interrupt polling rate is once per approximately 50 milliseconds - This is what the Tasmota firmware allows as a maximum and how it is configured in the MCP23008/MCP23017 driver by default. If you want to reduce the number of interrupt polls per second you may use the INTPRI command parameter as follows: sensor29 intpri Will give you the current setting via JSON response as follows: MQT: stat/tasmota/RESULT = {\"MCP230xx_INTPRI\":{\"D_99\":0}} To change the value you may use command as follows: sensor29 intpri,x Where x is the number of 50ms cycles (between 0 and 20) which will be skipped before the MCP23008/MCP23017 chip is polled for interrupt. The last interrupt recorded by the MCP23008/MCP23017 will be reported via the configured method. For example, lets assume you only want the interrupt polling to occur every 500ms (i.e. twice per second) you could do command: sensor29 intpri,10 // interrupt polled every 10*50 milliseconds, approximated","title":"ADVANCED FUNCTION #1 - INTERRUPT PRIORITY (INTPRI)"},{"location":"MCP230xx/#advanced-function-2-interrupt-defer-intdef","text":"This setting is useful if you need to defer the reporting of an interrupt by event or telemetry until it has occurred at least X number of times. Syntax: sensor29 intdef,pin // Will provide current setting of pin sensor29 intdef,pin,x // Will set new deffer value to x (0-15) Examples: sensor29 intdef,pin,5 // Will only report interrupt when it occurs 5 times sensor29 intdef,pin,10 // Will only report interrupt when it has occured 10 times Interrupts occurring a number of times prior to the setting will be counted but ignored for reporting purposes.","title":"ADVANCED FUNCTION #2 - INTERRUPT DEFER (INTDEF)"},{"location":"MCP230xx/#advanced-function-3-interrupt-timer-inttimer","text":"This function is used in conjunction with INTCOUNT (Documented below) It allows a timer to be configured over which period the number of interrupts will be counted. Syntax: sensor29 inttimer // Will provide the current amount of seconds for timer sensor29 inttimer,x // Allows setting number of seconds (x) for timer interval","title":"ADVANCED FUNCTION #3 - INTERRUPT TIMER (INTTIMER)"},{"location":"MCP230xx/#advanced-function-4-interrupt-counter-enable-intcnt","text":"Enable interrupt counting for a particular pin. This functionality works in conjunction with INTTIMER (Documented above) Syntax: sensor29 intcnt,pin // Readback current setting of interrupt counting for pin (0=OFF/1=ON) sensor29 intcnt,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) Use case example could be if you want to count the number of times an interrupt occurred on a D0 over a period of 60 seconds. For this we will need the following: sensor29 inttimer,60 // Enable interrupt timer for 60 second interval sensor29 intcnt,0,1 // Enable interrupt counter for pin D0 The above will result in the number of interrupts that occur within the 60 second period configured to be counted and then reported via telemetry at the end of the 60 second time. A use case for this would be to determine the RPM of something, or perhaps the number of pulses received from an energy meter within a 60 second period to determine energy usage on a per minute bases... or wind speed from impulses received from an anemometer.","title":"ADVANCED FUNCTION #4 - INTERRUPT COUNTER ENABLE (INTCNT)"},{"location":"MCP230xx/#advanced-function-5-interrupt-retain-intretain","text":"This functionality disables immediate even and/or telemetry reporting for a specific pin that has been configured for any of the interrupt modes listed above. If this is enabled for a particular pin and the pin has an interrupt mode configured the fact that an interrupt condition was met will be remembered (but not reported immediately) and will be reported in a MQTT message when the next telemetry period occurs in the following format: {\"Time\":\"2018-12-06T23:59:26\",\"MCP_INTRETAIN\": {\"D0\":1,\"D1\":0,\"D2\":1,\"D3\":1,\"D4\":0,\"Value\":13}} In the example above it means that an interrupt occurred at some point during the previous telemetry period for pins D0, D2, and D3 as indicated by the 1's present for each pin - Pins with a value of 0 means that although the pin was configured for interrupt retain that no interrupt occurred during the previous telemetry period for that particular pin. For the sake of handling bit-wise operations within your home automation software the decimal value of the respective bits are also aggregated into the Value output included in the telemetry message. Syntax: sensor29 intretain,pin // Readback current setting of interrupt retain for a pin (0=OFF/1=ON) sensor29 intretain,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON)","title":"ADVANCED FUNCTION #5 - INTERRUPT RETAIN (INTRETAIN)"},{"location":"MCP230xx/#output-functions-pin-modes-5-and-6","text":"Enable OUTPUT support by removing the comment (#) for the following compiler directive to your user_config_override.h #define USE_MCP230xx_OUTPUT This will extend the sensor29 command enabling pinmode 5 and 6 (inverted) for output, for example (nb. the output state will only be used/set with setoption0 = 0): sensor29 0,5,0 // Configure pin 0 as OUTPUT and default to OFF on reset/power-up sensor29 0,5,1 // Configure pin 0 as OUTPUT and default to ON on reset/power-up sensor29 0,5,2 // Configure pin 0 as OUTPUT and default to the value read from the MCP230xx on reset/power-up sensor29 0,6,0 // Configure pin 0 as INVERTED OUTPUT and default to ON on reset/power-up sensor29 0,6,1 // Configure pin 0 as INVERTED OUTPUT and default to OFF on reset/power-up sensor29 0,6,2 // Configure pin 0 as INVERTED OUTPUT and default to the value read from the MCP230xx on reset/power-up Confirmation will be sent using MQT, for example: MQT: stat/tasmota/RESULT = {\"Sensor29_D2\":{\"MODE\":5,\"START_UP\":\"OFF\",\"STATE\":\"OFF\"}} The only difference between pinmode 5 and pinmode 6 is that pinmode 5 will result in normal output state, i.e. pin will be LOW when OFF whereas pinmode 6 will cause the pin to be HIGH when OFF. This is useful when using relays which have inverted inputs. If SAVE_STATE / setoption0 is enabled in your firmware configuration then the last known state of the pin will be used on power-up/reset thereby ignoring the pull-up parameter in the commands above. To change the state of an output pin you may use: sensor29 0,ON // Turn pin ON (HIGH if pinmode 5 or LOW if pinmode 6(inverted)) sensor29 0,OFF // Turn pin OFF (LOW if pinmode 5 or HIGH if pinmode 6(inverted)) sensor29 0,T // Toggle the current state of pin from ON to OFF, or OFF to ON Additionally all OUTPUT pins will be exposed as RELAYS and ordered behind the normal GPIO based RELAYS. Instead of the above sensor command you can also use the POWERxx command like for any RELAY. If you define INTERLOCK and/or INTERLOCK groups these will also take care about the out pins. The numbering of the RELAY's is following the standard tasmota behavior. Counting from D0 any defined OUT pin will add a new RELAY. Example: D0, D2, D3, D7 are out pins, then D0=POWER1, D2=POWER2, D3=POWER3 and D7=POWER4. Same behavior you can expect when defining PULSETIME for RELAYS. Telemetry response will be provided accordingly, for example: MQT: stat/tasmota/RESULT = {\"S29cmnd_D0\":{\"COMMAND\":\"ON\",\"STATE\":\"ON\"}} MQT: stat/tasmota/RESULT = {\"S29cmnd_D0\":{\"COMMAND\":\"OFF\",\"STATE\":\"OFF\"}} MQT: stat/tasmota/RESULT = {\"S29cmnd_D0\":{\"COMMAND\":\"TOGGLE\",\"STATE\":\"ON\"}} COMMAND = Command which was sent STATE = New state after execution of command Telemetry data is provided for pins which are enabled for output. For example, if pin 0 was enabled for OUTPUT the following additional telemetry message will be sent by MQTT at the same time as the normal telemetry interval occurs which reports the current states of pins. Additionally you can also use the standard POWERxx reporting. MQT: tele/tasmota/SENSOR = {\"Time\":\"2018-08-18T16:41:20\",\"MCP230XX\":{\"D0\":0,\"D1\":0,\"D2\":1,\"D3\":0,\"D4\":0,\"D5\":0,\"D6\":0,\"D7\":0},\"MCP230_OUT\": {\"OUT_D4\":\"OFF\",\"END\":1}} Note the MCP230XX telemetry which provides the current logic state of all the pins and then the second MQT telemetry as MCP230_OUT which indicates the current state of pins configured for OUTPUT - In this case pin 4 or D4 Remember to adhere to the current limitations of OUTPUT pins when using the device for switching external devices such as LED's. That being said most readily available relay pc boards available from vendors are optically isolated from the input so these will work perfectly.","title":"OUTPUT FUNCTIONS (PIN MODES 5 AND 6)"},{"location":"MCP9808/","text":"MCP9808 temperature sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MCP9808 #define USE_MCP9808 // [I2cDriver51] Enable MCP9808 temperature sensor (I2C addresses 0x18 - 0x1F) (+0k9 code) #endif the MCP9808 is an I 2 C temperature sensor. Tasmota support up to 8 devices. Configuration ~ Wiring ~ MCP9808 ESP VCC 3.3V GND GND SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect automatically up to 8 MCP9808 and display sensor readings. and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"MCP9808\":{\"Temperature\":24.7},\"TempUnit\":\"C\"} Breakout Boards ~ Datasheet ~ MCP9808","title":"MCP9808 temperature sensor"},{"location":"MCP9808/#mcp9808-temperature-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MCP9808 #define USE_MCP9808 // [I2cDriver51] Enable MCP9808 temperature sensor (I2C addresses 0x18 - 0x1F) (+0k9 code) #endif the MCP9808 is an I 2 C temperature sensor. Tasmota support up to 8 devices.","title":"MCP9808 temperature sensor"},{"location":"MCP9808/#configuration","text":"","title":"Configuration"},{"location":"MCP9808/#wiring","text":"MCP9808 ESP VCC 3.3V GND GND SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"MCP9808/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect automatically up to 8 MCP9808 and display sensor readings. and in MQTT topic (according to TelePeriod): {\"Time\":\"2020-01-01T00:00:00\",\"MCP9808\":{\"Temperature\":24.7},\"TempUnit\":\"C\"}","title":"Tasmota Settings"},{"location":"MCP9808/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MCP9808/#datasheet","text":"MCP9808","title":"Datasheet"},{"location":"MFRC522/","text":"MFRC522 RFID reader ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #define USE_RC522 // Add support for MFRC522 13.56Mhz Rfid reader (+6k code) #define USE_RC522_DATA_FUNCTION // Add support for reading data block content (+0k4 code) #define USE_RC522_TYPE_INFORMATION // Add support for showing card type (+0k4 code) The MFRC522 is a highly integrated reader/writer IC for contactless communication at 13.56 MHz. The MFRC522 reader supports ISO/IEC 14443 A/MIFARE and NTAG. Datasheet . This reader is ubiquitous in many Arduino starter and sensor kits. It uses SPI protocol for communication with ESP. Wiring ~ MFRC522 ESP8266 Tasmota SDA GPIO0..5,15,16 RC522 CS SCK GPIO14 SPI CLK MOSI GPIO13 SPI MOSI MISO GPIO12 SPI MISO IRQ not used GND GND RST GPIO0..5,15,16 RC522 Rst 3V3 3V3 Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to RC522 Rst GPIOy to RC522 CS GPIO12 to SPI MISO GPIO13 to SPI MOSI GPIO14 to SPI CLK The module will reboot when you save this configuration. During start-up the following information should be visible in your console output: 00 : 00 : 00 MFR : RC 522 R f id Reader de te c te d If the device was not found please check your wiring and configuration and confirm that everything is as it should be. Example Configured using NodeMCU on pins: D1 (connected to RC522 Rst) and D8 (connected to RC522 CS) Usage ~ Tasmota will scan for a new card detect 4 times per second and if found will report it via immediate telemetry. The output on the console will look similar to the below when a new card is detected 13 : 10 : 50.346 MQT : tele /r f id - test /SENSOR = { \"Time\" : \"2021-01-23T13:10:50\" , \"RC522\" :{ \"UID\" : \"BA839D07\" , \"Data\" : \"\" , \"Type\" : \"MIFARE 1KB\" }} The UID of the card/tag is reported and any text stored in BLOCK 1 of a Mifare Classic card (up to 15 characters in length) is reported in the DATA field of the JSON sent via telemetry. Please note that the DATA field cannot contain spaces. Using the UID or DATA ~ For the purpose of using card/tag data on the device itself you will need to use rules along with the events that are caused. Example Example rule for responding to a specific UID on the device when a card/tag matching a specific UID is presented rule1 on RC522#UID=BA839D07 do power on endon Breakout Boards ~","title":"MFRC522 RFID reader"},{"location":"MFRC522/#mfrc522-rfid-reader","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #define USE_RC522 // Add support for MFRC522 13.56Mhz Rfid reader (+6k code) #define USE_RC522_DATA_FUNCTION // Add support for reading data block content (+0k4 code) #define USE_RC522_TYPE_INFORMATION // Add support for showing card type (+0k4 code) The MFRC522 is a highly integrated reader/writer IC for contactless communication at 13.56 MHz. The MFRC522 reader supports ISO/IEC 14443 A/MIFARE and NTAG. Datasheet . This reader is ubiquitous in many Arduino starter and sensor kits. It uses SPI protocol for communication with ESP.","title":"MFRC522 RFID reader"},{"location":"MFRC522/#wiring","text":"MFRC522 ESP8266 Tasmota SDA GPIO0..5,15,16 RC522 CS SCK GPIO14 SPI CLK MOSI GPIO13 SPI MOSI MISO GPIO12 SPI MISO IRQ not used GND GND RST GPIO0..5,15,16 RC522 Rst 3V3 3V3","title":"Wiring"},{"location":"MFRC522/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to RC522 Rst GPIOy to RC522 CS GPIO12 to SPI MISO GPIO13 to SPI MOSI GPIO14 to SPI CLK The module will reboot when you save this configuration. During start-up the following information should be visible in your console output: 00 : 00 : 00 MFR : RC 522 R f id Reader de te c te d If the device was not found please check your wiring and configuration and confirm that everything is as it should be. Example Configured using NodeMCU on pins: D1 (connected to RC522 Rst) and D8 (connected to RC522 CS)","title":"Tasmota Settings"},{"location":"MFRC522/#usage","text":"Tasmota will scan for a new card detect 4 times per second and if found will report it via immediate telemetry. The output on the console will look similar to the below when a new card is detected 13 : 10 : 50.346 MQT : tele /r f id - test /SENSOR = { \"Time\" : \"2021-01-23T13:10:50\" , \"RC522\" :{ \"UID\" : \"BA839D07\" , \"Data\" : \"\" , \"Type\" : \"MIFARE 1KB\" }} The UID of the card/tag is reported and any text stored in BLOCK 1 of a Mifare Classic card (up to 15 characters in length) is reported in the DATA field of the JSON sent via telemetry. Please note that the DATA field cannot contain spaces.","title":"Usage"},{"location":"MFRC522/#using-the-uid-or-data","text":"For the purpose of using card/tag data on the device itself you will need to use rules along with the events that are caused. Example Example rule for responding to a specific UID on the device when a card/tag matching a specific UID is presented rule1 on RC522#UID=BA839D07 do power on endon","title":"Using the UID or DATA"},{"location":"MFRC522/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MGC3130/","text":"MGC3130 3D tracking and gesture controller ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MGC3130 #define USE_MGC3130 // [I2cDriver27] Enable MGC3130 Electric Field Effect Sensor (I2C address 0x42) (+2k7 code, 0k3 mem) #endif The MGC3130 is an electrical-field (E-field) based three-dimensional (3D) tracking and gesture controller from Microchip. There are several boards available, which are connected via I 2 C. Usage ~ wire up SDA and SDL and configure as usual in Tasmota wire up RESET and TRFR (names may vary on different boards) to free GPIO's and configure them accordingly (TRFR is GPIO: MGC3130_XFER) Expected behaviour ~ after boot gestures (FLICK, EDGE_FLICK, TOUCH, TAP, DOUBLE_TAP) will be sensed and published via MQTT Flicks: Taps: you can select different modes with the COMMANDS, touch will always be sensed and report the duration in 1/20 seconds. Touch: the airwheel gesture will be sensed and published as \"AW\" via MQTT with values between 0 and 1023 - clockwise up Airwheel: after entering position mode the values for x,y,z will be sensed and published via MQTT with values between 0 and 1023 for x,y. Data is only published, when z is in the upper half (z values are between 0 and 511). Location sensing in active volume: near the surface you can move your finger without producing location data, i.e. to change the mode. at the moment the circle gestures ((COUNTER)CLOCKWISE) must be activated with the COMMAND: SENSOR91 1 (we must wait 250ms after the start and can not activate it in the init function, this might differ depending on the board firmware) Commands ~ SENSOR36 0 - next mode SENSOR36 1 - gesture mode SENSOR36 2 - air wheel mode SENSOR36 3 - position mode (ATTENTION: this will send a lot of data!) MQTT Messages ~ The terminology follows the documentation from MICROCHIP, but is shortened to save space especially for RULES. The board is to be viewed like a map, where UP is NORTH and RIGHT is EAST an so on. The big central part of the surface is CENTRE. A movement (FLICK) from LEFT to RIGHT is translated to FLICK-WEST-EAST and then finally shortened to {FL_WE:1}. If you only do a flick at the left edge (with a short movement to the right) this will be EDGE-FLICK-WEST-EAST and then in the final message: {E_FL_WE:1}. A TOUCH (leaving your finger on the board) reports the location and the duration (in counts of 50ms). So touching the center for a second, publishes messages from {TH_C:1} up to (approx.) {TH_C:20}. Touching for less than 1,25 seconds triggers a TAP-message in the moment of leaving the surface, so on the lower edge we will see: {TP_S:1} (plus some {TH_S:1...x} for the contact duration). Double Tap (like a double click on your mouse) works similar, but will (at the moment) always trigger a (single) TAP at the same position. Example for the upper edge: {DT_N:1} and before that: {TP_N:1} and some {TH_N:1...x}. Airwheel is a circular finger movement above the sensor, which will trigger a message {AW:0 ... 1023}. In position mode we get {X:0...1023,Y:0...1023,Z:0...511}, where X and Y are 0 in the lower left (west-south) corner. The z value is not published in close proximity to the surface in order to have a chance to switch to another mode with a TOUCH, TAP or DOUBLE-TAP. So the active sensing volume is in the upper z-half of the theoretical maximum sensing volume. Examples ~ A possible solution to cycle through the modes only with the sensor by double tapping the center is using rules: rule1 on Tele-MGC3130#DT_C do sensor91 0 endon or with a \"long\" touch of a second rule1 on Tele-MGC3130#TH_C > 20 do sensor91 0 endon Considerations ~ This is an extremely versatile sensor and the main problem is not to get it to work somehow in TASMOTA, but to make it usable in a sensible way. We can measure and publish all kinds of data in parallel, but this will likely end up in an unusable situation. It is important to have a basic understanding of the sensor, to not get confused with seemingly unreasonable messages (DOUBLE TAP triggers a TOUCH (or more than one), then a TAP (after the first lift of the finger) and then a DOUBLE TAP. The naming conventions of the gestures are according to the data sheets from Microchip, because if we only would have simple FLICKS, it would have made it easy to use: UP, DOWN, LEFT, RIGHT. But we have EDGE FLICKS and various TOUCHES too, and so the direction name could be ambiguous. That's why we (have to) use NORTH-SOUTH, EAST-WEST ... and NORTH, SOUTH, .... and CENTRE. To make the MQTT messages not too long, some useful abbreviations have to be found. This is definitely work in progress. Known Issues ~ After the initial flashing the ESP8266/TASMOTA can freeze at startup with a connected sensor board. If this happens disconnect the wires from the MGC3130-board (I 2 C-wires should be enough), reboot and reconnect. Keep in mind, that in general many things will interfere with an electrical field. In certain places it can simply be impossible to use such kind of sensor. For testing reasons it is fine to connect the ESP8266-device to the USB-Port of a computer (for POWER and SERIAL), but this will likely lead to weird effects in some cases (i.e. reading of nonsense-location-data by simply touching the keyboard of a connected laptop). The chip can saturate the I 2 C-bus and additional I 2 C-devices can lead to problems. The driver was developed and tested on a SKYWRITER-board from PIMORONI. The behavior of other boards can not be guaranteed.","title":"MGC3130 3D tracking and gesture controller"},{"location":"MGC3130/#mgc3130-3d-tracking-and-gesture-controller","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MGC3130 #define USE_MGC3130 // [I2cDriver27] Enable MGC3130 Electric Field Effect Sensor (I2C address 0x42) (+2k7 code, 0k3 mem) #endif The MGC3130 is an electrical-field (E-field) based three-dimensional (3D) tracking and gesture controller from Microchip. There are several boards available, which are connected via I 2 C.","title":"MGC3130 3D tracking and gesture controller"},{"location":"MGC3130/#usage","text":"wire up SDA and SDL and configure as usual in Tasmota wire up RESET and TRFR (names may vary on different boards) to free GPIO's and configure them accordingly (TRFR is GPIO: MGC3130_XFER)","title":"Usage"},{"location":"MGC3130/#expected-behaviour","text":"after boot gestures (FLICK, EDGE_FLICK, TOUCH, TAP, DOUBLE_TAP) will be sensed and published via MQTT Flicks: Taps: you can select different modes with the COMMANDS, touch will always be sensed and report the duration in 1/20 seconds. Touch: the airwheel gesture will be sensed and published as \"AW\" via MQTT with values between 0 and 1023 - clockwise up Airwheel: after entering position mode the values for x,y,z will be sensed and published via MQTT with values between 0 and 1023 for x,y. Data is only published, when z is in the upper half (z values are between 0 and 511). Location sensing in active volume: near the surface you can move your finger without producing location data, i.e. to change the mode. at the moment the circle gestures ((COUNTER)CLOCKWISE) must be activated with the COMMAND: SENSOR91 1 (we must wait 250ms after the start and can not activate it in the init function, this might differ depending on the board firmware)","title":"Expected behaviour"},{"location":"MGC3130/#commands","text":"SENSOR36 0 - next mode SENSOR36 1 - gesture mode SENSOR36 2 - air wheel mode SENSOR36 3 - position mode (ATTENTION: this will send a lot of data!)","title":"Commands"},{"location":"MGC3130/#mqtt-messages","text":"The terminology follows the documentation from MICROCHIP, but is shortened to save space especially for RULES. The board is to be viewed like a map, where UP is NORTH and RIGHT is EAST an so on. The big central part of the surface is CENTRE. A movement (FLICK) from LEFT to RIGHT is translated to FLICK-WEST-EAST and then finally shortened to {FL_WE:1}. If you only do a flick at the left edge (with a short movement to the right) this will be EDGE-FLICK-WEST-EAST and then in the final message: {E_FL_WE:1}. A TOUCH (leaving your finger on the board) reports the location and the duration (in counts of 50ms). So touching the center for a second, publishes messages from {TH_C:1} up to (approx.) {TH_C:20}. Touching for less than 1,25 seconds triggers a TAP-message in the moment of leaving the surface, so on the lower edge we will see: {TP_S:1} (plus some {TH_S:1...x} for the contact duration). Double Tap (like a double click on your mouse) works similar, but will (at the moment) always trigger a (single) TAP at the same position. Example for the upper edge: {DT_N:1} and before that: {TP_N:1} and some {TH_N:1...x}. Airwheel is a circular finger movement above the sensor, which will trigger a message {AW:0 ... 1023}. In position mode we get {X:0...1023,Y:0...1023,Z:0...511}, where X and Y are 0 in the lower left (west-south) corner. The z value is not published in close proximity to the surface in order to have a chance to switch to another mode with a TOUCH, TAP or DOUBLE-TAP. So the active sensing volume is in the upper z-half of the theoretical maximum sensing volume.","title":"MQTT Messages"},{"location":"MGC3130/#examples","text":"A possible solution to cycle through the modes only with the sensor by double tapping the center is using rules: rule1 on Tele-MGC3130#DT_C do sensor91 0 endon or with a \"long\" touch of a second rule1 on Tele-MGC3130#TH_C > 20 do sensor91 0 endon","title":"Examples"},{"location":"MGC3130/#considerations","text":"This is an extremely versatile sensor and the main problem is not to get it to work somehow in TASMOTA, but to make it usable in a sensible way. We can measure and publish all kinds of data in parallel, but this will likely end up in an unusable situation. It is important to have a basic understanding of the sensor, to not get confused with seemingly unreasonable messages (DOUBLE TAP triggers a TOUCH (or more than one), then a TAP (after the first lift of the finger) and then a DOUBLE TAP. The naming conventions of the gestures are according to the data sheets from Microchip, because if we only would have simple FLICKS, it would have made it easy to use: UP, DOWN, LEFT, RIGHT. But we have EDGE FLICKS and various TOUCHES too, and so the direction name could be ambiguous. That's why we (have to) use NORTH-SOUTH, EAST-WEST ... and NORTH, SOUTH, .... and CENTRE. To make the MQTT messages not too long, some useful abbreviations have to be found. This is definitely work in progress.","title":"Considerations"},{"location":"MGC3130/#known-issues","text":"After the initial flashing the ESP8266/TASMOTA can freeze at startup with a connected sensor board. If this happens disconnect the wires from the MGC3130-board (I 2 C-wires should be enough), reboot and reconnect. Keep in mind, that in general many things will interfere with an electrical field. In certain places it can simply be impossible to use such kind of sensor. For testing reasons it is fine to connect the ESP8266-device to the USB-Port of a computer (for POWER and SERIAL), but this will likely lead to weird effects in some cases (i.e. reading of nonsense-location-data by simply touching the keyboard of a connected laptop). The chip can saturate the I 2 C-bus and additional I 2 C-devices can lead to problems. The driver was developed and tested on a SKYWRITER-board from PIMORONI. The behavior of other boards can not be guaranteed.","title":"Known Issues"},{"location":"MH-Z19B/","text":"MH-Z19 CO 2 Sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MHZ19 #define USE_MHZ19 // Add support for MH-Z19 CO2 sensor (+2k code) #endif The MH-Z19 sensor is manufactured by Winsen Lt., China and the measurement method used is based on the non-dispersive infrared ( NDIR ) principle to detect the existence of CO 2 in the air. Key features according to the manufacturer are: good sensitivity non-oxygen dependent long life built-in temperature compensation UART serial interface and Pulse Width Modulation (PWM) output Principle of operation: The main components of an NDIR sensor are an infrared source (lamp), a sample chamber or light tube, a light filter and an infrared detector. The IR light is directed through the sample chamber towards the detector. In parallel there is another chamber with an enclosed reference gas, typically nitrogen. The gas in the sample chamber causes absorption of specific wavelengths according to the Beer\u00f1Lambert law, and the attenuation of these wavelengths is measured by the detector to determine the gas concentration. The detector has an optical filter in front of it that eliminates all light except the wavelength that the selected gas molecules can absorb. Wiring ~ ESP MH-Z19 VCC +5V Vin GND GND TX Rx RX Tx In some situations if you only get 0 ppm displayed it may be necessary to set \"TX GPIO1\" to \"MHZ Rx\" and \"RX GPIO3\" to \"MHZ Tx\" and correspondingly reverse the cabling for RX/TX. See here for more details. Tasmota Settings ~ In the Configuration -> Configure Module page assign: RX to MHZ Tx TX to MHZ Rx After a reboot the driver will detect MH-Z19 automatically and display measurements. Measure range can be selected with command: sensor15 1000 for 1000 ppm range sensor15 2000 for 2000 ppm range sensor15 3000 for 3000 ppm range sensor15 5000 for 5000 ppm range Full commands list for the sensor Model Comparison ~ Product model MH-Z19B MH-Z19C MH-Z19D Power supply voltage 4.5~ 5.5 V DC DC (5.0 \u00b1 0.1) V DC (5.0 \u00b1 0.1) V Average current < 60mA(@5V) <40mA (@5V power supply) <40mA (@5V power supply) Peak current 150 mA (@5V supply) 125mA (@5V power supply) 125 mA (@5V power supply) Measuring range 0~5000ppm, 0~10000ppm 400 5000ppm(optional) 400 10000ppm range could be customized 400~10000ppm(optional) Warm-up time 3min 2.5min 1min Response time T90<120s T90< 120s T90 <120s Working temperature 0 ~ 50 \u2103 -10\u2103 ~ 50\u2103 -10\u2103 ~ 50\u2103 Working humidity 0~ 90% RH (No condensation) 0~ 90% RH (No condensation) 0~ 90% RH (No condensation) Storage temperature -20\u2103\uff5e60\u2103 -20\u2103\uff5e60\u2103 Source link link link Available from AliExpress","title":"MH-Z19 CO~2~ Sensor"},{"location":"MH-Z19B/#mh-z19-co2-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MHZ19 #define USE_MHZ19 // Add support for MH-Z19 CO2 sensor (+2k code) #endif The MH-Z19 sensor is manufactured by Winsen Lt., China and the measurement method used is based on the non-dispersive infrared ( NDIR ) principle to detect the existence of CO 2 in the air. Key features according to the manufacturer are: good sensitivity non-oxygen dependent long life built-in temperature compensation UART serial interface and Pulse Width Modulation (PWM) output Principle of operation: The main components of an NDIR sensor are an infrared source (lamp), a sample chamber or light tube, a light filter and an infrared detector. The IR light is directed through the sample chamber towards the detector. In parallel there is another chamber with an enclosed reference gas, typically nitrogen. The gas in the sample chamber causes absorption of specific wavelengths according to the Beer\u00f1Lambert law, and the attenuation of these wavelengths is measured by the detector to determine the gas concentration. The detector has an optical filter in front of it that eliminates all light except the wavelength that the selected gas molecules can absorb.","title":"MH-Z19 CO2 Sensor"},{"location":"MH-Z19B/#wiring","text":"ESP MH-Z19 VCC +5V Vin GND GND TX Rx RX Tx In some situations if you only get 0 ppm displayed it may be necessary to set \"TX GPIO1\" to \"MHZ Rx\" and \"RX GPIO3\" to \"MHZ Tx\" and correspondingly reverse the cabling for RX/TX. See here for more details.","title":"Wiring"},{"location":"MH-Z19B/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: RX to MHZ Tx TX to MHZ Rx After a reboot the driver will detect MH-Z19 automatically and display measurements. Measure range can be selected with command: sensor15 1000 for 1000 ppm range sensor15 2000 for 2000 ppm range sensor15 3000 for 3000 ppm range sensor15 5000 for 5000 ppm range Full commands list for the sensor","title":"Tasmota Settings"},{"location":"MH-Z19B/#model-comparison","text":"Product model MH-Z19B MH-Z19C MH-Z19D Power supply voltage 4.5~ 5.5 V DC DC (5.0 \u00b1 0.1) V DC (5.0 \u00b1 0.1) V Average current < 60mA(@5V) <40mA (@5V power supply) <40mA (@5V power supply) Peak current 150 mA (@5V supply) 125mA (@5V power supply) 125 mA (@5V power supply) Measuring range 0~5000ppm, 0~10000ppm 400 5000ppm(optional) 400 10000ppm range could be customized 400~10000ppm(optional) Warm-up time 3min 2.5min 1min Response time T90<120s T90< 120s T90 <120s Working temperature 0 ~ 50 \u2103 -10\u2103 ~ 50\u2103 -10\u2103 ~ 50\u2103 Working humidity 0~ 90% RH (No condensation) 0~ 90% RH (No condensation) 0~ 90% RH (No condensation) Storage temperature -20\u2103\uff5e60\u2103 -20\u2103\uff5e60\u2103 Source link link link Available from AliExpress","title":"Model Comparison"},{"location":"MLX90614/","text":"MLX90614 infrared thermometer ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MLX90614 #define USE_MLX90614 // [I2cDriver32] Enable MLX90614 ir temp sensor (I2C address 0x5a) (+0.6k code) #endif The MLX90614 is an infrared thermometer for non-contact temperature measurements. Configuration ~ Wiring ~ MLX90614 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect MLX90614 automatically and display Temperature measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-11-11T00:03:30\" , \"MLX90614\" :{ \"OBJTMP\" : 23.8 , \"AMBTMP\" : 22.7 }} Breakout Boards ~ MLX90615 ~ This driver will also work with MLX90615 sensor with some code alterations. Change lines 26-30 #define I2_ADR_IRT 0x5b #define MLX90614_RAWIR1 0x05 #define MLX90614_TA 0x26 #define MLX90614_TOBJ1 0x27","title":"MLX90614 infrared thermometer"},{"location":"MLX90614/#mlx90614-infrared-thermometer","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MLX90614 #define USE_MLX90614 // [I2cDriver32] Enable MLX90614 ir temp sensor (I2C address 0x5a) (+0.6k code) #endif The MLX90614 is an infrared thermometer for non-contact temperature measurements.","title":"MLX90614 infrared thermometer"},{"location":"MLX90614/#configuration","text":"","title":"Configuration"},{"location":"MLX90614/#wiring","text":"MLX90614 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"MLX90614/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect MLX90614 automatically and display Temperature measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-11-11T00:03:30\" , \"MLX90614\" :{ \"OBJTMP\" : 23.8 , \"AMBTMP\" : 22.7 }}","title":"Tasmota Settings"},{"location":"MLX90614/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MLX90614/#mlx90615","text":"This driver will also work with MLX90615 sensor with some code alterations. Change lines 26-30 #define I2_ADR_IRT 0x5b #define MLX90614_RAWIR1 0x05 #define MLX90614_TA 0x26 #define MLX90614_TOBJ1 0x27","title":"MLX90615"},{"location":"MLX90640/","text":"MLX90640 Far infrared thermal sensor array ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MLX90640 #define USE_MLX90640 // [I2cDriver53] Enable MLX90640 IR array temperature sensor (I2C address 0x33) (+20k code) #endif The MLX90640 is a IR sensor array of 32x24 pixels, that is connected via an usual I2C-connection. Intended use case is to measure multiple points of interest of an object without the need to directly put a sensor on it, for instance if you are not allowed to apply hardware modifications to a heating. The update frequency of the measurements is approximately 1 per second. In the first driver version 6 POI\u2018s are freely selectable (POI1..6). POI-0 is reserved for the ambient temperature of the sensor (Ta). Data is published at Teleperiod as an array [POI-0...6]: { \"Time\": \"2020-09-11T09:18:08\", \"MLX90640\": { \"Temperature\": [30.8, 28.5, 24.2, 25.7, 24.5, 24.6, 24.9] }, \"TempUnit\": \"C\" } Configuration ~ Wiring ~ MLX90640 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect MLX90614 automatically and display Temperature measurements. Commands ~ Command: MLXPOIn xxyy, n ist poi 1...6, xx 0...31, yy 0...23 Example: Point 2 at x:12 and y:08 results in mlxpoi2 1208 The configuration can be saved via RULES. Web-GUI ~ In order to find the correct coordinates a thermal view is provided via webGUI, where points can be validated and/or updated. A stable Wifi-setup is mandatory for reliable operation. Breakout Boards ~","title":"MLX90640 Far infrared thermal sensor array"},{"location":"MLX90640/#mlx90640-far-infrared-thermal-sensor-array","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MLX90640 #define USE_MLX90640 // [I2cDriver53] Enable MLX90640 IR array temperature sensor (I2C address 0x33) (+20k code) #endif The MLX90640 is a IR sensor array of 32x24 pixels, that is connected via an usual I2C-connection. Intended use case is to measure multiple points of interest of an object without the need to directly put a sensor on it, for instance if you are not allowed to apply hardware modifications to a heating. The update frequency of the measurements is approximately 1 per second. In the first driver version 6 POI\u2018s are freely selectable (POI1..6). POI-0 is reserved for the ambient temperature of the sensor (Ta). Data is published at Teleperiod as an array [POI-0...6]: { \"Time\": \"2020-09-11T09:18:08\", \"MLX90640\": { \"Temperature\": [30.8, 28.5, 24.2, 25.7, 24.5, 24.6, 24.9] }, \"TempUnit\": \"C\" }","title":"MLX90640 Far infrared thermal sensor array"},{"location":"MLX90640/#configuration","text":"","title":"Configuration"},{"location":"MLX90640/#wiring","text":"MLX90640 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"MLX90640/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect MLX90614 automatically and display Temperature measurements.","title":"Tasmota Settings"},{"location":"MLX90640/#commands","text":"Command: MLXPOIn xxyy, n ist poi 1...6, xx 0...31, yy 0...23 Example: Point 2 at x:12 and y:08 results in mlxpoi2 1208 The configuration can be saved via RULES.","title":"Commands"},{"location":"MLX90640/#web-gui","text":"In order to find the correct coordinates a thermal view is provided via webGUI, where points can be validated and/or updated. A stable Wifi-setup is mandatory for reliable operation.","title":"Web-GUI"},{"location":"MLX90640/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MPR121/","text":"MPR121 capacitive touch sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MPR121 #define USE_MPR121 // [I2cDriver23] Enable MPR121 controller (I2C addresses 0x5A, 0x5B, 0x5C and 0x5D) in input mode for touch buttons (+1k3 code) #endif 12-button or touch pad I 2 C controller Driver supports up to 4x MPR121 controllers (= 48 buttons per ESP8266) Electrodes can be covered with adhesive paper and adhesive plastic foil for labeling and symbols Break-out and touch button PCBs ~ 2\u20ac at AliExpress Break-out PCB ~ $8 at Adafruit Technical Data from the manufacturer ~ MPR121 Fact sheet MPR121 Data sheet AN3889 MPR121 capacitive sensing settings AN3890 MPR121 capacitive sensing filtering and timing AN3891 MPR121 touch sensing baseline system AN3892 MPR121 touch sensing jitter and false touch rejection AN3893 MPR121 proximity sensing AN3894 MPR121 LED driver system AN3895 MPR121 serial communication AN4600 MPR121 Designing a Touch Panel MPR121 Evaluation board schematics Wiring breakout boards ~ Breakout ESP VCC/VIN +3.3VDC GND GND SCL GPIO I 2 SCL SDA GPIO I 2 SDA IRQ NC I 2 C address selection ~ Connect the ADD(R) pin/pad to one of the following pins/pads: Address ADD(R) 0x5A NC 0x5B +3.3VDC 0x5C GPIO I 2 SDA 0x5D GPIO I 2 SCL Tasmota SettingsCompile Tasmota with #define USE_MPR121 added in user_config_override.h ~ The driver will detect the I 2 C addresses of the MPR121s automatically. The MPR121 chip (or breakout board) must be connected to the ESP8266 and the I 2 C GPIO pins must be configured: Generally available types of breakout boards ~","title":"MPR121 capacitive touch sensor"},{"location":"MPR121/#mpr121-capacitive-touch-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_MPR121 #define USE_MPR121 // [I2cDriver23] Enable MPR121 controller (I2C addresses 0x5A, 0x5B, 0x5C and 0x5D) in input mode for touch buttons (+1k3 code) #endif 12-button or touch pad I 2 C controller Driver supports up to 4x MPR121 controllers (= 48 buttons per ESP8266) Electrodes can be covered with adhesive paper and adhesive plastic foil for labeling and symbols Break-out and touch button PCBs ~ 2\u20ac at AliExpress Break-out PCB ~ $8 at Adafruit","title":"MPR121 capacitive touch sensor"},{"location":"MPR121/#technical-data-from-the-manufacturer","text":"MPR121 Fact sheet MPR121 Data sheet AN3889 MPR121 capacitive sensing settings AN3890 MPR121 capacitive sensing filtering and timing AN3891 MPR121 touch sensing baseline system AN3892 MPR121 touch sensing jitter and false touch rejection AN3893 MPR121 proximity sensing AN3894 MPR121 LED driver system AN3895 MPR121 serial communication AN4600 MPR121 Designing a Touch Panel MPR121 Evaluation board schematics","title":"Technical Data from the manufacturer"},{"location":"MPR121/#wiring-breakout-boards","text":"Breakout ESP VCC/VIN +3.3VDC GND GND SCL GPIO I 2 SCL SDA GPIO I 2 SDA IRQ NC","title":"Wiring breakout boards"},{"location":"MPR121/#i2c-address-selection","text":"Connect the ADD(R) pin/pad to one of the following pins/pads: Address ADD(R) 0x5A NC 0x5B +3.3VDC 0x5C GPIO I 2 SDA 0x5D GPIO I 2 SCL","title":"I2C address selection"},{"location":"MPR121/#tasmota-settingscompile-tasmota-with-define-use_mpr121-added-in-user_config_overrideh","text":"The driver will detect the I 2 C addresses of the MPR121s automatically. The MPR121 chip (or breakout board) must be connected to the ESP8266 and the I 2 C GPIO pins must be configured:","title":"Tasmota SettingsCompile Tasmota with #define USE_MPR121 added in user_config_override.h"},{"location":"MPR121/#generally-available-types-of-breakout-boards","text":"","title":"Generally available types of breakout boards"},{"location":"MPU-6050/","text":"MPU-6050 gyroscope and accelerometer ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : ```arduino #ifndef USE_MPU6050 #define USE_MPU6050 // [I2cDriver25] Enable MPU6050 sensor (I2C address 0x68 AD0 low or 0x69 AD0 high) (+3K3 of code and 188 Bytes of RAM) #define USE_MPU6050_DMP // Enable in MPU6050 to use the DMP on the chip, should create better results (+8k6 of code) #endif ``` The MPU-6050 combines a 3-axis gyroscope and a 3-axis accelerometer on the same silicon die, together with an onboard Digital Motion Processor\u2122 (DMP\u2122), which processes complex 6-axis MotionFusion algorithms. Datasheet Configuration ~ Wiring ~ MPU-6050 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy XDA XCL AD0 INT Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect MCU-69050 automatically and display measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-12-10T19:37:50\" , \"MPU6050\" :{ \"Temperature\" : 27.7 , \"AccelXAxis\" : -7568.00 , \"AccelYAxis\" : -776.00 , \"AccelZAxis\" : 12812.00 , \"GyroXAxis\" : 270.00 , \"GyroYAxis\" : -741.00 , \"GyroZAxis\" : 700.00 }, \"TempUnit\" : \"C\" } Digital Motion Processor Enabled ~ If you define flag #define USE_MPU6050_DMP // Enable in MPU6050 to use the DMP on the chip, should create better results (+8k6 of code) enabling Digital Motion Processor\u2122 (DMP\u2122) you will get additional Yaw, Pitch and Roll measurements and more accurate measurements overall Sensor sends an expanded tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-12-10T19:24:55\" , \"MPU6050\" :{ \"Temperature\" : 25.0 , \"AccelXAxis\" : 756.00 , \"AccelYAxis\" : -1409.00 , \"AccelZAxis\" : 2152.00 , \"GyroXAxis\" : 0.00 , \"GyroYAxis\" : -1.00 , \"GyroZAxis\" : 10.00 , \"Yaw\" : 0.86 , \"Pitch\" : -1.45 , \"Roll\" : -10.76 }, \"TempUnit\" : \"C\" } Breakout Boards ~ Rule Triggers ~ The following trigger events are supported for use in Rules : ON MPU6050#Temperature DO <command> ENDON ON MPU6050#AccelXAxis DO <command> ENDON ON MPU6050#AccelYAxis DO <command> ENDON ON MPU6050#AccelZAxis DO <command> ENDON ON MPU6050#GyroXAxis DO <command> ENDON ON MPU6050#GyroYAxis DO <command> ENDON ON MPU6050#GyroZAxis DO <command> ENDON ON MPU6050#Yaw DO <command> ENDON ON MPU6050#Roll DO <command> ENDON ON MPU6050#Pitch DO <command> ENDON Example: ON MPU6050#Yaw DO publish espMotion/sensor/data/Yaw %value% ENDON","title":"MPU-6050 gyroscope and accelerometer"},{"location":"MPU-6050/#mpu-6050-gyroscope-and-accelerometer","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : ```arduino #ifndef USE_MPU6050 #define USE_MPU6050 // [I2cDriver25] Enable MPU6050 sensor (I2C address 0x68 AD0 low or 0x69 AD0 high) (+3K3 of code and 188 Bytes of RAM) #define USE_MPU6050_DMP // Enable in MPU6050 to use the DMP on the chip, should create better results (+8k6 of code) #endif ``` The MPU-6050 combines a 3-axis gyroscope and a 3-axis accelerometer on the same silicon die, together with an onboard Digital Motion Processor\u2122 (DMP\u2122), which processes complex 6-axis MotionFusion algorithms. Datasheet","title":"MPU-6050 gyroscope and accelerometer"},{"location":"MPU-6050/#configuration","text":"","title":"Configuration"},{"location":"MPU-6050/#wiring","text":"MPU-6050 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy XDA XCL AD0 INT","title":"Wiring"},{"location":"MPU-6050/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect MCU-69050 automatically and display measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele / tas mo ta /SENSOR = { \"Time\" : \"2019-12-10T19:37:50\" , \"MPU6050\" :{ \"Temperature\" : 27.7 , \"AccelXAxis\" : -7568.00 , \"AccelYAxis\" : -776.00 , \"AccelZAxis\" : 12812.00 , \"GyroXAxis\" : 270.00 , \"GyroYAxis\" : -741.00 , \"GyroZAxis\" : 700.00 }, \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"MPU-6050/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MPU-6050/#rule-triggers","text":"The following trigger events are supported for use in Rules : ON MPU6050#Temperature DO <command> ENDON ON MPU6050#AccelXAxis DO <command> ENDON ON MPU6050#AccelYAxis DO <command> ENDON ON MPU6050#AccelZAxis DO <command> ENDON ON MPU6050#GyroXAxis DO <command> ENDON ON MPU6050#GyroYAxis DO <command> ENDON ON MPU6050#GyroZAxis DO <command> ENDON ON MPU6050#Yaw DO <command> ENDON ON MPU6050#Roll DO <command> ENDON ON MPU6050#Pitch DO <command> ENDON Example: ON MPU6050#Yaw DO publish espMotion/sensor/data/Yaw %value% ENDON","title":"Rule Triggers"},{"location":"MQTT/","text":"MQTT is the main protocol for controlling Tasmota devices After you have a working MQTT broker you need to configure Tasmota to communicate with it. If you have no knowledge of what MQTT is, you can learn about it from MQTT Essentials articles. Configure MQTT ~ If you flashed a precompiled .bin or didn't enter MQTT info in user_config_override.h before compiling you have to configure it on your device first. Configure MQTT using WebUI ~ Go to Configuration -> Configure Other and make sure \"MQTT Enable\" box is checked. Once MQTT is enabled you need to set it up using Configuration -> Configure MQTT . Tip While here, you might as well change the Friendly Name into something more descriptive than generic \"Tasmota\". This is highly recommended for Home Assistant autodiscovery feature. For a basic setup you only need to set Host , User and Password but it is recommended to change Topic to avoid issues. Each device should have a unique Topic . Host = your MQTT broker address or IP ( mDNS is not available in the official Tasmota builds , means no .local domain!) Port = your MQTT broker port (default port is set to 1883) Client = device's unique identifier. In 99% of cases it's okay to leave it as is, however some Cloud-based MQTT brokers require a ClientID connected to your account. Can not be identical to Topic! User = username for authenticating on your MQTT broker Password = password for authenticating on your MQTT broker Topic = unique identifying topic for your device (e.g. hallswitch , kitchen-light ). %topic% in wiki references to this. It is recommended to use a single word for the topic. FullTopic = full topic definition . Modify it if you want to use multi-level topics for your devices, for example lights/%prefix%/%topic%/ or %prefix%/top_floor/bathroom/%topic%/ etc. Configure MQTT using Backlog ~ Using a serial connection or the WebUI Console you can issue (or even better, paste a premade) Backlog command for quick and easy MQTT setup. Backlog mqtthost < mqtt_broker_address > ; mqttport < mqtt_broker_port > ; mqttuser < username > ; mqttpassword < password > ; topic < device_topic > After a reboot all necessary MQTT settings are configured. Don't forget, you can use Backlog for all commands! Commands over MQTT ~ To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued to Tasmota by using topic cmnd/%topic%/<command> and payload <parameter> . If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . Tip If you are using mosquitto_pub , you can issue an empty payload using the -n command line option. If your MQTT client cannot issue an empty payload, you can use the single character ? instead. Command flow ~ The following example will go in depth on what happens when you send an MQTT command. A device was flashed and configured with the FullTopic as default %prefix%/%topic%/ and the Topic set to tasmota_switch . We want to see the current status of the switch and change it. By looking at the commands table we can learn about the POWER command and options associated with it. Ask the device for status ~ cmnd / tasmota_switch / Power \u2190 // an empty message/payload sends a status query \u21b3 stat / tasmota_switch / RESULT \u2192 { \"POWER\" : \"OFF\" } \u21b3 stat / tasmota_switch / POWER \u2192 OFF We can see that the switch (device's relay) is turned off. Send a command to toggle the relay ~ cmnd / tasmota_switch / Power TOGGLE \u21b3 // Power for relay 1 is toggled \u21b3 stat / tasmota_switch / RESULT \u2192 { \"POWER\" : \"ON\" } \u21b3 stat / tasmota_switch / POWER \u2192 ON We've sent the toggle command and received confirmation that the switch is turned on. Tip By default, Tasmota replies to all commands through .../RESULT . This behavior can be changed using SetOption4 , which makes the commands reply on the endpoint matching the command name, ex. cmnd/tasmota/PowerOnState will send a response on stat/tasmota/POWERONSTATE . Examples ~ In the following examples %topic% is tasmota , FullTopic is %prefix%/%topic%/ , and prefixes are default cmnd/stat/tele : The relay can be controlled with cmnd/tasmota/POWER on , cmnd/tasmota/POWER off or cmnd/tasmota/POWER toggle . Tasmota will send a MQTT status message like stat/tasmota/POWER ON . Power state message can be sent with the retain flag set using PowerRetain 1 . Telemetry messages can also be sent with the retain flag using SensorRetain . For Sonoff Dual or Sonoff 4CH the relays need to be addressed with cmnd/tasmota/POWER<x> , where {x} is the relay number from 1 to 2 (Sonoff Dual) or from 1 to 4 (Sonoff 4CH). cmnd/tasmota/POWER4 off turns off the 4th relay on a Sonoff 4CH. MQTT topic can be changed with cmnd/tasmota/Topic tasmota1 which reboots Tasmota and changes the %topic% to tasmota1 . From that point on MQTT commands should look like cmnd/tasmota1/POWER on . The OTA firmware location can be made known to tasmota with cmnd/tasmota/OtaUrl http://ota.tasmota.com/tasmota/release/tasmota.bin . Reset to default with cmnd/tasmota/OtaUrl 1 . Upgrade OTA firmware from the OtaUrl server with cmnd/tasmota/Upgrade 1 . Show all status information with cmnd/tasmota/Status 0 . The button can send a MQTT message to the broker that in turn will switch the relay. To configure this you need to perform cmnd/tasmota/ButtonTopic tasmota where tasmota equals to Topic. The message can also be provided with the retain flag by cmnd/tasmota/ButtonRetain on . Sonoff Pow (and any device with sensors) status can be requested manually with cmnd/tasmota/status 8 . Additionally, Tasmota periodically sends telemetry every TelePeriod , which defaults to 300 seconds (5 minutes). When a Sonoff Pow (and any device with power metering sensors) threshold like PowerLow has been met a message tele/tasmota/POWER_LOW ON will be sent. When the error is corrected a message tele/tasmota/POWER_LOW OFF will be sent. While most MQTT commands will result in a message in JSON format the power status feedback will always be returned like stat/tasmota/POWER ON as well. Telemetry data will be sent by prefix tele like tele/tasmota/SENSOR {\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}} MQTT Topic Definition ~ FullTopic ~ This is the MQTT topic used to communicate with Tasmota over MQTT. It is created using tokens placed within a user definable string (100 character limit). The tokens are substituted dynamically at run-time. Available substitution tokens are: %prefix% = one of three prefixes as defined by commands Prefix1 (default = cmnd ) , Prefix2 (default = stat ) and Prefix3 (default = tele ) . %topic% = one of five topics as defined by commands Topic , GroupTopic , ButtonTopic , SwitchTopic and MqttClient . %hostname% = the hostname of the device as defined through the web UI (default = %s-%04d ) or via Hostname command. %id% = MAC address of the device. Tip These substitution tokens will be used in examples across the documentation If FullTopic does not contain the %topic% token, the device will not subscribe to GroupTopic and FallbackTopic . Tip The order of %prefix% and %topic% doesn't matter, unless you have enabled Auto-discovery for Home Assistant ( SetOption19 ). Enabling this option re-formats the FullTopic to required order. Using the tokens the following example topics can be made: FullTopic %prefix%/%topic%/ default FullTopic tasmota/%topic%/%prefix%/ FullTopic tasmota/bedroom/%topic%/%prefix%/ FullTopic penthouse/bedroom1/bathroom2/%topic%/%prefix%/ FullTopic %prefix%/home/cellar/%topic%/ %prefix% ~ Tasmota uses 3 prefixes for forming a FullTopic: cmnd - prefix to issue commands; ask for status stat - reports back status or configuration message tele - reports telemetry info at specified intervals Warning To solve possible MQTT topic loops it is strongly suggested that you use the %prefix% token in all of your FullTopics. Status and telemetry do not need a prefix. %topic% ~ All MQTT status messages will be sent using the configurable %topic% which must be made unique by the user. It can be called bedroom but it could also be called XP-TS_10 as long as the user knows what it is and where to find it. Default Topic is tasmota_XXXXXX where XXXXXX is unique and derives from the last 6 characters of the MAC address The use of the %topic% token is mandatory in case you want to use ButtonTopic and/or SwitchTopic . It also provides for GroupTopic and Fallback Topic functionality. Tip Use %prefix% and %topic% tokens at all time within your FullTopic definition! GroupTopic ~ Having two devices with the same topic allowed for MQTT commands to be sent once to make the devices act in conjunction. That inspired a third topic called GroupTopic. Devices with the same GroupTopic will all listen to that GroupTopic and react to the same MQTT command sent to it. You can use this to take global actions like updating firmware on all devices or split up devices into different groups using a unique GroupTopic for each group. Default GroupTopic is tasmotas FallBack Topic ~ Initially Tasmota had one MQTT configurable topic planned called Topic. It soon became apparent that when two devices come online with the same topic this would be a challenge, to say the least! Tasmota then introduced a unique, non-configurable \"FallBack Topic\" that allows MQTT communication regardless of the configurable topic. This fallback topic is just what it is meant to be: a fallback topic in case of emergency! By default the Fallback Topic is DVES_XXXXXX_fb where xxxxxx is derived from the last 6 characters of the device's MAC address (excluding : ). It might look something like this: DVES_3D5E26_fb . You can find out the DVES code by looking at Information page in the webUI or issuing Status 6 : 12 : 36 : 17 MQT : s tat / tas mo ta /STATUS 6 = { \"StatusMQT\" :{ \"MqttHost\" : \"1.1.1.1\" , \"MqttPort\" : 1883 , \"MqttClientMask\" : \"DVES_%06X\" , \"MqttClient\" : \"DVES_3D5E26\" , \"MqttUser\" : \"tasmota\" , \"MqttCount\" : 1 , \"MAX_PACKET_SIZE\" : 1000 , \"KEEPALIVE\" : 30 }} LWT Topic (Last Will and Testament) ~ On connection to the MQTT broker tasmota uses the Last Will and Testament (LWT) feature that instructs the broker to generate a notification about an ungracefully disconnect or timeout. The topic to listen to for the state of this specific client is tele/<TOPIC>/LWT that with the mosquitto MQTT broker produces an output like: $ mosquitto_sub -t \"tele/tasmota_XXXXXX/LWT\" Offline Online The full LWT topic can be found in the tasmota console at boot: 15:51:51.281 MQT: tele/tasmota_XXXXXX/LWT = Online (retained) Retained MQTT Messages ~ If MQTT is defined and PowerRetain is used the last state will be stored permanently in MQTT database. Command Description PowerRetain Show current MQTT power retain state. 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update BUT , a message in your MQTT broker flagged as 'retained' will always override the PowerOnState . This is usually the main cause for \"ghost switching\". Learn more in MQTT retained messages explained . Check out this tutorial for troubleshooting switch ghosting. Clearing Retained Messages ~ To check, if there is a retain flag set for the switch's power topic, monitor cmnd/+/power in a MQTT client (recommended MQTT.fx for Windows or Eclipse Mosquitto in linux). You can use Tasmota Device Manager to clear all retained messages for selected device with a single click. or use the following tutorials/forum threads: Clearing retained messages with mosquitto Remove retained messages in Home Assistant Remove retained messages in hass.io MQTT addon Subscribe/Unsubscribe ~ This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef SUPPORT_MQTT_EVENT #define SUPPORT_MQTT_EVENT #endif Subscribe ~ Subscribes to an MQTT topic and assigns an Event name to it. Subscribe <eventName>, <mqttTopic> [, <key>] The <key> parameter is specified when you need to parse a key/value pair from a JSON payload in the MQTT message. In order to parse a value from a multi-level JSON pair, you can use one dot ( . ) syntax to split the key into sections. You subscribe to an MQTT topic and assign an event name. Once the subscribed MQTT message is received the configured event will be triggered. Command without any parameters will list all currently subscribed topics. You can set up a rule with ON EVENT#<event_name> DO ... ENDON to do what you want based on this MQTT message. The payload is passed as a parameter once the event has been triggered. If the payload is in JSON format, you are able to get the value of specified key as a parameter. For example, if you have a Tasmota based thermostat and multiple temperature sensors in different locations, usually you have to set up a home automation system like Domoticz to control the thermostat. Right now, with this new feature, you can write a rule to do this. Examples ~ Rule1 ON mqtt#connected DO Subscribe BkLight, stat/other-device-topic/POWER ENDON ON Event#BkLight=ON DO <command> ENDON Rule1 ON mqtt#connected DO Subscribe DnTemp, stat/other-device-topic/SENSOR, DS18B20.Temperature ENDON ON Event#DnTemp>=21 DO <command> ENDON where the MQTT message payload is {\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}} Rule1 ON mqtt#connected DO Subscribe DnTemp, stat/other-device-topic/SENSOR, DS18B20.Temperature ENDON ON Event#DnTemp DO TempMeasuredSet %value% ENDON will allow a thermostat to subscribe to a temperature sensor on another Tasmota device ON Event#DnTemp DO TempMeasuredSet %value% ENDON Will allow a thermostat to subscribe to a temperature sensor on another Tasmota device Unsubscribe ~ Unsubscribe from topics which were subscribed to using the Subscribe command. Unsubscribe from a specific MQTT topic Unsubscribe <eventName> The command without a parameter will unsubscribe from all currently subscribed topics. Return codes (rc) ~ Sometimes, something wrong can happen and you might need to check return codes. A return code can be found in the console, example output for Return Code = 5 : MQT: Connect failed to xxxx:1883, rc 5. Retry in 10 sec Below table provides more information about it. The original values are related to PubSubClient.h constants . Code Constant name Description -5 MQTT_DNS_DISCONNECTED the DNS server cannot be reached or name cannot be resolved -4 MQTT_CONNECTION_TIMEOUT the server didn't respond within the keepalive time -3 MQTT_CONNECTION_LOST the network connection was broken -2 MQTT_CONNECT_FAILED the network connection failed -1 MQTT_DISCONNECTED the client is disconnected cleanly 0 MQTT_CONNECTED the client is connected 1 MQTT_CONNECT_BAD_PROTOCOL the server doesn't support the requested version of MQTT 2 MQTT_CONNECT_BAD_CLIENT_ID the server rejected the client identifier 3 MQTT_CONNECT_UNAVAILABLE the server was unable to accept the connection 4 MQTT_CONNECT_BAD_CREDENTIALS the username/password were rejected 5 MQTT_CONNECT_UNAUTHORIZED the client was not authorized to connect","title":"MQTT"},{"location":"MQTT/#configure-mqtt","text":"If you flashed a precompiled .bin or didn't enter MQTT info in user_config_override.h before compiling you have to configure it on your device first.","title":"Configure MQTT"},{"location":"MQTT/#configure-mqtt-using-webui","text":"Go to Configuration -> Configure Other and make sure \"MQTT Enable\" box is checked. Once MQTT is enabled you need to set it up using Configuration -> Configure MQTT . Tip While here, you might as well change the Friendly Name into something more descriptive than generic \"Tasmota\". This is highly recommended for Home Assistant autodiscovery feature. For a basic setup you only need to set Host , User and Password but it is recommended to change Topic to avoid issues. Each device should have a unique Topic . Host = your MQTT broker address or IP ( mDNS is not available in the official Tasmota builds , means no .local domain!) Port = your MQTT broker port (default port is set to 1883) Client = device's unique identifier. In 99% of cases it's okay to leave it as is, however some Cloud-based MQTT brokers require a ClientID connected to your account. Can not be identical to Topic! User = username for authenticating on your MQTT broker Password = password for authenticating on your MQTT broker Topic = unique identifying topic for your device (e.g. hallswitch , kitchen-light ). %topic% in wiki references to this. It is recommended to use a single word for the topic. FullTopic = full topic definition . Modify it if you want to use multi-level topics for your devices, for example lights/%prefix%/%topic%/ or %prefix%/top_floor/bathroom/%topic%/ etc.","title":"Configure MQTT using WebUI"},{"location":"MQTT/#configure-mqtt-using-backlog","text":"Using a serial connection or the WebUI Console you can issue (or even better, paste a premade) Backlog command for quick and easy MQTT setup. Backlog mqtthost < mqtt_broker_address > ; mqttport < mqtt_broker_port > ; mqttuser < username > ; mqttpassword < password > ; topic < device_topic > After a reboot all necessary MQTT settings are configured. Don't forget, you can use Backlog for all commands!","title":"Configure MQTT using Backlog"},{"location":"MQTT/#commands-over-mqtt","text":"To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued to Tasmota by using topic cmnd/%topic%/<command> and payload <parameter> . If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . Tip If you are using mosquitto_pub , you can issue an empty payload using the -n command line option. If your MQTT client cannot issue an empty payload, you can use the single character ? instead.","title":"Commands over MQTT"},{"location":"MQTT/#command-flow","text":"The following example will go in depth on what happens when you send an MQTT command. A device was flashed and configured with the FullTopic as default %prefix%/%topic%/ and the Topic set to tasmota_switch . We want to see the current status of the switch and change it. By looking at the commands table we can learn about the POWER command and options associated with it.","title":"Command flow"},{"location":"MQTT/#examples","text":"In the following examples %topic% is tasmota , FullTopic is %prefix%/%topic%/ , and prefixes are default cmnd/stat/tele : The relay can be controlled with cmnd/tasmota/POWER on , cmnd/tasmota/POWER off or cmnd/tasmota/POWER toggle . Tasmota will send a MQTT status message like stat/tasmota/POWER ON . Power state message can be sent with the retain flag set using PowerRetain 1 . Telemetry messages can also be sent with the retain flag using SensorRetain . For Sonoff Dual or Sonoff 4CH the relays need to be addressed with cmnd/tasmota/POWER<x> , where {x} is the relay number from 1 to 2 (Sonoff Dual) or from 1 to 4 (Sonoff 4CH). cmnd/tasmota/POWER4 off turns off the 4th relay on a Sonoff 4CH. MQTT topic can be changed with cmnd/tasmota/Topic tasmota1 which reboots Tasmota and changes the %topic% to tasmota1 . From that point on MQTT commands should look like cmnd/tasmota1/POWER on . The OTA firmware location can be made known to tasmota with cmnd/tasmota/OtaUrl http://ota.tasmota.com/tasmota/release/tasmota.bin . Reset to default with cmnd/tasmota/OtaUrl 1 . Upgrade OTA firmware from the OtaUrl server with cmnd/tasmota/Upgrade 1 . Show all status information with cmnd/tasmota/Status 0 . The button can send a MQTT message to the broker that in turn will switch the relay. To configure this you need to perform cmnd/tasmota/ButtonTopic tasmota where tasmota equals to Topic. The message can also be provided with the retain flag by cmnd/tasmota/ButtonRetain on . Sonoff Pow (and any device with sensors) status can be requested manually with cmnd/tasmota/status 8 . Additionally, Tasmota periodically sends telemetry every TelePeriod , which defaults to 300 seconds (5 minutes). When a Sonoff Pow (and any device with power metering sensors) threshold like PowerLow has been met a message tele/tasmota/POWER_LOW ON will be sent. When the error is corrected a message tele/tasmota/POWER_LOW OFF will be sent. While most MQTT commands will result in a message in JSON format the power status feedback will always be returned like stat/tasmota/POWER ON as well. Telemetry data will be sent by prefix tele like tele/tasmota/SENSOR {\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}}","title":"Examples"},{"location":"MQTT/#mqtt-topic-definition","text":"","title":"MQTT Topic Definition"},{"location":"MQTT/#fulltopic","text":"This is the MQTT topic used to communicate with Tasmota over MQTT. It is created using tokens placed within a user definable string (100 character limit). The tokens are substituted dynamically at run-time. Available substitution tokens are: %prefix% = one of three prefixes as defined by commands Prefix1 (default = cmnd ) , Prefix2 (default = stat ) and Prefix3 (default = tele ) . %topic% = one of five topics as defined by commands Topic , GroupTopic , ButtonTopic , SwitchTopic and MqttClient . %hostname% = the hostname of the device as defined through the web UI (default = %s-%04d ) or via Hostname command. %id% = MAC address of the device. Tip These substitution tokens will be used in examples across the documentation If FullTopic does not contain the %topic% token, the device will not subscribe to GroupTopic and FallbackTopic . Tip The order of %prefix% and %topic% doesn't matter, unless you have enabled Auto-discovery for Home Assistant ( SetOption19 ). Enabling this option re-formats the FullTopic to required order. Using the tokens the following example topics can be made: FullTopic %prefix%/%topic%/ default FullTopic tasmota/%topic%/%prefix%/ FullTopic tasmota/bedroom/%topic%/%prefix%/ FullTopic penthouse/bedroom1/bathroom2/%topic%/%prefix%/ FullTopic %prefix%/home/cellar/%topic%/","title":"FullTopic"},{"location":"MQTT/#topic","text":"All MQTT status messages will be sent using the configurable %topic% which must be made unique by the user. It can be called bedroom but it could also be called XP-TS_10 as long as the user knows what it is and where to find it. Default Topic is tasmota_XXXXXX where XXXXXX is unique and derives from the last 6 characters of the MAC address The use of the %topic% token is mandatory in case you want to use ButtonTopic and/or SwitchTopic . It also provides for GroupTopic and Fallback Topic functionality. Tip Use %prefix% and %topic% tokens at all time within your FullTopic definition!","title":"%topic%"},{"location":"MQTT/#grouptopic","text":"Having two devices with the same topic allowed for MQTT commands to be sent once to make the devices act in conjunction. That inspired a third topic called GroupTopic. Devices with the same GroupTopic will all listen to that GroupTopic and react to the same MQTT command sent to it. You can use this to take global actions like updating firmware on all devices or split up devices into different groups using a unique GroupTopic for each group. Default GroupTopic is tasmotas","title":"GroupTopic"},{"location":"MQTT/#fallback-topic","text":"Initially Tasmota had one MQTT configurable topic planned called Topic. It soon became apparent that when two devices come online with the same topic this would be a challenge, to say the least! Tasmota then introduced a unique, non-configurable \"FallBack Topic\" that allows MQTT communication regardless of the configurable topic. This fallback topic is just what it is meant to be: a fallback topic in case of emergency! By default the Fallback Topic is DVES_XXXXXX_fb where xxxxxx is derived from the last 6 characters of the device's MAC address (excluding : ). It might look something like this: DVES_3D5E26_fb . You can find out the DVES code by looking at Information page in the webUI or issuing Status 6 : 12 : 36 : 17 MQT : s tat / tas mo ta /STATUS 6 = { \"StatusMQT\" :{ \"MqttHost\" : \"1.1.1.1\" , \"MqttPort\" : 1883 , \"MqttClientMask\" : \"DVES_%06X\" , \"MqttClient\" : \"DVES_3D5E26\" , \"MqttUser\" : \"tasmota\" , \"MqttCount\" : 1 , \"MAX_PACKET_SIZE\" : 1000 , \"KEEPALIVE\" : 30 }}","title":"FallBack Topic"},{"location":"MQTT/#lwt-topic-last-will-and-testament","text":"On connection to the MQTT broker tasmota uses the Last Will and Testament (LWT) feature that instructs the broker to generate a notification about an ungracefully disconnect or timeout. The topic to listen to for the state of this specific client is tele/<TOPIC>/LWT that with the mosquitto MQTT broker produces an output like: $ mosquitto_sub -t \"tele/tasmota_XXXXXX/LWT\" Offline Online The full LWT topic can be found in the tasmota console at boot: 15:51:51.281 MQT: tele/tasmota_XXXXXX/LWT = Online (retained)","title":"LWT Topic (Last Will and Testament)"},{"location":"MQTT/#retained-mqtt-messages","text":"If MQTT is defined and PowerRetain is used the last state will be stored permanently in MQTT database. Command Description PowerRetain Show current MQTT power retain state. 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update BUT , a message in your MQTT broker flagged as 'retained' will always override the PowerOnState . This is usually the main cause for \"ghost switching\". Learn more in MQTT retained messages explained . Check out this tutorial for troubleshooting switch ghosting.","title":"Retained MQTT Messages"},{"location":"MQTT/#clearing-retained-messages","text":"To check, if there is a retain flag set for the switch's power topic, monitor cmnd/+/power in a MQTT client (recommended MQTT.fx for Windows or Eclipse Mosquitto in linux). You can use Tasmota Device Manager to clear all retained messages for selected device with a single click. or use the following tutorials/forum threads: Clearing retained messages with mosquitto Remove retained messages in Home Assistant Remove retained messages in hass.io MQTT addon","title":"Clearing Retained Messages"},{"location":"MQTT/#subscribeunsubscribe","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef SUPPORT_MQTT_EVENT #define SUPPORT_MQTT_EVENT #endif","title":"Subscribe/Unsubscribe"},{"location":"MQTT/#subscribe","text":"Subscribes to an MQTT topic and assigns an Event name to it. Subscribe <eventName>, <mqttTopic> [, <key>] The <key> parameter is specified when you need to parse a key/value pair from a JSON payload in the MQTT message. In order to parse a value from a multi-level JSON pair, you can use one dot ( . ) syntax to split the key into sections. You subscribe to an MQTT topic and assign an event name. Once the subscribed MQTT message is received the configured event will be triggered. Command without any parameters will list all currently subscribed topics. You can set up a rule with ON EVENT#<event_name> DO ... ENDON to do what you want based on this MQTT message. The payload is passed as a parameter once the event has been triggered. If the payload is in JSON format, you are able to get the value of specified key as a parameter. For example, if you have a Tasmota based thermostat and multiple temperature sensors in different locations, usually you have to set up a home automation system like Domoticz to control the thermostat. Right now, with this new feature, you can write a rule to do this.","title":"Subscribe"},{"location":"MQTT/#unsubscribe","text":"Unsubscribe from topics which were subscribed to using the Subscribe command. Unsubscribe from a specific MQTT topic Unsubscribe <eventName> The command without a parameter will unsubscribe from all currently subscribed topics.","title":"Unsubscribe"},{"location":"MQTT/#return-codes-rc","text":"Sometimes, something wrong can happen and you might need to check return codes. A return code can be found in the console, example output for Return Code = 5 : MQT: Connect failed to xxxx:1883, rc 5. Retry in 10 sec Below table provides more information about it. The original values are related to PubSubClient.h constants . Code Constant name Description -5 MQTT_DNS_DISCONNECTED the DNS server cannot be reached or name cannot be resolved -4 MQTT_CONNECTION_TIMEOUT the server didn't respond within the keepalive time -3 MQTT_CONNECTION_LOST the network connection was broken -2 MQTT_CONNECT_FAILED the network connection failed -1 MQTT_DISCONNECTED the client is disconnected cleanly 0 MQTT_CONNECTED the client is connected 1 MQTT_CONNECT_BAD_PROTOCOL the server doesn't support the requested version of MQTT 2 MQTT_CONNECT_BAD_CLIENT_ID the server rejected the client identifier 3 MQTT_CONNECT_UNAVAILABLE the server was unable to accept the connection 4 MQTT_CONNECT_BAD_CREDENTIALS the username/password were rejected 5 MQTT_CONNECT_UNAUTHORIZED the client was not authorized to connect","title":"Return codes (rc)"},{"location":"MacOSX-Server/","text":"Mac OSX comes with a built in web server, although it's not running by default. Starting the web server can be done by running: sudo apachectl start To start the server, you'll be asked for your user's password. Opening your localhost will show you 'it works!', which will tell you that much - it works. The folder to put files in is /Library/WebServer/Documents You may wish to create a subfolder for the firmware files. Use the IP address of this local web server to OTA flash Tasmota. You can determine your IP address here . For example, http://192.168.1.123/tasmota.bin Issue this command to stop the web server when your are done flashing: sudo apachectl stop Note: The MAMP web server does not seem to deliver the results as expected!","title":"MacOSX Server"},{"location":"Modbus-Bridge/","text":"Modbus Bridge ~ Add a \"Modbus bridge\" functionality to a device that is otherwise serial Modbus RTU only This feature is only included in tasmota32 binary When compiling your build add the following to user_config_override.h : #ifndef USE_MODBUS_BRIDGE #define USE_MODBUS_BRIDGE // Add support for software Modbus Bridge (+3k code) #define USE_MODBUS_BRIDGE_TCP // Add support for software Modbus TCP Bridge (Must also enable USE_MODBUS_BRIDGE) #endif In most cases you'll need an RS485 converter like this: Introduction ~ Connect the Modbus device to an ESP and Tasmota will create a bridge to the Modbus network. The Modbus Bridge driver features 2 kind of bridges. USE_MODBUS_BRIDGE : The bridge can be used by commands in the console and via MQTT messages. USE_MODBUS_BRIDGE_TCP : The bridge can be used by commands in the console and via MQTT messages but also as Modbus TCP/IP bridge Configuration ~ First assign two GPIOs to ModBR Tx and ModBR Rx in the \"Configure Module\" page. The Rx/Tx are relative to the ESP device. For example with ESP-12's hardware serial, set GPIO1 as ModBR Tx and GPIO3 as ModBR Rx. Then set baud rate with ModbusSetBaudRate (default is 9600). Commands ~ Command Parameters ModbusSend Sending a message to the Modbus network as JSON payload. {\"deviceAddress\":<value>, \"functionCode\":<value>, \"startAddress\":<value>, \"type\":\"<value>\",\"count\":<value>} \u2003\u2003 \"deviceAddress\":1..255 = device address from the Modbus slave. \u2003\u2003 \"functioncode\":1..6 or 15..16 = function code to send to the Modbus slave (see table below). \u2003\u2003 \"startaddress\":1..65535 address of the first register to read. \u2003\u2003 \"type\":\"<value>\" Gives the type of the returned data (see table below). \u2003\u2003 \"count\":1..n the number of values to be requested. ModbusBaudrate ModbusSerialConfig FunctionCode ~ Function Code Description 1 Read Coils 2 Read Discrete Inputs 3 Read Multiple Holding Registers 4 Read Input Registers 5 Write Single Coil 6 Write Single Register 15 Write Multiple Coils 16 Write Multiple Registers Type ~ Type Description raw Return or send the slave data as a raw values bit Return or send the slave data as a bit values hex Return or send the slave data as a hex values float Return or send the slave data as floats uint8 Return or send the slave data as an 8 bits unsigned int uint32 Return or send the slave data as an 32 bits unsigned int uint16 Return or send the slave data as an 16 bits unsigned int uint32 Return or send the slave data as an 32 bits unsigned int int8 Return or send the slave data as an 8 bits signed int int16 Return or send the slave data as an 16 bits signed int int32 Return or send the slave data as an 32 bits signed int Additional commands for USE_MODBUS_TCP_BRIDGE ~ Command Parameters ModbusTcpStart Start the Modbus TCP bridge on the specified tcp port ModbusTcpConnect Returned Data ~ { \"ModbusReceived\" :{ \"DeviceAddress\" : <value> , \"FunctionCode\" : <value> , \"StartAddress\" : <value> , \"Length\" : <value> , \"Count\" : <value> , \"Values\" :[ value 1 , value 2 , value 3 , valueN ]}} In raw mode, only the data is returned, no other fields. Error Codes ~ There are 2 types of errors, errors from the tasmotamodbus driver and errors from this Modbusbridge module. Module Errors ~ Errors from this Modbus bridge module can be recognized by MBS: MBR Send error or MBS: MBR Recv error at the start of the errormessage. Errorcode Description 1 nodataexpected 2 wrongdeviceaddress 3 wrongfunctioncode 4 wrongstartaddress 5 wrongtype 6 wrongregistercount 7 wrongcount 8 tomanydata Driver Errors ~ Errors from the tasmotamodbus driver can be recognized by MBS: MBR Driver error Errorcode Description 1 Illegal Function 2 Illegal Data Address 3 Illegal Data Value 4 Slave Error 5 Acknowledge but not finished (no error) 6 Slave Busy 7 Not enough minimal data received 8 Memory Parity error 9 Crc error 10 Gateway Path Unavailable 11 Gateway Target device failed to respond 12 Wrong register count 13 Register data not specified Example of use ~ Requesting 4 holding registers starting from register 1 from slave address Register 1 ~ On command: ModBusSend {\"deviceaddress\": 1, \"functioncode\": 3, \"startaddress\": 1, \"type\":\"uint16\", \"count\":4}` Response: RSL : RESULT = { \"ModbusSend\" : \"Done\" } RSL : RESULT = { \"ModbusReceived\" :{ \"DeviceAddress\" : 1 , \"FunctionCode\" : 3 , \"StartAddress\" : 1 , \"Length\" : 13 , \"Count\" : 4 , \"Values\" :[ 65282 , 65028 , 65280 , 65024 ]}} Set coil register 1 of slaveaddress 1 to ON: ~ On command: ModBusSend {\"deviceaddress\": 1, \"functioncode\": 5, \"startaddress\": 1, \"type\":\"bit\", \"count\":1, \"values\":[1]} Response: RSL : RESULT = { \"ModbusSend\" : \"Done\" } RSL : RESULT = { \"ModbusReceived\" :{ \"DeviceAddress\" : 1 , \"FunctionCode\" : 5 , \"StartAddress\" : 1 , \"Length\" : 8 , \"Count\" : 1 , \"Values\" :[ 255 ]}} Setting multiple coils starting from coil register 1 from slave address 1 ~ On command: ModBusSend '{\"deviceaddress\": 1, \"functioncode\": 15, \"startaddress\": 1, \"type\":\"bit\", \"count\":8, \"values\":[1,0,0,1,1,1,0,0]} Response: RSL : RESULT = { \"ModbusSend\" : \"Done\" } RSL : RESULT = { \"ModbusReceived\" :{ \"DeviceAddress\" : 1 , \"FunctionCode\" : 15 , \"StartAddress\" : 1 , \"Length\" : 8 , \"Count\" : 1 }} Additional resources ~ Tasmota Pull Request Modbus Protocol More Modbus information","title":"Modbus Bridge"},{"location":"Modbus-Bridge/#modbus-bridge","text":"Add a \"Modbus bridge\" functionality to a device that is otherwise serial Modbus RTU only This feature is only included in tasmota32 binary When compiling your build add the following to user_config_override.h : #ifndef USE_MODBUS_BRIDGE #define USE_MODBUS_BRIDGE // Add support for software Modbus Bridge (+3k code) #define USE_MODBUS_BRIDGE_TCP // Add support for software Modbus TCP Bridge (Must also enable USE_MODBUS_BRIDGE) #endif In most cases you'll need an RS485 converter like this:","title":"Modbus Bridge"},{"location":"Modbus-Bridge/#introduction","text":"Connect the Modbus device to an ESP and Tasmota will create a bridge to the Modbus network. The Modbus Bridge driver features 2 kind of bridges. USE_MODBUS_BRIDGE : The bridge can be used by commands in the console and via MQTT messages. USE_MODBUS_BRIDGE_TCP : The bridge can be used by commands in the console and via MQTT messages but also as Modbus TCP/IP bridge","title":"Introduction"},{"location":"Modbus-Bridge/#configuration","text":"First assign two GPIOs to ModBR Tx and ModBR Rx in the \"Configure Module\" page. The Rx/Tx are relative to the ESP device. For example with ESP-12's hardware serial, set GPIO1 as ModBR Tx and GPIO3 as ModBR Rx. Then set baud rate with ModbusSetBaudRate (default is 9600).","title":"Configuration"},{"location":"Modbus-Bridge/#commands","text":"Command Parameters ModbusSend Sending a message to the Modbus network as JSON payload. {\"deviceAddress\":<value>, \"functionCode\":<value>, \"startAddress\":<value>, \"type\":\"<value>\",\"count\":<value>} \u2003\u2003 \"deviceAddress\":1..255 = device address from the Modbus slave. \u2003\u2003 \"functioncode\":1..6 or 15..16 = function code to send to the Modbus slave (see table below). \u2003\u2003 \"startaddress\":1..65535 address of the first register to read. \u2003\u2003 \"type\":\"<value>\" Gives the type of the returned data (see table below). \u2003\u2003 \"count\":1..n the number of values to be requested. ModbusBaudrate ModbusSerialConfig","title":"Commands"},{"location":"Modbus-Bridge/#functioncode","text":"Function Code Description 1 Read Coils 2 Read Discrete Inputs 3 Read Multiple Holding Registers 4 Read Input Registers 5 Write Single Coil 6 Write Single Register 15 Write Multiple Coils 16 Write Multiple Registers","title":"FunctionCode"},{"location":"Modbus-Bridge/#type","text":"Type Description raw Return or send the slave data as a raw values bit Return or send the slave data as a bit values hex Return or send the slave data as a hex values float Return or send the slave data as floats uint8 Return or send the slave data as an 8 bits unsigned int uint32 Return or send the slave data as an 32 bits unsigned int uint16 Return or send the slave data as an 16 bits unsigned int uint32 Return or send the slave data as an 32 bits unsigned int int8 Return or send the slave data as an 8 bits signed int int16 Return or send the slave data as an 16 bits signed int int32 Return or send the slave data as an 32 bits signed int","title":"Type"},{"location":"Modbus-Bridge/#additional-commands-for-use_modbus_tcp_bridge","text":"Command Parameters ModbusTcpStart Start the Modbus TCP bridge on the specified tcp port ModbusTcpConnect","title":"Additional commands for USE_MODBUS_TCP_BRIDGE"},{"location":"Modbus-Bridge/#returned-data","text":"{ \"ModbusReceived\" :{ \"DeviceAddress\" : <value> , \"FunctionCode\" : <value> , \"StartAddress\" : <value> , \"Length\" : <value> , \"Count\" : <value> , \"Values\" :[ value 1 , value 2 , value 3 , valueN ]}} In raw mode, only the data is returned, no other fields.","title":"Returned Data"},{"location":"Modbus-Bridge/#error-codes","text":"There are 2 types of errors, errors from the tasmotamodbus driver and errors from this Modbusbridge module.","title":"Error Codes"},{"location":"Modbus-Bridge/#module-errors","text":"Errors from this Modbus bridge module can be recognized by MBS: MBR Send error or MBS: MBR Recv error at the start of the errormessage. Errorcode Description 1 nodataexpected 2 wrongdeviceaddress 3 wrongfunctioncode 4 wrongstartaddress 5 wrongtype 6 wrongregistercount 7 wrongcount 8 tomanydata","title":"Module Errors"},{"location":"Modbus-Bridge/#driver-errors","text":"Errors from the tasmotamodbus driver can be recognized by MBS: MBR Driver error Errorcode Description 1 Illegal Function 2 Illegal Data Address 3 Illegal Data Value 4 Slave Error 5 Acknowledge but not finished (no error) 6 Slave Busy 7 Not enough minimal data received 8 Memory Parity error 9 Crc error 10 Gateway Path Unavailable 11 Gateway Target device failed to respond 12 Wrong register count 13 Register data not specified","title":"Driver Errors"},{"location":"Modbus-Bridge/#example-of-use","text":"Requesting 4 holding registers starting from register 1 from slave address","title":"Example of use"},{"location":"Modbus-Bridge/#additional-resources","text":"Tasmota Pull Request Modbus Protocol More Modbus information","title":"Additional resources"},{"location":"Modules/","text":"Module is a firmware supported device which has specific code to enable its features. Configure Module page in the webUI is used to configure additional components connected to one of the free GPIO pins of the device. Warning Use Templates to configure Tasmota for your device if it doesn't exist in the module list. New Modules are added to Tasmota only if a device requires additional code for new functions. Tip Use Generic module Module 18 to have almost all GPIO pins available. Each module is assigned a number which is used in Template configuration or when using Module command. # Name Module specifics 0 Template Module for currently active template. Named after the template NAME field. If a template is not active it will display Generic (0) . Do not use it until you configure a template , use Generic (18) instead 1 Sonoff Basic 2 Sonoff RF 3 Sonoff SV 4 Sonoff TH 5 Sonoff Dual Process relay and button via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps. Process buttons as single press only 6 Sonoff POW 7 Sonoff 4Ch 8 Sonoff S2X 9 Slampher 10 Sonoff Touch Invert LedState 1 functionality 11 Sonoff LED Set light type to 2 PWM channels disregarding SetOption15. Fix device specific LED instabilities by disabling GPIO04, GPIO5 and GPIO14 12 1 Channel 13 4 Channel See Sonoff Dual 14 Motor C/AC Force all relays ON at power up and disable command PowerOnState 15 ElectroDragon 16 EXS Relay(s) Enable pulse latching using even/odd numbered relay pairs 17 WION 18 Generic Show Wemos specific pin information in GUI 19 Sonoff Dev 20 H801 Change hardware UART Tx from GPIO01 to GPIO02 21 Sonoff SC Enable and process data via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps 22 Sonoff BN-SZ Set light type to 1 PWM channel disregarding SetOption15 23 Sonoff 4Ch Pro Button handling disregarding SetOption13 only allowing single press to enable RF learning while holding the button 24 Huafan SS 25 Sonoff Bridge Enable and Process data via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps. Process 16 buttons in web GUI. Enable EFM8BB1 firmware upload 26 Sonoff B1 Set light type to RGBWC using MY92x1 27 Ailight Set light type to RGBW using MY92x1 28 Sonoff T1 1Ch See Sonoff Touch 29 Sonoff T1 2Ch See Sonoff Touch 30 Sonoff T1 3Ch See Sonoff Touch 31 Supla Espablo 32 Witty Cloud 33 Yunshan Relay 34 MagicHome 35 Luani HVIO 36 KMC 70011 37 Arilux LC01 38 Arilux LC11 39 Sonoff Dual R2 Process buttons as single press only 40 Arilux LC06 41 Sonoff S31 Selects component types for the CSE7766 (serial connected energy monitoring chip) with Rx and Tx hardware serial (even parity) on GPIO01 and GPIO03 respectively. Sets serial interface to 4800 baud and disables serial logging 42 Zengge WF017 43 Sonoff Pow R2 44 Sonoff IFan02 Enable command FanSpeed . Disable Interlock and PulseTime . Tune status information, MQTT data and GUI. Sync with microcontroller. Process Domoticz Fan state 45 Blitzwolf SHP Module specific power monitoring calibration 46 Shelly 1 47 Shelly 2 48 Xiaomi Philips Process color temperature using PWM2 and intensity using PWM1 49 Neo Coolcam 50 ESP SwitCh 51 Obi Socket 52 Teckin 53 APLIC WDP303075 54 TuyaMCU Enable and process data via software or hardware serial interface using component 107 and 108. Change the baud rate to 9600 bps. Process all buttons. Read more... 55 Gosund SP1 v23 56 Armtronix Dimmers Enable and process data via software or hardware serial interface using component 148 and 149. Change baudrate to 115200 bps. 57 SK03 Outdoor (Tuya) 58 PS-16-DZ Enable and process data via software or hardware serial interface using component 148 and 149. Change the baud rate to 19200 bps. 59 Teckin US 60 Manzoku Strip (EU 4) 61 Obi Socket 2 62 YTF IR Bridge Disable serial interface to stop loopback. 63 Digoo DG-SP202 64 KA10 65 Luminea ZX2820 66 Mi Desk Lamp Process rotary and Button1 data specific to this device 67 SP10 68 WAGA CHCZ02MB 69 SYF05 70 Sonoff L1 71 Sonoff iFan03 72 EX-Store Dimmer 73 PWM Dimmer For MJ-SD01/acenx/NTONPOWER PWM dimmers. Read more... 74 Sonoff D1 Dimmer 75 Sonoff ZBBridge Sonoff Zigbee bridge Serial logging is disabled by the Tasmota code for several modules and components (e.g., Sonoff POW, Sonoff S31, Sonoff Dual (v1), Tuya dimmers, PZEM components, etc.). Serial communication is used by these devices to transfer the data from the MCU chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on these devices. It can cause the device software to crash. Supported Modules","title":"Modules"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_CHIRP #define USE_CHIRP // [I2cDriver33] Enable CHIRP soil moisture sensor (variable I2C address, default 0x20) #endif Chirp! I 2 C moisture sensor is the sensor-only version of the original Chirp! sensor. The \"sensor mode only\" (without the chirp function) is the preferred sensor variant for Tasmota. It provides additional temperature readings. Chirp! is a plant watering alarm which uses capacitive sensing to measure moisture. It provides ambient light readings and works in Tasmota, but is not the recommended version. Additional References: - Catnip electronics - Plant Watering Alarm Connecting to an ESP82xx ~ Use a standard I 2 C connection plus 3.3V and GND. Device Configuration ~ In the Configuration -> Configure Other page, enter and activate the following template: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,0,0,0,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} BASE: Generic (18) GPIO4 : I2C SDA (06) GPIO5 : I2C SCL (05) At boot time the driver will scan the I 2 C bus for CHIRP moisture sensors and enumerate them starting with 0. The sensor has a default I 2 C address of 0x20 , which can be changed within the driver so that multiple sensors are possible. Write access to the sensor is potentially dangerous!! Only change the I 2 C address while only one is sensor connected, using a stable power supply, and if you are familiar with how to flash the sensor. Commands ~ Command Description CHIRPSCAN Re-scan the I 2 C bus and re-enumerate the sensors. CHIRPSELECT Select the active sensor, which can receive commands. To select the first sensor use CHIRPSELECT 0 . CHIRPSET Set the new I 2 C address for the selected sensor. Use decimal address. To change active sensor to 0x1f (=31) use CHIRPSET 31 . CHIRPSLEEP Put the selected sensor into sleep mode. CHIRPWAKE Wake the selected (sleeping) sensor. CHIRPRESET Reset the selected sensor. Sensor readings ~ The original explanation from the manufacturer can be found on this tindie page . It is important to understand, that the light sensor does not provide LUX but a relative reading ( 0..65535 ), where more light means a lower value! The term DARKNESS is used in Tasmota. !! \u26a0\ufe0f PLEASE USE TelePeriod OF 20 OR GREATER \u26a0\ufe0f !! The driver will sync with the TelePeriod and start the measure cycle about 17 seconds before the next telemetry message. You can issue a Status 8 and any time to output that last sensor readings. Known issues ~ The sensor is relatively slow and therefore the driver will (try to) slow down the I 2 C bus-speed and extend the CLOCKSTRETCHLIMIT. A long discussion about it can be found here . The problem seems to occur mostly when the sensor wakes up from sleep. That is why the implemented auto-sleep-wake function is currently deactivated in the driver. Typically when you get readings of 0 for all 3 measurements, then the I 2 C bus is likely \"frozen\". The expected result for I2CSCAN on the console is {\"I2CScan\":\"Error 4 at 0x01\"} . A restart ( Restart 1 ) of Tasmota should be enough, but you may need to power cycle the device. Different ESP Cores may lead to different behavior. It is possible to flash incorrect firmware to a sensor (chirp vs non-chirp). This will very likely lead to nonsense temperature readings. Multiple sensors on one I 2 C bus were tested successfully, but are not guaranteed to work due to multiple possible reasons (power, cabling, ...). Your mileage may vary.","title":"Moisture Sensor and Chirp! Sensor"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#connecting-to-an-esp82xx","text":"Use a standard I 2 C connection plus 3.3V and GND.","title":"Connecting to an ESP82xx"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#device-configuration","text":"In the Configuration -> Configure Other page, enter and activate the following template: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,0,0,0,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} BASE: Generic (18) GPIO4 : I2C SDA (06) GPIO5 : I2C SCL (05) At boot time the driver will scan the I 2 C bus for CHIRP moisture sensors and enumerate them starting with 0. The sensor has a default I 2 C address of 0x20 , which can be changed within the driver so that multiple sensors are possible. Write access to the sensor is potentially dangerous!! Only change the I 2 C address while only one is sensor connected, using a stable power supply, and if you are familiar with how to flash the sensor.","title":"Device Configuration"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#commands","text":"Command Description CHIRPSCAN Re-scan the I 2 C bus and re-enumerate the sensors. CHIRPSELECT Select the active sensor, which can receive commands. To select the first sensor use CHIRPSELECT 0 . CHIRPSET Set the new I 2 C address for the selected sensor. Use decimal address. To change active sensor to 0x1f (=31) use CHIRPSET 31 . CHIRPSLEEP Put the selected sensor into sleep mode. CHIRPWAKE Wake the selected (sleeping) sensor. CHIRPRESET Reset the selected sensor.","title":"Commands"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#sensor-readings","text":"The original explanation from the manufacturer can be found on this tindie page . It is important to understand, that the light sensor does not provide LUX but a relative reading ( 0..65535 ), where more light means a lower value! The term DARKNESS is used in Tasmota. !! \u26a0\ufe0f PLEASE USE TelePeriod OF 20 OR GREATER \u26a0\ufe0f !! The driver will sync with the TelePeriod and start the measure cycle about 17 seconds before the next telemetry message. You can issue a Status 8 and any time to output that last sensor readings.","title":"Sensor readings"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#known-issues","text":"The sensor is relatively slow and therefore the driver will (try to) slow down the I 2 C bus-speed and extend the CLOCKSTRETCHLIMIT. A long discussion about it can be found here . The problem seems to occur mostly when the sensor wakes up from sleep. That is why the implemented auto-sleep-wake function is currently deactivated in the driver. Typically when you get readings of 0 for all 3 measurements, then the I 2 C bus is likely \"frozen\". The expected result for I2CSCAN on the console is {\"I2CScan\":\"Error 4 at 0x01\"} . A restart ( Restart 1 ) of Tasmota should be enough, but you may need to power cycle the device. Different ESP Cores may lead to different behavior. It is possible to flash incorrect firmware to a sensor (chirp vs non-chirp). This will very likely lead to nonsense temperature readings. Multiple sensors on one I 2 C bus were tested successfully, but are not guaranteed to work due to multiple possible reasons (power, cabling, ...). Your mileage may vary.","title":"Known issues"},{"location":"NRF24L01/","text":"NRF24L01 module ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifndef USE_NRF24 #define USE_NRF24 // Add SPI support for RF24L01(+) (+2k6 code) #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) #endif This chip is manufactured by Nordic Semiconductors as a single chip transceiver in the 2,4 GHz band. There are many applications of this chip in many projects as a versatile very low cost wireless module. In recent years solutions were found to use this chip for limited Bluetooth-Low-Energy communication. One of the first articles about this topic can be found here . Subsequently, further work was done by several developers and a working bridge to read sensor data from a Xiaomi MJ_HT_V1 BLE sensor was created. The fundamental principle is, that some of these sensors send its data as a usual BLE-advertisement packet with a proprietary data format at the end of the payload. These packets had to fit into the 32 bytes of the FIFO-RX-buffer of the RF24L01, otherwise the \"later\" bytes were lost. A new solution was found for the Tasmota driver. The basic idea is to use some constant ID-bytes of the BLE-packets as the PDU-type for the NRF24l01. Thus, all bytes before these ID-bytes are lost and the size restriction for the payload is successfully circumvented. That way it is possible to read the sensor data from a Mi Flora sensor, which is positioned outside of the 32-byte-range. Of course there is still no bidirectional \"real\" BLE-communication, only advertisements can be read. Configuration ~ Wiring ~ Configure the pins for SPI_DC and SPI_CS while connecting the hardware SPI pins 12 - 14 (MOSI, MISO and CLOCK). Tip In order to simplify the code, the pin names from the SPI-display-drivers are used in the webUI! For nRF24L01 SPI_DC translates to CSN and SPI_CS to CE. Warning Even slightly loose cables can lead to malfunctions of the SPI-data-transfer. This can produce a Software WDT reset. Tasmota Settings ~ No additional steps are necessary. The initial log should like this: 00:00:00 NRF24L01 initialized 00:00:00 NRF24L01+ detected 00:00:00 MIBLE: started The driver will do the rest automatically and start to look for known \"special\" packets, which will be used to extract the sensor readings. webUI and TELE-messages will be populated with sensor data. This can take a while after start and may be influenced by the general traffic on the 2,4 GHz band. For a complete overview of supported devices, commands and features read the Bluetooth article .","title":"NRF24L01 module"},{"location":"NRF24L01/#nrf24l01-module","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifndef USE_NRF24 #define USE_NRF24 // Add SPI support for RF24L01(+) (+2k6 code) #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) #endif This chip is manufactured by Nordic Semiconductors as a single chip transceiver in the 2,4 GHz band. There are many applications of this chip in many projects as a versatile very low cost wireless module. In recent years solutions were found to use this chip for limited Bluetooth-Low-Energy communication. One of the first articles about this topic can be found here . Subsequently, further work was done by several developers and a working bridge to read sensor data from a Xiaomi MJ_HT_V1 BLE sensor was created. The fundamental principle is, that some of these sensors send its data as a usual BLE-advertisement packet with a proprietary data format at the end of the payload. These packets had to fit into the 32 bytes of the FIFO-RX-buffer of the RF24L01, otherwise the \"later\" bytes were lost. A new solution was found for the Tasmota driver. The basic idea is to use some constant ID-bytes of the BLE-packets as the PDU-type for the NRF24l01. Thus, all bytes before these ID-bytes are lost and the size restriction for the payload is successfully circumvented. That way it is possible to read the sensor data from a Mi Flora sensor, which is positioned outside of the 32-byte-range. Of course there is still no bidirectional \"real\" BLE-communication, only advertisements can be read.","title":"NRF24L01 module"},{"location":"NRF24L01/#configuration","text":"","title":"Configuration"},{"location":"NRF24L01/#wiring","text":"Configure the pins for SPI_DC and SPI_CS while connecting the hardware SPI pins 12 - 14 (MOSI, MISO and CLOCK). Tip In order to simplify the code, the pin names from the SPI-display-drivers are used in the webUI! For nRF24L01 SPI_DC translates to CSN and SPI_CS to CE. Warning Even slightly loose cables can lead to malfunctions of the SPI-data-transfer. This can produce a Software WDT reset.","title":"Wiring"},{"location":"NRF24L01/#tasmota-settings","text":"No additional steps are necessary. The initial log should like this: 00:00:00 NRF24L01 initialized 00:00:00 NRF24L01+ detected 00:00:00 MIBLE: started The driver will do the rest automatically and start to look for known \"special\" packets, which will be used to extract the sensor readings. webUI and TELE-messages will be populated with sensor data. This can take a while after start and may be influenced by the general traffic on the 2,4 GHz band. For a complete overview of supported devices, commands and features read the Bluetooth article .","title":"Tasmota Settings"},{"location":"NeoPool/","text":"Sugar Valley NeoPool Controller ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : ```arduino define USE_NEOPOOL // Add support for Sugar Valley NeoPool Controller - also known under brands Hidrolife, Aquascenic, Oxilife, Bionet, Hidroniser, UVScenic, Station, Brilix, Bayrol and Hay (+6k flash, +60 mem) ~ define NEOPOOL_MODBUS_ADDRESS 1 // Any modbus address ~ #endif ``` Sugar Valley NeoPool are water treatment systems also known under the names Hidrolife, Aquascenic, Oxilife, Bionet, Hidroniser, UVScenic, Station, Brilix, Bayrol and Hay. It uses a RS485 interface with the Modbus data protocol for enhancment equipments like Wifi-Interface or a second attached control panel. All functions and parameters can be queried and controlled via this bus interface. The Tasmota Sugar Valley NeoPool Controller sensor module shows the most of parameters such as the built-in display: There are Tasmota commands implemented to control the high level functions for filtration, light and system parameters such as pH set point, hydrolysis level, redox set point etc. However, the sensor also provides low-level commands to directly [read]#NPRead) and write NeoPool register, means that you have the option to implement your own commands via home automation systems or by using the Tasmota build-in possibilities Rules with Backlog or the powerful Berry language on ESP32. Connection ~ The NeoPool controller uses a RS485 interface, the ESP has RS232 interfaces. Both are serial interfaces but with different physical specifications. Therefore to connect your NeoPool controller to an ESP82xx/32 you need a TTL-UART to RS485 converter. It is recommended to use GPIO1 and GPIO3 on ESP8266 side, since the ESP then uses the hardware serial interface. The following TTL UART to RS485 converter have been tested with both an ESP8266 and ESP32 using a Vcc of 3.3V: Note Your TTL UART to RS485 converter must be able to work with an operating voltage of 3.3V. Some converters are not designed for operating with 3.3V and only works with 5V TTL level - these converters are useless. Do not operate your TTL UART to RS485 converter with 5V , your converter must be operated with the 3.3V from ESP, otherwise the ESP GPIO ports will be damaged. The Sugar Valley NeoPool RS485 connector pins are located under the connection cover, for the Sugar-Valley products on the right-hand side next to the relay connections: The pin assignment (from top to bottom): Pin Description 1 +12V 2 nc 3 Modbus A+ 4 Modbus B- 5 Modbus GND The +12V connection is the 12V from the internal power supply, do not feed in any external voltage. You can use the \"WIFI\" or \"EXTERN\" connector, both are independent Modbus channels and uses the Modbus address 1 by default. Note The \"DISPLAY\" port can only be used if neither the built-in nor an external display is connected but since there is probably at least one display connected to one of the two \"DISPLAY\" ports, the \"DISPLAY\" port is useless. Using WIFI Port ~ Using EXTERN Port ~ Note Leave the define for NEOPOOL_MODBUS_ADDRESS set to 1 whether you are using the \"WIFI\" or \"EXTERNAL\" port (unless you have changed the parameters for it within your Sugar Valley device). Configuration ~ Tasmota settings ~ If you followed the recommendations above, the two GPIOs will be assigned as follows under Tasmota Configuration -> Configure Module : first change Module type to Generic (0) - this will restart your Tasmota After restart set * GPIO1 to NeoPool RX * GPIO3 to NeoPool TX so it looks like this Don't be surprised that Rx seems to be connected to Tx here (and vice versa). The Rx and Tx designations are to be considered from the point of view of the respective devices, which can be confusing. After Tasmota restarts, the main screen should display the controller data as shown above. If not, check that the A+/B pins aren't swapped and that the Rx/Tx pins are on the correct GPIOs - swap once if in doubt. SENSOR data ~ Sensor data is sent via the Tasmota topic tele/%topic%/SENSOR in JSON format every TelePeriod interval. To get the data immediately, use the Tasmota TelePeriod command without parameter: { \"Time\" : \"2021-06-01T11:00:00+02:00\" , \"NeoPool\" : { \"Time\" : \"2021-06-01T11:00:00\" , \"Type\" : \"Oxilife\" , \"Module\" : { \"pH\" : 1 , \"Redox\" : 1 , \"Hydrolysis\" : 1 , \"Chlorine\" : 1 , \"Conductivity\" : 1 , \"Ionization\" : 1 }, \"Temperature\" : 23.5 , \"Power\" : { \"Version\" : \"V3.45\" , \"NodeID\" : \"2A55 6E6B 6E6F 776E 2049 442A\" , \"5V\" : 5.017 , \"12V\" : 13.904 , \"24-30V\" : 33.721 , \"4-20mA\" : 0.01 }, \"pH\" : { \"Data\" : 7.2 , \"Min\" : 7.0 , \"Max\" : 7.2 , \"State\" : 0 , \"Pump\" : 2 , \"FL1\" : 0 , \"Tank\" : 1 }, \"Redox\" : { \"Data\" : 752 , \"Setpoint\" : 750 }, \"Chlorine\" : { \"Data\" : 0.7 , \"Setpoint\" : 1.0 }, \"Conductivity\" : 0 , \"Ionization\" : { \"Data\" : 0 , \"Setpoint\" : 0 , \"Max\" : 0 }, \"Hydrolysis\" : { \"Data\" : 100 , \"Unit\" : \"%\" , \"Runtime\" : { \"Total\" : \"28T22:13:19\" , \"Part\" : \"28T22:13:02\" , \"Pol1\" : \"14T12:32:46\" , \"Pol2\" : \"14T09:40:33\" , \"Changes\" : 258 }, \"State\" : \"Pol1\" , \"Cover\" : 0 , \"Boost\" : 0 , \"Low\" : 0 }, \"Filtration\" : { \"State\" : 1 , \"Speed\" : 2 , \"Mode\" : 1 }, \"Light\" : 0 , \"Relay\" : { \"State\" : [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ], \"Aux\" : [ 0 , 0 , 1 , 0 ], \"Acid\" : 0 } }, \"TempUnit\" : \"C\" } The JSON values \"pH\", \"Redox\", \"Hydrolysis\", \"Chlorine\", \"Conductivity\" and \"Ionization\" are only available if the corresponding module is installed in the device (the corresponding \"Module\" subkey must be 1 ). To check which modules are installed use the \"Module\" value from SENSOR topic or query it manually by using the NPControl command : { \"Modules\" : { \"pH\" : 1 , \"Redox\" : 1 , \"Hydrolysis\" : 1 , \"Chlorine\" : 0 , \"Conductivity\" : 0 , \"Ionization\" : 0 }, \"Relay\" : { \"Acid\" : 1 , \"Base\" : 0 , \"Redox\" : 0 , \"Chlorine\" : 0 , \"Conductivity\" : 0 , \"Heating\" : 0 , \"UV\" : 0 , \"Valve\" : 0 } } Commands ~ This sensor supports some high-level Tasmota commands for end user. Regardless, all other Modbus registers can be read and write, so you can enhance your Sugar Valley control by using low-level [NPRead]#NPRead)/[NPWrite]#NPWrite) commands. Modbus register addresses and their meaning are described within source file xsns_83_neopool.ino at the beginning and (partly) within document 171-Modbus-registers . Please note that Sugar Valley Modbus registers are not byte addresses but modbus registers containing 16-bit values - don't think in byte memory layout. Command Parameters NPFiltration {<state> {speed}} get/set manual filtration (state = 0 or 1 , speed = 1..3 ). Get if state is omitted, otherwise set accordingly <state> : 0 - manual turn filtration pump off 1 - manual turn filtration pump on optional speed control is possible for non-standard filtration types: 1 - slow 2 - medium 3 - fast NPFiltrationMode {<mode>} get/set filtration mode (mode = 0..4 or 13 ). Get if mode is omitted, otherwise set accordingly <mode> : 0 - MANUAL allows to turn the filtration (and all other systems that depend on it) on and off 1 - AUTO allows filtering to be turned on and off according to the settings of the MBF_PAR_TIMER_BLOCK_FILT_INT timers. 2 - HEATING similar to the AUTO mode, but includes setting the temperature for the heating function. This mode is activated only if the BF_PAR_HEATING_MODE register is at 1 and there is a heating relay assigned. 3 - SMART adjusts the pump operating times depending on the temperature. This mode is activated only if the MBF_PAR_TEMPERATURE_ACTIVE register is at 1. 4 - INTELLIGENT performs an intelligent filtration process in combination with the heating function. This mode is activated only if the MBF_PAR_HEATING_MODE register is at 1 and there is a heating relay assigned. 13 - BACKWASH started when the backwash operation is activated. NPTime {<time>} get/set device time. Get if time is omitted, otherwise set device time accordingly <time> : 0 - sync with Tasmota local time 1 - sync with Tasmota utc time 2..4294967295 - set time as epoch NPLight {<state> {delay}} get/set light (state = 0..4 , delay = 5..100 in 1/10 sec). Get if state is omitted, otherwise set accordingly <state> : 0 - manual turn light off 1 - manual turn light on 2 - manual toogle light 3 - switch light into auto mode according MBF_PAR_TIMER_BLOCK_LIGHT_INT settings 4 - select light RGB LED to next program. This is normally done by power the light on (if currently off), then power off the light for a given time (delay) and power on again. The default delay is 15 (=1.5 sec). NPpHMin {<ph>} (only available if pH module is installed) get/set pH lower limit (ph = 0..14 ) get current limit if is omitted, otherwise set. NPpHMax {<ph>} (only available if pH module is installed) get/set pH upper limit (ph = 0..14 ) get current limit if is omitted, otherwise set. NPpH {<ph>} (only available if pH module is installed) get/set pH upper limit (ph = 0..14 ) same as NPpHMax NPRedox {<setpoint>} (only available if redox module is installed) get/set redox set point in mV (setpoint = 0..100 , the upper limit of the range may vary depending on the MBF_PAR_HIDRO_NOM register) get current set point if is omitted, otherwise set NPHydrolysis {<level>} (only available if hydrolysis/electrolysis control is present) get/set hydrolysis/electrolysis level in % (level = 0..100 ) get current level if is omitted, otherwise set NPIonization {<level>} (only available if ionization control is present) get/set ionization target production level (level = 0..x , the upper limit x of the range may vary depending on the MBF_PAR_ION_NOM register) get current level if is omitted, otherwise set NPChlorine {<setpoint>} (only available if free chlorine probe detector is installed) get/set chlorine set point in ppm (setpoint = 0..10 ) get current set point if is omitted, otherwise set NPControl Show information about system controls NPOnError {<repeat>} get/set auto-repeat Modbus read/write commands on error (repeat = 0..10 ). Get if repeat is omitted, otherwise set accordingly <repeat> : 0 - disable auto-repeat on read/write error 1..10 - repeat commands n times until ok NPResult {<format>} get/set addr/data result format for read/write commands (format = 0|1 ). Get if format is omitted, otherwise set accordingly <format> : 0 - output decimal numbers 1 - output hexadecimal strings, this is the default NPPHRes {<digits>} get/set number of digits in results for PH value (digits = 0..3 ). NPCLRes {<digits>} get/set number of digits in results for CL value (digits = 0..3 ). NPIonRes {<digits>} get/set number of digits in results for ION value (digits = 0..3 ). NPRead <addr> {<cnt>} read 16-bit register (addr = 0..0x060F , cnt = 1..30 ). cnt = 1 if omitted NPReadL <addr> {<cnt>} read 32-bit register (addr = 0..0x060F , cnt = 1..15 ). cnt = 1 if omitted NPWrite <addr> <data> {<data>...} write 16-bit register (addr = 0..0x060F , data = 0..0xFFFF ). Use of data max 10 times NPWriteL <addr> <data> {<data>...} write 32-bit register (addr = 0..0x060F , data = 0..0xFFFFFFFF ). Use of data max 10 times NPBit <addr> <bit> {<data>} read/write a 16-bit register single bit (addr = 0..0x060F , bit = 0..15 , data = 0|1 ). Read if data is omitted, otherwise set single bit NPBitL <addr> <bit> {<data>} read/write a 32-bit register single bit (addr = 0..0x060F , bit = 0..31 , data = 0|1 ). Read if data is omitted, otherwise set single bit NPEscape clears possible errors (like pump exceeded time etc.) NPExec take over changes without writing to EEPROM. This command is necessary e.g. on changes in Installer page (addr 0x0400..0x04EE). NPSave write data permanently into EEPROM. During the EEPROM write procedure the NeoPool device may be unresponsive to MODBUS requests, this process always takes less than 1 second. Since this process is limited by the number of EEPROM write cycles, it is recommend to write all necessary changes to the registers and only then execute EEPROM write process using this command. Note: The number of EEPROM writes for Sugar Valley NeoPool devices is guaranteed 100,000 cycles. As soon as this number is exceeded, further storage of information can no longer be guaranteed . Examples ~ Example Get filtration mode NPFil trat io n Mode RESULT = { \"NPFiltrationmode\" : \"Manual\" } Example Set filtration mode NPFil trat io n Mode 1 { \"NPFiltrationmode\" : \"Auto\" } Example Enable hydrolysis boost mode without redox control To do this, write 0x85A0 to register MBF_BOOST_CTRL ( 0x020C ), exec, save it and notify system using register MBF_NOTIFICATION ( 0x0110 ) about changes: Backlog NPWri te 0 x 020 C , 0 x 85 A 0 ;NPSave;NPExec;NPWri te 0 x 0110 , 0 x 7 F RESULT = { \"NPWrite\" :{ \"Address\" : \"0x020C\" , \"Data\" : \"0x85A0\" }} RESULT = { \"NPSave\" : \"Done\" } RESULT = { \"NPExec\" : \"Done\" } RESULT = { \"NPWrite\" :{ \"Address\" : \"0x0110\" , \"Data\" : \"0x0000\" }} Example Disable hydrolysis boost mode To do this, write 0 to register MBF_BOOST_CTRL ( 0x020C ), exec, save it and notify system using register MBF_NOTIFICATION ( 0x0110 ) about changes: Backlog NPWri te 0 x 020 C , 0 ;NPSave;NPExec;NPWri te 0 x 0110 , 0 x 7 F RESULT = { \"NPWrite\" :{ \"Address\" : \"0x020C\" , \"Data\" : \"0x0000\" }} RESULT = { \"NPSave\" : \"Done\" } RESULT = { \"NPExec\" : \"Done\" } RESULT = { \"NPWrite\" :{ \"Address\" : \"0x0110\" , \"Data\" : \"0x0000\" }} Example Switch light relay on NPLigh t 1 RESULT = { \"NPLight\" : \"ON\" } Example Read Heating setpoint temperature Here we read register MBF_PAR_HEATING_TEMP ( 0x0416 ): Backlog NPResul t 0 ;NPRead 0 x 416 RESULT = { \"NPResult\" : 0 } RESULT = { \"NPRead\" :{ \"Address\" : 1046 , \"Data\" : 28 }} Example Enable additonal factory menu For that enable bit MBMSK_SHOW_FACTORY_MENU (15) in register MBF_PAR_UICFG_VISUAL_OPTIONS ( 0x0605 ) Backlog NPBi t 0 x 605 , 15 , 1 ;NPSave RESULT = { \"NPBit\" :{ \"Address\" : \"0x0605\" , \"Data\" : \"0xAFC0\" , \"Bit15\" : 1 }} RESULT = { \"NPSave\" : \"Done\" } Example Read system time We either use command NPTime or read the 32-bit value starting MBF_PAR_TIME_LOW ( 0x0408 ) using decimal output: Backlog NPResul t 0 ;NPTime;NPReadL 0 x 408 RESULT = { \"NPResult\" : 0 } RESULT = { \"NPTime\" : \"2021-01-31T21:22:20\" } RESULT = { \"NPReadL\" :{ \"Address\" : 1032 , \"Data\" : 1612124540 }} Example Enable temperature module Do this by enabling MBF_PAR_TEMPERATURE_ACTIVE ( 0x04F ) and set it permanently in EEPROM:: Backlog NPWri te 0 x 40 F , 1 ;NPSave RESULT = { \"NPWrite\" :{ \"Address\" : \"0x040F\" , \"Data\" : \"0x0001\" }} RESULT = { \"NPSave\" : \"Done\" } Example Hide auxiliary relay display from main menu To do this, set bit MBMSK_HIDE_AUX_RELAYS (3) in register MBF_PAR_UICFG_VISUAL_OPTIONS ( 0x0605 ): NPBi t 0 x 605 , 3 , 1 RESULT = { \"NPBit\" :{ \"Address\" : \"0x0605\" , \"Data\" : \"0x08C8\" }} Example Read Filtration interval 1-3 settings To do this, we read the registers MBF_PAR_TIMER_BLOCK_FILT_INT1 ( 0x0434 ), MBF_PAR_TIMER_BLOCK_FILT_INT2 ( 0x0443 ) and MBF_PAR_TIMER_BLOCK_FILT_INT3 ( 0x0452 ) with offset MBV_TIMER_OFFMB_TIMER_ENABLE (0) as 16-bit values and the remaining timer offset values MBV_TIMER_OFFMB_* as 32-bit values: Backlog NPResul t 0 ;NPRead 0 x 434 ;NPReadL 0 x 435 , 7 ;NPRead 0 x 443 ;NPReadL 0 x 444 , 7 ;NPRead 0 x 452 ;NPReadL 0 x 0453 , 7 RESULT = { \"NPResult\" : 0 } RESULT = { \"NPRead\" :{ \"Address\" : 1076 , \"Data\" : 1 }} RESULT = { \"NPReadL\" :{ \"Address\" : 1077 , \"Data\" :[ 28800 , 0 , 86400 , 14400 , 0 , 1 , 0 ]}} RESULT = { \"NPRead\" :{ \"Address\" : 1091 , \"Data\" : 1 }} RESULT = { \"NPReadL\" :{ \"Address\" : 1092 , \"Data\" :[ 43200 , 0 , 86400 , 21600 , 0 , 1 , 0 ]}} RESULT = { \"NPRead\" :{ \"Address\" : 1106 , \"Data\" : 1 }} RESULT = { \"NPReadL\" :{ \"Address\" : 1107 , \"Data\" :[ 0 , 0 , 86400 , 0 , 0 , 1 , 0 ]}} * Example Set filtration interval Here we set interval 1 to a daily interval between 9:00 - 12:30 (9:00: 3600 * 9 \u2259 32400 / 12:30 \u2259 3,5h = 12600) For this write register MBF_PAR_TIMER_BLOCK_FILT_INT1 ( 0x0434 ) using the offsets MBV_TIMER_OFFMB_ . For the sake of simplicity we write 4 consecutive 32-bit registers: MBV_TIMER_OFFMB_TIMER_ON : Timer start = 9 3600 + 00 60 = 32400 MBV_TIMER_OFFMB_TIMER_OFF : Timer stop - not used MBV_TIMER_OFFMB_TIMER_PERIOD : Time in seconds between starting points = 86400 (means daily interval) MBV_TIMER_OFFMB_TIMER_INTERVAL : Time in seconds that the timer has to run when started. This is the difference between 12:30 (12 3600 + 30 60 = 45000) and 9:30(see Timer start = 32400) = 12600 NPWri te L 0 x 435 , 32400 0 86400 12600 RESULT = { \"NPWriteL\" :{ \"Address\" : 1077 , \"Data\" :[ 32400 , 0 , 86400 , 12600 ]}} Example Manual switch relay 7 (Aux4) To switch Aux4 ON, we set MBF_PAR_TIMER_BLOCK_AUX4_INT1 ( 0x04D9 ) + MBV_TIMER_OFFMB_TIMER_ENABLE (0) to MBV_PAR_CTIMER_ALWAYS_ON ( 3 ):. Backlog NPWri te 0 x 4 D 9 , 3 ;NPExec RESULT = { \"NPWrite\" :{ \"Address\" : \"0x04D9\" , \"Data\" : \"0x0003\" }} RESULT = { \"NPExec\" : \"Done\" } To switch Aux4 OFF, we set MBF_PAR_TIMER_BLOCK_AUX4_INT1 ( 0x04D9 ) + MBV_TIMER_OFFMB_TIMER_ENABLE (0) to MBV_PAR_CTIMER_ALWAYS_OFF ( 4 ):. Backlog NPWri te 0 x 4 D 9 , 4 ;NPExec RESULT = { \"NPWrite\" :{ \"Address\" : \"0x04D9\" , \"Data\" : \"0x0004\" }} RESULT = { \"NPExec\" : \"Done\" } Example Modbus autorepeat on communication error Read current autorepeat value: NPO n Error RESULT = { \"NPOnError\" : 2 } Set autorepeat value to 3: NPO n Error 3 RESULT = { \"NPOnError\" : 3 } Enhancements ~ Daily sync device to Tasmota time ~ Since the NeoPool devices, without a WiFi module, have no way of synchronizing their internal clock with an external clock and, in addition, the accuracy of the internal clock leaves something to be desired, it makes sense to synchronize the clock with Tasmota once a day. Advantageously, we do this at night after a possible daylight saving time or normal time change. We use a rule that synchronizes the time and which is triggered by the Tasmota built-in timer (here we use timer 10): Rule2 ON Clock # Timer = 10 DO NPTime 0 ENDON Activate it: Backlog Rule2 4 ; Rule2 1 Configure Tasmota \"Timer 10\" for your needs: ESP82xx: Add buttons for filtration and light control ~ Add two dummy buttons to control the filtration pump and the light. First we define two dummy relay (which does not have any physical function) on two unused GPIO (here we use GPIO0 and GPIO4 where we define Tasmota Relay 1 and 2): Backlog GPIO0 224 ; GPIO4 225 Then we rename the buttons for better visibility: Backlog WebButton1 Filtration ; WebButton2 Light Now we have the WebGUI buttons like this: but missing the functionality behind. For that we use Rules and connect the states for Tasmota Power, Neopool filtration and light: Rule1 ON Power1 # State == 0 DO NPFiltration % value % ENDON ON Power1 # State == 1 DO NPFiltration % value % ENDON ON NeoPool # Filtration # State == 0 DO Power1 % value % ENDON ON NeoPool # Filtration # State == 1 DO Power1 % value % ENDON ON Power2 # State == 0 DO NPLight % value % ENDON ON Power2 # State == 1 DO NPLight % value % ENDON ON NeoPool # Light == 0 DO Power2 % value % ENDON ON NeoPool # Light == 1 DO Power2 % value % ENDON Don't wonder about the double trigger definition, which at first glance seem nonsensical - they are necessary so that the rule does not trigger endless. At least we activate the rule: Backlog Rule1 5 ; Rule1 1 It is important to enable the Rule ONCE ( Rule1 5 ) function, which prevents the trigger is triggering themself in a loop. You can now control filtration and light using the WebGUI and get the current status of the device elements when they are switched by auto-mode or manually on the device directly. Additional advantage is that you can also use Tasmota Timer switching Power1 (=filtration) and Power2 (light) for your needs. ESP32: Adding user defined NeoPool commands to Tasmota ~ The following enhancements are made using the Berry Scripting Language which is available on ESP32 only. The class NeoPoolCommands below adds two new commands to Tasmota: Command Parameters NPBoost {<state>} get/set boost mode (state = 0..2 ). Get if state is omitted, otherwise set accordingly <state> : 0 - disable boost mode 1 - enable boost mode (without redox control) 2 - enable boost mode (with redox control) NPAux<x> {<state>} get/set auxiliary relay <x> (state = 0..2 ). Get if state is omitted, otherwise set accordingly <state> : 0 - switch off auxiliary relay 1 - switch on auxiliary relay The class members NPBoost and NPAux can also be used as templates for further commands. Store the following code using the WebGUI \"Console\" / \"Manage File system\". ESP32 file neopool.be : class NeoPoolCommands var TEXT_OFF var TEXT_ON # string helper def ltrim ( s ) import string var i = 0 while ( s [ i ] == ' ' ) i += 1 end return string . split ( s , i )[ 1 ] end def rtrim ( s ) import string return string . split ( s , \" \" )[ 0 ] end def trim ( s ) return self . rtrim ( self . ltrim ( s )); end # NPBoost OFF|0|ON|1|REDOX|2 # 0|OFF: Switch boost off # 1|ON: Switch boost on without redox control # 2|REDOX: Switch boost on with redox control def NPBoost ( cmd , idx , payload ) import string var ctrl , parm try parm = string . toupper ( self . trim ( payload )) except .. parm = \"\" end if parm != \"\" if string . find ( parm , 'OFF' ) >= 0 || string . find ( parm , self . TEXT_OFF ) >= 0 || string . find ( parm , '0' ) >= 0 ctrl = 0 elif string . find ( parm , 'ON' ) >= 0 || string . find ( parm , self . TEXT_ON ) >= 0 || string . find ( parm , '1' ) >= 0 ctrl = 0x85A0 elif string . find ( parm , 'REDOX' ) >= 0 || string . find ( parm , '2' ) >= 0 ctrl = 0x05A0 else tasmota . resp_cmnd_error () return end tasmota . cmd ( string . format ( \"Backlog NPWrite 0x020C,0x %04X ;NPSave;NPExec;NPWrite 0x0110,0x7F\" , ctrl )) else try ctrl = compile ( \"return \" + str ( tasmota . cmd ( \"NPRead 0x020C\" )[ 'NPRead' ][ 'Data' ]))() except .. tasmota . resp_cmnd_error () return end end tasmota . resp_cmnd ( string . format ( '{\"NPBoost\":\" %s \"}' , ctrl == 0 ? self . TEXT_OFF : ( ctrl & 0x8500 ) == 0x8500 ? self . TEXT_ON : \"REDOX\" )) end # NPAux<x> OFF|0|ON|1 (<x> = 1..4) # 0|OFF: Switch aux x off # 1|ON: Switch aux x on def NPAux ( cmd , idx , payload ) import string var ctrl , parm if idx < 1 || idx > 4 tasmota . resp_cmnd_error () return end try parm = string . toupper ( self . trim ( payload )) except .. parm = \"\" end if parm != \"\" if string . find ( parm , 'OFF' ) >= 0 || string . find ( parm , self . TEXT_OFF ) >= 0 || string . find ( parm , '0' ) >= 0 ctrl = 4 elif string . find ( parm , 'ON' ) >= 0 || string . find ( parm , self . TEXT_ON ) >= 0 || string . find ( parm , '1' ) >= 0 ctrl = 3 else tasmota . resp_cmnd_error () return end tasmota . cmd ( string . format ( \"Backlog NPWrite 0x %04X , %d ;NPExec\" , [ 0x04AC , 0x04BB , 0x04CA , 0x04D9 ][ idx - 1 ], ctrl )) else try ctrl = ( compile ( \"return \" + str ( tasmota . cmd ( \"NPRead 0x010E\" )[ 'NPRead' ][ 'Data' ]))() >> ( idx + 2 )) & 1 except .. tasmota . resp_cmnd_error () return end end tasmota . resp_cmnd ( string . format ( '{\"NPAux %d \":\" %s \"}' , idx , ctrl == ( parm != \"\" ? 4 : 0 ) ? self . TEXT_OFF : self . TEXT_ON )) end def init () self . TEXT_OFF = tasmota . cmd ( \"StateText1\" )[ 'StateText1' ] self . TEXT_ON = tasmota . cmd ( \"StateText2\" )[ 'StateText2' ] # Add commands tasmota . add_cmd ( 'NPBoost' , / cmd , idx , payload -> self . NPBoost ( cmd , idx , payload )) tasmota . add_cmd ( 'NPAux' , / cmd , idx , payload -> self . NPAux ( cmd , idx , payload )) end def deinit () tasmota . remove_cmd ( 'NPBoost' ) tasmota . remove_cmd ( 'NPAux' ) end end neopool_commands = NeoPoolCommands () To activate the new commands go to WebGUI \"Consoles\" / \"Berry Scripting console\" and execute load ( \"neopool.be\" ) If you want get the new commands available after a restart of your ESP32, store the load command into the special file autoexec.be : ESP32 file autoexec.be : load ( \"neopool.be\" )","title":"Sugar Valley NeoPool Controller"},{"location":"NeoPool/#sugar-valley-neopool-controller","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : ```arduino","title":"Sugar Valley NeoPool Controller"},{"location":"NeoPool/#define-use_neopool-add-support-for-sugar-valley-neopool-controller-also-known-under-brands-hidrolife-aquascenic-oxilife-bionet-hidroniser-uvscenic-station-brilix-bayrol-and-hay-6k-flash-60-mem","text":"","title":"define USE_NEOPOOL                       // Add support for Sugar Valley NeoPool Controller - also known under brands Hidrolife, Aquascenic, Oxilife, Bionet, Hidroniser, UVScenic, Station, Brilix, Bayrol and Hay (+6k flash, +60 mem)"},{"location":"NeoPool/#define-neopool_modbus_address-1-any-modbus-address","text":"#endif ``` Sugar Valley NeoPool are water treatment systems also known under the names Hidrolife, Aquascenic, Oxilife, Bionet, Hidroniser, UVScenic, Station, Brilix, Bayrol and Hay. It uses a RS485 interface with the Modbus data protocol for enhancment equipments like Wifi-Interface or a second attached control panel. All functions and parameters can be queried and controlled via this bus interface. The Tasmota Sugar Valley NeoPool Controller sensor module shows the most of parameters such as the built-in display: There are Tasmota commands implemented to control the high level functions for filtration, light and system parameters such as pH set point, hydrolysis level, redox set point etc. However, the sensor also provides low-level commands to directly [read]#NPRead) and write NeoPool register, means that you have the option to implement your own commands via home automation systems or by using the Tasmota build-in possibilities Rules with Backlog or the powerful Berry language on ESP32.","title":"define NEOPOOL_MODBUS_ADDRESS       1    // Any modbus address"},{"location":"NeoPool/#connection","text":"The NeoPool controller uses a RS485 interface, the ESP has RS232 interfaces. Both are serial interfaces but with different physical specifications. Therefore to connect your NeoPool controller to an ESP82xx/32 you need a TTL-UART to RS485 converter. It is recommended to use GPIO1 and GPIO3 on ESP8266 side, since the ESP then uses the hardware serial interface. The following TTL UART to RS485 converter have been tested with both an ESP8266 and ESP32 using a Vcc of 3.3V: Note Your TTL UART to RS485 converter must be able to work with an operating voltage of 3.3V. Some converters are not designed for operating with 3.3V and only works with 5V TTL level - these converters are useless. Do not operate your TTL UART to RS485 converter with 5V , your converter must be operated with the 3.3V from ESP, otherwise the ESP GPIO ports will be damaged. The Sugar Valley NeoPool RS485 connector pins are located under the connection cover, for the Sugar-Valley products on the right-hand side next to the relay connections: The pin assignment (from top to bottom): Pin Description 1 +12V 2 nc 3 Modbus A+ 4 Modbus B- 5 Modbus GND The +12V connection is the 12V from the internal power supply, do not feed in any external voltage. You can use the \"WIFI\" or \"EXTERN\" connector, both are independent Modbus channels and uses the Modbus address 1 by default. Note The \"DISPLAY\" port can only be used if neither the built-in nor an external display is connected but since there is probably at least one display connected to one of the two \"DISPLAY\" ports, the \"DISPLAY\" port is useless.","title":"Connection"},{"location":"NeoPool/#using-wifi-port","text":"","title":"Using WIFI Port"},{"location":"NeoPool/#using-extern-port","text":"Note Leave the define for NEOPOOL_MODBUS_ADDRESS set to 1 whether you are using the \"WIFI\" or \"EXTERNAL\" port (unless you have changed the parameters for it within your Sugar Valley device).","title":"Using EXTERN Port"},{"location":"NeoPool/#configuration","text":"","title":"Configuration"},{"location":"NeoPool/#tasmota-settings","text":"If you followed the recommendations above, the two GPIOs will be assigned as follows under Tasmota Configuration -> Configure Module : first change Module type to Generic (0) - this will restart your Tasmota After restart set * GPIO1 to NeoPool RX * GPIO3 to NeoPool TX so it looks like this Don't be surprised that Rx seems to be connected to Tx here (and vice versa). The Rx and Tx designations are to be considered from the point of view of the respective devices, which can be confusing. After Tasmota restarts, the main screen should display the controller data as shown above. If not, check that the A+/B pins aren't swapped and that the Rx/Tx pins are on the correct GPIOs - swap once if in doubt.","title":"Tasmota settings"},{"location":"NeoPool/#sensor-data","text":"Sensor data is sent via the Tasmota topic tele/%topic%/SENSOR in JSON format every TelePeriod interval. To get the data immediately, use the Tasmota TelePeriod command without parameter: { \"Time\" : \"2021-06-01T11:00:00+02:00\" , \"NeoPool\" : { \"Time\" : \"2021-06-01T11:00:00\" , \"Type\" : \"Oxilife\" , \"Module\" : { \"pH\" : 1 , \"Redox\" : 1 , \"Hydrolysis\" : 1 , \"Chlorine\" : 1 , \"Conductivity\" : 1 , \"Ionization\" : 1 }, \"Temperature\" : 23.5 , \"Power\" : { \"Version\" : \"V3.45\" , \"NodeID\" : \"2A55 6E6B 6E6F 776E 2049 442A\" , \"5V\" : 5.017 , \"12V\" : 13.904 , \"24-30V\" : 33.721 , \"4-20mA\" : 0.01 }, \"pH\" : { \"Data\" : 7.2 , \"Min\" : 7.0 , \"Max\" : 7.2 , \"State\" : 0 , \"Pump\" : 2 , \"FL1\" : 0 , \"Tank\" : 1 }, \"Redox\" : { \"Data\" : 752 , \"Setpoint\" : 750 }, \"Chlorine\" : { \"Data\" : 0.7 , \"Setpoint\" : 1.0 }, \"Conductivity\" : 0 , \"Ionization\" : { \"Data\" : 0 , \"Setpoint\" : 0 , \"Max\" : 0 }, \"Hydrolysis\" : { \"Data\" : 100 , \"Unit\" : \"%\" , \"Runtime\" : { \"Total\" : \"28T22:13:19\" , \"Part\" : \"28T22:13:02\" , \"Pol1\" : \"14T12:32:46\" , \"Pol2\" : \"14T09:40:33\" , \"Changes\" : 258 }, \"State\" : \"Pol1\" , \"Cover\" : 0 , \"Boost\" : 0 , \"Low\" : 0 }, \"Filtration\" : { \"State\" : 1 , \"Speed\" : 2 , \"Mode\" : 1 }, \"Light\" : 0 , \"Relay\" : { \"State\" : [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ], \"Aux\" : [ 0 , 0 , 1 , 0 ], \"Acid\" : 0 } }, \"TempUnit\" : \"C\" } The JSON values \"pH\", \"Redox\", \"Hydrolysis\", \"Chlorine\", \"Conductivity\" and \"Ionization\" are only available if the corresponding module is installed in the device (the corresponding \"Module\" subkey must be 1 ). To check which modules are installed use the \"Module\" value from SENSOR topic or query it manually by using the NPControl command : { \"Modules\" : { \"pH\" : 1 , \"Redox\" : 1 , \"Hydrolysis\" : 1 , \"Chlorine\" : 0 , \"Conductivity\" : 0 , \"Ionization\" : 0 }, \"Relay\" : { \"Acid\" : 1 , \"Base\" : 0 , \"Redox\" : 0 , \"Chlorine\" : 0 , \"Conductivity\" : 0 , \"Heating\" : 0 , \"UV\" : 0 , \"Valve\" : 0 } }","title":"SENSOR data"},{"location":"NeoPool/#commands","text":"This sensor supports some high-level Tasmota commands for end user. Regardless, all other Modbus registers can be read and write, so you can enhance your Sugar Valley control by using low-level [NPRead]#NPRead)/[NPWrite]#NPWrite) commands. Modbus register addresses and their meaning are described within source file xsns_83_neopool.ino at the beginning and (partly) within document 171-Modbus-registers . Please note that Sugar Valley Modbus registers are not byte addresses but modbus registers containing 16-bit values - don't think in byte memory layout. Command Parameters NPFiltration {<state> {speed}} get/set manual filtration (state = 0 or 1 , speed = 1..3 ). Get if state is omitted, otherwise set accordingly <state> : 0 - manual turn filtration pump off 1 - manual turn filtration pump on optional speed control is possible for non-standard filtration types: 1 - slow 2 - medium 3 - fast NPFiltrationMode {<mode>} get/set filtration mode (mode = 0..4 or 13 ). Get if mode is omitted, otherwise set accordingly <mode> : 0 - MANUAL allows to turn the filtration (and all other systems that depend on it) on and off 1 - AUTO allows filtering to be turned on and off according to the settings of the MBF_PAR_TIMER_BLOCK_FILT_INT timers. 2 - HEATING similar to the AUTO mode, but includes setting the temperature for the heating function. This mode is activated only if the BF_PAR_HEATING_MODE register is at 1 and there is a heating relay assigned. 3 - SMART adjusts the pump operating times depending on the temperature. This mode is activated only if the MBF_PAR_TEMPERATURE_ACTIVE register is at 1. 4 - INTELLIGENT performs an intelligent filtration process in combination with the heating function. This mode is activated only if the MBF_PAR_HEATING_MODE register is at 1 and there is a heating relay assigned. 13 - BACKWASH started when the backwash operation is activated. NPTime {<time>} get/set device time. Get if time is omitted, otherwise set device time accordingly <time> : 0 - sync with Tasmota local time 1 - sync with Tasmota utc time 2..4294967295 - set time as epoch NPLight {<state> {delay}} get/set light (state = 0..4 , delay = 5..100 in 1/10 sec). Get if state is omitted, otherwise set accordingly <state> : 0 - manual turn light off 1 - manual turn light on 2 - manual toogle light 3 - switch light into auto mode according MBF_PAR_TIMER_BLOCK_LIGHT_INT settings 4 - select light RGB LED to next program. This is normally done by power the light on (if currently off), then power off the light for a given time (delay) and power on again. The default delay is 15 (=1.5 sec). NPpHMin {<ph>} (only available if pH module is installed) get/set pH lower limit (ph = 0..14 ) get current limit if is omitted, otherwise set. NPpHMax {<ph>} (only available if pH module is installed) get/set pH upper limit (ph = 0..14 ) get current limit if is omitted, otherwise set. NPpH {<ph>} (only available if pH module is installed) get/set pH upper limit (ph = 0..14 ) same as NPpHMax NPRedox {<setpoint>} (only available if redox module is installed) get/set redox set point in mV (setpoint = 0..100 , the upper limit of the range may vary depending on the MBF_PAR_HIDRO_NOM register) get current set point if is omitted, otherwise set NPHydrolysis {<level>} (only available if hydrolysis/electrolysis control is present) get/set hydrolysis/electrolysis level in % (level = 0..100 ) get current level if is omitted, otherwise set NPIonization {<level>} (only available if ionization control is present) get/set ionization target production level (level = 0..x , the upper limit x of the range may vary depending on the MBF_PAR_ION_NOM register) get current level if is omitted, otherwise set NPChlorine {<setpoint>} (only available if free chlorine probe detector is installed) get/set chlorine set point in ppm (setpoint = 0..10 ) get current set point if is omitted, otherwise set NPControl Show information about system controls NPOnError {<repeat>} get/set auto-repeat Modbus read/write commands on error (repeat = 0..10 ). Get if repeat is omitted, otherwise set accordingly <repeat> : 0 - disable auto-repeat on read/write error 1..10 - repeat commands n times until ok NPResult {<format>} get/set addr/data result format for read/write commands (format = 0|1 ). Get if format is omitted, otherwise set accordingly <format> : 0 - output decimal numbers 1 - output hexadecimal strings, this is the default NPPHRes {<digits>} get/set number of digits in results for PH value (digits = 0..3 ). NPCLRes {<digits>} get/set number of digits in results for CL value (digits = 0..3 ). NPIonRes {<digits>} get/set number of digits in results for ION value (digits = 0..3 ). NPRead <addr> {<cnt>} read 16-bit register (addr = 0..0x060F , cnt = 1..30 ). cnt = 1 if omitted NPReadL <addr> {<cnt>} read 32-bit register (addr = 0..0x060F , cnt = 1..15 ). cnt = 1 if omitted NPWrite <addr> <data> {<data>...} write 16-bit register (addr = 0..0x060F , data = 0..0xFFFF ). Use of data max 10 times NPWriteL <addr> <data> {<data>...} write 32-bit register (addr = 0..0x060F , data = 0..0xFFFFFFFF ). Use of data max 10 times NPBit <addr> <bit> {<data>} read/write a 16-bit register single bit (addr = 0..0x060F , bit = 0..15 , data = 0|1 ). Read if data is omitted, otherwise set single bit NPBitL <addr> <bit> {<data>} read/write a 32-bit register single bit (addr = 0..0x060F , bit = 0..31 , data = 0|1 ). Read if data is omitted, otherwise set single bit NPEscape clears possible errors (like pump exceeded time etc.) NPExec take over changes without writing to EEPROM. This command is necessary e.g. on changes in Installer page (addr 0x0400..0x04EE). NPSave write data permanently into EEPROM. During the EEPROM write procedure the NeoPool device may be unresponsive to MODBUS requests, this process always takes less than 1 second. Since this process is limited by the number of EEPROM write cycles, it is recommend to write all necessary changes to the registers and only then execute EEPROM write process using this command. Note: The number of EEPROM writes for Sugar Valley NeoPool devices is guaranteed 100,000 cycles. As soon as this number is exceeded, further storage of information can no longer be guaranteed .","title":"Commands"},{"location":"NeoPool/#examples","text":"Example Get filtration mode NPFil trat io n Mode RESULT = { \"NPFiltrationmode\" : \"Manual\" } Example Set filtration mode NPFil trat io n Mode 1 { \"NPFiltrationmode\" : \"Auto\" } Example Enable hydrolysis boost mode without redox control To do this, write 0x85A0 to register MBF_BOOST_CTRL ( 0x020C ), exec, save it and notify system using register MBF_NOTIFICATION ( 0x0110 ) about changes: Backlog NPWri te 0 x 020 C , 0 x 85 A 0 ;NPSave;NPExec;NPWri te 0 x 0110 , 0 x 7 F RESULT = { \"NPWrite\" :{ \"Address\" : \"0x020C\" , \"Data\" : \"0x85A0\" }} RESULT = { \"NPSave\" : \"Done\" } RESULT = { \"NPExec\" : \"Done\" } RESULT = { \"NPWrite\" :{ \"Address\" : \"0x0110\" , \"Data\" : \"0x0000\" }} Example Disable hydrolysis boost mode To do this, write 0 to register MBF_BOOST_CTRL ( 0x020C ), exec, save it and notify system using register MBF_NOTIFICATION ( 0x0110 ) about changes: Backlog NPWri te 0 x 020 C , 0 ;NPSave;NPExec;NPWri te 0 x 0110 , 0 x 7 F RESULT = { \"NPWrite\" :{ \"Address\" : \"0x020C\" , \"Data\" : \"0x0000\" }} RESULT = { \"NPSave\" : \"Done\" } RESULT = { \"NPExec\" : \"Done\" } RESULT = { \"NPWrite\" :{ \"Address\" : \"0x0110\" , \"Data\" : \"0x0000\" }} Example Switch light relay on NPLigh t 1 RESULT = { \"NPLight\" : \"ON\" } Example Read Heating setpoint temperature Here we read register MBF_PAR_HEATING_TEMP ( 0x0416 ): Backlog NPResul t 0 ;NPRead 0 x 416 RESULT = { \"NPResult\" : 0 } RESULT = { \"NPRead\" :{ \"Address\" : 1046 , \"Data\" : 28 }} Example Enable additonal factory menu For that enable bit MBMSK_SHOW_FACTORY_MENU (15) in register MBF_PAR_UICFG_VISUAL_OPTIONS ( 0x0605 ) Backlog NPBi t 0 x 605 , 15 , 1 ;NPSave RESULT = { \"NPBit\" :{ \"Address\" : \"0x0605\" , \"Data\" : \"0xAFC0\" , \"Bit15\" : 1 }} RESULT = { \"NPSave\" : \"Done\" } Example Read system time We either use command NPTime or read the 32-bit value starting MBF_PAR_TIME_LOW ( 0x0408 ) using decimal output: Backlog NPResul t 0 ;NPTime;NPReadL 0 x 408 RESULT = { \"NPResult\" : 0 } RESULT = { \"NPTime\" : \"2021-01-31T21:22:20\" } RESULT = { \"NPReadL\" :{ \"Address\" : 1032 , \"Data\" : 1612124540 }} Example Enable temperature module Do this by enabling MBF_PAR_TEMPERATURE_ACTIVE ( 0x04F ) and set it permanently in EEPROM:: Backlog NPWri te 0 x 40 F , 1 ;NPSave RESULT = { \"NPWrite\" :{ \"Address\" : \"0x040F\" , \"Data\" : \"0x0001\" }} RESULT = { \"NPSave\" : \"Done\" } Example Hide auxiliary relay display from main menu To do this, set bit MBMSK_HIDE_AUX_RELAYS (3) in register MBF_PAR_UICFG_VISUAL_OPTIONS ( 0x0605 ): NPBi t 0 x 605 , 3 , 1 RESULT = { \"NPBit\" :{ \"Address\" : \"0x0605\" , \"Data\" : \"0x08C8\" }} Example Read Filtration interval 1-3 settings To do this, we read the registers MBF_PAR_TIMER_BLOCK_FILT_INT1 ( 0x0434 ), MBF_PAR_TIMER_BLOCK_FILT_INT2 ( 0x0443 ) and MBF_PAR_TIMER_BLOCK_FILT_INT3 ( 0x0452 ) with offset MBV_TIMER_OFFMB_TIMER_ENABLE (0) as 16-bit values and the remaining timer offset values MBV_TIMER_OFFMB_* as 32-bit values: Backlog NPResul t 0 ;NPRead 0 x 434 ;NPReadL 0 x 435 , 7 ;NPRead 0 x 443 ;NPReadL 0 x 444 , 7 ;NPRead 0 x 452 ;NPReadL 0 x 0453 , 7 RESULT = { \"NPResult\" : 0 } RESULT = { \"NPRead\" :{ \"Address\" : 1076 , \"Data\" : 1 }} RESULT = { \"NPReadL\" :{ \"Address\" : 1077 , \"Data\" :[ 28800 , 0 , 86400 , 14400 , 0 , 1 , 0 ]}} RESULT = { \"NPRead\" :{ \"Address\" : 1091 , \"Data\" : 1 }} RESULT = { \"NPReadL\" :{ \"Address\" : 1092 , \"Data\" :[ 43200 , 0 , 86400 , 21600 , 0 , 1 , 0 ]}} RESULT = { \"NPRead\" :{ \"Address\" : 1106 , \"Data\" : 1 }} RESULT = { \"NPReadL\" :{ \"Address\" : 1107 , \"Data\" :[ 0 , 0 , 86400 , 0 , 0 , 1 , 0 ]}} * Example Set filtration interval Here we set interval 1 to a daily interval between 9:00 - 12:30 (9:00: 3600 * 9 \u2259 32400 / 12:30 \u2259 3,5h = 12600) For this write register MBF_PAR_TIMER_BLOCK_FILT_INT1 ( 0x0434 ) using the offsets MBV_TIMER_OFFMB_ . For the sake of simplicity we write 4 consecutive 32-bit registers: MBV_TIMER_OFFMB_TIMER_ON : Timer start = 9 3600 + 00 60 = 32400 MBV_TIMER_OFFMB_TIMER_OFF : Timer stop - not used MBV_TIMER_OFFMB_TIMER_PERIOD : Time in seconds between starting points = 86400 (means daily interval) MBV_TIMER_OFFMB_TIMER_INTERVAL : Time in seconds that the timer has to run when started. This is the difference between 12:30 (12 3600 + 30 60 = 45000) and 9:30(see Timer start = 32400) = 12600 NPWri te L 0 x 435 , 32400 0 86400 12600 RESULT = { \"NPWriteL\" :{ \"Address\" : 1077 , \"Data\" :[ 32400 , 0 , 86400 , 12600 ]}} Example Manual switch relay 7 (Aux4) To switch Aux4 ON, we set MBF_PAR_TIMER_BLOCK_AUX4_INT1 ( 0x04D9 ) + MBV_TIMER_OFFMB_TIMER_ENABLE (0) to MBV_PAR_CTIMER_ALWAYS_ON ( 3 ):. Backlog NPWri te 0 x 4 D 9 , 3 ;NPExec RESULT = { \"NPWrite\" :{ \"Address\" : \"0x04D9\" , \"Data\" : \"0x0003\" }} RESULT = { \"NPExec\" : \"Done\" } To switch Aux4 OFF, we set MBF_PAR_TIMER_BLOCK_AUX4_INT1 ( 0x04D9 ) + MBV_TIMER_OFFMB_TIMER_ENABLE (0) to MBV_PAR_CTIMER_ALWAYS_OFF ( 4 ):. Backlog NPWri te 0 x 4 D 9 , 4 ;NPExec RESULT = { \"NPWrite\" :{ \"Address\" : \"0x04D9\" , \"Data\" : \"0x0004\" }} RESULT = { \"NPExec\" : \"Done\" } Example Modbus autorepeat on communication error Read current autorepeat value: NPO n Error RESULT = { \"NPOnError\" : 2 } Set autorepeat value to 3: NPO n Error 3 RESULT = { \"NPOnError\" : 3 }","title":"Examples"},{"location":"NeoPool/#enhancements","text":"","title":"Enhancements"},{"location":"NeoPool/#daily-sync-device-to-tasmota-time","text":"Since the NeoPool devices, without a WiFi module, have no way of synchronizing their internal clock with an external clock and, in addition, the accuracy of the internal clock leaves something to be desired, it makes sense to synchronize the clock with Tasmota once a day. Advantageously, we do this at night after a possible daylight saving time or normal time change. We use a rule that synchronizes the time and which is triggered by the Tasmota built-in timer (here we use timer 10): Rule2 ON Clock # Timer = 10 DO NPTime 0 ENDON Activate it: Backlog Rule2 4 ; Rule2 1 Configure Tasmota \"Timer 10\" for your needs:","title":"Daily sync device to Tasmota time"},{"location":"NeoPool/#esp82xx-add-buttons-for-filtration-and-light-control","text":"Add two dummy buttons to control the filtration pump and the light. First we define two dummy relay (which does not have any physical function) on two unused GPIO (here we use GPIO0 and GPIO4 where we define Tasmota Relay 1 and 2): Backlog GPIO0 224 ; GPIO4 225 Then we rename the buttons for better visibility: Backlog WebButton1 Filtration ; WebButton2 Light Now we have the WebGUI buttons like this: but missing the functionality behind. For that we use Rules and connect the states for Tasmota Power, Neopool filtration and light: Rule1 ON Power1 # State == 0 DO NPFiltration % value % ENDON ON Power1 # State == 1 DO NPFiltration % value % ENDON ON NeoPool # Filtration # State == 0 DO Power1 % value % ENDON ON NeoPool # Filtration # State == 1 DO Power1 % value % ENDON ON Power2 # State == 0 DO NPLight % value % ENDON ON Power2 # State == 1 DO NPLight % value % ENDON ON NeoPool # Light == 0 DO Power2 % value % ENDON ON NeoPool # Light == 1 DO Power2 % value % ENDON Don't wonder about the double trigger definition, which at first glance seem nonsensical - they are necessary so that the rule does not trigger endless. At least we activate the rule: Backlog Rule1 5 ; Rule1 1 It is important to enable the Rule ONCE ( Rule1 5 ) function, which prevents the trigger is triggering themself in a loop. You can now control filtration and light using the WebGUI and get the current status of the device elements when they are switched by auto-mode or manually on the device directly. Additional advantage is that you can also use Tasmota Timer switching Power1 (=filtration) and Power2 (light) for your needs.","title":"ESP82xx: Add buttons for filtration and light control"},{"location":"NeoPool/#esp32-adding-user-defined-neopool-commands-to-tasmota","text":"The following enhancements are made using the Berry Scripting Language which is available on ESP32 only. The class NeoPoolCommands below adds two new commands to Tasmota: Command Parameters NPBoost {<state>} get/set boost mode (state = 0..2 ). Get if state is omitted, otherwise set accordingly <state> : 0 - disable boost mode 1 - enable boost mode (without redox control) 2 - enable boost mode (with redox control) NPAux<x> {<state>} get/set auxiliary relay <x> (state = 0..2 ). Get if state is omitted, otherwise set accordingly <state> : 0 - switch off auxiliary relay 1 - switch on auxiliary relay The class members NPBoost and NPAux can also be used as templates for further commands. Store the following code using the WebGUI \"Console\" / \"Manage File system\". ESP32 file neopool.be : class NeoPoolCommands var TEXT_OFF var TEXT_ON # string helper def ltrim ( s ) import string var i = 0 while ( s [ i ] == ' ' ) i += 1 end return string . split ( s , i )[ 1 ] end def rtrim ( s ) import string return string . split ( s , \" \" )[ 0 ] end def trim ( s ) return self . rtrim ( self . ltrim ( s )); end # NPBoost OFF|0|ON|1|REDOX|2 # 0|OFF: Switch boost off # 1|ON: Switch boost on without redox control # 2|REDOX: Switch boost on with redox control def NPBoost ( cmd , idx , payload ) import string var ctrl , parm try parm = string . toupper ( self . trim ( payload )) except .. parm = \"\" end if parm != \"\" if string . find ( parm , 'OFF' ) >= 0 || string . find ( parm , self . TEXT_OFF ) >= 0 || string . find ( parm , '0' ) >= 0 ctrl = 0 elif string . find ( parm , 'ON' ) >= 0 || string . find ( parm , self . TEXT_ON ) >= 0 || string . find ( parm , '1' ) >= 0 ctrl = 0x85A0 elif string . find ( parm , 'REDOX' ) >= 0 || string . find ( parm , '2' ) >= 0 ctrl = 0x05A0 else tasmota . resp_cmnd_error () return end tasmota . cmd ( string . format ( \"Backlog NPWrite 0x020C,0x %04X ;NPSave;NPExec;NPWrite 0x0110,0x7F\" , ctrl )) else try ctrl = compile ( \"return \" + str ( tasmota . cmd ( \"NPRead 0x020C\" )[ 'NPRead' ][ 'Data' ]))() except .. tasmota . resp_cmnd_error () return end end tasmota . resp_cmnd ( string . format ( '{\"NPBoost\":\" %s \"}' , ctrl == 0 ? self . TEXT_OFF : ( ctrl & 0x8500 ) == 0x8500 ? self . TEXT_ON : \"REDOX\" )) end # NPAux<x> OFF|0|ON|1 (<x> = 1..4) # 0|OFF: Switch aux x off # 1|ON: Switch aux x on def NPAux ( cmd , idx , payload ) import string var ctrl , parm if idx < 1 || idx > 4 tasmota . resp_cmnd_error () return end try parm = string . toupper ( self . trim ( payload )) except .. parm = \"\" end if parm != \"\" if string . find ( parm , 'OFF' ) >= 0 || string . find ( parm , self . TEXT_OFF ) >= 0 || string . find ( parm , '0' ) >= 0 ctrl = 4 elif string . find ( parm , 'ON' ) >= 0 || string . find ( parm , self . TEXT_ON ) >= 0 || string . find ( parm , '1' ) >= 0 ctrl = 3 else tasmota . resp_cmnd_error () return end tasmota . cmd ( string . format ( \"Backlog NPWrite 0x %04X , %d ;NPExec\" , [ 0x04AC , 0x04BB , 0x04CA , 0x04D9 ][ idx - 1 ], ctrl )) else try ctrl = ( compile ( \"return \" + str ( tasmota . cmd ( \"NPRead 0x010E\" )[ 'NPRead' ][ 'Data' ]))() >> ( idx + 2 )) & 1 except .. tasmota . resp_cmnd_error () return end end tasmota . resp_cmnd ( string . format ( '{\"NPAux %d \":\" %s \"}' , idx , ctrl == ( parm != \"\" ? 4 : 0 ) ? self . TEXT_OFF : self . TEXT_ON )) end def init () self . TEXT_OFF = tasmota . cmd ( \"StateText1\" )[ 'StateText1' ] self . TEXT_ON = tasmota . cmd ( \"StateText2\" )[ 'StateText2' ] # Add commands tasmota . add_cmd ( 'NPBoost' , / cmd , idx , payload -> self . NPBoost ( cmd , idx , payload )) tasmota . add_cmd ( 'NPAux' , / cmd , idx , payload -> self . NPAux ( cmd , idx , payload )) end def deinit () tasmota . remove_cmd ( 'NPBoost' ) tasmota . remove_cmd ( 'NPAux' ) end end neopool_commands = NeoPoolCommands () To activate the new commands go to WebGUI \"Consoles\" / \"Berry Scripting console\" and execute load ( \"neopool.be\" ) If you want get the new commands available after a restart of your ESP32, store the load command into the special file autoexec.be : ESP32 file autoexec.be : load ( \"neopool.be\" )","title":"ESP32: Adding user defined NeoPool commands to Tasmota"},{"location":"NodeRed/","text":"Home automation system examples with Pi, Tasmota and Node-Red ~ Detailed setting up Node-Red and mosquitto on a Raspberry PI and initial control of a Sonoff Switch: https://www.instructables.com/id/Powerful-Standalone-Home-Automation-System-Pi-Sono/ Detailed setting up of sensors and LEDs using Tasmota: https://www.instructables.com/id/Home-Automation-Sonoff-Tasmota-Sensors-LEDs-Develo// Credits: @MikePRoberts ESP8266 OTA Firmware Upgrade Manager and Server https://flows.nodered.org/flow/888b4cd95250197eb429b2f40d188185 Dynamically Populate Dashboard with Buttons to Tasmota-Sonoff Devices https://flows.nodered.org/flow/1541bcbba48bb088ec1503dba109f63c","title":"NodeRed"},{"location":"OTA-over-SCP/","text":"How to setup and configure \"OTA over SCP\" upload for PlatformIO. The uploader pushes .bin files to remote OTA server using SCP (SSH connection). Images can be served to Tasmotas from there. Configuration ~ To upload .bin images to OTA server using SCP, edit the following lines under target environment: ; *** Upload file to OTA server using SCP upload_port = USER@HOST:/path extra_scripts = pio/sftp-uploader.py upload_port should be modified to reflect user, host and path on the host where images should be uploaded. Requirements ~ SSH communication between the build server and OTA server should be pre-configured so that it doesn't require password (pre-shared keys). Add the pre-shared key ~ On a linux client machine type the following to generate the key. Press enter three times (without any input): ssh-keygen -t rsa -C \"YOUR OWN KEY DESCRIPTION\" Copy the key to your ssh server. You need to confirm this action. Use your server ssh password (one last time): ssh-copy-id -i ~/.ssh/id_rsa.pub USER@HOST Optionally, reload the ssh service: sudo /etc/init.d/ssh restart Upload Tasmota ~ Easy compilation and upload can be performed from the icons at the left side of the PlatformIO screen or use Ctrl + Alt + U to upload (will build if needed).","title":"OTA over SCP"},{"location":"OTA-over-SCP/#configuration","text":"To upload .bin images to OTA server using SCP, edit the following lines under target environment: ; *** Upload file to OTA server using SCP upload_port = USER@HOST:/path extra_scripts = pio/sftp-uploader.py upload_port should be modified to reflect user, host and path on the host where images should be uploaded.","title":"Configuration"},{"location":"OTA-over-SCP/#requirements","text":"SSH communication between the build server and OTA server should be pre-configured so that it doesn't require password (pre-shared keys).","title":"Requirements"},{"location":"OTA-over-SCP/#add-the-pre-shared-key","text":"On a linux client machine type the following to generate the key. Press enter three times (without any input): ssh-keygen -t rsa -C \"YOUR OWN KEY DESCRIPTION\" Copy the key to your ssh server. You need to confirm this action. Use your server ssh password (one last time): ssh-copy-id -i ~/.ssh/id_rsa.pub USER@HOST Optionally, reload the ssh service: sudo /etc/init.d/ssh restart","title":"Add the pre-shared key"},{"location":"OTA-over-SCP/#upload-tasmota","text":"Easy compilation and upload can be performed from the icons at the left side of the PlatformIO screen or use Ctrl + Alt + U to upload (will build if needed).","title":"Upload Tasmota"},{"location":"Octoprint/","text":"OctoPrint ~ OctoPrint provides a snappy web interface for controlling consumer 3D printers. It is Free Software and released under the GNU Affero General Public License V3 by Gina H\u00e4u\u00dfge. Its website can be found at http://www.octoprint.org . OctoPrint-Tasmota ~ Jneilliii wrote a plugin to control your Sonoff device with tasmota firmware via OctoPrint, for example shutdown the printer after a print has finished. Repository: https://github.com/jneilliii/OctoPrint-Tasmota","title":"OctoPrint"},{"location":"Octoprint/#octoprint","text":"OctoPrint provides a snappy web interface for controlling consumer 3D printers. It is Free Software and released under the GNU Affero General Public License V3 by Gina H\u00e4u\u00dfge. Its website can be found at http://www.octoprint.org .","title":"OctoPrint"},{"location":"Octoprint/#octoprint-tasmota","text":"Jneilliii wrote a plugin to control your Sonoff device with tasmota firmware via OctoPrint, for example shutdown the printer after a print has finished. Repository: https://github.com/jneilliii/OctoPrint-Tasmota","title":"OctoPrint-Tasmota"},{"location":"OpenHASP/","text":"This page moved to HASPmota","title":"OpenHASP"},{"location":"OpenTherm/","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_OPENTHERM #define USE_OPENTHERM #endif Implementation of OpenTherm protocol OpenTherm integration is based on OpenTherm protocol specification v2.2 and works with all OpenTherm compatible boilers. OpenTherm protocol requires a simple low voltage two-wire connection to the boiler, but voltage levels (7..15V) still much higher than ESP8266 levels, which requires OpenTherm Adapter. Compatible OpenTherm Adapters ~ Ihor Melnyk OpenTherm Adapter OpenTherm Gateway Arduino shield OpenTherm master shield for Wemos/Lolin All adapters have a fully isolated circuit from the boiler. However, please be aware that you can damage your boiler. You may also void your boiler warranty by installing this hardware. Please consult with your boiler manufacturer. Note For my home automation project, I used OpenTherm Gateway Arduino shield ; however, this project uses OpenTherm library from Ihor Melnyk . I assume all adapters will work. Please note, this integration does not work with the OTGW . You might want to take a look at the HA OpenTherm GW Connecting to the Boiler ~ Current integration acts as a master to the boiler. Note If OpenTherm master device is present, the boiler may disable it's front panel controls. Users may not be able to set a boiler and hot water temperature through the boiler. Now it's the responsibility of the master device. This behavior might vary across different boilers. You may disable this behavior by removing OpenTherm Slave Status command. However, the integration will not be able to read flame/heating/failure flags. OpenTherm Gateway Arduino shield support a gateway mode. As of now, this mode does not supported by the integration. As of now, gateway mode is not supported Setting Up Tasmota ~ Note You need to define USE_OPENTHERM and rebuild Tasmota to enable OpenTherm integration. Log into your Tasmota device Go to Configuration -> Configure Module Select Generic module type, save & restart In the Module parameters window, assign OpenTherm RX and OpenTherm TX to the corresponding pins Save settings and restart Note The integration attaches ISR to the RX GPIO to avoid pooling. That GPIO should support interrupts. Please consider this while working on the schematics. Troubleshooting ~ In order to troubleshoot you may need to enable Debug or More Debug logging level, After restart you might see the following in the logs: 00:00:00 CFG: Loaded from flash at 3F7, Count 72 00:00:00 QPC: Flag 0E 00:00:00 CFG: CR 338/699 00:00:00 SRC: Restart 00:00:00 Project tasmota Tasmota Version 8.2.0(sensors)-STAGE 00:00:01 [OTH]: perform handshake 00:00:01 [OTH]: Processing response. Status=SUCCESS, Response=0x4003011B 00:00:01 [OTH]: getLastResponseStatus SUCCESS. Slave Cfg: 4003011B 00:00:01 [OTH]: Processing response. Status=SUCCESS, Response=0xC0000000 00:00:02 [OTH]: Setting Boiler Temp. Old: 0, New: 85 00:00:02 [OTH]: Processing response. Status=SUCCESS, Response=0xD0015500 00:00:02 [OTH]: Setting Hot Water Temp. Old: 0, New: 37 12:34:58 [OTH]: Processing response. Status=INVALID, Response=0x70730000 12:34:58 [OTH]: command OEMD is not supported by the boiler. Last status: INVALID 12:35:00 [OTH]: Processing response. Status=INVALID, Response=0xF01B0000 12:35:00 [OTH]: command TOUT is not supported by the boiler. Last status: INVALID 12:35:00 [OTH]: Processing response. Status=INVALID, Response=0x701C0000 12:35:00 [OTH]: command TRET is not supported by the boiler. Last status: INVALID 12:35:16 MQT: tele/boiler/SENSOR = {\"Time\":\"2020-05-12T12:35:16\",\"ANALOG\":{\"A0\":7},\"OPENTHERM\":{\"conn\":\"BUSY\",\"settings\":3,\"SLAVE\":{\"FAULT\":0,\"CH\":0,\"DHW\":0,\"FL\":0,\"COOL\":0,\"CH2\":0,\"DIAG\":0,\"RAW\":3221225472},\"BTMP\":{\"FAULT\":0,\"REQ\":85.0,\"ACT\": 85.0},\"HWTMP\":{\"REQ\":37.0,\"ACT\": 37.0},\"ASFF\":{\"FC\":0,\"OFC\":0},\"FLM\":0.0,\"TB\":31.0,\"TDHW\":30.0,\"DHWS\":37.0,\"TMAX\":0.0}} In the example, perform handshake was successful, and the OpenTherm integration started to fetch various OpenTherm statuses. Note Your boiler may not respond to some of the OpenTherm commands. The integration made 3 attempts to execute the command. If the third attempt failed, the command marked as not supported and excluded from the rotation. External Thermostat Wiring and Safety ~ Central heating is the last thing you want to fail in your home. You might have significant damage to your property in case of the software bug or your custom hardware or wiring failure. As a last resort measure, you probably want to use some sort of mechanical thermostat, which turns on your boiler if the temperature drops below the safe threshold. In the worst-case scenario, your OpenTherm hardware stop communicating with the boiler. Proper boiler implementation will flag external panel error and take control back, following the external thermostat circuit state. The second issue can be with your thermostat logic, especially if your logic is running on some external device. To address this, OpenTherm integration is using Diagnostics Indication to enable central heating. That way, if your external thermostat report freezing condition, OpenTherm integration activates heating. To enable this option, set the CHOD flag. Note Another use case for the CHOD flag might be an external hot water tank storage using central heating to heat the hot water in the tank. Configuration ~ OpenTherm integration supports the following commands. ot_flags Get/Set OpenTherm flags ot_tboiler Get/Set central heating temperature ot_twater Get/Set domestic hot water temperature ot_save_setpoints Save central heating and domestic hot water temperatures ot_ch Activate/Deactivate central heating ot_flags command ~ OpenTherm integration supports the following flags: CHOD - Enable CH (central heating) on diagnostics flag. See External Thermostat section DHW - Enable Domestic Hot Water. If you have an on-demand gas heater, it won't start heating immediately, but enable heating when water is on CH - If set, activate central heating permanently, following the ot_tboiler setpoint value. If disabled and CHOD is set, it follows the Diagnostics flag. Otherwise, heating is controlled by the ot_ch status COOL - Enable cooling, if supported. Refer to your boiler manual. OTC - Enable external temperature compensation thermistor. Refer to your boiler manual. CH2 - Enable auxiliary central heating. Refer to your boiler manual. Note During the first run, ot_flags is set to the CHOD,DHW . Hot water setpoint set to 36-degree Celsius and central heating temperature set to 85 degree celsius To get OpenTherm flags, type ot_flags 13:49:48 CMD: ot_flags 13:49:48 MQT: stat/boiler/RESULT = CHOD,DHW To set OpenTherm flags, type ot_flags DHW,CH,OTC 13:49:48 CMD: ot_flags DHW,CH,OTC 13:49:48 MQT: stat/boiler/RESULT = DHW,CH,OTC ot_tboiler command ~ ot_tboiler set boiler (CH) desired temperature. The actual command to the boiler will be issued if your new temperature difference bigger than the OPENTHERM_BOILER_SETPOINT_TOLERANCE value which is 1-degree Celsius as of today. 14:12:04 CMD: ot_tboiler 14:12:04 MQT: stat/boiler/RESULT = {\"ot_tboiler\":60.0} 14:12:55 CMD: ot_tboiler 85 14:12:55 MQT: stat/boiler/RESULT = {\"ot_tboiler\":85.0} 14:12:57 [OTH]: Setting Boiler Temp. Old: 60, New: 85 Note Some boilers might write setpoint temperature into the Flash memory. Having PID controlled appliance may produce a lot of small fluctuations in the setpoint value, wearing out Boiler flash memory. Warning ot_tboiler do not write the value in the Tasmota settings, reducing Flash memory writes. To store it permanently, invoke ot_save_setpoints command after ot_tboiler command ot_twater command ~ ot_twater set domestic hot water temperature setpoint (DHW). Warning ot_twater do not write the value in the Tasmota settings. To store it permanently, invoke ot_save_setpoints command after ot_twater command. 14:13:55 CMD: ot_twater 14:13:55 MQT: stat/boiler/RESULT = {\"ot_twater\":38.0} 14:13:55 CMD: ot_twater 40 14:13:55 MQT: stat/boiler/RESULT = {\"ot_twater\":40.0} ot_save_setpoints command ~ ot_save_setpoints store boiler and domestic hot water setpoints into the flash memory of the Tasmota. ot_ch command ~ ot_ch enable or disable central heating (CH). The Boiler follows the ot_tboiler temperature setpoint. 14:14:57 CMD: ot_ch 14:14:57 MQT: stat/boiler/RESULT = {\"ot_ch\":0} 14:15:57 CMD: ot_ch 1 14:15:57 MQT: stat/boiler/RESULT = {\"ot_ch\":1} Warning ot_ch 0 won't turn the boiler off, if CHOD flag is set and external thermostat requires heat Setting Hot Water temperature ~ One of the drawbacks, at least with my boiler, is that the boiler disables all the external knobs, so I can not set up the desired hot water temperature from the boiler itself. You might come up with the automation, setting hot water temperature by some schedule. Another way is to use Home Assistant with the HomeKit integration. I created MQTT Hot Water Heater integration to the Home Assistant, so the Water Heater is exposed to the Home Kit. You should be able to install it through HACS You can add the following configuration into the configuration.yaml of your Home Assistant set up. water_heater: platform: mqtt_water_heater name: \"Water Heater\" state_topic: \"tele/boiler/SENSOR\" command_topic: \"cmnd/boiler/OT_TWATER\" value_template: \"{{ value_json.OPENTHERM.DHWS }}\" qos: 0 availability_topic: \"tele/boiler/LWT\" payload_available: \"Online\" payload_not_available: \"Offline\" target_temperature: 38 heater_min_temperature: 35 heater_max_temperature: 50 Automation Examples ~ This automation example turns on then Bathroom towel heater if someone is using hot water more than 5 minutes in the evening or more than 7 minutes in the evening. Bathroom towel heater has a coolant pump relay at 192.168.1.xx Also, it always turns on the heater on Clock#Timer3 event, working according to the schedule It publishes state to the st/boiler/rr_dry for the Home Assistant bookkeeping. Also, it set boiler temperature to the %var3% value if external heating is required during the bathroom Dry mode. Also, it syncs up the coolant pump state in case of the pump controller power outage. # var1 - hot water ON time to enable bathroom Dry mode # var2 - Bathroom Dry Mode boiler setpoint # var3 - Normal Mode boiler setpoint # var15 - a lock of the flame mode to avoid timer restart # var16 - sync power4 state # use VAR3 to set the actual boiler temperature setpoint # If heat demand is on during RR Dry Mode, the temperature should be set back to the normal Rule1 on system#boot do backlog TelePeriod 20; var1=540; var2=60; var3=85; var15 0; var16 0 endon on tele-OPENTHERM#SLAVE#FL do WebSend [192.168.1.xx] POWER4 %var16%; endon on Clock#Timer=1 do var1=300 endon on Clock#Timer=2 do var1=420 endon on Clock#Timer=3 do event dr=1 endon on var3#state do ot_tboiler %value% endon Rule2 on tele-OPENTHERM#SLAVE#DHW>%var15% do backlog RuleTimer1 %var1%; var15 1 endon on tele-OPENTHERM#SLAVE#DHW=0 do backlog RuleTimer1 0; var15 0 endon on Rules#Timer=2 do backlog ot_ch 0; ot_tboiler %var3%; var16 0; WebSend [192.168.1.xx] POWER4 OFF; publish st/boiler/rr_dry 0 endon on Rules#Timer=1 do event dr=1 endon on event#dr do backlog RuleTimer2 7200; ot_ch 1; ot_tboiler %var2%; var16 1; WebSend [192.168.1.xx] POWER4 ON; publish st/boiler/rr_dry 1 endon Rule3 on tele-OPENTHERM#SLAVE#DIAG=1 do ot_tboiler %var3%; endon on tele-OPENTHERM#SLAVE#DIAG=0 do ot_tboiler %var2%; endon","title":"OpenTherm"},{"location":"OpenTherm/#compatible-opentherm-adapters","text":"Ihor Melnyk OpenTherm Adapter OpenTherm Gateway Arduino shield OpenTherm master shield for Wemos/Lolin All adapters have a fully isolated circuit from the boiler. However, please be aware that you can damage your boiler. You may also void your boiler warranty by installing this hardware. Please consult with your boiler manufacturer. Note For my home automation project, I used OpenTherm Gateway Arduino shield ; however, this project uses OpenTherm library from Ihor Melnyk . I assume all adapters will work. Please note, this integration does not work with the OTGW . You might want to take a look at the HA OpenTherm GW","title":"Compatible OpenTherm Adapters"},{"location":"OpenTherm/#connecting-to-the-boiler","text":"Current integration acts as a master to the boiler. Note If OpenTherm master device is present, the boiler may disable it's front panel controls. Users may not be able to set a boiler and hot water temperature through the boiler. Now it's the responsibility of the master device. This behavior might vary across different boilers. You may disable this behavior by removing OpenTherm Slave Status command. However, the integration will not be able to read flame/heating/failure flags. OpenTherm Gateway Arduino shield support a gateway mode. As of now, this mode does not supported by the integration. As of now, gateway mode is not supported","title":"Connecting to the Boiler"},{"location":"OpenTherm/#setting-up-tasmota","text":"Note You need to define USE_OPENTHERM and rebuild Tasmota to enable OpenTherm integration. Log into your Tasmota device Go to Configuration -> Configure Module Select Generic module type, save & restart In the Module parameters window, assign OpenTherm RX and OpenTherm TX to the corresponding pins Save settings and restart Note The integration attaches ISR to the RX GPIO to avoid pooling. That GPIO should support interrupts. Please consider this while working on the schematics.","title":"Setting Up Tasmota"},{"location":"OpenTherm/#troubleshooting","text":"In order to troubleshoot you may need to enable Debug or More Debug logging level, After restart you might see the following in the logs: 00:00:00 CFG: Loaded from flash at 3F7, Count 72 00:00:00 QPC: Flag 0E 00:00:00 CFG: CR 338/699 00:00:00 SRC: Restart 00:00:00 Project tasmota Tasmota Version 8.2.0(sensors)-STAGE 00:00:01 [OTH]: perform handshake 00:00:01 [OTH]: Processing response. Status=SUCCESS, Response=0x4003011B 00:00:01 [OTH]: getLastResponseStatus SUCCESS. Slave Cfg: 4003011B 00:00:01 [OTH]: Processing response. Status=SUCCESS, Response=0xC0000000 00:00:02 [OTH]: Setting Boiler Temp. Old: 0, New: 85 00:00:02 [OTH]: Processing response. Status=SUCCESS, Response=0xD0015500 00:00:02 [OTH]: Setting Hot Water Temp. Old: 0, New: 37 12:34:58 [OTH]: Processing response. Status=INVALID, Response=0x70730000 12:34:58 [OTH]: command OEMD is not supported by the boiler. Last status: INVALID 12:35:00 [OTH]: Processing response. Status=INVALID, Response=0xF01B0000 12:35:00 [OTH]: command TOUT is not supported by the boiler. Last status: INVALID 12:35:00 [OTH]: Processing response. Status=INVALID, Response=0x701C0000 12:35:00 [OTH]: command TRET is not supported by the boiler. Last status: INVALID 12:35:16 MQT: tele/boiler/SENSOR = {\"Time\":\"2020-05-12T12:35:16\",\"ANALOG\":{\"A0\":7},\"OPENTHERM\":{\"conn\":\"BUSY\",\"settings\":3,\"SLAVE\":{\"FAULT\":0,\"CH\":0,\"DHW\":0,\"FL\":0,\"COOL\":0,\"CH2\":0,\"DIAG\":0,\"RAW\":3221225472},\"BTMP\":{\"FAULT\":0,\"REQ\":85.0,\"ACT\": 85.0},\"HWTMP\":{\"REQ\":37.0,\"ACT\": 37.0},\"ASFF\":{\"FC\":0,\"OFC\":0},\"FLM\":0.0,\"TB\":31.0,\"TDHW\":30.0,\"DHWS\":37.0,\"TMAX\":0.0}} In the example, perform handshake was successful, and the OpenTherm integration started to fetch various OpenTherm statuses. Note Your boiler may not respond to some of the OpenTherm commands. The integration made 3 attempts to execute the command. If the third attempt failed, the command marked as not supported and excluded from the rotation.","title":"Troubleshooting"},{"location":"OpenTherm/#external-thermostat-wiring-and-safety","text":"Central heating is the last thing you want to fail in your home. You might have significant damage to your property in case of the software bug or your custom hardware or wiring failure. As a last resort measure, you probably want to use some sort of mechanical thermostat, which turns on your boiler if the temperature drops below the safe threshold. In the worst-case scenario, your OpenTherm hardware stop communicating with the boiler. Proper boiler implementation will flag external panel error and take control back, following the external thermostat circuit state. The second issue can be with your thermostat logic, especially if your logic is running on some external device. To address this, OpenTherm integration is using Diagnostics Indication to enable central heating. That way, if your external thermostat report freezing condition, OpenTherm integration activates heating. To enable this option, set the CHOD flag. Note Another use case for the CHOD flag might be an external hot water tank storage using central heating to heat the hot water in the tank.","title":"External Thermostat Wiring and Safety"},{"location":"OpenTherm/#configuration","text":"OpenTherm integration supports the following commands. ot_flags Get/Set OpenTherm flags ot_tboiler Get/Set central heating temperature ot_twater Get/Set domestic hot water temperature ot_save_setpoints Save central heating and domestic hot water temperatures ot_ch Activate/Deactivate central heating","title":"Configuration"},{"location":"OpenTherm/#ot_flags-command","text":"OpenTherm integration supports the following flags: CHOD - Enable CH (central heating) on diagnostics flag. See External Thermostat section DHW - Enable Domestic Hot Water. If you have an on-demand gas heater, it won't start heating immediately, but enable heating when water is on CH - If set, activate central heating permanently, following the ot_tboiler setpoint value. If disabled and CHOD is set, it follows the Diagnostics flag. Otherwise, heating is controlled by the ot_ch status COOL - Enable cooling, if supported. Refer to your boiler manual. OTC - Enable external temperature compensation thermistor. Refer to your boiler manual. CH2 - Enable auxiliary central heating. Refer to your boiler manual. Note During the first run, ot_flags is set to the CHOD,DHW . Hot water setpoint set to 36-degree Celsius and central heating temperature set to 85 degree celsius To get OpenTherm flags, type ot_flags 13:49:48 CMD: ot_flags 13:49:48 MQT: stat/boiler/RESULT = CHOD,DHW To set OpenTherm flags, type ot_flags DHW,CH,OTC 13:49:48 CMD: ot_flags DHW,CH,OTC 13:49:48 MQT: stat/boiler/RESULT = DHW,CH,OTC","title":"ot_flags command"},{"location":"OpenTherm/#ot_tboiler-command","text":"ot_tboiler set boiler (CH) desired temperature. The actual command to the boiler will be issued if your new temperature difference bigger than the OPENTHERM_BOILER_SETPOINT_TOLERANCE value which is 1-degree Celsius as of today. 14:12:04 CMD: ot_tboiler 14:12:04 MQT: stat/boiler/RESULT = {\"ot_tboiler\":60.0} 14:12:55 CMD: ot_tboiler 85 14:12:55 MQT: stat/boiler/RESULT = {\"ot_tboiler\":85.0} 14:12:57 [OTH]: Setting Boiler Temp. Old: 60, New: 85 Note Some boilers might write setpoint temperature into the Flash memory. Having PID controlled appliance may produce a lot of small fluctuations in the setpoint value, wearing out Boiler flash memory. Warning ot_tboiler do not write the value in the Tasmota settings, reducing Flash memory writes. To store it permanently, invoke ot_save_setpoints command after ot_tboiler command","title":"ot_tboiler command"},{"location":"OpenTherm/#ot_twater-command","text":"ot_twater set domestic hot water temperature setpoint (DHW). Warning ot_twater do not write the value in the Tasmota settings. To store it permanently, invoke ot_save_setpoints command after ot_twater command. 14:13:55 CMD: ot_twater 14:13:55 MQT: stat/boiler/RESULT = {\"ot_twater\":38.0} 14:13:55 CMD: ot_twater 40 14:13:55 MQT: stat/boiler/RESULT = {\"ot_twater\":40.0}","title":"ot_twater command"},{"location":"OpenTherm/#ot_save_setpoints-command","text":"ot_save_setpoints store boiler and domestic hot water setpoints into the flash memory of the Tasmota.","title":"ot_save_setpoints command"},{"location":"OpenTherm/#ot_ch-command","text":"ot_ch enable or disable central heating (CH). The Boiler follows the ot_tboiler temperature setpoint. 14:14:57 CMD: ot_ch 14:14:57 MQT: stat/boiler/RESULT = {\"ot_ch\":0} 14:15:57 CMD: ot_ch 1 14:15:57 MQT: stat/boiler/RESULT = {\"ot_ch\":1} Warning ot_ch 0 won't turn the boiler off, if CHOD flag is set and external thermostat requires heat","title":"ot_ch command"},{"location":"OpenTherm/#setting-hot-water-temperature","text":"One of the drawbacks, at least with my boiler, is that the boiler disables all the external knobs, so I can not set up the desired hot water temperature from the boiler itself. You might come up with the automation, setting hot water temperature by some schedule. Another way is to use Home Assistant with the HomeKit integration. I created MQTT Hot Water Heater integration to the Home Assistant, so the Water Heater is exposed to the Home Kit. You should be able to install it through HACS You can add the following configuration into the configuration.yaml of your Home Assistant set up. water_heater: platform: mqtt_water_heater name: \"Water Heater\" state_topic: \"tele/boiler/SENSOR\" command_topic: \"cmnd/boiler/OT_TWATER\" value_template: \"{{ value_json.OPENTHERM.DHWS }}\" qos: 0 availability_topic: \"tele/boiler/LWT\" payload_available: \"Online\" payload_not_available: \"Offline\" target_temperature: 38 heater_min_temperature: 35 heater_max_temperature: 50","title":"Setting Hot Water temperature"},{"location":"OpenTherm/#automation-examples","text":"This automation example turns on then Bathroom towel heater if someone is using hot water more than 5 minutes in the evening or more than 7 minutes in the evening. Bathroom towel heater has a coolant pump relay at 192.168.1.xx Also, it always turns on the heater on Clock#Timer3 event, working according to the schedule It publishes state to the st/boiler/rr_dry for the Home Assistant bookkeeping. Also, it set boiler temperature to the %var3% value if external heating is required during the bathroom Dry mode. Also, it syncs up the coolant pump state in case of the pump controller power outage. # var1 - hot water ON time to enable bathroom Dry mode # var2 - Bathroom Dry Mode boiler setpoint # var3 - Normal Mode boiler setpoint # var15 - a lock of the flame mode to avoid timer restart # var16 - sync power4 state # use VAR3 to set the actual boiler temperature setpoint # If heat demand is on during RR Dry Mode, the temperature should be set back to the normal Rule1 on system#boot do backlog TelePeriod 20; var1=540; var2=60; var3=85; var15 0; var16 0 endon on tele-OPENTHERM#SLAVE#FL do WebSend [192.168.1.xx] POWER4 %var16%; endon on Clock#Timer=1 do var1=300 endon on Clock#Timer=2 do var1=420 endon on Clock#Timer=3 do event dr=1 endon on var3#state do ot_tboiler %value% endon Rule2 on tele-OPENTHERM#SLAVE#DHW>%var15% do backlog RuleTimer1 %var1%; var15 1 endon on tele-OPENTHERM#SLAVE#DHW=0 do backlog RuleTimer1 0; var15 0 endon on Rules#Timer=2 do backlog ot_ch 0; ot_tboiler %var3%; var16 0; WebSend [192.168.1.xx] POWER4 OFF; publish st/boiler/rr_dry 0 endon on Rules#Timer=1 do event dr=1 endon on event#dr do backlog RuleTimer2 7200; ot_ch 1; ot_tboiler %var2%; var16 1; WebSend [192.168.1.xx] POWER4 ON; publish st/boiler/rr_dry 1 endon Rule3 on tele-OPENTHERM#SLAVE#DIAG=1 do ot_tboiler %var3%; endon on tele-OPENTHERM#SLAVE#DIAG=0 do ot_tboiler %var2%; endon","title":"Automation Examples"},{"location":"P1-Smart-Meter/","text":"P1 Smart Meter ~ Reading serial data from a P1 smart meter using a Wemos with Tasmota installed. Tested on the following smart meters: Kaifa MA105C De Landis + Gyr, E350 (ZCF110) Sanxing SX631 (S34U18) Schematics ~ The transistor makes sure that the RxD signal is converted and inverted to 3.3V. According to the DSMR v5.0.2 P1 specification the P1 connector on the meter provides 5V DC output for the OSM (Other Service Module) connected to this port, which is able to continuously supply maximum current of 250mA. A Wemos D1 mini module draws way less than 100mA so it is perfectly safe to use this as a power source. It can be powered through the 5V pin just inserting a protection diode. Tasmota Settings ~ In the Configuration -> Configure Module page, select module Generic (18) From the web console set the serial delimiter to 10 (newline). This makes Tasmota publish each line of the telegram separately to mqtt. SerialDelimiter 10 SerialSend 1 For more details see serial-bridge . Should you run into problems with serial buffer overflows, then try to increase the serial buffer size using SerialBuffer 520 . This will not be automatically persisted , so try the command first and when the device works fine after having increased the serial buffer size, then try to add a rule like: Rule1 ON Power1 # Boot DO SerialBuffer 520 ENDON Example output ~ Below an example of the telegram message published (per line) to mqtt. From here your HA system can process the data required for your needs. 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"/KFM5KAIFA-METER\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-3:0.2.8(42)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:1.0.0(200913101618S)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.1.1(4530303235303030303639363432393136)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.1(005779.835*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.2(005583.617*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.1(000000.000*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.2(000000.000*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.14.0(0001)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.7.0(00.498*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.7.0(00.000*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.21(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.9(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.32.0(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.36.0(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.1()\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.0()\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:31.7.0(002*A)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:21.7.0(00.496*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:22.7.0(00.000*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.1.0(003)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:96.1.0(4730303332353631323736373836373136)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.2.1(200913100000S)(04139.079*m3)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"!F798\\r\" } Description of each line ~ see also DSMR 5.0 - P1 Companion Standard Header information - {\"SerialReceived\":\"/KFM5KAIFA-METER\"} Empty line - {\"SerialReceived\":\"\"} Version information for P1 output - {\"SerialReceived\":\"1-3:0.2.8(42)\"} Date-time stamp of the P1 message - {\"SerialReceived\":\"0-0:1.0.0(181227093413W)\"} Equipment identifier - {\"SerialReceived\":\"0-0:96.1.1(4530303235303030303639363432393136)\"} electricityUsedTariff1 >> Meter Reading electricity delivered to client (Tariff 1) in 0,001 kWh - {\"SerialReceived\":\"1-0:1.8.1(002293.192*kWh)\"} electricityUsedTariff2 >> Meter Reading electricity delivered to client (Tariff 2) in 0,001 kWh - {\"SerialReceived\":\"1-0:1.8.2(002523.640*kWh)\"} Meter Reading electricity delivered by client (Tariff 1) in 0,001 kWh - {\"SerialReceived\":\"1-0:2.8.1(000000.000*kWh)\"} Meter Reading electricity delivered by client (Tariff 2) in 0,001 kWh - {\"SerialReceived\":\"1-0:2.8.2(000000.000*kWh)\"} electricityActiveTariff >> Tariff indicator electricity. The tariff indicator can also be used to switch tariff dependent loads e.g boilers. This is the responsibility of the P1 user - {\"SerialReceived\":\"0-0:96.14.0(0002)\"} Actual electricity power delivered (+P) in 1 Watt resolution - {\"SerialReceived\":\"1-0:1.7.0(00.474*kW)\"} Actual electricity power received (-P) in 1 Watt resolution - {\"SerialReceived\":\"1-0:2.7.0(00.000*kW)\"} Number of power failures in any phase - {\"SerialReceived\":\"0-0:96.7.21(00000)\"} Number of long power failures in any phase - {\"SerialReceived\":\"0-0:96.7.9(00000)\"} Power Failure Event Log (long power failures) - {\"SerialReceived\":\"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\"} Number of voltage sags in phase L1 - {\"SerialReceived\":\"1-0:32.32.0(00000)\"} Number of voltage swells in phase L1 - {\"SerialReceived\":\"1-0:32.36.0(00000)\"} Text message max 1024 characters. - {\"SerialReceived\":\"0-0:96.13.1()\"} Text message max 1024 characters. - {\"SerialReceived\":\"0-0:96.13.0()\"} Instantaneous current L1 in A resolution - {\"SerialReceived\":\"1-0:31.7.0(002*A)\"} Instantaneous active power L1 (+P) in W resolution - {\"SerialReceived\":\"1-0:21.7.0(00.474*kW)\"} Instantaneous active power L1 (-P) in W resolution - {\"SerialReceived\":\"1-0:22.7.0(00.000*kW)\"} Device-Type - {\"SerialReceived\":\"0-1:24.1.0(003)\"} Equipment identifier (Gas) - {\"SerialReceived\":\"0-1:96.1.0(4730303332353631323736373836373136)\"} GasMeterReadingFiveMinutes >> Last 5-minute value (temperature converted), gas delivered to client in m3, including decimal values and capture time - {\"SerialReceived\":\"0-1:24.2.1(181227090000W)(02910.491*m3)\"} {\"SerialReceived\":\"!5E3E\"} Also see Tasmota's Smart Meter Interface if you want to have these OBIS lines translated in selected sensors populatinng MQTT payloads. Additional info * Kaifa Meters (Dutch) * DSMR 5.0 - P1 Companion Standard","title":"P1 Smart Meter"},{"location":"P1-Smart-Meter/#p1-smart-meter","text":"Reading serial data from a P1 smart meter using a Wemos with Tasmota installed. Tested on the following smart meters: Kaifa MA105C De Landis + Gyr, E350 (ZCF110) Sanxing SX631 (S34U18)","title":"P1 Smart Meter"},{"location":"P1-Smart-Meter/#schematics","text":"The transistor makes sure that the RxD signal is converted and inverted to 3.3V. According to the DSMR v5.0.2 P1 specification the P1 connector on the meter provides 5V DC output for the OSM (Other Service Module) connected to this port, which is able to continuously supply maximum current of 250mA. A Wemos D1 mini module draws way less than 100mA so it is perfectly safe to use this as a power source. It can be powered through the 5V pin just inserting a protection diode.","title":"Schematics"},{"location":"P1-Smart-Meter/#tasmota-settings","text":"In the Configuration -> Configure Module page, select module Generic (18) From the web console set the serial delimiter to 10 (newline). This makes Tasmota publish each line of the telegram separately to mqtt. SerialDelimiter 10 SerialSend 1 For more details see serial-bridge . Should you run into problems with serial buffer overflows, then try to increase the serial buffer size using SerialBuffer 520 . This will not be automatically persisted , so try the command first and when the device works fine after having increased the serial buffer size, then try to add a rule like: Rule1 ON Power1 # Boot DO SerialBuffer 520 ENDON","title":"Tasmota Settings"},{"location":"P1-Smart-Meter/#example-output","text":"Below an example of the telegram message published (per line) to mqtt. From here your HA system can process the data required for your needs. 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"/KFM5KAIFA-METER\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-3:0.2.8(42)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:1.0.0(200913101618S)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.1.1(4530303235303030303639363432393136)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.1(005779.835*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.2(005583.617*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.1(000000.000*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.2(000000.000*kWh)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.14.0(0001)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.7.0(00.498*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.7.0(00.000*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.21(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.9(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.32.0(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.36.0(00000)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.1()\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.0()\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:31.7.0(002*A)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:21.7.0(00.496*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:22.7.0(00.000*kW)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.1.0(003)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:96.1.0(4730303332353631323736373836373136)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.2.1(200913100000S)(04139.079*m3)\\r\" } 09 : 16 : 17 MQT : tele /wemos -9 /RESULT = { \"SerialReceived\" : \"!F798\\r\" }","title":"Example output"},{"location":"P1-Smart-Meter/#description-of-each-line","text":"see also DSMR 5.0 - P1 Companion Standard Header information - {\"SerialReceived\":\"/KFM5KAIFA-METER\"} Empty line - {\"SerialReceived\":\"\"} Version information for P1 output - {\"SerialReceived\":\"1-3:0.2.8(42)\"} Date-time stamp of the P1 message - {\"SerialReceived\":\"0-0:1.0.0(181227093413W)\"} Equipment identifier - {\"SerialReceived\":\"0-0:96.1.1(4530303235303030303639363432393136)\"} electricityUsedTariff1 >> Meter Reading electricity delivered to client (Tariff 1) in 0,001 kWh - {\"SerialReceived\":\"1-0:1.8.1(002293.192*kWh)\"} electricityUsedTariff2 >> Meter Reading electricity delivered to client (Tariff 2) in 0,001 kWh - {\"SerialReceived\":\"1-0:1.8.2(002523.640*kWh)\"} Meter Reading electricity delivered by client (Tariff 1) in 0,001 kWh - {\"SerialReceived\":\"1-0:2.8.1(000000.000*kWh)\"} Meter Reading electricity delivered by client (Tariff 2) in 0,001 kWh - {\"SerialReceived\":\"1-0:2.8.2(000000.000*kWh)\"} electricityActiveTariff >> Tariff indicator electricity. The tariff indicator can also be used to switch tariff dependent loads e.g boilers. This is the responsibility of the P1 user - {\"SerialReceived\":\"0-0:96.14.0(0002)\"} Actual electricity power delivered (+P) in 1 Watt resolution - {\"SerialReceived\":\"1-0:1.7.0(00.474*kW)\"} Actual electricity power received (-P) in 1 Watt resolution - {\"SerialReceived\":\"1-0:2.7.0(00.000*kW)\"} Number of power failures in any phase - {\"SerialReceived\":\"0-0:96.7.21(00000)\"} Number of long power failures in any phase - {\"SerialReceived\":\"0-0:96.7.9(00000)\"} Power Failure Event Log (long power failures) - {\"SerialReceived\":\"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\"} Number of voltage sags in phase L1 - {\"SerialReceived\":\"1-0:32.32.0(00000)\"} Number of voltage swells in phase L1 - {\"SerialReceived\":\"1-0:32.36.0(00000)\"} Text message max 1024 characters. - {\"SerialReceived\":\"0-0:96.13.1()\"} Text message max 1024 characters. - {\"SerialReceived\":\"0-0:96.13.0()\"} Instantaneous current L1 in A resolution - {\"SerialReceived\":\"1-0:31.7.0(002*A)\"} Instantaneous active power L1 (+P) in W resolution - {\"SerialReceived\":\"1-0:21.7.0(00.474*kW)\"} Instantaneous active power L1 (-P) in W resolution - {\"SerialReceived\":\"1-0:22.7.0(00.000*kW)\"} Device-Type - {\"SerialReceived\":\"0-1:24.1.0(003)\"} Equipment identifier (Gas) - {\"SerialReceived\":\"0-1:96.1.0(4730303332353631323736373836373136)\"} GasMeterReadingFiveMinutes >> Last 5-minute value (temperature converted), gas delivered to client in m3, including decimal values and capture time - {\"SerialReceived\":\"0-1:24.2.1(181227090000W)(02910.491*m3)\"} {\"SerialReceived\":\"!5E3E\"} Also see Tasmota's Smart Meter Interface if you want to have these OBIS lines translated in selected sensors populatinng MQTT payloads. Additional info * Kaifa Meters (Dutch) * DSMR 5.0 - P1 Companion Standard","title":"Description of each line"},{"location":"PAJ7620/","text":"PAJ7620U2 gesture sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_PAJ7620 #define USE_PAJ7620 // [I2cDriver34] Enable PAJ7620 gesture sensor (I2C address 0x73) (+2.5k code) #endif PAJ7620U2 is an integrated gesture recognition I 2 C sensor from PixArt-Imaging Inc. based on infrared. It also has built-in proximity detection and can sense various properties like position (x,y,z) and speed. Gesture recognition seems to be more stable than with the APDS-9960 , which on the other hand is a lot cheaper. Configuration ~ Wiring ~ Breakout ESP VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT Not used Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect the PAJ7620 automatically. After restart Tasmota needs some time to completely configure its state. In this time frame it is likely to miss some gestures. This should stabilize after a few moments. Commands ~ To use the sensor you need to switch to the desired mode of operation with Sensor50 <x> where <x> = 0\u20265 . It will not appear in the webUI but it can be observed via MQTT messages in console. 0 - Off ~ Sensor muted, no readings in Tasmota. 1 - Gesture Mode ~ Reports gesture movement with: \u2003 Up \u2003 Down \u2003 Left \u2003 Right \u2003 Near \u2003 Far \u2003 CW (clockwise rotation) \u2003 CCW (counter-clockwise rotation) As expected, \"Near\" and \"Far\" gestures are tricky and you have to train your movements to catch them. Sometimes the sensor reports \"Near\" and \"Far\" at once (which will be discarded). There is some postprocessing to allow the object (hand or finger) to move into the sensing area and delay the initial direction report (up, down, left, right) to give the chance to trigger (the intended) \"Near\" or \"Far\" movement. Especially \"Far\" is a bit harder to achieve. example: \u2026{Up:1} = up gesture once \u2026{Left:3} = left gesture 3 times in a row, without any other gesture in between 2 - Proximity Mode ~ Arbitrary values between 0 (far away) and 255 (very near) are given. Exit from the sensor field will always give at least one \"zero message\". tele is only triggered, when the value has changed. example: \u2026{Proximity:255} = close proximity, almost touching the sensor \u2026{Proximity:0} = object has left the sensing area 3 - Corner Mode ~ Sensing area is organised in quarters. An object in one of the corners will trigger the corresponding number. 1 2 3 4 example: \u2026{Corner:2} = object in upper right corner 4 - PIN Mode: ~ A fluent movement of an object through a given sequence of corners (similar to unlocking a smartphone) will trigger a valid \"PIN\". The next corner must be reached in about 0.7 seconds. example: \u2026{PIN:1} = valid PIN 5 - Cursor Mode: ~ Shows x- and y-coordinates. Mainly intended for debugging and \"seeing\" the sensing area. This reads only the upper 5-bit-values, which automatically removes much of the jitter, giving values between 0 and 15. example: \u2026{x:1, y:15} = upper left corner The sensor provides some more goodies, like velocity of an object, so if someone has a fancy use case for this, feel free to open a feature request. Of course it would be possible to mix the modes, but this can produce a lot of MQTT-messages. This could be added later upon user request (based on real world use cases). Breakout boards ~","title":"PAJ7620U2 gesture sensor"},{"location":"PAJ7620/#paj7620u2-gesture-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_PAJ7620 #define USE_PAJ7620 // [I2cDriver34] Enable PAJ7620 gesture sensor (I2C address 0x73) (+2.5k code) #endif PAJ7620U2 is an integrated gesture recognition I 2 C sensor from PixArt-Imaging Inc. based on infrared. It also has built-in proximity detection and can sense various properties like position (x,y,z) and speed. Gesture recognition seems to be more stable than with the APDS-9960 , which on the other hand is a lot cheaper.","title":"PAJ7620U2 gesture sensor"},{"location":"PAJ7620/#configuration","text":"","title":"Configuration"},{"location":"PAJ7620/#wiring","text":"Breakout ESP VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT Not used","title":"Wiring"},{"location":"PAJ7620/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect the PAJ7620 automatically. After restart Tasmota needs some time to completely configure its state. In this time frame it is likely to miss some gestures. This should stabilize after a few moments.","title":"Tasmota Settings"},{"location":"PAJ7620/#commands","text":"To use the sensor you need to switch to the desired mode of operation with Sensor50 <x> where <x> = 0\u20265 . It will not appear in the webUI but it can be observed via MQTT messages in console.","title":"Commands"},{"location":"PAJ7620/#breakout-boards","text":"","title":"Breakout boards"},{"location":"PCA9685/","text":"PCA9685 12-bit PWM controller ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_PCA9685 #define USE_PCA9685 // [I2cDriver1] Enable PCA9685 I2C HW PWM Driver - Must define I2C Address in #define USE_PCA9685_ADDR below - range 0x40 - 0x47 (+1k4 code) #define USE_PCA9685_ADDR 0x40 // Enable PCA9685 I2C Address to use (Must be within range 0x40 through 0x47 - set according to your wired setup) #define USE_PCA9685_FREQ 50 // Define default PWM frequency in Hz to be used (must be within 24 to 1526) - If other value is used, it will rever to 50Hz #endif Technical Data: Product Information from NXP IMPLEMENTATION STATUS IN TASMOTA ~ The PCA9685 driver is implemented in such a way that it may be used as standard individual OUTPUT pins, or as PWM capable OUTPUT pins - The latter offloads the PWM functionality from the ESP8266 insofar that the PCA9685 will continue to perform its configured output PWM/ON/OFF state without direct control or intervention from the Tasmota firmware. Support was added in line with the datasheet specification insofar that the PWM frequency can be set from 24hz all the way up to 1526hz. This driver does not currently have any perpetual settings so will revert to a base frequency of 50hz (usually suitable for most applications) and will be set in an OFF state for all pins during power-up and/or reset. The latter may change as the driver grows in cases where user requirements and development requirements are met. USAGE OF THE PCA9685 DRIVER IN TASMOTA ~ The driver needs to be connected to the I 2 C bus of your Tasmota powered device (note that most Sonoff devices will not have reachable I 2 C pins so it's applicable to a limited number, so most likely only applicable to bare ESP8266 or WeMos type users. If you modify a Sonoff or similar device to gain access to the I 2 C bus please be aware that other problems may persist and that for such use cases support in Tasmota chat or Issues is not guaranteed in any way whatsoever) For information on how to set up a development environment please check the wiki on PlatformIO Note that the I 2 C selection must correspond with how you have wired the module or chip as incorrect addressing will result in the PCA9685 not being detected. The valid I 2 C address range is 0x40 through 0x47 for the PCA9685 and most off-the-shelf modules would likely default to 0x40. If you are unsure please use I2CScan from Tasmota console to scan for devices on the I 2 C bus and you should find a device within the mentioned range. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. Once connected, correctly flashed, and configured Tasmota will detect the device automatically on startup. DRIVER USAGE ~ There is no web interface for this driver. The driver is used via MQTT or console command using the following available commands and their respective parameters driver15 pwmf,frequency // where frequency is the PWM frequency from 24 to 1526 in Hz driver15 pwm,pin,pwmvalue // where pin = LED pin 0 through 15 and pwmvalue is the pulse width between 0 and 4096 driver15 pwm,pin,ON // Fully turn a specific pin/LED ON driver15 pwm,pin,OFF // Fully turn a specific pin/LED OFF driver15 reset // Reset to power-up settings - i.e. F=50hz and all pins in OFF state driver15 status // Will return a JSON string containing all the current settings / parameters OTHER IMPORTANT INFORMATION ~ Please remember to consider the voltage and current limitations of the chip and per pin output current limitations as outlined in the datasheet. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. OUTSTANDING FEATURE REQUESTS ~ Dimming ON / OFF a dimming value in a certain time and fade on \"ON / OFF\" (Not yet scheduled for implementation) Allow usage of RGBW in pairs of 4 PWM outputs (i.e. drive 4 x 4pin RGBW LED's) (Not yet scheduled for implementation)","title":"PCA9685 12-bit PWM controller"},{"location":"PCA9685/#pca9685-12-bit-pwm-controller","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_PCA9685 #define USE_PCA9685 // [I2cDriver1] Enable PCA9685 I2C HW PWM Driver - Must define I2C Address in #define USE_PCA9685_ADDR below - range 0x40 - 0x47 (+1k4 code) #define USE_PCA9685_ADDR 0x40 // Enable PCA9685 I2C Address to use (Must be within range 0x40 through 0x47 - set according to your wired setup) #define USE_PCA9685_FREQ 50 // Define default PWM frequency in Hz to be used (must be within 24 to 1526) - If other value is used, it will rever to 50Hz #endif Technical Data: Product Information from NXP","title":"PCA9685 12-bit PWM controller"},{"location":"PCA9685/#implementation-status-in-tasmota","text":"The PCA9685 driver is implemented in such a way that it may be used as standard individual OUTPUT pins, or as PWM capable OUTPUT pins - The latter offloads the PWM functionality from the ESP8266 insofar that the PCA9685 will continue to perform its configured output PWM/ON/OFF state without direct control or intervention from the Tasmota firmware. Support was added in line with the datasheet specification insofar that the PWM frequency can be set from 24hz all the way up to 1526hz. This driver does not currently have any perpetual settings so will revert to a base frequency of 50hz (usually suitable for most applications) and will be set in an OFF state for all pins during power-up and/or reset. The latter may change as the driver grows in cases where user requirements and development requirements are met.","title":"IMPLEMENTATION STATUS IN TASMOTA"},{"location":"PCA9685/#usage-of-the-pca9685-driver-in-tasmota","text":"The driver needs to be connected to the I 2 C bus of your Tasmota powered device (note that most Sonoff devices will not have reachable I 2 C pins so it's applicable to a limited number, so most likely only applicable to bare ESP8266 or WeMos type users. If you modify a Sonoff or similar device to gain access to the I 2 C bus please be aware that other problems may persist and that for such use cases support in Tasmota chat or Issues is not guaranteed in any way whatsoever) For information on how to set up a development environment please check the wiki on PlatformIO Note that the I 2 C selection must correspond with how you have wired the module or chip as incorrect addressing will result in the PCA9685 not being detected. The valid I 2 C address range is 0x40 through 0x47 for the PCA9685 and most off-the-shelf modules would likely default to 0x40. If you are unsure please use I2CScan from Tasmota console to scan for devices on the I 2 C bus and you should find a device within the mentioned range. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. Once connected, correctly flashed, and configured Tasmota will detect the device automatically on startup.","title":"USAGE OF THE PCA9685 DRIVER IN TASMOTA"},{"location":"PCA9685/#driver-usage","text":"There is no web interface for this driver. The driver is used via MQTT or console command using the following available commands and their respective parameters driver15 pwmf,frequency // where frequency is the PWM frequency from 24 to 1526 in Hz driver15 pwm,pin,pwmvalue // where pin = LED pin 0 through 15 and pwmvalue is the pulse width between 0 and 4096 driver15 pwm,pin,ON // Fully turn a specific pin/LED ON driver15 pwm,pin,OFF // Fully turn a specific pin/LED OFF driver15 reset // Reset to power-up settings - i.e. F=50hz and all pins in OFF state driver15 status // Will return a JSON string containing all the current settings / parameters","title":"DRIVER USAGE"},{"location":"PCA9685/#other-important-information","text":"Please remember to consider the voltage and current limitations of the chip and per pin output current limitations as outlined in the datasheet. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts.","title":"OTHER IMPORTANT INFORMATION"},{"location":"PCA9685/#outstanding-feature-requests","text":"Dimming ON / OFF a dimming value in a certain time and fade on \"ON / OFF\" (Not yet scheduled for implementation) Allow usage of RGBW in pairs of 4 PWM outputs (i.e. drive 4 x 4pin RGBW LED's) (Not yet scheduled for implementation)","title":"OUTSTANDING FEATURE REQUESTS"},{"location":"PCF8574/","text":"PCF8574 / PCF8574A GPIO Expander ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_I2C // Add support for I2C #define USE_PCF8574 // [I2cDriver2] Enable PCF8574 I/O Expander (I2C addresses 0x20 - 0x26 and 0x39 - 0x3F) (+1k9 code) // #define USE_PCF8574_SENSOR // enable PCF8574 inputs and outputs in SENSOR message // #define USE_PCF8574_DISPLAYINPUT // enable PCF8574 inputs display in Web page // #define USE_PCF8574_MQTTINPUT // enable MQTT message & rule process on input change detection : stat/%topic%/PCF8574_INP = {\"Time\":\"2021-03-07T16:19:23+01:00\",\"PCF8574-1_INP\":{\"D1\":1}} In order to use PCF8574 inputs, uncomment the last three lines. Introduction ~ PCF8574 and PCF8574A are I2C 8-bit IO port extender originally designed by Philips (now NXP) but also now available from various manufacturer. PCF8574 and PCF8574A at NXP PCF8574 and PCF8574A at Texas Instruments As usual when using an electronic part, reading the datasheet is highly recommended as the below document only focus on Tasmota integration. A few different breakout boards are available although some are dedicated to be mounted as a backpack on standard 16x2 or 16x4 LCD displays and are not suitable for general I/Os (but works well with tasmota-display). On the left: generic modules suitable for extending IO On the right: specific module to control a LCD display (not the purpose of this doc page) Supported I2C addresses and number of PCF8574 ~ PCF8574 and PCF8574A are identical functionally and each can be configured to work on 1 of 8 possible I2C address. PCF8574 can use one address of 0x20 to 0x27 and PCF8574A can use one of 0x38 to 0x3F. As of today, Tasmota driver supports: Up to 4 PCF8574 OR PCF8574A is supported by Tasmota allowing up to 32 additional GPIO pins. Addresses 0x27 and 0x38 are excluded to avoid conflict with other I2C peripheral which can't be differentiated at run-time. If USE_MCP230xx_ADDR is defined, this address is reserved for MCP230XX IO expander. The first 2 lines are mandatory to enable I2C support and including the driver in the build. The 3 other lines allows to add optional features to support inputs. By default only the \"outputs\" feature is enabled. Tasmota Configuration ~ Note Once the firmware with the PCF8574 driver has been loaded, make sure to have it enabled with I2Cdriver2 1 . PCF8574 can be configured from Tasmota web GUI in \"Configure\" => \"Configure PCF8574\" Each IO port can be configured as Input or Output in a similar way as a native GPIO of the ESP. If you are using outputs to drive relays, it is possible to choose if the relay is activated by a HIGH signal (checkbox \"Invert Ports\" unchecked) or a LOW signal (checkbox checked). The selection applies to all output ports. This checkbox can also be controlled by SetOption81 . Once configuration is complete, it must be saved by clicking on the green \"Save\" button. Like for general ESP GPIO configuration, this will trigger a reboot of the ESP. It is not possible to change pin definition at run-time. Outputs ~ A PCF8574 pin configured as an output support all features of a Tasmota Relay component. It is assigned a Power index and can be controlled by Power command (on, off, toggle). Power indexes of PCF8574 outputs are assigned after the ESP GPIO configured as Relay . For example, if you have Relay 1 (Power1) to Relay 4 (Power4) configured on the ESP's GPIO, PCF8574 outputs will start at Power5. A state text and an on/off button are automatically created on the Web GUI and syncs with the pin state. All Power features are supported including PowerOnState , PulseTime , Blink , SetOption0 , ... Usage ~ Enabling USE_PCF8574_SENSOR adds a PCF8574-xx field into the JSON payload of the tele/topic/SENSOR message. The form of the message is: { \"Time\" : \"2021-03-11T19:50:58+01:00\" , \"PCF8574-1\" :{ \"D0\" : 1 , \"D1\" : 1 , \"D2\" : 1 , \"D3\" : 1 , \"D4\" : 0 , \"D5\" : 0 , \"D6\" : 0 , \"D7\" : 0 }} As you can see, all pins are listed, including both inputs and outputs. The value reported is the digital level of the pin. If \"Invert Ports\" has been enabled, Power ON will be reported as 0 as the pin is at a LOW level. As for any sensor published in the tele/topic/SENSOR message, it is possible to use Rules triggers such as: ON tele-PCF8574-1#D0 DO something_with %value% ENDON Numerical operators such as == can be used to compare to 0 or 1. See also change detection . PCF8574 inputs pins in the Web GUI ~ Enabling USE_PCF8574_DISPLAYINPUT will add the state of PCF8574 inputs displayed as sensors in the Web GUI. Outputs are not represented here as they are already shown as Power. Value of pin is updated in almost \"real-time\". Input Change Detection ~ While reporting the pin level in SENSOR or on the GUI is interesting, it is even better to detect pin change. This is enabled by USE_PCF8574_MQTTINPUT . When this feature is enabled at build time, a test will be performed every 50ms to detect if an input pin has changed. In that case, Tasmota will publish on stat/topic/PCF8574_INP a JSON payload with the PCF8574 index and the pin level: 20 : 19 : 39.385 MQT : s tat / t opic/PCF 8574 _INP = { \"Time\" : \"2021-03-11T20:19:39+01:00\" , \"PCF8574-1_INP\" :{ \"D0\" : 0 }} 20 : 19 : 39.584 MQT : s tat / t opic/PCF 8574 _INP = { \"Time\" : \"2021-03-11T20:19:39+01:00\" , \"PCF8574-1_INP\" :{ \"D0\" : 1 }} This can be caught in rules such as: Implementing a Power push \"Button\": ON PCF8574-1_INP#D0=0 DO Power2 toggle ENDON","title":"PCF8574 / PCF8574A GPIO Expander"},{"location":"PCF8574/#pcf8574-pcf8574a-gpio-expander","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_I2C // Add support for I2C #define USE_PCF8574 // [I2cDriver2] Enable PCF8574 I/O Expander (I2C addresses 0x20 - 0x26 and 0x39 - 0x3F) (+1k9 code) // #define USE_PCF8574_SENSOR // enable PCF8574 inputs and outputs in SENSOR message // #define USE_PCF8574_DISPLAYINPUT // enable PCF8574 inputs display in Web page // #define USE_PCF8574_MQTTINPUT // enable MQTT message & rule process on input change detection : stat/%topic%/PCF8574_INP = {\"Time\":\"2021-03-07T16:19:23+01:00\",\"PCF8574-1_INP\":{\"D1\":1}} In order to use PCF8574 inputs, uncomment the last three lines.","title":"PCF8574 / PCF8574A GPIO Expander"},{"location":"PCF8574/#introduction","text":"PCF8574 and PCF8574A are I2C 8-bit IO port extender originally designed by Philips (now NXP) but also now available from various manufacturer. PCF8574 and PCF8574A at NXP PCF8574 and PCF8574A at Texas Instruments As usual when using an electronic part, reading the datasheet is highly recommended as the below document only focus on Tasmota integration. A few different breakout boards are available although some are dedicated to be mounted as a backpack on standard 16x2 or 16x4 LCD displays and are not suitable for general I/Os (but works well with tasmota-display). On the left: generic modules suitable for extending IO On the right: specific module to control a LCD display (not the purpose of this doc page)","title":"Introduction"},{"location":"PCF8574/#tasmota-configuration","text":"Note Once the firmware with the PCF8574 driver has been loaded, make sure to have it enabled with I2Cdriver2 1 . PCF8574 can be configured from Tasmota web GUI in \"Configure\" => \"Configure PCF8574\" Each IO port can be configured as Input or Output in a similar way as a native GPIO of the ESP. If you are using outputs to drive relays, it is possible to choose if the relay is activated by a HIGH signal (checkbox \"Invert Ports\" unchecked) or a LOW signal (checkbox checked). The selection applies to all output ports. This checkbox can also be controlled by SetOption81 . Once configuration is complete, it must be saved by clicking on the green \"Save\" button. Like for general ESP GPIO configuration, this will trigger a reboot of the ESP. It is not possible to change pin definition at run-time.","title":"Tasmota Configuration"},{"location":"PCF8574/#outputs","text":"A PCF8574 pin configured as an output support all features of a Tasmota Relay component. It is assigned a Power index and can be controlled by Power command (on, off, toggle). Power indexes of PCF8574 outputs are assigned after the ESP GPIO configured as Relay . For example, if you have Relay 1 (Power1) to Relay 4 (Power4) configured on the ESP's GPIO, PCF8574 outputs will start at Power5. A state text and an on/off button are automatically created on the Web GUI and syncs with the pin state. All Power features are supported including PowerOnState , PulseTime , Blink , SetOption0 , ...","title":"Outputs"},{"location":"PCF8574/#usage","text":"Enabling USE_PCF8574_SENSOR adds a PCF8574-xx field into the JSON payload of the tele/topic/SENSOR message. The form of the message is: { \"Time\" : \"2021-03-11T19:50:58+01:00\" , \"PCF8574-1\" :{ \"D0\" : 1 , \"D1\" : 1 , \"D2\" : 1 , \"D3\" : 1 , \"D4\" : 0 , \"D5\" : 0 , \"D6\" : 0 , \"D7\" : 0 }} As you can see, all pins are listed, including both inputs and outputs. The value reported is the digital level of the pin. If \"Invert Ports\" has been enabled, Power ON will be reported as 0 as the pin is at a LOW level. As for any sensor published in the tele/topic/SENSOR message, it is possible to use Rules triggers such as: ON tele-PCF8574-1#D0 DO something_with %value% ENDON Numerical operators such as == can be used to compare to 0 or 1. See also change detection .","title":"Usage"},{"location":"PCF8574/#pcf8574-inputs-pins-in-the-web-gui","text":"Enabling USE_PCF8574_DISPLAYINPUT will add the state of PCF8574 inputs displayed as sensors in the Web GUI. Outputs are not represented here as they are already shown as Power. Value of pin is updated in almost \"real-time\".","title":"PCF8574 inputs pins in the Web GUI"},{"location":"PCF8574/#input-change-detection","text":"While reporting the pin level in SENSOR or on the GUI is interesting, it is even better to detect pin change. This is enabled by USE_PCF8574_MQTTINPUT . When this feature is enabled at build time, a test will be performed every 50ms to detect if an input pin has changed. In that case, Tasmota will publish on stat/topic/PCF8574_INP a JSON payload with the PCF8574 index and the pin level: 20 : 19 : 39.385 MQT : s tat / t opic/PCF 8574 _INP = { \"Time\" : \"2021-03-11T20:19:39+01:00\" , \"PCF8574-1_INP\" :{ \"D0\" : 0 }} 20 : 19 : 39.584 MQT : s tat / t opic/PCF 8574 _INP = { \"Time\" : \"2021-03-11T20:19:39+01:00\" , \"PCF8574-1_INP\" :{ \"D0\" : 1 }} This can be caught in rules such as: Implementing a Power push \"Button\": ON PCF8574-1_INP#D0=0 DO Power2 toggle ENDON","title":"Input Change Detection"},{"location":"PID-Control/","text":"This extension adds a PID (Proportional Integral Derivative) feature into the Tasmota software. The PID algorithm is designed to be used to control real-world processes. This includes room heating/cooling, temperature control when brewing, and a multitude of other processes. The PID tuning parameters are designed to be meaningful in the real world (rather than the abstract Ki Kd Kp that are often used which are completely meaningless to most). The algorithm is based on that in the node-red node node-red-contrib-pid which has been well received. In use it can either regularly be given the current process value via MQTT or if the device has a sensor attached then that sensor can be used to read the process value. So using any Tasmota-capable device with a e.g. a temperature sensor (e.g. a TH10 with a DS18B20) the complete PID loop control can be built into the device so that the process will continue to be controlled even if the wifi is down. This is a very cost effective way of achieving PID control. The algorithm allows the relay to be used in a time proportioned way using the Time Proportioned output extension. The loop tuning parameters can be set at build time and can be adjusted at run time via MQTT. The feature is included in Tasmota v9.3.0 onward. The PID code adds about 11.1k and the Timeprop code another 1k Detailed instructions for setup are in these two xdrv files: tasmota/xdrv_48_timeprop.ino and tasmota/xdrv_49_pid.ino . The ESP8266 will run the PID algorithm at 1 cycle per second, which is much faster than is needed for the sort of processes Sonoff devices are usually associated with. It rather clobbers the Tasmota terminal output in the web browser at that rate so it is getting near to the limit. The maximum anyone is likely to need it running at is maybe once every 5 seconds, and the majority of home IoT applications probably nearer once per minute would be sufficient, so the device is well up to the task. Help with using the PID algorithm and with loop tuning can be found at http://blog.clanlaw.org.uk/pid-loop-tuning.html This is directed towards using the algorithm in the node-red node node-red-contrib-pid but the algorithm here is based on the same code so the tuning technique described there should work just the same. Due to limited hardware availability this has so far only been tested in a Sonoff Basic with a TH10, and a Sonoff Mini with a DS18B20 connected. If there are any issues running this on other hardware let us know.","title":"PID Control"},{"location":"PIR-Motion-Sensors/","text":"PIR motion sensors, albeit called sensors, are configured as switches in Tasmota since they basically report motion ( 1 ) or no motion ( 0 ) to the device. Most PIR's are single wire and they require connecting to VCC, GND and one GPIO. In this guide we will use GPIO13 as the pin that the PIR output is connected to. See PIN Restrictions on which pins not to use Tasmota Settings ~ In Configuration -> Configure Module menu change GPIO13 to Switch1 . If there already is a Switch1 simply choose the next in line. Same applies if you're connecting more than 1 PIR on a single device. A configured PIR will not appear in the web UI in any form. To make it report like a sensor we need a rule that will send movement triggers to an MQTT topic. SwitchMode1 1 SwitchTopic 0 Rule1 on Switch1#state=1 do publish stat/%topic%/PIR1 ON endon on Switch1#state=0 do Publish stat/%topic%/PIR1 OFF endon Rule1 1 You can change ( PIR1 ) and the message ( ON / OFF ) to whatever suits your needs. %topic% is the configured device topic. Look in console for motion detection messages [20:24:03] stat/%topic%/PIR1 ON to verify everything is working optional: Before using rules configure any GPIO that doesn't have anything connected to it as Relay1 . This creates a dummy relay which is triggered by the PIR so you can see the changes in the web UI. This method is not recommended for daily use and should only be used for testing. A more advanced example of rules with PIRs. AM312 ~ AM312 works even on 3.3v instead of 5v (like HC-SR501) which makes it perfect for ESP8266 devices without a 5V line (like Sonoff Basic). It is also less prone to false triggers due to Wi-Fi interference. Pinout ~ Pin marked VOUT is connected to a free GPIO pin on the device. This PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Another configuration option is to change Switchmode to 14 with Pulsetime of 130 (30 seconds on every time the AM312 is triggered) Another use case as a hand wave switch . HC-SR501 ~ Pinout ~ Configuration with HC-SR501 is easiest with Switchmode 1, since this module has a built-in trigger/delay potentiometers and the state remains ON during the trigger period. MH-SR602 ~ This is a very small version of a PIR that is able to modify the sensitivity and delay by soldering resistors. With factory settings this PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Pinout ~ Panasonic EKMC1603111 ~ Set the data pin to Switch n for it to work. Datasheet","title":"PIR Motion Sensors"},{"location":"PIR-Motion-Sensors/#tasmota-settings","text":"In Configuration -> Configure Module menu change GPIO13 to Switch1 . If there already is a Switch1 simply choose the next in line. Same applies if you're connecting more than 1 PIR on a single device. A configured PIR will not appear in the web UI in any form. To make it report like a sensor we need a rule that will send movement triggers to an MQTT topic. SwitchMode1 1 SwitchTopic 0 Rule1 on Switch1#state=1 do publish stat/%topic%/PIR1 ON endon on Switch1#state=0 do Publish stat/%topic%/PIR1 OFF endon Rule1 1 You can change ( PIR1 ) and the message ( ON / OFF ) to whatever suits your needs. %topic% is the configured device topic. Look in console for motion detection messages [20:24:03] stat/%topic%/PIR1 ON to verify everything is working optional: Before using rules configure any GPIO that doesn't have anything connected to it as Relay1 . This creates a dummy relay which is triggered by the PIR so you can see the changes in the web UI. This method is not recommended for daily use and should only be used for testing. A more advanced example of rules with PIRs.","title":"Tasmota Settings"},{"location":"PIR-Motion-Sensors/#am312","text":"AM312 works even on 3.3v instead of 5v (like HC-SR501) which makes it perfect for ESP8266 devices without a 5V line (like Sonoff Basic). It is also less prone to false triggers due to Wi-Fi interference.","title":"AM312"},{"location":"PIR-Motion-Sensors/#pinout","text":"Pin marked VOUT is connected to a free GPIO pin on the device. This PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Another configuration option is to change Switchmode to 14 with Pulsetime of 130 (30 seconds on every time the AM312 is triggered) Another use case as a hand wave switch .","title":"Pinout"},{"location":"PIR-Motion-Sensors/#hc-sr501","text":"","title":"HC-SR501"},{"location":"PIR-Motion-Sensors/#pinout_1","text":"Configuration with HC-SR501 is easiest with Switchmode 1, since this module has a built-in trigger/delay potentiometers and the state remains ON during the trigger period.","title":"Pinout"},{"location":"PIR-Motion-Sensors/#mh-sr602","text":"This is a very small version of a PIR that is able to modify the sensitivity and delay by soldering resistors. With factory settings this PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger.","title":"MH-SR602"},{"location":"PIR-Motion-Sensors/#pinout_2","text":"","title":"Pinout"},{"location":"PIR-Motion-Sensors/#panasonic-ekmc1603111","text":"Set the data pin to Switch n for it to work. Datasheet","title":"Panasonic EKMC1603111"},{"location":"PN532/","text":"PN532 NFC reader ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_PN532_HSU #define USE_PN532_HSU // Add support for PN532 using HSU (Serial) interface (+1k8 code, 140 bytes mem) // Optional defines, uncomment (remove //) as needed // #define USE_PN532_DATA_FUNCTION // Add sensor40 command support for erase, setting data block content (+1k7 code, 388 bytes mem) // #define USE_PN532_DATA_RAW // Allow DATA block to be used by non-alpha-numberic data (+ 80 bytes code, 48 bytes ram) #endif The PN532 is a highly integrated transceiver module for contactless communication at 13.56 MHz based on the 80C51 microcontroller core. The datasheet for the PN532 chip is available here . Please note that although the datasheet mentions that the PN532 can be used on SPI, I 2 C and HSUART that only the HSU interface is implemented in the Tasmota driver. Configuration ~ #define USE_PN532_CAUSE_EVENTS is replaced with generic rule trigger on pn532#uid= #define USE_PN532_DATA_FUNCTION This function is experimental. There are limitations because it seems not all cards are supported by this driver and/or the PN532 module. See issue 4941 for more information. We are still researching the Wiring ~ As mentioned earlier the PN532 breakout boards usually have pins broken out for all three protocols supported by the PN532 but we are only interested in the HSU interface as that is all the driver currently supports. For this reason breakout boards have either micro dip switches as shown in the image below, or they have pads on the PC board which you need to bridge out with solder to select which mode the PN532 will operate in. After selecting the correct protocol mode and connecting the HSU TX/RX pins of the PN532 to the pins you configured on your ESP8266 board you can power it up and the PN532 should be detected automatically. PN532 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to PN532 Rx (139) GPIOy to PN532 Tx (138) The module will reboot when you save this configuration. During start-up the following information should be visible in your console output: 00:00:00 NFC: PN532 NFC Reader detected (V1.6) If the device was not found please check your wiring and configuration and confirm that everything is as it should be. Example Configured using Wemos D1 mini on pins: D1 (connected to PN532 SCL) and D2 (connected to PN532 SDA) Usage ~ Tasmota will scan for a new card detect 4 times per second and if found will report it via immediate telemetry. The output on the console will look similar to the below when a new card is detected 18:23:24 MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-10T18:23:24\",\"PN532\":{\"UID\":\"94D8FC5F\", \"DATA\":\"\"}} 18:23:24 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} 18:23:25 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} The UID of the card/tag is reported and any text stored in BLOCK 1 of a Mifare Classic card (up to 15 characters in length) is reported in the DATA field of the JSON sent via telemetry. Please note that the DATA field cannot contain spaces. The content of the DATA on BLOCK 1 of a Mifare Classic card can be set as follows Sensor40 S,ILOVETASMOTA Once executed the very next card/tag that is presented to the reader will be programmed accordingly and the data will be retained on the card/tag until either changed or erased. To erase the content of the DATA field the following command may be used Sensor40 E Once executed the very next card/tag that is presented to the reader will have its BLOCK 1 erased. Text logging of the above two actions are also presented during the process for information purposes. Using the UID and DATA of a presented card ~ When a card is presented to the PN532 under normal operating conditions up to 3 ways of using the data is possible. The first is the immediate telemetry generated which looks as follows 18:31:39 MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-10T18:31:39\",\"PN532\":{\"UID\":\"94D8FC5F\", \"DATA\":\"ILOVETASMOTA\"}} Since this is an immediate telemetry generation as opposed to the sensor data you would normally be expected to be presented when the telemetry period occurs, this telemetry data is not directly usable on the device itself. It is generated and immediately transmitted over MQTT and the purpose of this is so that immediate action may be taken by any home automation software you are using with the data obtained from the card/tag as opposed to waiting for the telemetry period to expire and be sent with normal telemetry data. For the purpose of using card/tag data on the device itself you will need to use rules along with the events that are caused. Example Example rule for responding to a specific UID on the device when a card/tag matching a specific UID is presented rule1 on PN532#UID=94D8FC5F do power on endon Example Example rule for responding to a specific DATA content that was previously programmed to one or more cards using the Sensor40 S,xxxx command Rule 1on EVENT#PN532_DATA=ILOVETASMOTA do power on endon 18:41:12 MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-10T18:41:12\",\"PN532\":{\"UID\":\"94D8FC5F\", \"DATA\":\"ILOVETASMOTA\"}} 18:41:13 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} 18:41:13 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} 18:41:13 RUL: EVENT#PN532_DATA=ILOVETASMOTA performs \"power on\" 18:41:13 MQT: stat/tasmota/RESULT = {\"POWER\":\"ON\"} 18:41:13 MQT: stat/tasmota/POWER = ON Breakout Boards ~ Since the PN532 chip itself is surface mount and requires some external components to operate the best is probably to obtain a breakout board similar to the one below from your favourite online supplier. Please make sure the breakout board you order has the HSU pins (SCL=TX and SDA=RX) broken out as it will be very difficult to add them manually - Usually they have them but for good measure just make sure.","title":"PN532 NFC reader"},{"location":"PN532/#pn532-nfc-reader","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_PN532_HSU #define USE_PN532_HSU // Add support for PN532 using HSU (Serial) interface (+1k8 code, 140 bytes mem) // Optional defines, uncomment (remove //) as needed // #define USE_PN532_DATA_FUNCTION // Add sensor40 command support for erase, setting data block content (+1k7 code, 388 bytes mem) // #define USE_PN532_DATA_RAW // Allow DATA block to be used by non-alpha-numberic data (+ 80 bytes code, 48 bytes ram) #endif The PN532 is a highly integrated transceiver module for contactless communication at 13.56 MHz based on the 80C51 microcontroller core. The datasheet for the PN532 chip is available here . Please note that although the datasheet mentions that the PN532 can be used on SPI, I 2 C and HSUART that only the HSU interface is implemented in the Tasmota driver.","title":"PN532 NFC reader"},{"location":"PN532/#configuration","text":"#define USE_PN532_CAUSE_EVENTS is replaced with generic rule trigger on pn532#uid= #define USE_PN532_DATA_FUNCTION This function is experimental. There are limitations because it seems not all cards are supported by this driver and/or the PN532 module. See issue 4941 for more information. We are still researching the","title":"Configuration"},{"location":"PN532/#wiring","text":"As mentioned earlier the PN532 breakout boards usually have pins broken out for all three protocols supported by the PN532 but we are only interested in the HSU interface as that is all the driver currently supports. For this reason breakout boards have either micro dip switches as shown in the image below, or they have pads on the PC board which you need to bridge out with solder to select which mode the PN532 will operate in. After selecting the correct protocol mode and connecting the HSU TX/RX pins of the PN532 to the pins you configured on your ESP8266 board you can power it up and the PN532 should be detected automatically. PN532 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"PN532/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to PN532 Rx (139) GPIOy to PN532 Tx (138) The module will reboot when you save this configuration. During start-up the following information should be visible in your console output: 00:00:00 NFC: PN532 NFC Reader detected (V1.6) If the device was not found please check your wiring and configuration and confirm that everything is as it should be. Example Configured using Wemos D1 mini on pins: D1 (connected to PN532 SCL) and D2 (connected to PN532 SDA)","title":"Tasmota Settings"},{"location":"PN532/#usage","text":"Tasmota will scan for a new card detect 4 times per second and if found will report it via immediate telemetry. The output on the console will look similar to the below when a new card is detected 18:23:24 MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-10T18:23:24\",\"PN532\":{\"UID\":\"94D8FC5F\", \"DATA\":\"\"}} 18:23:24 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} 18:23:25 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} The UID of the card/tag is reported and any text stored in BLOCK 1 of a Mifare Classic card (up to 15 characters in length) is reported in the DATA field of the JSON sent via telemetry. Please note that the DATA field cannot contain spaces. The content of the DATA on BLOCK 1 of a Mifare Classic card can be set as follows Sensor40 S,ILOVETASMOTA Once executed the very next card/tag that is presented to the reader will be programmed accordingly and the data will be retained on the card/tag until either changed or erased. To erase the content of the DATA field the following command may be used Sensor40 E Once executed the very next card/tag that is presented to the reader will have its BLOCK 1 erased. Text logging of the above two actions are also presented during the process for information purposes.","title":"Usage"},{"location":"PN532/#using-the-uid-and-data-of-a-presented-card","text":"When a card is presented to the PN532 under normal operating conditions up to 3 ways of using the data is possible. The first is the immediate telemetry generated which looks as follows 18:31:39 MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-10T18:31:39\",\"PN532\":{\"UID\":\"94D8FC5F\", \"DATA\":\"ILOVETASMOTA\"}} Since this is an immediate telemetry generation as opposed to the sensor data you would normally be expected to be presented when the telemetry period occurs, this telemetry data is not directly usable on the device itself. It is generated and immediately transmitted over MQTT and the purpose of this is so that immediate action may be taken by any home automation software you are using with the data obtained from the card/tag as opposed to waiting for the telemetry period to expire and be sent with normal telemetry data. For the purpose of using card/tag data on the device itself you will need to use rules along with the events that are caused. Example Example rule for responding to a specific UID on the device when a card/tag matching a specific UID is presented rule1 on PN532#UID=94D8FC5F do power on endon Example Example rule for responding to a specific DATA content that was previously programmed to one or more cards using the Sensor40 S,xxxx command Rule 1on EVENT#PN532_DATA=ILOVETASMOTA do power on endon 18:41:12 MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-10T18:41:12\",\"PN532\":{\"UID\":\"94D8FC5F\", \"DATA\":\"ILOVETASMOTA\"}} 18:41:13 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} 18:41:13 MQT: stat/tasmota/RESULT = {\"Event\":\"Done\"} 18:41:13 RUL: EVENT#PN532_DATA=ILOVETASMOTA performs \"power on\" 18:41:13 MQT: stat/tasmota/RESULT = {\"POWER\":\"ON\"} 18:41:13 MQT: stat/tasmota/POWER = ON","title":"Using the UID and DATA of a presented card"},{"location":"PN532/#breakout-boards","text":"Since the PN532 chip itself is surface mount and requires some external components to operate the best is probably to obtain a breakout board similar to the one below from your favourite online supplier. Please make sure the breakout board you order has the HSU pins (SCL=TX and SDA=RX) broken out as it will be very difficult to add them manually - Usually they have them but for good measure just make sure.","title":"Breakout Boards"},{"location":"PS-16-DZ-Dimmer/","text":"PS-16-DZ Dimmer ~ The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ. Pics ~ Opened it up, found a ESP8285 and a Nuvoton N76E003. Flash and GPIO pins ~ Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND Communication between ESP8285 and N76E003 ~ It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266: Send from ESP8266 AT+UPDATE=\"sequence\":\"1528335040032\",\"switch\":\"on\" Receive from MCU AT+RESULT=\"sequence\":1528335040032\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn off the switch from ESP8266: Send from ESP8266 AT+UPDATE=\"sequence\":\"1528335118327\",\"switch\":\"off\" Receive from MCU AT+RESULT=\"sequence\":1528335118327\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Change brightness to 44 from ESP8266: Send from ESP8266: AT+UPDATE=\"sequence\":\"1528335181502\",\"bright\":44 Receive from MCU AT+RESULT=\"sequence\":1528335181502\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn on the switch with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn off the switch with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"off\",\"bright\":44 Send from ESP8266: AT+SEND=ok Change the brightness to 52 with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":52 Send from ESP8266: AT+SEND=ok Holding the middle button on faceplate to reset the device: Received from MCU AT+SETTING=enterESPTOUCH Send from ESP8266: AT+SETTING=enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"PS-16-DZ Dimmer"},{"location":"PS-16-DZ-Dimmer/#ps-16-dz-dimmer","text":"The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ.","title":"PS-16-DZ Dimmer"},{"location":"PS-16-DZ-Dimmer/#pics","text":"Opened it up, found a ESP8285 and a Nuvoton N76E003.","title":"Pics"},{"location":"PS-16-DZ-Dimmer/#flash-and-gpio-pins","text":"Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND","title":"Flash and GPIO pins"},{"location":"PS-16-DZ-Dimmer/#communication-between-esp8285-and-n76e003","text":"It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266: Send from ESP8266 AT+UPDATE=\"sequence\":\"1528335040032\",\"switch\":\"on\" Receive from MCU AT+RESULT=\"sequence\":1528335040032\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn off the switch from ESP8266: Send from ESP8266 AT+UPDATE=\"sequence\":\"1528335118327\",\"switch\":\"off\" Receive from MCU AT+RESULT=\"sequence\":1528335118327\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Change brightness to 44 from ESP8266: Send from ESP8266: AT+UPDATE=\"sequence\":\"1528335181502\",\"bright\":44 Receive from MCU AT+RESULT=\"sequence\":1528335181502\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn on the switch with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn off the switch with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"off\",\"bright\":44 Send from ESP8266: AT+SEND=ok Change the brightness to 52 with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":52 Send from ESP8266: AT+SEND=ok Holding the middle button on faceplate to reset the device: Received from MCU AT+SETTING=enterESPTOUCH Send from ESP8266: AT+SETTING=enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"Communication between ESP8285 and N76E003"},{"location":"PWM-dimmer-switch/","text":"PWM Dimmer ~ PWM dimmer is supported in standard tasmota.bin To enable PWM dimmer operation, select the PWM Dimmer module. PWM Dimmer module adds support for PWM dimmer switches and devices with one or more buttons that control devices in a device group. The brightness of the load for PWM dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a powered-on LED, five brightness LEDs and another status LED. The SD0x dimmer from Martin Jerry, Acenx, Tessan or NTONPOWER is an example of such a device. Any other device with one or more buttons, such as any typical Tasmota-capable wall switch, can make use of the PWM Dimmer module to control the power, brightness and light channels of one or more device groups. For single-button devices or multi-button devices with remote device mode enabled, only the operations controlled by the power button in the instructions below apply. Examples include: PWM Dimmer Operation ~ Pressing and releasing the power button toggles the power on/off. If the toggle turns the power on, the light is returned to the last brightness it was set to. If Fade is enabled, the light is faded on/off at the rate defined by the Speed setting. When the power is on, holding the down or up button decreases/increases the brightness. The brightness can also be changed using just the power button. When the power is on, holding the power button alternately increases or decreases the brightness. Initially, holding the power button increases the brightness. Releasing and then holding the power button again decreases the brightness. When the power is off, pressing and releasing the down or up button turns the power on at a temporary brightness of the low/high levels set by the BriPreset command. Turning the power on at the low preset can also be accomplished by holding the power button while the power is off. The brightness presets are intended to enable quickly turning on a light to a dim or bright level without changing the normal desired brightness. Turning the power on to a preset does not change the brightness the light will be set to when the switch is turned on the next time. For example, if the light is on and you adjust the brightness to 80 and then turn the light off, when you turn it back on, the brightness will return to 80. If you turn the power off again and then press the down button, the light will be turned on at the brightness defined by the low preset. If you then turn the light off and on again, the brightness will return to 80. If there are LEDs defined in the template, they are turned on to indicate the current brightness. More LEDs are turned on at higher brightnesses. SetOption86 enables/disables the LED timeout. If SetOption86 is enabled, the LEDs turn off five seconds after the last change in brightness. Note that the lowest LED and the blue power LED are always on when the power is on. The LED timeout can also be enabled/disabled by holding the power button while tapping (pressing and releasing quickly) the down button. The LedLink LED can be used as a nightlight/powered-off indicator. SetOption87 enables/disables turning the LedLink LED on when the power is off. The powered-off indicator can also be enabled/disabled by holding the power button and tapping the up button. Holding the power button and then holding the down or up button publishes an MQTT EVENT command. The topic follows the format of the Full Topic with a subtopic of EVENT (ex. cmnd/LightSwitch1/EVENT ). The MQTT payload is Trigger# , where # is 1 if the down button is held or 2 if the up button is held. These triggers can be used in rules on remote devices ( ON Event#Trigger1 ) or by automation software to trigger automations such as scene changes. For example, the Event topic Trigger1 payload could trigger the automation software to turn on the previous scene in a list and the Trigger2 payload could trigger the automation software to turn on the next scene in a list. Holding the power button, tapping the down button and then tapping or holding the down or up button sends a device group message to set CW/RGB/RGBW/RGBCW lights in the device group to the previous/next fixed color. The command is sent/value is adjusted once every .75 seconds for as long as the button is held. The color sequence is red, green, blue, orange, light green, light blue, amber, cyan, purple, yellow, pink, white using RGB channels; cold white using CT channels; and warm white using CT channels. Holding the power button, tapping the up button and then tapping or holding the down or up button publishes an MQTT Event command. The command is sent once every .75 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger# , where # is 3 if the down button is held or 4 if the up button is held. Pressing and releasing the power button and then holding the power button publishes an MQTT Event command. The command is sent once every .75 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger# , where # is 5. Button presses and holds execute the normal ButtonTopic and Rule processing. If ButtonTopic is set and SetOption61 is 0 or a the button press/hold matches a rule, the button press/hold is ignored by PWM Dimmer. Operations invoked by holding the power button in combination with the up/dowm buttons cannot be overridden by rules. Standard Tasmota multi-press button presses operate as normal. PWM Dimmer uses the Light module to control the PWM. Brightness levels are rescaled to PWM values between the dimmer_min and dimmer_max values specified with DimmerRange . Most LED bulbs do not show a significant difference between PWM value of 1 and PWM value of 100. This results in the lower 10% of the dimmer range having no effect. For best results, DimmerRange <dimmerMin> value should be set to the highest value that results in the lowest bulb brightness (Typically in the range of 8 - 18). When Device Groups are enabled, the PWM Dimmer brightness presets are kept in sync across all switches in the group. The powered-off LED and LED timeout settings are specific to each switch. Changing them does not replicate the change to the other switches in the group. When CW/RGB/RGBW/RGBCW lights are in the same device group as the PWM Dimmer device, use the PWMDimmerPWMs command to define the PWM (channel) count of the lights. This allows the PWM Dimmer module to correctly determine the brightness (dimmer) level and allows the color of all the lights in the device group to be controlled from the PWM Dimmer device. Commands ~ Command Parameters BriPreset <low>,<high> = set brightness low and high presets 1..255 = set brightness preset + = increase brightness preset - = decrease brightness preset LedMask Set a bitmask specifiying which LEDs are used to indicate the current brightness. LEDs not included in the bitmask can be controlled with LedPower . <bitmask> = bitwise value representing each LED. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). Note that LED 0 is tied to the relay and is always used to indicate the first level of brightness. 0xFFFF (= 1111 1111 1111 1111) All LEDs are used to indicate the brightness (default) Ex.: LedMask 3 = Use LEDs 0, 1 and 2 to indicate the brightness. PWMDimmerPWMs Set the PWM (channel) count of lights in the device group controlled by the module (CW=2, RGB=3, RGBW=4, RGBCW=5). SetOption86 Set brightness LED timeout 0 = disable timeout (default) 1 = enable timeout SetOption87 Set powered-off LED (nightlight) 0 = disable powered-off LED (default) 1 = enable powered-off LED SetOption88 Set remote device mode 0 = disable remote device mode(default) 1 = enable remote device mode Remote Device Mode ~ Remote device mode allows PWM Dimmer switches to control remote devices. With remote device mode enabled, each button controls a different device. Remote device mode is included in the default Tasmota binary. To include remote device mode support in other builds, define USE_PWM_DIMMER_REMOTE and USE_DEVICE_GROUPS in your user_config_override. Remote device mode support requires device group support. Remote device mode support adds 1K to the code size in addition to the code size required for device groups support. To enable remote device mode, execute SetOption88 1 (the device will restart). Each remote device must be running firmware with device group support and have remote device support enabled. Remote devices do not need to be built with PWM Dimmer support nor do they need to be switches. If a remote device also uses the PWM Dimmer module, the device acts like a 3-way dimmer switch and may or may not have a load connected to it. All PWM Dimmer switches in the device group can control the power, brightness and color of one or more smart lights with Tasmota with device group support loaded on them. When remote device mode is enabled, button 1 is the power button for the local device while buttons 2 and 3 are the power buttons for remote devices. Group names for buttons 2 and 3 are set by the DevGroupName2 and DevGroupName3 commands respectively. Note that the button numbers are defined by the module template and can be in any physical order on the switch (button 1 can be defined as the top button, the middle button or the bottom button). Button combinations that publish MQTT Event commands use a topic in the format cmnd/%group-topic%/EVENT . While holding a button, the other two buttons act like the down and up buttons for the remote device associated with the first button pressed. All the functions performed by the down and up buttons in non-remote device mode are available in remote device mode. While holding button 1, button 2 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 2, button 1 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 3, button 1 performs the functions of the down button and button 2 performs the functions of the up button.","title":"PWM Dimmer"},{"location":"PWM-dimmer-switch/#pwm-dimmer","text":"PWM dimmer is supported in standard tasmota.bin To enable PWM dimmer operation, select the PWM Dimmer module. PWM Dimmer module adds support for PWM dimmer switches and devices with one or more buttons that control devices in a device group. The brightness of the load for PWM dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a powered-on LED, five brightness LEDs and another status LED. The SD0x dimmer from Martin Jerry, Acenx, Tessan or NTONPOWER is an example of such a device. Any other device with one or more buttons, such as any typical Tasmota-capable wall switch, can make use of the PWM Dimmer module to control the power, brightness and light channels of one or more device groups. For single-button devices or multi-button devices with remote device mode enabled, only the operations controlled by the power button in the instructions below apply. Examples include:","title":"PWM Dimmer"},{"location":"PWM-dimmer-switch/#pwm-dimmer-operation","text":"Pressing and releasing the power button toggles the power on/off. If the toggle turns the power on, the light is returned to the last brightness it was set to. If Fade is enabled, the light is faded on/off at the rate defined by the Speed setting. When the power is on, holding the down or up button decreases/increases the brightness. The brightness can also be changed using just the power button. When the power is on, holding the power button alternately increases or decreases the brightness. Initially, holding the power button increases the brightness. Releasing and then holding the power button again decreases the brightness. When the power is off, pressing and releasing the down or up button turns the power on at a temporary brightness of the low/high levels set by the BriPreset command. Turning the power on at the low preset can also be accomplished by holding the power button while the power is off. The brightness presets are intended to enable quickly turning on a light to a dim or bright level without changing the normal desired brightness. Turning the power on to a preset does not change the brightness the light will be set to when the switch is turned on the next time. For example, if the light is on and you adjust the brightness to 80 and then turn the light off, when you turn it back on, the brightness will return to 80. If you turn the power off again and then press the down button, the light will be turned on at the brightness defined by the low preset. If you then turn the light off and on again, the brightness will return to 80. If there are LEDs defined in the template, they are turned on to indicate the current brightness. More LEDs are turned on at higher brightnesses. SetOption86 enables/disables the LED timeout. If SetOption86 is enabled, the LEDs turn off five seconds after the last change in brightness. Note that the lowest LED and the blue power LED are always on when the power is on. The LED timeout can also be enabled/disabled by holding the power button while tapping (pressing and releasing quickly) the down button. The LedLink LED can be used as a nightlight/powered-off indicator. SetOption87 enables/disables turning the LedLink LED on when the power is off. The powered-off indicator can also be enabled/disabled by holding the power button and tapping the up button. Holding the power button and then holding the down or up button publishes an MQTT EVENT command. The topic follows the format of the Full Topic with a subtopic of EVENT (ex. cmnd/LightSwitch1/EVENT ). The MQTT payload is Trigger# , where # is 1 if the down button is held or 2 if the up button is held. These triggers can be used in rules on remote devices ( ON Event#Trigger1 ) or by automation software to trigger automations such as scene changes. For example, the Event topic Trigger1 payload could trigger the automation software to turn on the previous scene in a list and the Trigger2 payload could trigger the automation software to turn on the next scene in a list. Holding the power button, tapping the down button and then tapping or holding the down or up button sends a device group message to set CW/RGB/RGBW/RGBCW lights in the device group to the previous/next fixed color. The command is sent/value is adjusted once every .75 seconds for as long as the button is held. The color sequence is red, green, blue, orange, light green, light blue, amber, cyan, purple, yellow, pink, white using RGB channels; cold white using CT channels; and warm white using CT channels. Holding the power button, tapping the up button and then tapping or holding the down or up button publishes an MQTT Event command. The command is sent once every .75 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger# , where # is 3 if the down button is held or 4 if the up button is held. Pressing and releasing the power button and then holding the power button publishes an MQTT Event command. The command is sent once every .75 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger# , where # is 5. Button presses and holds execute the normal ButtonTopic and Rule processing. If ButtonTopic is set and SetOption61 is 0 or a the button press/hold matches a rule, the button press/hold is ignored by PWM Dimmer. Operations invoked by holding the power button in combination with the up/dowm buttons cannot be overridden by rules. Standard Tasmota multi-press button presses operate as normal. PWM Dimmer uses the Light module to control the PWM. Brightness levels are rescaled to PWM values between the dimmer_min and dimmer_max values specified with DimmerRange . Most LED bulbs do not show a significant difference between PWM value of 1 and PWM value of 100. This results in the lower 10% of the dimmer range having no effect. For best results, DimmerRange <dimmerMin> value should be set to the highest value that results in the lowest bulb brightness (Typically in the range of 8 - 18). When Device Groups are enabled, the PWM Dimmer brightness presets are kept in sync across all switches in the group. The powered-off LED and LED timeout settings are specific to each switch. Changing them does not replicate the change to the other switches in the group. When CW/RGB/RGBW/RGBCW lights are in the same device group as the PWM Dimmer device, use the PWMDimmerPWMs command to define the PWM (channel) count of the lights. This allows the PWM Dimmer module to correctly determine the brightness (dimmer) level and allows the color of all the lights in the device group to be controlled from the PWM Dimmer device.","title":"PWM Dimmer Operation"},{"location":"PWM-dimmer-switch/#commands","text":"Command Parameters BriPreset <low>,<high> = set brightness low and high presets 1..255 = set brightness preset + = increase brightness preset - = decrease brightness preset LedMask Set a bitmask specifiying which LEDs are used to indicate the current brightness. LEDs not included in the bitmask can be controlled with LedPower . <bitmask> = bitwise value representing each LED. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). Note that LED 0 is tied to the relay and is always used to indicate the first level of brightness. 0xFFFF (= 1111 1111 1111 1111) All LEDs are used to indicate the brightness (default) Ex.: LedMask 3 = Use LEDs 0, 1 and 2 to indicate the brightness. PWMDimmerPWMs Set the PWM (channel) count of lights in the device group controlled by the module (CW=2, RGB=3, RGBW=4, RGBCW=5). SetOption86 Set brightness LED timeout 0 = disable timeout (default) 1 = enable timeout SetOption87 Set powered-off LED (nightlight) 0 = disable powered-off LED (default) 1 = enable powered-off LED SetOption88 Set remote device mode 0 = disable remote device mode(default) 1 = enable remote device mode","title":"Commands"},{"location":"PWM-dimmer-switch/#remote-device-mode","text":"Remote device mode allows PWM Dimmer switches to control remote devices. With remote device mode enabled, each button controls a different device. Remote device mode is included in the default Tasmota binary. To include remote device mode support in other builds, define USE_PWM_DIMMER_REMOTE and USE_DEVICE_GROUPS in your user_config_override. Remote device mode support requires device group support. Remote device mode support adds 1K to the code size in addition to the code size required for device groups support. To enable remote device mode, execute SetOption88 1 (the device will restart). Each remote device must be running firmware with device group support and have remote device support enabled. Remote devices do not need to be built with PWM Dimmer support nor do they need to be switches. If a remote device also uses the PWM Dimmer module, the device acts like a 3-way dimmer switch and may or may not have a load connected to it. All PWM Dimmer switches in the device group can control the power, brightness and color of one or more smart lights with Tasmota with device group support loaded on them. When remote device mode is enabled, button 1 is the power button for the local device while buttons 2 and 3 are the power buttons for remote devices. Group names for buttons 2 and 3 are set by the DevGroupName2 and DevGroupName3 commands respectively. Note that the button numbers are defined by the module template and can be in any physical order on the switch (button 1 can be defined as the top button, the middle button or the bottom button). Button combinations that publish MQTT Event commands use a topic in the format cmnd/%group-topic%/EVENT . While holding a button, the other two buttons act like the down and up buttons for the remote device associated with the first button pressed. All the functions performed by the down and up buttons in non-remote device mode are available in remote device mode. While holding button 1, button 2 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 2, button 1 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 3, button 1 performs the functions of the down button and button 2 performs the functions of the up button.","title":"Remote Device Mode"},{"location":"PZEM-0XX/","text":"PZEM-0xx power monitor ~ PZEM is a dedicated separate energy monitor, device calibration in Tasmota is not supported. PZEM-004 ~ The PZEM-004T together with a Sonoff Basic provide a good clamp on energy monitor. Parts needed ~ Sonoff Basic PZEM-004T Resistor 1k Enclosure Power cable Preparation ~ Install Tasmota on the Sonoff Basic and confirm it is functional before connecting the PZEM-004T to its serial interface. Hardware connections ~ As the PZEM-004T RX optocoupler series resistor (1K ohm, R15 for v.1 .0 and R8 for v.3.0 ) is designed for 5V, that resistor value had to be reduced in order to achieve the current for driving the RX optocoupler diode. This can be accomplished by soldering a 1k resistor between the joints shown below (modification works for version v.1.0 and v.3.0). The resistor has to be connected between VDD (5V/3.3V) terminal and the RX opto terminal 1. PZEM-004T v.1.0 PZEM-004T v.3.0 It can be used a SMD resistor 102 or 1001 (1K) soldered near/parallel with R8 or a normal resistor (THT) similar to that used on the image of v.1.0 The resistor is placed in different place on v.3.0 because the optocouplers RX and TX are reversed compared to v.1.0 Connect the serial interface of the Sonoff Basic with the serial interface of the PZEM-004T. See pictures regarding used colors and connections. 3V3/5V Red Rx Yellow Tx Green Gnd Grey (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) If you need 5V you can use directly from Sonoff (for something else) but do not connect to PZEM logic because this will result in a big flash (kaboom!, the sonoff LIVE line may reach the PZEM NEUTRAL or viceversa). Using 5V from Sonoff for PZEM TTL port is safe but the resistor mod explained above must be undoed and another mod is needed for dropping the PZEM TX line from 5V to 3.3V. So, the simplest way is to use 3.3V from Sonoff to 5V TTL terminal of the PZEM and the resistor mod explained in the above images. Cut the power cable in two and connect the input wires to both Sonoff Basic and PZEM-004T. Route one of the power output wires through the PZEM-004T core and connect the output wires to the Sonoff Basic output. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure. Software configuration ~ Configure the GPIO's for hardware serial connection as shown below. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} PZEM-004T version V3 ~ {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} The PZEM-004T together with a HW-655 Relay provide a good clamp-on energy monitor for a 240V clothes dryer. Parts needed ~ Circuit Box 3-prong Dryer Electrical Cord (Note - some households use a 4-prong plug) 3-prong Dryer Receptacle (Note - some households use a 4-prong plug) PZEM-004T HW-655 w/ ESP-01 ESHION SPSD-5S AC-DC 5V Buck Converter 4-pin Serial Connector DuPont Connectors & 22 AWG wire Preparation ~ Install Tasmota on the ESP-01 and confirm it is functional before connecting the PZEM-004T to its serial interface. Use of pins other that the default hardware serial GPIO (01 & 03) in order for TASMOTA to emulate a serial interface using software serial. Hardware connections ~ Connect the serial interface of the HW-655 with the serial interface of the PZEM-004T. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure. Software configuration ~ Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} PZEM-004T version V3 ~ {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} Use the module template to configure the GPIO's for hardware serial connection. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Connected Power Meter using PZEM-004T, Wemos D1 Mini and a 1602 I 2 C display ~ Parts needed ~ Wemos D1 Mini PZEM-004T 1kOhm Resistor (optional - see alternate wiring) Enclosure 5V buck converter power supply (search for \"700ma 3.5w 5v\" on usual stores...) I 2 C 1602 LCD Display (I had issues with green one, I 2 C address 0x3F, while no problems with blue ones, address 0x27) Mains Power cable Mammuth Clamps Preparation ~ You need to compile your own Tasmota firmware as none of the pre-compiled binaries have support for display and PZEM module. Set up your preferred IDE as described in wiki Enable IDE to Use Custom Settings ~ Create user_config_override.h in the tasmota folder and paste the contents of this sample configuration file . PlatformIO ~ Rename platformio_override_sample.ini . to platformio_override.ini Enter platformio run -e <variant-name> Examples: platformio run -e tasmota-sensors platformio run -e tasmota-DE Arduino IDE ~ Edit my_user_config.h . Uncomment the statement by removing the \"//\" in front of the line: #define USE_CONFIG_OVERRIDE Click compile Flash the binary on the Wemos D1 Mini and confirm it is functional before connecting the PZEM-004T to its serial interface. Tasmota Parameter Configuration ~ Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} PZEM-004T version V3 ~ {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} use I2CScan to detect your device address use DeviceAddress XXX (where XXX is the decimal converted address found) to set the I 2 C address set TelePeriod 10 to have the display refresh every 10 seconds (you can't go under this value) set DisplayModel 1 , and DisplayMode 0 finally, add a Rule to display values (I choose these): Rule1 ON Tele-ENERGY#Power DO DisplayText [z] [x1y0]%value%W ENDON ON Tele-ENERGY#Today DO DisplayText [x8y0]%value%Wh ENDON ON Tele-ENERGY#Voltage DO DisplayText [x1y1]%value%V ENDON ON Tele-ENERGY#Current DO DisplayText [x8y1]%value%A ENDON remember to enable the rule, with Rule1 1 Images and Wiring diagram ~ DANGER - MAINS VOLTAGE . Be sure to crimp connectors and use heat-shrinking tube wherever possible/needed, and tightly secure any screw. How it looks, from web GUI: How it looks, from enclosure: You can set the contrast using the little trimmer/pot on back of the display. I cut a bit of the corners from the display to have it flush with border, and used two hexagonal plastic standoffs with nuts and bolts to secure it to transparent top. Mains IN, mains OUT, all sealed: Wiring Diagram: * Check images below for more information about the 1kOhm resistor needed to use 3.3V instead of 5V for the PZEM-004T serial connection. PZEM-004T v.1.0 PZEM-004T v.3.0 Calibration ~ Per Theo - As the PZEM is a dedicated energy monitor, device calibration in TASMOTA is currently not supported. PZEM-016 ~ DO NOT PERFORM THIS MODIFICATION WITHOUT REMOVING POWER FROM THE PZEM FIRST! Note : the PZEM-016 TTL output is at 5V signal levels. There are varying schools of thought on whether the ESP82xx has 5V tolerant GPIO. You may want to use a level shifter for the serial communications signals to bring them to the recommended 3.3V. PZEM-016 modules can be converted from RS485 to TTL serial level devices by simply removing the internal MAX485 chip and adding two internal jumper wires. This will bring the serial port connections out via the four-pin terminal block. Pin A is now TTL serial out (Tx) and pin B TTL serial in (Rx). The modification retains the optical isolation used by the PZEM for safety to ensure no high voltages on the outputs. You can use a voltage level shifter to power the ESP82xx from the PZEM-016 module's 5V power. This may also require a 470uf 35V capacitor across the 5V line to work reliably. Tasmota Configuration ~ It is recommended to use GPIO1/GPIO3 or GPIO13/GPIO15 for the most reliable serial communications. When using other GPIOs software serial will be activated and used. GPIO Component PZEM 1 PZEM0XX Tx (62) Pin B 3 PZEM016 Rx (98) Pin A","title":"PZEM-0xx power monitor"},{"location":"PZEM-0XX/#pzem-0xx-power-monitor","text":"PZEM is a dedicated separate energy monitor, device calibration in Tasmota is not supported.","title":"PZEM-0xx power monitor"},{"location":"PZEM-0XX/#pzem-004","text":"The PZEM-004T together with a Sonoff Basic provide a good clamp on energy monitor.","title":"PZEM-004"},{"location":"PZEM-0XX/#parts-needed","text":"Sonoff Basic PZEM-004T Resistor 1k Enclosure Power cable","title":"Parts needed"},{"location":"PZEM-0XX/#preparation","text":"Install Tasmota on the Sonoff Basic and confirm it is functional before connecting the PZEM-004T to its serial interface.","title":"Preparation"},{"location":"PZEM-0XX/#hardware-connections","text":"As the PZEM-004T RX optocoupler series resistor (1K ohm, R15 for v.1 .0 and R8 for v.3.0 ) is designed for 5V, that resistor value had to be reduced in order to achieve the current for driving the RX optocoupler diode. This can be accomplished by soldering a 1k resistor between the joints shown below (modification works for version v.1.0 and v.3.0). The resistor has to be connected between VDD (5V/3.3V) terminal and the RX opto terminal 1. PZEM-004T v.1.0 PZEM-004T v.3.0 It can be used a SMD resistor 102 or 1001 (1K) soldered near/parallel with R8 or a normal resistor (THT) similar to that used on the image of v.1.0 The resistor is placed in different place on v.3.0 because the optocouplers RX and TX are reversed compared to v.1.0 Connect the serial interface of the Sonoff Basic with the serial interface of the PZEM-004T. See pictures regarding used colors and connections. 3V3/5V Red Rx Yellow Tx Green Gnd Grey (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) If you need 5V you can use directly from Sonoff (for something else) but do not connect to PZEM logic because this will result in a big flash (kaboom!, the sonoff LIVE line may reach the PZEM NEUTRAL or viceversa). Using 5V from Sonoff for PZEM TTL port is safe but the resistor mod explained above must be undoed and another mod is needed for dropping the PZEM TX line from 5V to 3.3V. So, the simplest way is to use 3.3V from Sonoff to 5V TTL terminal of the PZEM and the resistor mod explained in the above images. Cut the power cable in two and connect the input wires to both Sonoff Basic and PZEM-004T. Route one of the power output wires through the PZEM-004T core and connect the output wires to the Sonoff Basic output. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure.","title":"Hardware connections"},{"location":"PZEM-0XX/#software-configuration","text":"Configure the GPIO's for hardware serial connection as shown below. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1}","title":"Software configuration"},{"location":"PZEM-0XX/#pzem-004t-version-v3","text":"{\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} The PZEM-004T together with a HW-655 Relay provide a good clamp-on energy monitor for a 240V clothes dryer.","title":"PZEM-004T version V3"},{"location":"PZEM-0XX/#parts-needed_1","text":"Circuit Box 3-prong Dryer Electrical Cord (Note - some households use a 4-prong plug) 3-prong Dryer Receptacle (Note - some households use a 4-prong plug) PZEM-004T HW-655 w/ ESP-01 ESHION SPSD-5S AC-DC 5V Buck Converter 4-pin Serial Connector DuPont Connectors & 22 AWG wire","title":"Parts needed"},{"location":"PZEM-0XX/#preparation_1","text":"Install Tasmota on the ESP-01 and confirm it is functional before connecting the PZEM-004T to its serial interface. Use of pins other that the default hardware serial GPIO (01 & 03) in order for TASMOTA to emulate a serial interface using software serial.","title":"Preparation"},{"location":"PZEM-0XX/#hardware-connections_1","text":"Connect the serial interface of the HW-655 with the serial interface of the PZEM-004T. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure.","title":"Hardware connections"},{"location":"PZEM-0XX/#software-configuration_1","text":"Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18}","title":"Software configuration"},{"location":"PZEM-0XX/#pzem-004t-version-v3_1","text":"{\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} Use the module template to configure the GPIO's for hardware serial connection. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater.","title":"PZEM-004T version V3"},{"location":"PZEM-0XX/#connected-power-meter-using-pzem-004t-wemos-d1-mini-and-a-1602-i2c-display","text":"","title":"Connected Power Meter using PZEM-004T, Wemos D1 Mini and a 1602 I2C display"},{"location":"PZEM-0XX/#parts-needed_2","text":"Wemos D1 Mini PZEM-004T 1kOhm Resistor (optional - see alternate wiring) Enclosure 5V buck converter power supply (search for \"700ma 3.5w 5v\" on usual stores...) I 2 C 1602 LCD Display (I had issues with green one, I 2 C address 0x3F, while no problems with blue ones, address 0x27) Mains Power cable Mammuth Clamps","title":"Parts needed"},{"location":"PZEM-0XX/#preparation_2","text":"You need to compile your own Tasmota firmware as none of the pre-compiled binaries have support for display and PZEM module. Set up your preferred IDE as described in wiki","title":"Preparation"},{"location":"PZEM-0XX/#tasmota-parameter-configuration","text":"Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18}","title":"Tasmota Parameter Configuration"},{"location":"PZEM-0XX/#pzem-004t-version-v3_2","text":"{\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} use I2CScan to detect your device address use DeviceAddress XXX (where XXX is the decimal converted address found) to set the I 2 C address set TelePeriod 10 to have the display refresh every 10 seconds (you can't go under this value) set DisplayModel 1 , and DisplayMode 0 finally, add a Rule to display values (I choose these): Rule1 ON Tele-ENERGY#Power DO DisplayText [z] [x1y0]%value%W ENDON ON Tele-ENERGY#Today DO DisplayText [x8y0]%value%Wh ENDON ON Tele-ENERGY#Voltage DO DisplayText [x1y1]%value%V ENDON ON Tele-ENERGY#Current DO DisplayText [x8y1]%value%A ENDON remember to enable the rule, with Rule1 1","title":"PZEM-004T version V3"},{"location":"PZEM-0XX/#images-and-wiring-diagram","text":"DANGER - MAINS VOLTAGE . Be sure to crimp connectors and use heat-shrinking tube wherever possible/needed, and tightly secure any screw. How it looks, from web GUI: How it looks, from enclosure: You can set the contrast using the little trimmer/pot on back of the display. I cut a bit of the corners from the display to have it flush with border, and used two hexagonal plastic standoffs with nuts and bolts to secure it to transparent top. Mains IN, mains OUT, all sealed: Wiring Diagram: * Check images below for more information about the 1kOhm resistor needed to use 3.3V instead of 5V for the PZEM-004T serial connection. PZEM-004T v.1.0 PZEM-004T v.3.0","title":"Images and Wiring diagram"},{"location":"PZEM-0XX/#calibration","text":"Per Theo - As the PZEM is a dedicated energy monitor, device calibration in TASMOTA is currently not supported.","title":"Calibration"},{"location":"PZEM-0XX/#pzem-016","text":"DO NOT PERFORM THIS MODIFICATION WITHOUT REMOVING POWER FROM THE PZEM FIRST! Note : the PZEM-016 TTL output is at 5V signal levels. There are varying schools of thought on whether the ESP82xx has 5V tolerant GPIO. You may want to use a level shifter for the serial communications signals to bring them to the recommended 3.3V. PZEM-016 modules can be converted from RS485 to TTL serial level devices by simply removing the internal MAX485 chip and adding two internal jumper wires. This will bring the serial port connections out via the four-pin terminal block. Pin A is now TTL serial out (Tx) and pin B TTL serial in (Rx). The modification retains the optical isolation used by the PZEM for safety to ensure no high voltages on the outputs. You can use a voltage level shifter to power the ESP82xx from the PZEM-016 module's 5V power. This may also require a 470uf 35V capacitor across the 5V line to work reliably.","title":"PZEM-016"},{"location":"PZEM-0XX/#tasmota-configuration","text":"It is recommended to use GPIO1/GPIO3 or GPIO13/GPIO15 for the most reliable serial communications. When using other GPIOs software serial will be activated and used. GPIO Component PZEM 1 PZEM0XX Tx (62) Pin B 3 PZEM016 Rx (98) Pin A","title":"Tasmota Configuration"},{"location":"Peripherals/","text":"Peripherals ~ Peripherals are sensors, displays, controllers, LEDs and other devices wired to available GPIO pins of your device Tip A peripheral must have correctly wired power, GND and data pins to the device prior to booting in order for Tasmota to detect it and initialize it properly. Supported peripherals ~ Tasmota Settings ~ Tasmota allows for easy selection of peripherals and assignment to GPIO pins. Configuration is possible in the webUI Configuration - Configure Module page or by using commands: Module and GPIO , or Template . Module ~ First select desired module for the device (Wait for the restart). Depending on the type of Module , only certain GPIO pins are user configurable. Module Generic (18) has all the GPIOs configurable. Modules shows supported modules GPIO ~ Assign a component to a GPIO. GPIO14 2 configures sensor AM2301 to GPIO14_ Backlog GPIO14 5; GPIO4 6 sets I 2 C SCL to GPIO14 and I 2 C SDA to GPIO4 Tasmota will auto-detect all connected and supported I 2 C devices. If you have conflicting I 2 C addresses see I2CDEVICES GPIOs All shows list of all available components by name and index For a peripheral to show up you may need to power cycle your device instead of a soft restart. Template ~ Instead of using Module and GPIO you can define everything using Template . Read more... Additional Options ~ Measurement Units ~ Temperature units can be set to Celsius or Fahrenheit with SetOption8 command. Pressure units can be set to hPa or mmHg with SetOption24 command. Update Interval ~ To change the update interval (TelePeriod) of MQTT messages change the TelePeriod . Default interval is 300 seconds but can be set between 10 and 3600 seconds. TelePeriod 10 will set the update interval to 10 seconds, so the sensor will update 6 times a minute. Peripheral Specific ~ Some peripherals offer, or even require, additional commands. See Sensor commands page for peripheral specific commands. Tip To make a link between the different naming schemes the Pin Definition overview in the ESP8266 wiki is quite helpful. Examples ~ Connect switch ~ If you take a Sonoff Basic and connect a switch between pin4 (GND) and pin5 (GPIO14) of the 5 pin programming header you now have a second switch connected to the device. You can set this through the module config page as option Switch1 (9) or from the command line with gpio14 9 . See Buttons and Switches for more information. Connect jack ~ Instead of connecting a switch, you could connect a 4-pin 2.5mm jack, with the pins wired: Jack Pin ESP8266 tip 5 GPIO14 R1 no connection R2 1 GND R3 4 3.3V You can then plug a sensor into the jack like you would to a Sonoff TH and define what sensor you have connected to GPIO14. Restrictions ~ Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document . Voltage and Current ~ Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA. Power Supply ~ It is important to have a reliable power supply The power supplied to the device is one of the most important elements for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself. Electrical Considerations ~ When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 ) ESP8266 In Depth ~ Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html Digital I/O ~ Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current). Usable Pins ~ The ESP8266 and ESP8285 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8285 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data. GPIO 1, 2 and 3 will cause boot failure if LOW on boot - use with care. Boot Mode Pins ~ Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor. PWM ~ ESP8266 Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions . ESP8266 has only software and supports 5 PWM channels. PWM and PWMi GPIOs are used in two modes depending on SetOption15 : either as lights or as pure PWM. ESP32 has hardware PWM support, named ledc , up to 16 channels depending on CPU type. You can mix lights and pure PWM channels. The first 5 PWM are reserved for lights, unless SetOption15 0 . For pure PWM GPIOs, you can assign any PWM number, they don't need to be continuous. For example you can use PWM 1/2/3 for a 3-channel RGB light, and PWM 6 & PWM 10 for pure PWM at the same time. CPU type PWM channels ESP32 16 channels ESP32S2 8 channels ESP32C3 6 channels Channels are assigned to GPIOs in a first-in-first-serve way, and PWM GPIOs are assigned first. If ledc channel are exhausted, an error will appear in logs. The following GPIOs use ledc PWM channels: GPIO type Description PWM or PWMi PWM 1..5 are used for lights, PWM O6..11 are general purpose PWM. LedPwmMode Assigns a Led GPIO to a PWM channel Buzzer If BuzzerPwm is used Backlight PWM backlighting for displays XCLK Used as a clock generator for webcam Example of PWM console output with 16 PWM assigned. By default PWM range is 0..1023. RSL: RESULT = {\"PWM\":{\"PWM1\":410,\"PWM2\":286,\"PWM3\":286,\"PWM4\":0,\"PWM5\":0,\"PWM6\":0,\"PWM7\":0,\"PWM8\":0,\"PWM9\":0,\"PWM10\":0,\"PWM11\":0,\"PWM12\":0,\"PWM13\":0,\"PWM14\":0,\"PWM15\":0,\"PWM16\":0}} Auto-phasing of PWM ~ (ESP32 only) By default, phases of consecutive PWM are disaligned so that a PWM pulses starts when the pulse of the previous PWM channels ends. This helps in distributing over time all pulses and have a smoother effect on power supply. With auto-phasing: You can revert this with SetOption134 1 ; all phases are synces and all pulses start at the same moment. H-bridge ~ H-bridge is an electronic circuit that switches the polarity of a voltage applied to a load. It uses 2 PWM outputs to control the current sent to each polarity. When auto-phasing is enabled, you can use 2 consecutive PWM to drive a H-bridge siunce PWM phases don't overlap - under the condition that the sum of both PWM don't exceed 1023 . Important : you must always ensure that the sum of both PWM channels is less or equal than 1023 . Values over this threshold can damage the circuit. Analog Input ~ The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits. Communication ~ Serial ~ The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins. I\u00b2C ~ ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz. SPI ~ The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software). GPIO Overview ~ NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission - Boot will fail if LOW at boot D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time - boot will fail. Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"Peripherals"},{"location":"Peripherals/#peripherals","text":"Peripherals are sensors, displays, controllers, LEDs and other devices wired to available GPIO pins of your device Tip A peripheral must have correctly wired power, GND and data pins to the device prior to booting in order for Tasmota to detect it and initialize it properly.","title":"Peripherals"},{"location":"Peripherals/#supported-peripherals","text":"","title":"Supported peripherals"},{"location":"Peripherals/#tasmota-settings","text":"Tasmota allows for easy selection of peripherals and assignment to GPIO pins. Configuration is possible in the webUI Configuration - Configure Module page or by using commands: Module and GPIO , or Template .","title":"Tasmota Settings"},{"location":"Peripherals/#module","text":"First select desired module for the device (Wait for the restart). Depending on the type of Module , only certain GPIO pins are user configurable. Module Generic (18) has all the GPIOs configurable. Modules shows supported modules","title":"Module"},{"location":"Peripherals/#gpio","text":"Assign a component to a GPIO. GPIO14 2 configures sensor AM2301 to GPIO14_ Backlog GPIO14 5; GPIO4 6 sets I 2 C SCL to GPIO14 and I 2 C SDA to GPIO4 Tasmota will auto-detect all connected and supported I 2 C devices. If you have conflicting I 2 C addresses see I2CDEVICES GPIOs All shows list of all available components by name and index For a peripheral to show up you may need to power cycle your device instead of a soft restart.","title":"GPIO"},{"location":"Peripherals/#template","text":"Instead of using Module and GPIO you can define everything using Template . Read more...","title":"Template"},{"location":"Peripherals/#additional-options","text":"","title":"Additional Options"},{"location":"Peripherals/#examples","text":"","title":"Examples"},{"location":"Peripherals/#restrictions","text":"Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document .","title":"Restrictions"},{"location":"Peripherals/#voltage-and-current","text":"Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA.","title":"Voltage and Current"},{"location":"Peripherals/#power-supply","text":"It is important to have a reliable power supply The power supplied to the device is one of the most important elements for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself.","title":"Power Supply"},{"location":"Peripherals/#electrical-considerations","text":"When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 )","title":"Electrical Considerations"},{"location":"Peripherals/#esp8266-in-depth","text":"Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html","title":"ESP8266 In Depth"},{"location":"Peripherals/#digital-io","text":"Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current).","title":"Digital I/O"},{"location":"Peripherals/#usable-pins","text":"The ESP8266 and ESP8285 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8285 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data. GPIO 1, 2 and 3 will cause boot failure if LOW on boot - use with care.","title":"Usable Pins"},{"location":"Peripherals/#pwm","text":"ESP8266 Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions . ESP8266 has only software and supports 5 PWM channels. PWM and PWMi GPIOs are used in two modes depending on SetOption15 : either as lights or as pure PWM. ESP32 has hardware PWM support, named ledc , up to 16 channels depending on CPU type. You can mix lights and pure PWM channels. The first 5 PWM are reserved for lights, unless SetOption15 0 . For pure PWM GPIOs, you can assign any PWM number, they don't need to be continuous. For example you can use PWM 1/2/3 for a 3-channel RGB light, and PWM 6 & PWM 10 for pure PWM at the same time. CPU type PWM channels ESP32 16 channels ESP32S2 8 channels ESP32C3 6 channels Channels are assigned to GPIOs in a first-in-first-serve way, and PWM GPIOs are assigned first. If ledc channel are exhausted, an error will appear in logs. The following GPIOs use ledc PWM channels: GPIO type Description PWM or PWMi PWM 1..5 are used for lights, PWM O6..11 are general purpose PWM. LedPwmMode Assigns a Led GPIO to a PWM channel Buzzer If BuzzerPwm is used Backlight PWM backlighting for displays XCLK Used as a clock generator for webcam Example of PWM console output with 16 PWM assigned. By default PWM range is 0..1023. RSL: RESULT = {\"PWM\":{\"PWM1\":410,\"PWM2\":286,\"PWM3\":286,\"PWM4\":0,\"PWM5\":0,\"PWM6\":0,\"PWM7\":0,\"PWM8\":0,\"PWM9\":0,\"PWM10\":0,\"PWM11\":0,\"PWM12\":0,\"PWM13\":0,\"PWM14\":0,\"PWM15\":0,\"PWM16\":0}}","title":"PWM"},{"location":"Peripherals/#analog-input","text":"The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits.","title":"Analog Input"},{"location":"Peripherals/#communication","text":"","title":"Communication"},{"location":"Peripherals/#serial","text":"The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins.","title":"Serial"},{"location":"Peripherals/#i2c","text":"ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz.","title":"I\u00b2C"},{"location":"Peripherals/#spi","text":"The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software).","title":"SPI"},{"location":"Peripherals/#gpio-overview","text":"NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission - Boot will fail if LOW at boot D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time - boot will fail. Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"GPIO Overview"},{"location":"Pinouts/","text":"Wi-Fi Module Pinouts ~ ESP82xx Based ~ ESP8266 and ESP8285 ~ ESP-12E/ESP-12F ~ ESP-12S ~ ESP-WROOM-02 ~ LM1 ~ LM2 ~ TYWE1S ~ TYWE2S ~ TYWE2L ~ TYWE3S ~ TYWE3L ~ TYLC4 ~ TYLC5 ~ TYWE5P ~ PSF-B85/PSF-B01/PSF-B04 ~ ESP8266-S3 ~ 449A-ECOPLUGS ~ Datasheet CUCO-Z0-V1.1 (Used by Gosund) ~ Overview Front Back ESP32 Based ~ ESP32-CAM ~ ESP32-S ~ ESP32-SOLO-1 ~ ESP32-WROVER ~ Includes ESP32-WROVER-B and ESP32-WROVER-BI ESP32-WROOM-32x ~ ESP32-S ~ ESP-12K ~ ESP32-C3 ~ ESP-C3-12F ~ ESP-C3-32S ~ ESP-C3-13 ~ ESP-C3-01M ~ Devices ~ Sonoff Mini ~ Sonoff TH ~ Sonoff Basic ~ Digoo DG-SP202 / OxaOxe NX-SP202 ~ (Found out by tracing the PCB copper tracks of the unknown ESP module. Not verified, except GPIO0, RX, TX, Vcc and GND which have successfully been used for flashing.)","title":"Wi-Fi Module Pinouts"},{"location":"Pinouts/#wi-fi-module-pinouts","text":"","title":"Wi-Fi Module Pinouts"},{"location":"Pinouts/#esp82xx-based","text":"","title":"ESP82xx Based"},{"location":"Pinouts/#esp8266-and-esp8285","text":"","title":"ESP8266 and ESP8285"},{"location":"Pinouts/#esp-12eesp-12f","text":"","title":"ESP-12E/ESP-12F"},{"location":"Pinouts/#esp-12s","text":"","title":"ESP-12S"},{"location":"Pinouts/#esp-wroom-02","text":"","title":"ESP-WROOM-02"},{"location":"Pinouts/#lm1","text":"","title":"LM1"},{"location":"Pinouts/#lm2","text":"","title":"LM2"},{"location":"Pinouts/#tywe1s","text":"","title":"TYWE1S"},{"location":"Pinouts/#tywe2s","text":"","title":"TYWE2S"},{"location":"Pinouts/#tywe2l","text":"","title":"TYWE2L"},{"location":"Pinouts/#tywe3s","text":"","title":"TYWE3S"},{"location":"Pinouts/#tywe3l","text":"","title":"TYWE3L"},{"location":"Pinouts/#tylc4","text":"","title":"TYLC4"},{"location":"Pinouts/#tylc5","text":"","title":"TYLC5"},{"location":"Pinouts/#tywe5p","text":"","title":"TYWE5P"},{"location":"Pinouts/#psf-b85psf-b01psf-b04","text":"","title":"PSF-B85/PSF-B01/PSF-B04"},{"location":"Pinouts/#esp8266-s3","text":"","title":"ESP8266-S3"},{"location":"Pinouts/#449a-ecoplugs","text":"Datasheet","title":"449A-ECOPLUGS"},{"location":"Pinouts/#cuco-z0-v11-used-by-gosund","text":"Overview Front Back","title":"CUCO-Z0-V1.1 (Used by Gosund)"},{"location":"Pinouts/#esp32-based","text":"","title":"ESP32 Based"},{"location":"Pinouts/#esp32-cam","text":"","title":"ESP32-CAM"},{"location":"Pinouts/#esp32-s","text":"","title":"ESP32-S"},{"location":"Pinouts/#esp32-solo-1","text":"","title":"ESP32-SOLO-1"},{"location":"Pinouts/#esp32-wrover","text":"Includes ESP32-WROVER-B and ESP32-WROVER-BI","title":"ESP32-WROVER"},{"location":"Pinouts/#esp32-wroom-32x","text":"","title":"ESP32-WROOM-32x"},{"location":"Pinouts/#esp32-s_1","text":"","title":"ESP32-S"},{"location":"Pinouts/#esp-12k","text":"","title":"ESP-12K"},{"location":"Pinouts/#esp32-c3","text":"","title":"ESP32-C3"},{"location":"Pinouts/#esp-c3-12f","text":"","title":"ESP-C3-12F"},{"location":"Pinouts/#esp-c3-32s","text":"","title":"ESP-C3-32S"},{"location":"Pinouts/#esp-c3-13","text":"","title":"ESP-C3-13"},{"location":"Pinouts/#esp-c3-01m","text":"","title":"ESP-C3-01M"},{"location":"Pinouts/#devices","text":"","title":"Devices"},{"location":"Pinouts/#sonoff-mini","text":"","title":"Sonoff Mini"},{"location":"Pinouts/#sonoff-th","text":"","title":"Sonoff TH"},{"location":"Pinouts/#sonoff-basic","text":"","title":"Sonoff Basic"},{"location":"Pinouts/#digoo-dg-sp202-oxaoxe-nx-sp202","text":"(Found out by tracing the PCB copper tracks of the unknown ESP module. Not verified, except GPIO0, RX, TX, Vcc and GND which have successfully been used for flashing.)","title":"Digoo DG-SP202 / OxaOxe NX-SP202"},{"location":"PlatformIO-CLI/","text":"How to flash the Tasmota firmware onto a device using the platformio command line interface. This manual was tested on Ubuntu 17.10. Prerequisites ~ Install Python and PIP ~ sudo apt-get install python-pip Install PlatformIO CLI ~ sudo pip install -U platformio Download the Tasmota source code ~ Either download the latest Tasmota Source code from https://github.com/arendst/Tasmota/ and extract it or clone the Git repository: git clone https://github.com/arendst/Tasmota.git Select the environment ~ The default environment configuration can be used to easily generate Tasmota firmware variants (tasmota, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, use the -e command line argument (e.g., -e tasmota-sensors ). Compile and upload ~ Once all the prerequisites are in place, compiling and uploading is one simple command. Execute this from within the Tasmota source code directory: platformio run -e <variant> --target upload --upload-port <port> Just make sure to replace <port> with the actual serial port your device is connected to. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.)]. Depending on your configuration your user account may need to be in the dialout group .","title":"PlatformIO CLI"},{"location":"PlatformIO-CLI/#prerequisites","text":"","title":"Prerequisites"},{"location":"PlatformIO-CLI/#install-python-and-pip","text":"sudo apt-get install python-pip","title":"Install Python and PIP"},{"location":"PlatformIO-CLI/#install-platformio-cli","text":"sudo pip install -U platformio","title":"Install PlatformIO CLI"},{"location":"PlatformIO-CLI/#download-the-tasmota-source-code","text":"Either download the latest Tasmota Source code from https://github.com/arendst/Tasmota/ and extract it or clone the Git repository: git clone https://github.com/arendst/Tasmota.git","title":"Download the Tasmota source code"},{"location":"PlatformIO-CLI/#select-the-environment","text":"The default environment configuration can be used to easily generate Tasmota firmware variants (tasmota, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, use the -e command line argument (e.g., -e tasmota-sensors ).","title":"Select the environment"},{"location":"PlatformIO-CLI/#compile-and-upload","text":"Once all the prerequisites are in place, compiling and uploading is one simple command. Execute this from within the Tasmota source code directory: platformio run -e <variant> --target upload --upload-port <port> Just make sure to replace <port> with the actual serial port your device is connected to. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.)]. Depending on your configuration your user account may need to be in the dialout group .","title":"Compile and upload"},{"location":"PlatformIO/","text":"How to setup and configure PlatformIO for Tasmota compilation and upload. Download PlatformIO ~ Download PlatformIO from https://platformio.org/ Install PlatformIO ~ Install PlatformIO to a known folder. Download Tasmota ~ Download the latest Tasmota Source code from https://github.com/arendst/Tasmota and unzip to another known folder. Compile Tasmota ~ Choose the Tasmota variant from the Platformio menu . Upload Tasmota ~ PlatformIO uses the serial interface to upload the firmware to your device. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.). Put device into programming mode ~ When performing a firmware upload do not connect the device to AC . Use a 3.3v DC power supply such as that provided by your serial programming adapter. Put the device in programming mode by grounding pin GPIO0 and then applying power (e.g., connecting your computer to the serial adapter). Grounding pin GPIO0 can often be achieved by pressing the button on the device or using a wire between GPIO0 and GND if the button is not available. Deviations may apply. Perform serial upload ~ Select Upload from the menu. NOTE: For a proper device initialization after first firmware upload power down and power up the device.","title":"PlatformIO"},{"location":"PlatformIO/#download-platformio","text":"Download PlatformIO from https://platformio.org/","title":"Download PlatformIO"},{"location":"PlatformIO/#install-platformio","text":"Install PlatformIO to a known folder.","title":"Install PlatformIO"},{"location":"PlatformIO/#download-tasmota","text":"Download the latest Tasmota Source code from https://github.com/arendst/Tasmota and unzip to another known folder.","title":"Download Tasmota"},{"location":"PlatformIO/#compile-tasmota","text":"Choose the Tasmota variant from the Platformio menu .","title":"Compile Tasmota"},{"location":"PlatformIO/#upload-tasmota","text":"PlatformIO uses the serial interface to upload the firmware to your device. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.).","title":"Upload Tasmota"},{"location":"PlatformIO/#put-device-into-programming-mode","text":"When performing a firmware upload do not connect the device to AC . Use a 3.3v DC power supply such as that provided by your serial programming adapter. Put the device in programming mode by grounding pin GPIO0 and then applying power (e.g., connecting your computer to the serial adapter). Grounding pin GPIO0 can often be achieved by pressing the button on the device or using a wire between GPIO0 and GND if the button is not available. Deviations may apply.","title":"Put device into programming mode"},{"location":"PlatformIO/#perform-serial-upload","text":"Select Upload from the menu. NOTE: For a proper device initialization after first firmware upload power down and power up the device.","title":"Perform serial upload"},{"location":"Power-Monitoring-Calibration/","text":"!> You need to calibrate your power monitoring device as correct measurements are influenced by hardware and timing differences. Your power monitoring capable device flashed with Tasmota and configured with the correct module/template that supports power monitoring An AC capable calibrated multi-meter A known wattage load with a power factor as close to 1 as possible (e.g., a resistive load) for best results Note A resistive load device is any device which draws a constant amount of power. For example, an incandescent or halogen light bulb (best choice since their power draw is declared on them). An electric kettle, heater, or blow dryer are also options but you will also need a power meter since the power draw could vary. Danger Do not use switch mode driven devices such as LED lamps, computer equipment, or inductive/capacitive devices such as motors! (optional) A calibrated power meter (a.k.a Kill-a-Watt) or AC multi-meter Setup ~ Connect the load (e.g., a 60W incandescent light bulb) to your device (optional) Plug your load into the Kill-a-Watt Open two Tasmota web UI browser windows for your power monitoring device: Click on Console in one browser window Keep the other on the main page to view the Power telemetry data Turn the power on to your device. Be sure to turn the output on so the load is powered on as well Wait a few seconds for the readings to stabilize Calibration Procedure ~ Verify the Power reading in the web UI (optionally with the power meter as well) for the expected wattage. Adjust the power offset if needed (in Watts): PowerSet 60.0 If you're using something other than a 60W bulb, enter your load's power rating Verify the Voltage reading. Adjust the voltage offset if needed (in Volts): VoltageSet <voltage> Replace <voltage> with your standard voltage or with reading on your multi-meter if you have one. Your voltage will vary depending on the electrical standards and your electrical grid Verify the Current reading by calculating current value (amperage) using this formula: P (W) /V (V) =I (A) . Adjust the current offset if needed (in milliAmps (mA=A*1000)): CurrentSet <current> Replace <current> with your calculated value (in milliAmps) CurrentSet calculation: P/V=I 1000 * Watts/Volts = milliAmperes Example 1000*(60.0/235.5) = 254.777 Confirm the validity of your calibration process checking Power Factor from the web UI which should be as close as possible to 1.00 . In theory resistive loads will always provide a power factor of 1.00. If that is not the case, we recommend you repeat the calibration process and make sure everything was done correctly. Fine Tuning ~ This procedure requires the use of a calibrated power meter or AC multi-meter. Commands CurrentCal , PowerCal and VoltageCal allow fine tuning of the power calibration. Repeat the procedure below for each of the readings: Current, Power, and Voltage using the corresponding calibration command ( CurrentCal , PowerCal , and VoltageCal respectively). Take note that the offset ranges vary for each command . Check the reading using a multi-meter Compare it with the reading on the Tasmota web UI If there is an observed difference, change the offset value by issuing the calibration command in the Console (e.g., PowerCal 10000 ) Adjust the offset value up or down until the readings on the multi-meter and the web page are as close as possible The CurrentCal , PowerCal , VoltageCal commands accept values up to 32000. If the offset values you would like to specify are larger, you may have configured an incorrect power monitoring chip in the template. For example: if you specify the BL0937 (134) while you actually have an HLW8012 (133). Change the template to proper power monitoring chip to fix. Known Issues ~ Power monitoring chips such as HLW8032 (Blitzwolf SHP5) and CSE7766 (Sonoff S31, Sonoff POW R2) occasionally report invalid power measurements for load values below 5W. During this situation it sometimes reports a valid load. By setting SetOption39 to 128 (default) it must read at least 128 invalid power readings before reporting there is no load. To discard all loads below 6W simply set SetOption39 1 ( 0 will reset to default on next restart) so it will report no load below 6W.","title":"Power Monitoring Calibration"},{"location":"Power-Monitoring-Calibration/#setup","text":"Connect the load (e.g., a 60W incandescent light bulb) to your device (optional) Plug your load into the Kill-a-Watt Open two Tasmota web UI browser windows for your power monitoring device: Click on Console in one browser window Keep the other on the main page to view the Power telemetry data Turn the power on to your device. Be sure to turn the output on so the load is powered on as well Wait a few seconds for the readings to stabilize","title":"Setup"},{"location":"Power-Monitoring-Calibration/#calibration-procedure","text":"Verify the Power reading in the web UI (optionally with the power meter as well) for the expected wattage. Adjust the power offset if needed (in Watts): PowerSet 60.0 If you're using something other than a 60W bulb, enter your load's power rating Verify the Voltage reading. Adjust the voltage offset if needed (in Volts): VoltageSet <voltage> Replace <voltage> with your standard voltage or with reading on your multi-meter if you have one. Your voltage will vary depending on the electrical standards and your electrical grid Verify the Current reading by calculating current value (amperage) using this formula: P (W) /V (V) =I (A) . Adjust the current offset if needed (in milliAmps (mA=A*1000)): CurrentSet <current> Replace <current> with your calculated value (in milliAmps) CurrentSet calculation: P/V=I 1000 * Watts/Volts = milliAmperes Example 1000*(60.0/235.5) = 254.777 Confirm the validity of your calibration process checking Power Factor from the web UI which should be as close as possible to 1.00 . In theory resistive loads will always provide a power factor of 1.00. If that is not the case, we recommend you repeat the calibration process and make sure everything was done correctly.","title":"Calibration Procedure"},{"location":"Power-Monitoring-Calibration/#fine-tuning","text":"This procedure requires the use of a calibrated power meter or AC multi-meter. Commands CurrentCal , PowerCal and VoltageCal allow fine tuning of the power calibration. Repeat the procedure below for each of the readings: Current, Power, and Voltage using the corresponding calibration command ( CurrentCal , PowerCal , and VoltageCal respectively). Take note that the offset ranges vary for each command . Check the reading using a multi-meter Compare it with the reading on the Tasmota web UI If there is an observed difference, change the offset value by issuing the calibration command in the Console (e.g., PowerCal 10000 ) Adjust the offset value up or down until the readings on the multi-meter and the web page are as close as possible The CurrentCal , PowerCal , VoltageCal commands accept values up to 32000. If the offset values you would like to specify are larger, you may have configured an incorrect power monitoring chip in the template. For example: if you specify the BL0937 (134) while you actually have an HLW8012 (133). Change the template to proper power monitoring chip to fix.","title":"Fine Tuning"},{"location":"Power-Monitoring-Calibration/#known-issues","text":"Power monitoring chips such as HLW8032 (Blitzwolf SHP5) and CSE7766 (Sonoff S31, Sonoff POW R2) occasionally report invalid power measurements for load values below 5W. During this situation it sometimes reports a valid load. By setting SetOption39 to 128 (default) it must read at least 128 invalid power readings before reporting there is no load. To discard all loads below 6W simply set SetOption39 1 ( 0 will reset to default on next restart) so it will report no load below 6W.","title":"Known Issues"},{"location":"PowerOnState/","text":"PowerOnState Functionality ~ Command Description PowerOnState Control relay state after powering up the device. 0 / OFF = keep relay(s) OFF after power up 1 / ON = turn relay(s) ON after power up 2 / TOGGLE = toggle relay(s) from last saved state 3 = switch relay(s) to their last saved state (default) 4 = turn relay(s) ON and disable further relay control 5 = after a PulseTime period turn relay(s) ON (acts as inverted PulseTime mode) The PowerOnState device configuration parameter is applied when the device is initially powered up. It does not apply to device warm restarts . Tasmota tracks the relays' state in a masked variable. A set bit ( 1 ) means the corresponding relay is turned ON. The associated GPIO state will be high or low according to whether the relay is configured as Relay<x> or Relay<x>i . Every command for setting the relay state is \"recorded\" in the variable and saved to flash (depending on SetOption0 ). The setting of the relay GPIO is then executed. After a warm restart , the mask variable is re-initialised with the saved state from flash and the relay(s) set to that state. PowerOnState is not executed. During any a device restart, the relay power feedback state is scanned according to the setting of SetOption63 . Scanning the relay state attempts to READ from GPIOs that are configured as relays, i.e., OUTPUTS! The result will not always be what is expected as it depends on how the device relays are wired to the GPIO. SetOption63 was introduced to make this scan optional. With SetOption63 set to 0 (the default), each GPIO assigned as a Relay<x> or Relay<x>i is scanned using 'digitalRead' . The mask variable will be updated with the detected values. The state of the relay(s) will not be changed. READING from an OUTPUT GPIO may result in the mask value being different from the state the relays are in. Thus, SetOption63 was introduced to disable the startup scan for devices where the scan leads to undefined results. SetOption63 is executed after PowerOnState or restart initialization.","title":"PowerOnState"},{"location":"PowerOnState/#poweronstate-functionality","text":"Command Description PowerOnState Control relay state after powering up the device. 0 / OFF = keep relay(s) OFF after power up 1 / ON = turn relay(s) ON after power up 2 / TOGGLE = toggle relay(s) from last saved state 3 = switch relay(s) to their last saved state (default) 4 = turn relay(s) ON and disable further relay control 5 = after a PulseTime period turn relay(s) ON (acts as inverted PulseTime mode) The PowerOnState device configuration parameter is applied when the device is initially powered up. It does not apply to device warm restarts . Tasmota tracks the relays' state in a masked variable. A set bit ( 1 ) means the corresponding relay is turned ON. The associated GPIO state will be high or low according to whether the relay is configured as Relay<x> or Relay<x>i . Every command for setting the relay state is \"recorded\" in the variable and saved to flash (depending on SetOption0 ). The setting of the relay GPIO is then executed. After a warm restart , the mask variable is re-initialised with the saved state from flash and the relay(s) set to that state. PowerOnState is not executed. During any a device restart, the relay power feedback state is scanned according to the setting of SetOption63 . Scanning the relay state attempts to READ from GPIOs that are configured as relays, i.e., OUTPUTS! The result will not always be what is expected as it depends on how the device relays are wired to the GPIO. SetOption63 was introduced to make this scan optional. With SetOption63 set to 0 (the default), each GPIO assigned as a Relay<x> or Relay<x>i is scanned using 'digitalRead' . The mask variable will be updated with the detected values. The state of the relay(s) will not be changed. READING from an OUTPUT GPIO may result in the mask value being different from the state the relays are in. Thus, SetOption63 was introduced to disable the startup scan for devices where the scan leads to undefined results. SetOption63 is executed after PowerOnState or restart initialization.","title":"PowerOnState Functionality"},{"location":"Project-AM312-and-Sonoff-R2/","text":"This use case represents a method to use AM312 as a \"wave hand toggle\" (for under-cabinet kitchen LED). Please note that this solution isn't working in 100% (this sensor has a detection range of a few meters, to decrease the range you can remove the lens from the sensor but still it will pick up movement from 50 cm. You can create the Tasmota rule that will disable AM312 toggle action when the light is on and turn off the power after a few minutes. The gesture sensor APDS-9960 should work better for \"hand-wave\" toggle. Wiring for Sonoff Basic R2 ~ As the R2 version doesn't have GPIO14 exposed you can use GPIO3 (RX) as the AM312 data pin. GPIO2 goes high during the boot (it would toggle the switch then). AM312 ESP8255 device VCC 3V3 or VCC VOUT GPIO3 (RX) GND GND Remember to remove the lens to lower the sensitivity of the sensor. Configuration ~ Go to IP of the device, next Configuration --> Configure Module --> set \"GPIO3 Serial In\" to \"Switch1 (9)\" Go to Console and type \" SwitchMode 4 \" ( detailed description of SwitchModes ) to enable toggle switch type. Set rule to turn off light after X amount of seconds (mentioned workaround): rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180 endon on Rules#Timer=1 do backlog Power1 0 endon rule1 1 Rule explanation: Switch1#State=2 - fire the event when switch1 is toggled, Power1 1 - turn on power, RuleTimer1 180 - set Timer1 to 180 seconds and start counting, Rules#Timer=1 - fire the event when Timer1 has stopped, Power1 0 - turn off power. This rule will turn off the light after 3 minutes, if the movement will be detected prior, the timer will be restarted and will count the time from the beginning. Instead of point 3, you can set below rules in order to ignore the second and next movements. It will just turn off the power after 3 minutes. rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180; Rule1 0; Rule2 1 endon rule2 on Rules#Timer=1 do backlog Power1 0; Rule1 1; Rule2 0 endon on Switch1#State=2 do break backlog rule1 1; rule2 0 Rules explanation: rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180; Rule1 0; Rule2 1 endon : Switch1#State=2 - fire the event when switch1 is toggled, Power1 1 - turn on power, RuleTimer1 180 - set Timer1 to 180 seconds and start counting, Rule1 0 - disable Rule1, Rule2 1 - enable Rule2. rule2 on Rules#Timer=1 do backlog Power1 0; Rule1 1; Rule2 0 endon on Switch1#State=2 do break : Rules#Timer=1 - fire the event when Timer1 has stopped Power1 0 - turn off power Rule1 1 - enable Rule1 Rule2 0 - disable Rule2 Switch1#State=2 do break - ignore toggling","title":"Project AM312 and Sonoff R2"},{"location":"Project-AM312-and-Sonoff-R2/#wiring-for-sonoff-basic-r2","text":"As the R2 version doesn't have GPIO14 exposed you can use GPIO3 (RX) as the AM312 data pin. GPIO2 goes high during the boot (it would toggle the switch then). AM312 ESP8255 device VCC 3V3 or VCC VOUT GPIO3 (RX) GND GND Remember to remove the lens to lower the sensitivity of the sensor.","title":"Wiring for Sonoff Basic R2"},{"location":"Projector/","text":"LCD/DLP projector Serial Control ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_PROJECTOR_CTRL // _Mandatory:_ choose the communication protocol for your projector. define only one of them: #define USE_PROJECTOR_CTRL_NEC #define USE_PROJECTOR_CTRL_OPTOMA #define USE_PROJECTOR_CTRL_ACER // _Optional:_ set the Relay that powers your device (default is 1) #define PROJECTOR_CTRL_PWR_BY_RELAY 1 //the relay that powers the projector // _Optional:_ set the baudrate to communicate to your device (default is 9600): #define PROJECTOR_CTRL_SERIAL_BAUDRATE 9600 // _Optional:_ enable debugging messages: #define DEBUG_PROJECTOR_CTRL // _Optional:_ Add Serial to TCP Bridge to your build if you want to play with your projector's communication protocol over network connection. Useful for ASCII protocol testing. Needs a different GPIO configuration and is completely independent to this module: #define USE_TCP_BRIDGE Description ~ This driver simulates an additional relay in your Tasmota device. If you have N physical relays and you configure GPIO pin functions DLP Tx and DLP Rx you'll see relay (N+1) after reboot. The two GPIO pins will be used for serial communication with your LCD or DLP projector. The communication protocol is unique for each manufacturer (compile-time option). The driver polls the projector's state periodically and updates the fake relay state. When you toggle the fake relay, serial commands are sent to the projector to power it up or down. While the projector is running, the driver prevents to switch off the real relay that feeds the projector. This protects the lamp of the projector (needs to be cooled down before power is cut from the device). Supported Projectors ~ NEC projectors - tested with NEC V300W OPTOMA projectors - not tested yet / report your results! Acer projectors - tested with Acer P1500 & H5360BD Fixes and definitions for further manufacturers should go to tasmota\\xdrv_53_projector_ctrl.h Physical Connection ~ Connect your Tasmota GPIO pins (3.3V TTL level) to a MAX3232 interface (cheap items on internet sales). Such interface changes TTL signals to proper RS232 levels. There are 4 wires on TTL side (Vcc, GND, Rx and Tx) and 3 wires on RS232 side (GND, Tx and Rx). A wire jumper between pins 7(RTS) and 8(CTS) may be needed in DSUB9 connector going to projector. Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIO1 to DLP Tx GPIO3 to DLP Rx Replace GPIO1/GPIO3 with your scenario. Use command Weblog 3 to see extended logging of serial communication in Console. Projector Configuration ~ Check your projector settings concerning Serial port. It must match Tasmota settings eg. 9600 8N1. Some models have \"ID number\" feature to allow several projectors in one room. The control commands in Tasmota contain ID 0. Please switch off the \"ID\" control completely or set the ID to 0. Since Acer H5360BD does not offer a simple RS2332 port setup is as follows:","title":"LCD/DLP Projector Control"},{"location":"Projector/#lcddlp-projector-serial-control","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_PROJECTOR_CTRL // _Mandatory:_ choose the communication protocol for your projector. define only one of them: #define USE_PROJECTOR_CTRL_NEC #define USE_PROJECTOR_CTRL_OPTOMA #define USE_PROJECTOR_CTRL_ACER // _Optional:_ set the Relay that powers your device (default is 1) #define PROJECTOR_CTRL_PWR_BY_RELAY 1 //the relay that powers the projector // _Optional:_ set the baudrate to communicate to your device (default is 9600): #define PROJECTOR_CTRL_SERIAL_BAUDRATE 9600 // _Optional:_ enable debugging messages: #define DEBUG_PROJECTOR_CTRL // _Optional:_ Add Serial to TCP Bridge to your build if you want to play with your projector's communication protocol over network connection. Useful for ASCII protocol testing. Needs a different GPIO configuration and is completely independent to this module: #define USE_TCP_BRIDGE","title":"LCD/DLP projector Serial Control"},{"location":"Projector/#description","text":"This driver simulates an additional relay in your Tasmota device. If you have N physical relays and you configure GPIO pin functions DLP Tx and DLP Rx you'll see relay (N+1) after reboot. The two GPIO pins will be used for serial communication with your LCD or DLP projector. The communication protocol is unique for each manufacturer (compile-time option). The driver polls the projector's state periodically and updates the fake relay state. When you toggle the fake relay, serial commands are sent to the projector to power it up or down. While the projector is running, the driver prevents to switch off the real relay that feeds the projector. This protects the lamp of the projector (needs to be cooled down before power is cut from the device).","title":"Description"},{"location":"Projector/#supported-projectors","text":"NEC projectors - tested with NEC V300W OPTOMA projectors - not tested yet / report your results! Acer projectors - tested with Acer P1500 & H5360BD Fixes and definitions for further manufacturers should go to tasmota\\xdrv_53_projector_ctrl.h","title":"Supported Projectors"},{"location":"Projector/#physical-connection","text":"Connect your Tasmota GPIO pins (3.3V TTL level) to a MAX3232 interface (cheap items on internet sales). Such interface changes TTL signals to proper RS232 levels. There are 4 wires on TTL side (Vcc, GND, Rx and Tx) and 3 wires on RS232 side (GND, Tx and Rx). A wire jumper between pins 7(RTS) and 8(CTS) may be needed in DSUB9 connector going to projector.","title":"Physical Connection"},{"location":"Projector/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIO1 to DLP Tx GPIO3 to DLP Rx Replace GPIO1/GPIO3 with your scenario. Use command Weblog 3 to see extended logging of serial communication in Console.","title":"Tasmota Settings"},{"location":"Projector/#projector-configuration","text":"Check your projector settings concerning Serial port. It must match Tasmota settings eg. 9600 8N1. Some models have \"ID number\" feature to allow several projectors in one room. The control commands in Tasmota contain ID 0. Please switch off the \"ID\" control completely or set the ID to 0. Since Acer H5360BD does not offer a simple RS2332 port setup is as follows:","title":"Projector Configuration"},{"location":"Python-HTTP-OTA-Server/","text":"Introduction ~ Tasmota firmware can be upgraded using 'Firmware Upgrade' option on the main menu and selecting an OTA URL to fetch (and flash) a new firmware on the device. To use this feature, firmware files need to be hosted on an HTTP web server (e.g., http://ota.tasmota.com/tasmota). Alternatively, users can to deploy a local HTTP server with Apache, Nginx, or other software solutions. Python makes available the Flask (micro)framework that can be used at different levels of complexity due to its modular architecture. A simple HTTP server (hello-world) can be deployed with only six lines of Python code. A Flask application to offer Tasmota firmware images for OTA upgrades is available as part of the available tools . Requirements ~ Switching to superuser privileges and installing additional packages (and libraries) on a Linux/Windows box. Python3 (follow instruction related to your operating system) netifaces and Flask libraries - can be installed by 'pip' package manager: pip install netifaces flask Instructions ~ Copy Tasmota firmware binary files in 'tools/fw' directory. A set of pre-built firmware binary files can be downloaded from the Tasmota repository . Configure your Tasmota device with your firmware server URL: Firmware Upgrade -> Upgrade by web server: http://<ip_address>:5000/tasmota.bin or use the following command: Backlog OTAURL http://<ip_address>:5000/tasmota.bin; Upgrade 1 Usage ~ To start Python HTTP server: python fw-server.py -d <net_iface> (default: eth0) or python fw-server.py -i <ip_address> Example: python fw-server.py -d wlan0 or python fw-server.py -i 192.168.1.1 Note: On Windows it is advisable to use '-i' option because Windows uses UUID naming for network interfaces that are difficult to enter. Linux server: ~ If your MQTT broker is hosted on a local server, you may want your firmware web server used for Tasmota OTA updates to reside on the same server. Follow these steps to create it as a service: - Copy the python script on the Linux server: $ sudo su # mkdir /srv/tasmota/fw_server/fw # cd /srv/tasmota/fw_server # wget https://github.com/arendst/Tasmota/tree/development/tools/fw_server/fw-server.py - Create a new file named tasmota.service in /etc/systemd/system/ and paste these lines (replace XYZ by your username): [Unit] Description=Local OTA server for Tasmota Requires=network.target After=network.target multi-user.target [Service] User=XYZ Type=idle ExecStart=/usr/bin/python /srv/tasmota/fw_server/fw-server.py -d wlan0 Restart=on-failure [Install] WantedBy=multi-user.target - User rights: The files and directories have been created as root but this is not desirable. Invoke the following commands (replace the four instances of XYZ by your username): # chown -hR XYZ:XYZ /srv/tasmota # chown XYZ:XYZ /etc/systemd/system/tasmota.service - Run the service: # systemctl daemon-reload # systemctl enable tasmota.service # systemctl start tasmota.service If the server is rebooted, the service will automatically restart. - Check that the service is active and running: # systemctl status tasmota.service - Test the server: Copy new firmware files to the /srv/tasmota/fw_server/fw folder. Ensure that they have XYZ user rights in a similar fashion as shown above. You can use scp or a samba share. Copy the firmware files into the folder ( firmware.bin in the example below). The service can be tested from any browser by issuing the address http://<ip_address>:5000/firmware.bin were <ip_address> is the address of the Linux server. If the web server becomes unresponsive: After a power failure, your wlan0 IP may resolve to an invalid value like 169.254.5.153 because your LAN gateway was not ready when the web server restarted. If you notice that the OTA mechanism is broken, try to download the file from a browser. If you can't, then restart the service and check the status. Log in using a terminal session and enter: $ sudo su # systemctl restart tasmota.service # systemctl status tasmota.service If you recognize the IP address of your server on the last line of the status output, the web server should be OK. You can confirm that your OTA web server is restored by trying to download a file using your web browser. PlatformIO: If you want PlatformIO to be able to upload your compiled binaries to the local server, you'll still have to setup ssh with ssh-keygen in order to use the Tasmota script pio/sftp-uploader.py without a password.","title":"Python HTTP OTA Server"},{"location":"Python-HTTP-OTA-Server/#introduction","text":"Tasmota firmware can be upgraded using 'Firmware Upgrade' option on the main menu and selecting an OTA URL to fetch (and flash) a new firmware on the device. To use this feature, firmware files need to be hosted on an HTTP web server (e.g., http://ota.tasmota.com/tasmota). Alternatively, users can to deploy a local HTTP server with Apache, Nginx, or other software solutions. Python makes available the Flask (micro)framework that can be used at different levels of complexity due to its modular architecture. A simple HTTP server (hello-world) can be deployed with only six lines of Python code. A Flask application to offer Tasmota firmware images for OTA upgrades is available as part of the available tools .","title":"Introduction"},{"location":"Python-HTTP-OTA-Server/#requirements","text":"Switching to superuser privileges and installing additional packages (and libraries) on a Linux/Windows box. Python3 (follow instruction related to your operating system) netifaces and Flask libraries - can be installed by 'pip' package manager: pip install netifaces flask","title":"Requirements"},{"location":"Python-HTTP-OTA-Server/#instructions","text":"Copy Tasmota firmware binary files in 'tools/fw' directory. A set of pre-built firmware binary files can be downloaded from the Tasmota repository . Configure your Tasmota device with your firmware server URL: Firmware Upgrade -> Upgrade by web server: http://<ip_address>:5000/tasmota.bin or use the following command: Backlog OTAURL http://<ip_address>:5000/tasmota.bin; Upgrade 1","title":"Instructions"},{"location":"Python-HTTP-OTA-Server/#usage","text":"To start Python HTTP server: python fw-server.py -d <net_iface> (default: eth0) or python fw-server.py -i <ip_address> Example: python fw-server.py -d wlan0 or python fw-server.py -i 192.168.1.1 Note: On Windows it is advisable to use '-i' option because Windows uses UUID naming for network interfaces that are difficult to enter.","title":"Usage"},{"location":"Python-HTTP-OTA-Server/#linux-server","text":"If your MQTT broker is hosted on a local server, you may want your firmware web server used for Tasmota OTA updates to reside on the same server. Follow these steps to create it as a service: - Copy the python script on the Linux server: $ sudo su # mkdir /srv/tasmota/fw_server/fw # cd /srv/tasmota/fw_server # wget https://github.com/arendst/Tasmota/tree/development/tools/fw_server/fw-server.py - Create a new file named tasmota.service in /etc/systemd/system/ and paste these lines (replace XYZ by your username): [Unit] Description=Local OTA server for Tasmota Requires=network.target After=network.target multi-user.target [Service] User=XYZ Type=idle ExecStart=/usr/bin/python /srv/tasmota/fw_server/fw-server.py -d wlan0 Restart=on-failure [Install] WantedBy=multi-user.target - User rights: The files and directories have been created as root but this is not desirable. Invoke the following commands (replace the four instances of XYZ by your username): # chown -hR XYZ:XYZ /srv/tasmota # chown XYZ:XYZ /etc/systemd/system/tasmota.service - Run the service: # systemctl daemon-reload # systemctl enable tasmota.service # systemctl start tasmota.service If the server is rebooted, the service will automatically restart. - Check that the service is active and running: # systemctl status tasmota.service - Test the server: Copy new firmware files to the /srv/tasmota/fw_server/fw folder. Ensure that they have XYZ user rights in a similar fashion as shown above. You can use scp or a samba share. Copy the firmware files into the folder ( firmware.bin in the example below). The service can be tested from any browser by issuing the address http://<ip_address>:5000/firmware.bin were <ip_address> is the address of the Linux server. If the web server becomes unresponsive: After a power failure, your wlan0 IP may resolve to an invalid value like 169.254.5.153 because your LAN gateway was not ready when the web server restarted. If you notice that the OTA mechanism is broken, try to download the file from a browser. If you can't, then restart the service and check the status. Log in using a terminal session and enter: $ sudo su # systemctl restart tasmota.service # systemctl status tasmota.service If you recognize the IP address of your server on the last line of the status output, the web server should be OK. You can confirm that your OTA web server is restored by trying to download a file using your web browser. PlatformIO: If you want PlatformIO to be able to upload your compiled binaries to the local server, you'll still have to setup ssh with ssh-keygen in order to use the Tasmota script pio/sftp-uploader.py without a password.","title":"Linux server:"},{"location":"RCWL-0516/","text":"RCWL-0516 microwave radar motion sensor ~ module uses a \u201cmicrowave Doppler radar\u201d technique to detect moving objects. Its advantage over traditional PIRs is that it can detect presence through obstacles with a sensing distance of 3m average in real life conditions. Configuration ~ Wiring ~ RCWL-0516 ESP GND GND VIN 5V OUT GPIOx Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to Switch1 (9) A configured RCWL-0516 will not appear in the web UI, only the console displays the status of Switch1 as POWER . Continue to use RCWL-0516 just as any other PIR in Tasmota. Buy from AliExpress Features of RCWL-0516 RCWL-0516 Datasheet RCWL-0516 GitHub","title":"RCWL-0516 microwave radar motion sensor"},{"location":"RCWL-0516/#rcwl-0516-microwave-radar-motion-sensor","text":"module uses a \u201cmicrowave Doppler radar\u201d technique to detect moving objects. Its advantage over traditional PIRs is that it can detect presence through obstacles with a sensing distance of 3m average in real life conditions.","title":"RCWL-0516 microwave radar motion sensor"},{"location":"RCWL-0516/#configuration","text":"","title":"Configuration"},{"location":"RCWL-0516/#wiring","text":"RCWL-0516 ESP GND GND VIN 5V OUT GPIOx","title":"Wiring"},{"location":"RCWL-0516/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to Switch1 (9) A configured RCWL-0516 will not appear in the web UI, only the console displays the status of Switch1 as POWER . Continue to use RCWL-0516 just as any other PIR in Tasmota. Buy from AliExpress Features of RCWL-0516 RCWL-0516 Datasheet RCWL-0516 GitHub","title":"Tasmota Settings"},{"location":"RDM6300/","text":"RDM6300 RFID reader ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_RDM6300 #define USE_RDM6300 // Add support for RDM6300 125kHz RFID Reader (+0k8) #endif RDM6300 125KHz cardreader mini-module is designed for reading code from 125KHz card compatible read-only tags and read/write card. Warning ~ There seems to be an issue with some card readers!(the cheap ones?) These output some fake/ghost readings that look like valid card numbers and validate thru the XOR method but are not real. This is confirmed by multiple users. Please see details in issue #9952 . There seem to not be issues yet with SeeedStudio Grove 125Khz Reader or RDM630 Configuration ~ Sensor uses serial interface for communication. Wiring ~ RDM6300 ESP TX GPIOx RX GPIOy Pin3 unused GND GND VCC 5V Tasmota Settings ~ Update 12.10.2020: Seems there is a new driver and you can use RDM6300 RX instead of the SerBr Tx and SerBr Rx . This also seems to show the last card read in the management interface. As a note, the card number that comes from the SerBr was 12 chars and the RDM6300 one has only 8, being stripped by the first 2 and last 2 chars. In the Configuration -> Configure Module page assign: GPIOx to SerBr Tx (71) GPIOy to SerBr Rx (72) If the RFID Tag is held in front of the Antenna the reader starts sending the Tag ID. The Tag Id is prefaced with a 0x02 and the end is delimited with a 0x03. If the reader reads the tag multiple times you would get one line with multiple times the Tag ID. For this to seperate you can add a SerialDelimiter of 0x03. This will split the result from the serial into serveral single mqtt messages. But (probably) all the messages wil be prepended with a binary 0x02. Set SerialDelimiter to 3 SerialDelimiter 3 OpenHab ~ sonoff-rfid.items: // tele/sonoff-rfid-1/RESULT {\"SSerialReceived\":\"01020304FAFA\"} String RFID_1 \"RFID [%s]\" {mqtt=\"<[broker:tele/sonoff-rfid-1/RESULT:state:JSONPATH($.SSerialReceived)]\"} Breakout Boards ~","title":"RDM6300 RFID reader"},{"location":"RDM6300/#rdm6300-rfid-reader","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_RDM6300 #define USE_RDM6300 // Add support for RDM6300 125kHz RFID Reader (+0k8) #endif RDM6300 125KHz cardreader mini-module is designed for reading code from 125KHz card compatible read-only tags and read/write card.","title":"RDM6300 RFID reader"},{"location":"RDM6300/#warning","text":"There seems to be an issue with some card readers!(the cheap ones?) These output some fake/ghost readings that look like valid card numbers and validate thru the XOR method but are not real. This is confirmed by multiple users. Please see details in issue #9952 . There seem to not be issues yet with SeeedStudio Grove 125Khz Reader or RDM630","title":"Warning"},{"location":"RDM6300/#configuration","text":"Sensor uses serial interface for communication.","title":"Configuration"},{"location":"RDM6300/#wiring","text":"RDM6300 ESP TX GPIOx RX GPIOy Pin3 unused GND GND VCC 5V","title":"Wiring"},{"location":"RDM6300/#tasmota-settings","text":"Update 12.10.2020: Seems there is a new driver and you can use RDM6300 RX instead of the SerBr Tx and SerBr Rx . This also seems to show the last card read in the management interface. As a note, the card number that comes from the SerBr was 12 chars and the RDM6300 one has only 8, being stripped by the first 2 and last 2 chars. In the Configuration -> Configure Module page assign: GPIOx to SerBr Tx (71) GPIOy to SerBr Rx (72) If the RFID Tag is held in front of the Antenna the reader starts sending the Tag ID. The Tag Id is prefaced with a 0x02 and the end is delimited with a 0x03. If the reader reads the tag multiple times you would get one line with multiple times the Tag ID. For this to seperate you can add a SerialDelimiter of 0x03. This will split the result from the serial into serveral single mqtt messages. But (probably) all the messages wil be prepended with a binary 0x02. Set SerialDelimiter to 3 SerialDelimiter 3","title":"Tasmota Settings"},{"location":"RDM6300/#openhab","text":"sonoff-rfid.items: // tele/sonoff-rfid-1/RESULT {\"SSerialReceived\":\"01020304FAFA\"} String RFID_1 \"RFID [%s]\" {mqtt=\"<[broker:tele/sonoff-rfid-1/RESULT:state:JSONPATH($.SSerialReceived)]\"}","title":"OpenHab"},{"location":"RDM6300/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"RF-Protocol/","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_RC_SWITCH #define USE_RC_SWITCH // Add support for RF transceiver using library RcSwitch (+2k7 code, 460 iram) #endif This guide does not apply to Sonoff RF Bridge specific commands Tasmota uses the rc-switch library to decode RF codes. Supported hardware depends on rc-switch library support only. Sending RF Codes ~ Send an RF control code as a decimal or hexadecimal string in a JSON payload. An inexpensive RF receiver such as a STX882 can be connected to a device running Tasmota. In order to send RF data you need to configure the connected GPIO as RFSend (105) Command Parameters RFsend <value> = code decimal or JSON. Data value is required and can be decimal or hexadecimal (using the 0x prefix), other values are optional. JSON {\"Data\":\"<value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} \"Data\":\"<value>\" = hexadecimal code \"Bits\":<value> = required number of data bits (default = 24 ) \"Protocol\":<value> = protocol number (default = 1 ) \"Repeat\":<value> = repeat value (default = 10 ) \"Pulse\":<value> = pulse value ( 350 = default for protocol 1) \u2003e.g., RFsend {\"Data\":\"0x7028DC\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238} Decimal data, bits, protocol, repeat, pulse \u2003e.g., RFsend 7350492, 24, 1, 10, 238 or RFsend 0x7028DC, 24, 1, 10, 238 If you send only the \"Data\" value in decimal or hexadecimal other values will be sent as default. Example RfSend 123456 will be sent as {\"Data\":\"0x1E240\",\"Bits\":24,\"Protocol\":1,\"Pulse\":351} When sending decimal formatted command you need to follow the pattern otherwise a part of the command will be ignored. Example RfSend 123456, 24, 1, 238 is missing the repeat value so the last number intended as pulse value won't be sent Receiving RF Codes ~ An inexpensive RF receiver such as a SRX882 can be connected to a device running Tasmota. Configure the GPIO connected to Data pin on the RF receiver as 'RFrecv (106)'. Once you have identified the protocols that you want to receive data on , you can enable only those protocols . The RfProtocol command will only work if you have set a pin function to rfrecv Command Parameters RfProtocol <value> <value> 0 .. 0x7FFFFFFFF or 'A' for All :: This Sets the Enabled Protocol Mask Value RfProtocol <idx> <value> <idx> 1 .. 35 <value> 0 or 1 :: This Disables or Enables a Specific Protocol Example RfProtocol 5 will enable only protocols 1 & 3 stat/tasmota_D728A8/RESULT {\"RfProtocol\":\"1,3\"} RfProtocol27 1 will enable protocol 27 stat/tasmota_D728A8/RESULT {\"RfProtocol\":\"1,3,27\"} RfProtocol 0 stat/tasmota_D728A8/RESULT {\"RfProtocol\":\"None Enabled\"} RfProtocol a stat/tasmota_D728A8/RESULT {\"RfProtocol\":\"1,2,3,4,5,6,7,8,9,10,11,12, 13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35\"} If you have an RF receiver configured, a message will be logged each time an RF code is seen. RF driver will try to decode it against all protocols supported by rc-switch library. When Tasmota receives an RF message, the data portion of the payload has the same format as the RFSend JSON parameters. \"RfReceived\":{\"Data\":\"<hex-value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} This JSON payload data can be used in a rule such as: ON RfReceived#Data=<hex-value> DO <command> ENDON Examples: Sonoff RM433 Remote MQT: tele/tasmota/RESULT = {\"Time\":\"2020-05-27T18:59:06\",\"RfReceived\":{\"Data\":\"0x7028D2\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238}}","title":"RF Communication"},{"location":"RF-Protocol/#sending-rf-codes","text":"Send an RF control code as a decimal or hexadecimal string in a JSON payload. An inexpensive RF receiver such as a STX882 can be connected to a device running Tasmota. In order to send RF data you need to configure the connected GPIO as RFSend (105) Command Parameters RFsend <value> = code decimal or JSON. Data value is required and can be decimal or hexadecimal (using the 0x prefix), other values are optional. JSON {\"Data\":\"<value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} \"Data\":\"<value>\" = hexadecimal code \"Bits\":<value> = required number of data bits (default = 24 ) \"Protocol\":<value> = protocol number (default = 1 ) \"Repeat\":<value> = repeat value (default = 10 ) \"Pulse\":<value> = pulse value ( 350 = default for protocol 1) \u2003e.g., RFsend {\"Data\":\"0x7028DC\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238} Decimal data, bits, protocol, repeat, pulse \u2003e.g., RFsend 7350492, 24, 1, 10, 238 or RFsend 0x7028DC, 24, 1, 10, 238 If you send only the \"Data\" value in decimal or hexadecimal other values will be sent as default. Example RfSend 123456 will be sent as {\"Data\":\"0x1E240\",\"Bits\":24,\"Protocol\":1,\"Pulse\":351} When sending decimal formatted command you need to follow the pattern otherwise a part of the command will be ignored. Example RfSend 123456, 24, 1, 238 is missing the repeat value so the last number intended as pulse value won't be sent","title":"Sending RF Codes"},{"location":"RF-Protocol/#receiving-rf-codes","text":"An inexpensive RF receiver such as a SRX882 can be connected to a device running Tasmota. Configure the GPIO connected to Data pin on the RF receiver as 'RFrecv (106)'. Once you have identified the protocols that you want to receive data on , you can enable only those protocols . The RfProtocol command will only work if you have set a pin function to rfrecv Command Parameters RfProtocol <value> <value> 0 .. 0x7FFFFFFFF or 'A' for All :: This Sets the Enabled Protocol Mask Value RfProtocol <idx> <value> <idx> 1 .. 35 <value> 0 or 1 :: This Disables or Enables a Specific Protocol Example RfProtocol 5 will enable only protocols 1 & 3 stat/tasmota_D728A8/RESULT {\"RfProtocol\":\"1,3\"} RfProtocol27 1 will enable protocol 27 stat/tasmota_D728A8/RESULT {\"RfProtocol\":\"1,3,27\"} RfProtocol 0 stat/tasmota_D728A8/RESULT {\"RfProtocol\":\"None Enabled\"} RfProtocol a stat/tasmota_D728A8/RESULT {\"RfProtocol\":\"1,2,3,4,5,6,7,8,9,10,11,12, 13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35\"} If you have an RF receiver configured, a message will be logged each time an RF code is seen. RF driver will try to decode it against all protocols supported by rc-switch library. When Tasmota receives an RF message, the data portion of the payload has the same format as the RFSend JSON parameters. \"RfReceived\":{\"Data\":\"<hex-value>\",\"Bits\":<value>,\"Protocol\":<value>,\"Pulse\":<value>} This JSON payload data can be used in a rule such as: ON RfReceived#Data=<hex-value> DO <command> ENDON Examples: Sonoff RM433 Remote MQT: tele/tasmota/RESULT = {\"Time\":\"2020-05-27T18:59:06\",\"RfReceived\":{\"Data\":\"0x7028D2\",\"Bits\":24,\"Protocol\":1,\"Pulse\":238}}","title":"Receiving RF Codes"},{"location":"RF-Transceiver/","text":"RC Switch driver enables sending RF codes through an RF transmitter and receiving them through an RF receiver via rc-switch library . RF Transmitter ~ Not all transmitter modules will work with the rc-switch library. Some of officially supported modules by rc-switch are: SC5262 / SC5272 HX2262 / HX2272 PT2262 / PT2272 EV1527 / RT1527 / FP1527 / HS1527 Intertechno outlets HT6P20X This guide was created using STX882 RF transmitter which also works without issues. Wiring ~ RF ESP data GPIOx + 3.3v/5v - GND Tasmota ~ In the Configuration -> Configure Module page assign: GPIOx to RFSend See RF commands for use. RF Receiver ~ RF receiver is used to capture RF codes. Those codes can be sent using RFSend or used as a rule trigger. Not all transmitter modules will have sufficient power or range for normal use This guide is using SRX882 RF receiver module with a helical antenna. Wiring ~ SRX882 ESP Data GPIOx VCC 5v GND GND CS 3v3 or 5v CS pin needs to be pulled high to put the module in active mode Tasmota ~ In the Configuration -> Configure Module page assign: GPIOx to RFrecv (106) On a captured code RF receiver sends a tele/%topic%/RESULT JSON reponse visible in console: { \"Time\" : \"2019-01-01T00:00:00\" , \"RfReceived\" : { \"Data\" : \"0x7028D5\" , \"Bits\" : 24 , \"Protocol\" : 1 , \"Pulse\" : 238 } }","title":"RF Transceiver"},{"location":"RF-Transceiver/#rf-transmitter","text":"Not all transmitter modules will work with the rc-switch library. Some of officially supported modules by rc-switch are: SC5262 / SC5272 HX2262 / HX2272 PT2262 / PT2272 EV1527 / RT1527 / FP1527 / HS1527 Intertechno outlets HT6P20X This guide was created using STX882 RF transmitter which also works without issues.","title":"RF Transmitter"},{"location":"RF-Transceiver/#wiring","text":"RF ESP data GPIOx + 3.3v/5v - GND","title":"Wiring"},{"location":"RF-Transceiver/#tasmota","text":"In the Configuration -> Configure Module page assign: GPIOx to RFSend See RF commands for use.","title":"Tasmota"},{"location":"RF-Transceiver/#rf-receiver","text":"RF receiver is used to capture RF codes. Those codes can be sent using RFSend or used as a rule trigger. Not all transmitter modules will have sufficient power or range for normal use This guide is using SRX882 RF receiver module with a helical antenna.","title":"RF Receiver"},{"location":"RF-Transceiver/#wiring_1","text":"SRX882 ESP Data GPIOx VCC 5v GND GND CS 3v3 or 5v CS pin needs to be pulled high to put the module in active mode","title":"Wiring"},{"location":"RF-Transceiver/#tasmota_1","text":"In the Configuration -> Configure Module page assign: GPIOx to RFrecv (106) On a captured code RF receiver sends a tele/%topic%/RESULT JSON reponse visible in console: { \"Time\" : \"2019-01-01T00:00:00\" , \"RfReceived\" : { \"Data\" : \"0x7028D5\" , \"Bits\" : 24 , \"Protocol\" : 1 , \"Pulse\" : 238 } }","title":"Tasmota"},{"location":"Range-Extender/","text":"Range Extender ~ This feature allows Tasmota to publish an AP with a dedicated SSID that is then routed to the core WiFi network. This feature is not included in precompiled binaries To use it you must compile your build Create a section in platformio_tasmota_cenv.ini such as the following for an ESP8266: [env:tasmota-rangeextender] monitor_port = /dev/cu.SLAB* upload_port = /dev/cu.SLAB* upload_speed = 921600 build_unflags = ${esp_defaults.build_unflags} build_flags = ${esp82xx_defaults.build_flags} -D FIRMWARE_RANGE_EXTENDER -D USE_WIFI_RANGE_EXTENDER ; adds about 11k to flash size -D USE_WIFI_RANGE_EXTENDER_NAPT ; Optional, adds about 1k to flash size -D PIO_FRAMEWORK_ARDUINO_LWIP2_HIGHER_BANDWIDTH ; required option to use this feature For ESP32 (note this extends the tasmota32idf4 section included in the platformio_tasmota_cenv_sample.ini ): [env:tasmota32-rangeextender] extends = env:tasmota32idf4 build_flags = ${env:tasmota32idf4.build_flags} -D FIRMWARE_TASMOTA32 -D USE_WIFI_RANGE_EXTENDER -D USE_WIFI_RANGE_EXTENDER_NAPT Alternatively, add the following to user_config_override.h (however the PIO_FRAMEWORK_ARDUINO_LWIP2_HIGHER_BANDWIDTH or tasmota32idf4 must still be set as per above): #ifndef USE_WIFI_RANGE_EXTENDER #define USE_WIFI_RANGE_EXTENDER #endif // Optionally, to enable NAT/NAPT #ifndef USE_WIFI_RANGE_EXTENDER_NAPT #undef USE_WIFI_RANGE_EXTENDER_NAPT #endif Overview ~ If you have a Tasmota device at the edge of your WiFi coverage and require a bit more distance, this feature allows you to turn it into a routing WiFi node. Note that this should be considered low bandwidth as the ESP has to process every packet. Additionally, if desired, it can also NAT/NAPT traffic, removing the need for a route on your core router. See below for the pros and cons of each option. Routing (not NAPT) ~ If using routing, you must setup a return route on your \"core\" router for each extender node. Each extender must also have a unique client side IP address range, and a static core side IP address so the core router knows where to send routes. Pros Can access web interface remote devices Lower overhead on the extender device Slightly smaller flash foot print if you choose to disable NAPT Cons More complex to setup, requiring return routes and static IP addressing An example setup using commands to match the above image to route traffic, with an AP name rangeextender and password securepassword would be: RgxSSID rangeextender RgxPassword securepassword RgxAddress 10.99.1.1 RgxSubnet 255.255.255.0 RgxState ON Alternatively, it could also be set in your user_config_override.h with: #define WIFI_RGX_SSID \"rangeextender\" #define WIFI_RGX_PASSWORD \"securepassword\" #define WIFI_RGX_IP_ADDRESS \"10.99.1.1\" #define WIFI_RGX_SUBNETMASK \"255.255.255.0\" #define WIFI_RGX_STATE 1 NAPT defaults to off - however if you needed to disable it, run RgxNAPT OFF . With NAPT ~ If using NAPT, deployment is a lot easier as there is no need for a static IP address, or adding routes to your core router. Also, all extender nodes could have the same \"remote\" IP address range as these addresses never enter into the \"core\" network. Pros Very simple to setup Cons More overhead on the extender device No access to the web interface of the remote devices An example setup using commands to match the above image with NAPT, with an AP name rangeextender and password securepassword would be: RgxSSID rangeextender RgxPassword securepassword RgxAddress 10.99.1.1 RgxSubnet 255.255.255.0 RgxState ON RgxNAPT ON Alternatively, it could also be set in your user_config_override.h with: #define WIFI_RGX_SSID \"rangeextender\" #define WIFI_RGX_PASSWORD \"securepassword\" #define WIFI_RGX_IP_ADDRESS \"10.99.1.1\" #define WIFI_RGX_SUBNETMASK \"255.255.255.0\" #define WIFI_RGX_STATE 1 #define WIFI_RGX_NAPT 1 Commands ~ Command Parameters RgxSSID The SSID of the AP that Tasmota will present for devices to connect to RgxPassword The password for the above SSID RgxAddress The IP address on the AP side, the connection to the \"core\" network IP addressing remains the same (eg: DHCP) RgxSubnet The subnet mask for the AP side, it's recommended to use 255.255.255.0 . The AP will automatically use addresses from this subnet to serve via DHCP to connecting devices RgxState Enable or disable the AP. Note that turning the AP off will cause a reboot RgxNAPT Only available if USE_WIFI_RANGE_EXTENDER_NAPT is enabled. Enable or disable NAPT. Note that turning off NAPT will cause the device to reboot","title":"Wi-Fi Range Extender"},{"location":"Range-Extender/#range-extender","text":"This feature allows Tasmota to publish an AP with a dedicated SSID that is then routed to the core WiFi network. This feature is not included in precompiled binaries To use it you must compile your build Create a section in platformio_tasmota_cenv.ini such as the following for an ESP8266: [env:tasmota-rangeextender] monitor_port = /dev/cu.SLAB* upload_port = /dev/cu.SLAB* upload_speed = 921600 build_unflags = ${esp_defaults.build_unflags} build_flags = ${esp82xx_defaults.build_flags} -D FIRMWARE_RANGE_EXTENDER -D USE_WIFI_RANGE_EXTENDER ; adds about 11k to flash size -D USE_WIFI_RANGE_EXTENDER_NAPT ; Optional, adds about 1k to flash size -D PIO_FRAMEWORK_ARDUINO_LWIP2_HIGHER_BANDWIDTH ; required option to use this feature For ESP32 (note this extends the tasmota32idf4 section included in the platformio_tasmota_cenv_sample.ini ): [env:tasmota32-rangeextender] extends = env:tasmota32idf4 build_flags = ${env:tasmota32idf4.build_flags} -D FIRMWARE_TASMOTA32 -D USE_WIFI_RANGE_EXTENDER -D USE_WIFI_RANGE_EXTENDER_NAPT Alternatively, add the following to user_config_override.h (however the PIO_FRAMEWORK_ARDUINO_LWIP2_HIGHER_BANDWIDTH or tasmota32idf4 must still be set as per above): #ifndef USE_WIFI_RANGE_EXTENDER #define USE_WIFI_RANGE_EXTENDER #endif // Optionally, to enable NAT/NAPT #ifndef USE_WIFI_RANGE_EXTENDER_NAPT #undef USE_WIFI_RANGE_EXTENDER_NAPT #endif","title":"Range Extender"},{"location":"Range-Extender/#overview","text":"If you have a Tasmota device at the edge of your WiFi coverage and require a bit more distance, this feature allows you to turn it into a routing WiFi node. Note that this should be considered low bandwidth as the ESP has to process every packet. Additionally, if desired, it can also NAT/NAPT traffic, removing the need for a route on your core router. See below for the pros and cons of each option.","title":"Overview"},{"location":"Range-Extender/#routing-not-napt","text":"If using routing, you must setup a return route on your \"core\" router for each extender node. Each extender must also have a unique client side IP address range, and a static core side IP address so the core router knows where to send routes. Pros Can access web interface remote devices Lower overhead on the extender device Slightly smaller flash foot print if you choose to disable NAPT Cons More complex to setup, requiring return routes and static IP addressing An example setup using commands to match the above image to route traffic, with an AP name rangeextender and password securepassword would be: RgxSSID rangeextender RgxPassword securepassword RgxAddress 10.99.1.1 RgxSubnet 255.255.255.0 RgxState ON Alternatively, it could also be set in your user_config_override.h with: #define WIFI_RGX_SSID \"rangeextender\" #define WIFI_RGX_PASSWORD \"securepassword\" #define WIFI_RGX_IP_ADDRESS \"10.99.1.1\" #define WIFI_RGX_SUBNETMASK \"255.255.255.0\" #define WIFI_RGX_STATE 1 NAPT defaults to off - however if you needed to disable it, run RgxNAPT OFF .","title":"Routing (not NAPT)"},{"location":"Range-Extender/#with-napt","text":"If using NAPT, deployment is a lot easier as there is no need for a static IP address, or adding routes to your core router. Also, all extender nodes could have the same \"remote\" IP address range as these addresses never enter into the \"core\" network. Pros Very simple to setup Cons More overhead on the extender device No access to the web interface of the remote devices An example setup using commands to match the above image with NAPT, with an AP name rangeextender and password securepassword would be: RgxSSID rangeextender RgxPassword securepassword RgxAddress 10.99.1.1 RgxSubnet 255.255.255.0 RgxState ON RgxNAPT ON Alternatively, it could also be set in your user_config_override.h with: #define WIFI_RGX_SSID \"rangeextender\" #define WIFI_RGX_PASSWORD \"securepassword\" #define WIFI_RGX_IP_ADDRESS \"10.99.1.1\" #define WIFI_RGX_SUBNETMASK \"255.255.255.0\" #define WIFI_RGX_STATE 1 #define WIFI_RGX_NAPT 1","title":"With NAPT"},{"location":"Range-Extender/#commands","text":"Command Parameters RgxSSID The SSID of the AP that Tasmota will present for devices to connect to RgxPassword The password for the above SSID RgxAddress The IP address on the AP side, the connection to the \"core\" network IP addressing remains the same (eg: DHCP) RgxSubnet The subnet mask for the AP side, it's recommended to use 255.255.255.0 . The AP will automatically use addresses from this subnet to serve via DHCP to connecting devices RgxState Enable or disable the AP. Note that turning the AP off will cause a reboot RgxNAPT Only available if USE_WIFI_RANGE_EXTENDER_NAPT is enabled. Enable or disable NAPT. Note that turning off NAPT will cause the device to reboot","title":"Commands"},{"location":"Rule-Cookbook/","text":"","title":"Rule Cookbook"},{"location":"Rules/","text":"Rules expand the functionality of Tasmota with user configurable flexible logic Tasmota provides a Rule feature heavily inspired by the ESPEasy implementation while maintaining a small memory footprint. Automation solutions can be implemented without having to add dedicated code or use external solutions. Rules perform actions based on triggers (e.g., switch state change, temperature threshold, events like system boot, a defined timer elapsing, custom defined events, etc.) They are stored in flash and therefore will survive a reboot. Note Most pre-compiled builds have the Rules feature enabled. If you are >compiling your own firmware, in order to use rules, include #define USE_RULES in user_config_override.h . List of Rules Commands Rule Syntax ~ Rule definition syntax ON < trigger > DO < command > [ ENDON | BREAK ] ON - marks the beginning of a rule <trigger> - what condition needs to occur for the rule to trigger DO - statement marking end of trigger and beginning of command part <command> - command that is executed if the <trigger> condition is met ENDON - marks the end of a rule. It can be followed by another rule. BREAK - marks the end of a rule. BREAK will stop the execution of the remaining rules that follow this rule within the rule set. If a rule that ends with BREAK is triggered, the following rules in that rule set will not be executed. This allows the rules to somewhat simulate an \"IF/ELSE\" statement. Rule sets are defined by using the Rule<x> command. After defining a rule set, you have to enable it (turn it on) using Rule<x> 1 . Similarly you can disable the rule set using Rule<x> 0 . Note If bootloops are detected all rules will be disabled as a precaution. See SetOption36 . There are three separate rule sets called Rule1 , Rule2 and Rule3 . Each rule set can contain many rules. The number of rules that can fit in a rule set varies, but expect at least 1000 characters available per set. Additionally, rules are dynamically compressed, meaning they will be compressed automatically when doing so is required, but left uncompressed until that point. Whenever a rule set is enabled all the rules in it will be active. If the character count of the rules in one set actually exceeds the limit, start using the next rule set. If you have a long list of rules, verify the rules have all fit by inspecting the resulting log. Rules inside a rule set Rule<x> are concatenated and entered as a single statement. Rule < x > ON < trigger1 > DO < command > ENDON ON < trigger2 > DO < command > ENDON ... Spaces after ON , around DO , and before ENDON or BREAK are mandatory. A rule is not case sensitive. Rule Trigger ~ Rule trigger names are derived from the JSON message displayed in the console. Each JSON level (all values enclosed in {...} ) is separated in the trigger with a # . A rule trigger can consist of: [TriggerName]#[ValueName] [TriggerName]#[ValueName][comparison][value] [SensorName]#[ValueName] [SensorName]#[ValueName][comparison][value] Tele-[SensorName]#[ValueName] [TriggerName1]#[TriggerName2]#[ValueName] [TriggerName1]#?#[ValueName] Use ? as a wildcard for a single trigger level. Rule will trigger on [TriggerName]#?#[Value] where ? is any value. Example Rule with a trigger of ZBReceived#?#Power=0 will trigger on {\"ZBReceived\":{\"0x4773\":{\"Power\":0}}} and on {\"ZBReceived\":{\"aqara_switch\":{\"Power\":0}}} both. Note Same trigger may be used in more than one rule. This may be required for some cases of using IF/ELSE since an IF statement cannot be used within a Backlog . Rule Trigger Comparison Operators ~ Operator Function = equal to (used for string comparison) == equal to (used for numerical comparison) > greater than < lesser than != number not equal to (for string see below) >= greater than or equal to <= lesser than or equal to $< string starts with $> string ends with $| string contains $! string is not equal to $^ string do not contains | used for modulo operation with remainder = 0 (exact division) Examples of Available Triggers ~ This is just a sampling of available triggers to showcase what is possible and not a definitive list Trigger When it occurs Analog#A0div10 when the A0 input changes by more than 1% it provides a value between 0 and 100 Button2#State when a button changes state: 0 = OFF 1 = ON 2 = TOGGLE 3 = HOLD Clock#Timer=3 when global Timer3 is activated Dimmer#Boot occurs after Tasmota starts Dimmer#State when the value for Dimmer is changed Event#eventName when command Event eventName is executed. You can define your own event values and trigger them with the Event command. An event with a = will provide a %value% to use in the execution part of the rule. Example: Command Event speed=2 in rule trigger on event#speed will have the %value% of 2 . FanSpeed#Data=3 when the fan speed is set to 3 Mem<x>#State when the value for Mem<x> is changed Http#Initialized Mqtt#Connected when MQTT is connected Mqtt#Disconnected when MQTT is disconnected Power1#Boot Relay1 state before Wi-Fi and MQTT are connected and before Time sync but after PowerOnState is executed. Power#Boot triggers before System#Boot. This trigger's value will be the last state of Relay1 if PowerOnState is set to its default value ( 3 ). Power1#State when a power output is changed use Power1#state=0 and Power1#state=1 for comparison, not =off or =on Power2 for Relay2, etc. Rotary1#Pos1 when rotary encoder change. See Use a rotary encoder . Rules#Timer=<x> when countdown RuleTimer<x> expires (x = 1..8 ). Switch1#Boot occurs after Tasmota starts before it is initializated. Switch1#State when a switch changes to state. Will not trigger if SwitchTopic is set. use Switch1#state=0 and Switch1#state=1 for comparison, not =off or =on 0 = OFF 1 = ON 2 = TOGGLE 3 = HOLD ( SwitchTopic 0 must be set for this to trigger) 4 = INC_DEC (increment or decrement dimmer) 5 = INV (change from increment to decrement dimmer and vice versa) 6 = CLEAR (button released for the time set with SetOption32 ) System#Boot occurs once after Tasmota is fully intialized (after the INFO1, INFO2 and INFO3 console messages). System#Boot triggers after Wi-Fi and MQTT (if enabled) are connected. If you need a trigger prior to every service being initialized, use Power1#Boot System#Init occurs once after restart before Wi-Fi and MQTT are initialized System#Save executed just before a planned restart Time#Initialized once when NTP is initialized and time is in sync Time#Minute every minute Time#Minute|5 every five minutes Time#Minute=241 every day once at 04:01 (241 minutes after midnight) Time#Set every hour when NTP makes time in sync Var<x>#State when the value for Var<x> is changed (triggers whenever a value is written to Var<x> even if its the same value) Wifi#Connected when Wi-Fi is connected Wifi#Disconnected when Wi-Fi is disconnected Tele-Wifi#AP when a teleperiod message is sent with the number of the used AP Tele-Wifi#Ssid when a teleperiod message is sent with the name of the used AP Tele-Wifi#Bssid when a teleperiod message is sent with the name of the bSSID Tele-Wifi#Channel when a teleperiod message is sent with the number of the wifi channel used Tele-Wifi#RSSI when a teleperiod message is sent with the RSSI LEVEL Tele-Wifi#LinkCount when a teleperiod message is sent with the number of wifi disconnections Tele-Wifi#Downtime when a teleperiod message is sent with the total seconds of wifi disconnections Every command with a JSON payload response has an associated rule trigger. Trigger When it occurs <command>#Data A one level JSON payload such as {\"Command\":\"value\"} . For example, for {\"Fanspeed\":3}, the trigger is Fanspeed#Data . <command>#level1#level2#levelN A multi-level JSON payload such as {\"TriggerLevel1\":{\"TriggerLevel2\":{\"ValueName\":\"value\"}}} does NOT have the #Data trigger. Instead, the trigger for these responses is TriggerLevel1#TriggerLevel2#ValueName . When the JSON payload response is produced by a command executed by a rule i.e. on time=120 do status 8 endon , the StatusSNS#Data trigger will not fire unless the command is wrapped in backlog i.e. on time=120 do backlog status 8 endon Example For {\"PulseTime2\":{\"Set\":0,\"Remaining\":0}} , the triggers are PulseTime2#Set and PulseTime2#Remaining .| For a 3 level JSON message such as {\"ZbReceived\":{\"test_switch\":{\"Device\":\"0x0C94\",\"Power\":1,\"Endpoint\":8,\"LinkQuality\":70}}} one possible trigger is ZbReceived#test_switch#Power or another ZbReceived#test_switch#LinkQuality Connected sensors can be a trigger in the form as they are represented in the TelePeriod and Status 8 JSON payloads. Trigger When it occurs DS18B20#Temperature whenever the temperature of sensor DS18B20 changes DS18B20#Temperature<20 whenever the temperature of sensor DS18B20 is below 20 degrees BME280#Humidity==55.5 whenever the humidity of sensor BEM280 equals 55.5% INA219#Current>0.100 whenever the current drawn is more than 0.1A Energy#Power>100 whenever the power used is more than 100W When the payload consists of an array of data eg: ENERGY\":{Current\":[1.320,2.100]} Trigger When it occurs Energy#Current[N] N = Number of the field. 1 for the first 1.320 , 2 for the second 2.100 etc. Energy#Current[1]>1.000 whenever the first value of Energy#Current is higher than 1.000. To trigger only at TelePeriod time, prefix the sensor with the word Tele- . Trigger When it occurs Tele-AM2301#Temperature sensor AM2301 Temperature value when the TelePeriod JSON payload is output Hardware and software serial interface, RF, IR and TuyaMCU are also supported based on their JSON status message: Trigger When it occurs TuyaReceived#Data=<hex_string> whenever <hex_string> is received with TuyaMCU component SerialReceived#Data=<string> whenever <string> is received via hardware serial SSerialReceived#Data=<string> whenever <string> is received via software serial IrReceived#Data=801 whenever an IR signal for a RC5 remote control button 1 is received IrReceived#Data=0x00FF9867 whenever an IR signal with hex code 0x00FF9867 is received RfReceived#RfKey=4 whenever the RF Bridge receives a recognized RfKey 4 signal RfReceived#Data=0xE8329E whenever an RF signal with hex code 0xE8329E is received Rule Command ~ A rule command can be any command listed in the Commands list . The command's <parameter> can be replaced with %value% which will use the value of the trigger. ON Switch1#State DO Power %value% ENDON To accomplish a rule with one trigger but several commands, you need to use Backlog : ON <trigger> DO Backlog <command1>; <command2>; <command3> ENDON Appending new rule onto an existing rule set Use the + character to append a new rule to the rule set. For example: Existing Rule1: ON Rules#Timer=1 DO Mem2 %time% ENDON Rule to append: ON Button1#state DO POWER TOGGLE ENDON Command: Rule1 + ON button1#state DO POWER TOGGLE ENDON Resulting in Rule1 ON Rules # Timer = 1 DO Mem2 % time % ENDON ON Button1 # state DO POWER TOGGLE ENDON You can repeate the same trigger in rules. Rule ON Power2 # state = 1 DO Power1 1 ENDON ON Power2 # state = 1 DO RuleTimer1 100 ENDON Rule Variables ~ There are thirty-two (32) available variables (single precision reals) in Tasmota: Var1..Var16 and Mem1..Mem16 . They provide a means to store the trigger %value% to be used in any rule. All Var will be empty strings when the program starts. The value of all Mem persists after a reboot. The value of a Var<x> and Mem<x> can be: any number any text %var1% to %var16% %mem1% to %mem16% %color% %deviceid% %macaddr% %sunrise% %sunset% %time% %timer1% to %timer16% %timestamp% %topic% %uptime% %utctime% %zbdevice% %zbgroup% %zbcluster% %zbendpoint% To set the value for Var<x> and Mem<x> use the command Var<x> <value> Mem<x> <value> The <value> can also be the value of the trigger of the rule. Set Var2 to the temperature of the AM2301 sensor - ON AM2301#Temperature DO Var2 %value% ENDON Set Var4 to Var2's value - ON Event#temp DO Var4 %Var2% ENDON Set Mem2 to the current time (minutes elapsed since midnight) - ON Rules#Timer=1 DO Mem2 %time% ENDON After a Wi-Fi reconnect event, publish a payload containing timestamps of when Wi-Fi was disconnected in From: and when Wi-Fi re-connected in To: to stat/topic/BLACKOUT . Rule1 ON wifi # disconnected DO Var1 % timestamp % ENDON ON wifi # connected DO Var2 % timestamp % ENDON ON mqtt # connected DO Publish stat / topic / BLACKOUT { \"From\" : \"%Var1%\" , \"To\" : \"%Var2%\" } ENDON Delete rule ~ To clear / delete use double quote(s): Rule1 \" Conditional Rules ~ This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Major features ~ Support IF, ELSEIF, ELSE Support for <comparison> and <logical expression> as condition Support for executing multiple commands Available free RAM is the only limit for logical operators and parenthesis. Grammar ~ <if-statement> IF (<logical-expression>) <statement-list> {ELSEIF (<logical-expression>) <statement-list>} [ELSE <statement-list>] ENDIF (<logical-expression>) Parentheses must enclose the expression. They can also be used to explicitly control the order of evaluation. <comparison-expression> ( <comparison-expression> | <logical-expression> ) {{ AND | OR } <logical-expression> } ( <logical-expression> ) { AND | OR } <logical expression> } <comparison-expression> <expression> { = | < | > | | | == | <= | >= | != } <expression> <statement-list> <statement> { ; <statement> } <statement> { <Tasmota-command> | <if-statement> } Syntax ~ IF statement supports 3 formats: IF (<logical-expression>) <statement-list> ENDIF IF (<logical-expression>) <statement-list> ELSE <statement-list> ENDIF IF (<logical-expression>) <statement-list> [ELSEIF (<logical-expression>) <statement-list> ] ELSE <statement-list> ENDIF When the <if-statement> directly follows the trigger the standard 'Do' syntax applies, however, it is not necessary to use 'Backlog' within the chain Rule1 ON Power1#State DO IF (%value%==1) Backlog Power2 1;Power3 1 ENDIF ENDON is permitted Rule1 ON Power1#State DO IF (%value%==1) Power2 1;Power3 1 ENDIF ENDON is also permitted When the <if-statement> is preceded by other Tasmota commands you should use Backlog along with Do , e.g. Rule1 ON ENERGY#Current>10 DO Backlog Power1 0; IF (%var1%==1) Power1 1 ENDIF;Power 2 0;Power3 1 ENDON and not Rule1 ON ENERGY#Current>10 DO Power1 0; IF (%var1%==1) Power1 1 ENDIF ENDON or Rule1 ON ENERGY#Current>10 Backlog Power1 0; IF (%var1%==1) Power1 1 ENDIF ENDON (<logical-expression>) example: (VAR1>=10) - Multiple comparison expressions with logical operator AND or OR between them. AND has higher priority than OR . For example: ((UPTIME>100) AND (MEM1==1) OR (MEM2==1)) - Parenthesis can be used to change the priority of the logical expression evaluation. For example: ((UPTIME>100) AND ((MEM1==1) OR (MEM2==1))) Following variables can be used in <condition> : Symbol Description VAR<x> variable (<x> = 1..MAX_RULE_VARS , e.g., VAR2 ) MEM<x> persistent variable (<x> = 1..MAX_RULE_MEMS , e.g., MEM3 ) TIME minutes past midnight UPTIME uptime minutes UTCTIME UTC time, UNIX timestamp, seconds since 01/01/1970 LOCALTIME local time, UNIX timestamp SUNRISE current sunrise time (minutes past midnight) SUNSET current sunset time (minutes past midnight) COLOR current color <statement-list> - A Tasmota command (e.g., LedPower on ) - Another IF statement ( IF ... ENDIF ) - Multiple Tasmota commands or IF statements separated by ; . For example: Power1 off; LedPower on; IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on Backlog is implied and is not required (saves rule set buffer space). But not like this: Power1 off; LedPower on; IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on You should split it in two lines like: ON Power2#state=1 DO Power1 off; LedPower on; ENDON ON Power2#state=1 DO IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on ENDON Example Rule used to control pressure cooker with a Sonoff S31. Once it is finished cooking, shut off the power immediately. Rule1 ON system # boot DO var1 0 ENDON ON energy # power > 100 DO if ( var1 != 1 ) ruletimer1 0 ; var1 1 endif ENDON ON tele - energy # power < 50 DO if ( var1 == 1 ) var1 2 ; ruletimer1 600 endif ENDON ON rules # timer = 1 DO Backlog var1 0 ; power off ENDON Expressions in Rules ~ This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Beginning with Tasmota version 6.4.1.14, an optional feature for using mathematical expressions in rules was introduced. Supported Commands ~ Once the feature is enabled, the use of expressions is supported in the following commands: Var Mem RuleTimer If conditional statement (requires #define SUPPORT_IF_STATEMENT ) Syntax ~ Expressions can use of the following operators. They are listed by the order of operations priority, from higher to lower. ( ) (parentheses can be used to explicitly control the order of operations) ^ (power) % (modulo, division by zero returns modulo \"0\") * and / (multiplication and division; division by zero returns \"0\") + and - (addition and subtraction) Example 1+2*2 results in 5.0 as the multiplication is done first due to its higher priority (1+2)*2 results in 6.0 In addition to numeric constants, the following symbolic values can be used: Symbol Description VAR<x> variable (<x> = 1..MAX_RULE_VARS , e.g., VAR2 ) MEM<x> persistent variable (<x> = 1..MAX_RULE_MEMS , e.g., MEM3 ) TIME minutes past midnight UPTIME uptime minutes UTCTIME UTC time, UNIX timestamp, seconds since 01/01/1970 LOCALTIME local time, UNIX timestamp SUNRISE current sunrise time (minutes past midnight) SUNSET current sunset time (minutes past midnight) COLOR current color Example Mem1=((0.5*Var1)+10)*0.7 To use expressions in the Var , Mem and RuleTimer commands, an equal sign ( = ) character has to be used after the command. If not, the traditional syntax interpretation is used. Statement Var1 Result Var1=42 42 Var1 1+1 \"1+1\" (the literal string) Var1=1+1 2 Var1=sunset-sunrise duration of daylight in minutes Rule Cookbook ~ Long press on a switch ~ This example is for GPIOs defined as switches not buttons Activate long press action with Switchmode 5 and shorten long press time to 2 seconds ( Setoption32 20 ). Backlog SwitchMode 5 ; SetOption32 20 Rule ON switch1 # state = 3 DO publish cmnd / tasmota02 / POWER 2 ENDON Long pressing on switch1 sends POWER 2 (toggle action) command to the tasmota02 device Notice we use Rule which edits Rule1 rule set. They can be used interchangeably. If your rule does not trigger there could some constraints, in this case if SwitchTopic has a value it will override rules for switches and will need to be disabled: SwitchTopic 0 . Send MQTT message on button press ~ When a button is pressed the user has the possibility to send a MQTT message based on FullTopic and ButtonTopic. This MQTT message is going to be received by the MQTT broker and if there is any other device(s) subscribed to that Topic, it will receive also that message. So this approach can be used for sending messages/commands to MQTT Broker to Home Automation System, and/or sending messages/commands to MQTT Broker to other device(s). A problem with this solution is that on a Sonoff 4CH all four buttons will be sending the same MQTT topic using only a different Power index number like cmnd/ButtonTopic/Power3 toggle . By using a rule a single button can send any MQTT message allowing for more flexibility. Disable ButtonTopic as it overrides rules for buttons: ButtonTopic 0 Rule ~ Rule1 ON button1 # state DO publish cmnd / ring2 / power % value % ENDON ON button2 # state DO publish cmnd / strip1 / power % value % ENDON You will need to enable this rule if it's the first time you've used rule with Rule1 1 Result ~ When Button1 is pressed the rule kicks in and sends a MQTT message substituting variable %value% with the button state, f.e cmnd/ring2/Power 2 . When Button2 is pressed an MQTT message cmnd/strip1/Power 2 will be sent. Usage of one-shot (once) ~ The rule command once option provides the possibility to trigger only once ON a slow change while the change is still within the bounds of the test. Rule ON ENERGY # Current > 0.100 DO publish tool / tablesaw / power 1 ENDON ON ENERGY # Current < 0.100 DO publish tool / tablesaw / power 0 ENDON This creates a rule to publish MQTT commands whenever a Sonoff POW has current passing through it. Used as is, it will publish MQTT commands repeatedly, over and over, while current is >0.100 ... but, executing another command: Rule 5 Now the MQTT message will be sent once, and only once, while the condition is met. This is perfect for thermostat on/off depending on temperature, bathroom extractor fan on/off depending on humidity, workshop dust collector on/off depending on whether some dust-producing machine is running. It meets the 'hard thermostat' requests that have been common. Use a potentiometer ~ Connecting a potentiometer to the Analog A0 input and a rule can be used to control the dimmer state of any device. Hardware - Wemos D1 mini - Potentiometer of 2k2 connected to Gnd, A0 and 3V3 - WS2812 LED Rule ON analog # a0div10 DO dimmer % value % ENDON Result ~ Turning the potentiometer the voltage on the analog input will change resulting in a value change of 0 (Off) to 100 for the trigger. Using this value to control the dimmer of the WS2812 will control the brightness of the led(s) Rule ON analog # a0div10 DO publish cmnd / grouplight / dimmer % value % ENDON Result This time all lights configured with GroupTopic grouplight will change their brightness according to the potentiometer position. NOTE: You might want to execute command SaveData 2 to reduce flash writes ;-) Use a rotary encoder ~ You can capture in rules the value of a rotary encoder connected to 2 GPIOs configured as Rotary_a|<n> and Rotary_b|<n> . Optionally the button of the rotary encoder can be connected to another GPIO configured as Button|<n> . <n> must be the same to allow the encoder to manage 2 absolute counters from the same rotary encoder. To get triggers from the rotary encoder into rules, you must enable SetOption98 1 . The rotary encoder <n> provides a JSON in the form of {'Rotary<n>': {'Pos1': value, 'Pos2': value}} . You can use the following rules triggers: SetOption98 1 Rule1 ON Rotary1 # Pos1 DO something_with % value % ENDON ON Rotary1 # Pos2 DO something_with % value % ENDON Result ~ Pos1 is changed when the rotary encoder is turned while button is not pressed. Pos2 is changed while button is pressed. Both Pos1 and Pos2 are published whatever is the button position, so both trig at the same time. The button will still have it's default action (such as toggling power). If you want to avoid that, you need to capture the button into a dummy rule such as ON Button1#state DO Delay 0 ENDON . The range of the rotary encoder is hardcoded in #define ROTARY_MAX_STEPS 10 . If you want to change the range, you must change the value in your user_config_override.h and recompile . Use Zigbee to control Tasmota devices ~ This setup uses a Zigbee gateway with an Ikea remote switch paired. Ikea switch's name was set with ZbName to make it more user friendly. Rule ~ Rule1 on zbreceived # ikea_switch # power = 1 do publish cmnd / backyard / POWER TOGGLE endon on zbreceived # ikea_switch # power = 0 do publish cmnd / hall_light / POWER TOGGLE endon Result ~ Pressing I on the Ikea switch will toggle backyard device and pressing O toggles hall_light device. Button single press, double press and hold ~ This example show how to assign different behavior to a button other than Button1 . Button1 has special multi-press behaviors associated with it (see Note in Multi-Press Functions ), examples 1 and 2 cannot be applied to Button1. 1st example: ~ [assuming Button2 (or >2) and Setoption73 0] single press: Toggle Power2 (or >2) double press: send a mqtt message hold 2 secs: send a different mqtt message Backlog ButtonTopic 0 ; SetOption1 1 ; SetOption11 0 ; SetOption32 20 Rule1 ON button2 # state = 3 DO publish cmnd / topicHOLD / power2 2 ENDON ON button2 # state = 2 DO publish cmnd / topicDOUBLEPRESS / power2 2 ENDON Rule1 1 2nd example with Setoption11 1 : ~ [assuming Button2 (or >2) and Setoption73 0] single press: send MQTT message double press: Toggle Power2 (or >2) (SetOption11 swaps single and double press) hold 2 secs: send another mqtt message Backlog ButtonTopic 0 ; SetOption1 1 ; SetOption11 1 ; SetOption32 20 Rule1 ON button2 # state = 3 DO publish cmnd / topicHOLD / power2 2 ENDON ON button2 # state = 2 DO publish cmnd / topicSINGLEPRESS / power2 2 ENDON Rule1 1 3rd example for Button1: ~ For assigning different actions to multi-press on Button1, it is mandatory to detach buttons from their default function using SetOption73 1 . With SetOption73 1 buttons only publish a MQTT message ( stat/tasmota/BUTTON<x> = {\"ACTION\":\"xxxx\"} ). To re-assign a specific action, rules must be used like below: single press: Toggle Power1 double press: send a mqtt message hold 2 secs: send a different mqtt message Backlog ButtonTopic 0 ; SetOption73 1 ; SetOption32 20 Rule1 ON button1 # state = 10 DO power1 2 ENDON ON button1 # state = 3 DO publish cmnd / topicHOLD / power 2 ENDON ON button1 # state = 11 DO publish cmnd / topicDOUBLEPRESS / power 2 ENDON Rule1 1 Note SetOption73 1 detaches ALL buttons. If you have more than 1 button, you must create rules for each buttons where you want an action (other than publishing stat/tasmota/BUTTON<x> = {\"ACTION\":\"xxxx\"} ) Disable switch single press and use long press ~ SetOption11 0 Switches do not have double press feature [assuming a connected pushbutton configured as Switch1] single press: Does nothing (empty Delay commands) hold 2 secs: Toggle Power1 Backlog SwitchTopic1 0 ; SwitchMode1 5 ; SetOption32 20 Rule1 ON Switch1 # State = 3 DO Power1 2 ENDON ON Switch1 # State = 2 DO Delay ENDON Rule1 1 Execute several commands when a Timer expires ~ The default Timer1..16 functionality allows for controlling one output to either off, on, toggle or blink. When rules are enabled the blink option will be replaced by rule functionality allowing much more flexibility. Configure timer5 for rule execution when activated: Timer5 { \"Enable\" : 1 , \"Mode\" : 0 , \"Time\" : \"16:00\" , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Action\" : 3 } Rule ~ Rule1 ON clock # Timer = 5 DO Backlog Power2 on ; Power1 off ; Power3 2 ENDON Result ~ When the timer expires the rule kicks in and set Power1 to OFF, Power2 to ON and Power3 TOGGLE. If you want to have blink functionality define a rule like ON clock#Timer=5 DO power 3 ENDON Setting variables ~ Demonstrate the use of variables. Make sure to execute commands Rule 4 (Disable one-shot detection) first when trying the following example. Set a variable Rule ON event # setvar1 DO var1 % value % ENDON Command: event setvar1=1 View a variable rule ON event # getvar1 DO var1 ENDON Command: event getvar1 Toggle a variable Rule ON event # togglevar1 DO event toggling1 =% var1 % ENDON ON event # toggling1 < 1 DO event setvar1 = 1 ENDON ON event # toggling1 > 0 DO event setvar1 = 0 ENDON ON event # setvar1 DO var1 % value % ENDON Command: event togglevar1 Show Messages: Rule ON event # message DO publish stat / [ topic ] / log % value % ENDON Command: event message=INIT All event commands can be executed from: console: event anyname=number mqtt: cmnd/[topic]/event anyname=number Everything together: Rule1 ON event # togglevar1 DO event toggling1 =% var1 % ENDON ON event # toggling1 < 1 DO event setvar1 = 1 ENDON ON event # toggling1 > 0 DO event setvar1 = 0 ENDON ON event # setvar1 DO var1 % value % ENDON ON event # getvar1 DO var1 ENDON ON event # message DO publish stat / mqttTopic / log % value % ENDON The following won't work: Rule1 ON event#setvar1 DO Backlog var1 %value%; Power1 %var1% ENDON At least not as you probably would expect. The var1 value used by the Power1 command will be the value present before the Backlog command is executed. This is so, because the rule will replace %var1% BEFORE the Backlog commands are put in the Backlog command stream. Time-delayed Auto-off Switch ~ Rule ~ Rule1 ON button1 # state DO Backlog Power1 % value % ; RuleTimer1 600 ENDON ON Rules # Timer = 1 DO Power1 off ENDON Result ~ on button1#state do Backlog Power1 %value%; On Button press the Light will toggle on/off RuleTimer1 600 ENDON Additionally RuleTimer1 will begin to countdown 10 minutes ON Rules#Timer=1 DO Power1 off ENDON After the RuleTimer1 expires the light will be turned off (if you forgot to turn it off) Time-delay After Switch Off ~ Rule ~ Backlog switchmode1 1 ; rule1 1 Rule1 ON switch1 # state = 1 DO Backlog Power1 on ; ruletimer1 0 ENDON ON switch1 # state = 0 DO ruletimer1 300 ENDON ON rules # timer = 1 DO Power1 0 ENDON Result ~ ruletimer1 300 sets a 5 minute timer. After that time, fan will be switched off. If during the defined 5 minutes (or in general - when timer is counting) you the switch on, the timer will be canceled. switchmode1 1 sets the switch in follow mode (LOW=off, HIGH=on) If you have inverted switch (LOW=on, HIGH=off) then use switchmode1 2 Auto-off Motion Sense Switch ~ Example works fine on a Wemos D1 Mini. Used as night light with motion sensor or as ambient light on floor or kitchen. Connect an LED Strip WS2812 on D1 and the PIR on D2 and a LDR on A0 (voltage divider with 10k ohm resistor) SwitchMode1 1 Rule ~ Rule1 ON analog # a0 < 400 DO Backlog Rule3 0 ; Rule2 1 ENDON ON analog # a0 > 500 DO Backlog Rule2 0 ; Rule3 1 ENDON Rule2 ON switch1 # state DO Backlog Power1 1 ; RuleTimer1 30 ENDON ON Rules # Timer = 1 DO Power1 off ENDON Rule3 ON switch1 # state DO Power1 off ENDON Activate Rule1 with one shot detection Backlog Rule1 1; Rule1 6 Optional Backlog Rule2 4; Rule3 4 Result ~ on analog#a0>400 disable Rule3 and activate Rule2 on analog#a0>500 disable Rule2 and activate Rule3 Rule2 activates the LEDs for RuleTimer1 30 seconds on each trigger from PIR the RuleTimer start again. on Rules#Timer=1 do Power1 off The LEDs turn off after the RuleTimer expires Rule3 is active on daylight and pipe the PIR signal in a Power1 off signal. The LEDs stay off. Control Timers from a Switch ~ Assuming that your switch is on GPIO00 and configured as Switch1 : Switchmode1 1 will make Switch1#state be 1 when ON and 0 when OFF If you don't set Switchmode1 or it is equal 0, it will only have Switch1#state=2 (toggle) and the rule will not work. Rule ~ Rule1 ON Switch1 # state = 1 DO Timers 0 ENDON ON Switch1 # state = 0 DO Timers 1 ENDON Toggle Relay when holding button for 2 seconds ~ The following example is to explain how to catch and use the HOLD feature for buttons. Behavior: Disable Button1 Short Press and Toggle Relay1 only when holding button1 for 2 Seconds. Backlog ButtonTopic 0 ; SetOption1 1 ; SetOption32 20 Rule1 ON button1 # state = 3 DO Power1 2 ENDON ON button1 # state = 2 DO delay ENDON Rule1 1 Commands Explanation ButtonTopic 0 : (default) To not use topics for buttons SetOption1 1 : Allow only single, double and hold press button actions SetOption32 20 : Set key hold time from 0.1 to 10 seconds (20 = 2 seconds) Rule ON button1#state=3 DO Power1 2 ENDON : When holding the button1 for 2 seconds it will toggle relay 1 (state = 3 means HOLD) ON button1#state=2 DO delay ENDON : Do nothing when short pressing the button1 (state = 2 means TOGGLE) Rule1 1 : To enable rules NOTE: There is no state value for \"double press\" for Buttons. It is designed that double press will toggle the relay. See Multi-Press Functions for more information. In the case you do not want the double press feature you can configure your button as switch and also set SwitchMode that fits your use case (such as SwitchMode 5 to make the switch behave like a pushbutton) [SWITCH does not support double press] Another example but using switch instead of button: Backlog SwitchTopic1 0 ; SwitchMode1 5 ; SetOption32 20 Rule1 ON switch1 # state = 3 DO Power1 2 ENDON ON switch1 # state = 2 DO delay ENDON Rule1 1 Make sure Light is on at night ~ Using Timers, you can set a light to turn on and off to illuminate a street/patio by night. But if the device has no power at the trigger time, then, when it powers up, the light will be off all night. So, as a fail-safe, implement a conditional control to be checked at Tasmota Startup. Set Timers to turn on your light at Sunset and Turn off at sunrise. Use poweronstate 0 in order to start with lights off when powering up your device. Set the following rules: Rule1 ON Time # Initialized DO Backlog event checksunrise =% time % ; event checksunset =% time % ENDON ON event # checksunset >% sunset % DO Power1 1 ENDON ON event # checksunrise <% sunrise % DO Power1 1 ENDON The previous rules are conditionals that represent the following logic: IF %time%>%sunset DO Power1 1 / IF %time%<%sunrise DO Power1 1 Turn On Light Before Dawn and At Dusk ~ Turn on light at dusk until your nighttime and again in the morning before dawn. What if the sun sets after your nighttime, as in during the summer? Then the timer will turn off the light at \"night\", but then the Sunset timer will turn it on again, so it stays on all night. Rule ~ Rule1 ON Time # Initialized DO event chkSun ENDON ON Time # Minute =% sunset % DO event chkSun ENDON ON Time # Minute =% mem2 % DO event chkSun ENDON ON Time # Minute =% sunrise % DO event chkSun ENDON ON Time # Minute =% mem1 % DO event chkSun ENDON Rule2 ON event # chkSun DO Backlog var1 0 ; event chkSunrise =% time % ; event chkSunset =% time % ; event chkmorn =% time % ; event chknight =% time % ; event setPower ENDON ON event # chkSunrise <% sunrise % DO var1 1 ENDON ON event # chkSunset >=% sunset % DO var1 1 ENDON ON event # chkmorn <% mem1 % DO var1 0 ENDON ON event # chknight >=% mem2 % DO var1 0 ENDON ON event # setPower DO Power1 % var1 % ENDON Backlog mem1 360 ; mem2 1350 ; Rule1 1 ; Rule2 1 Result ~ When device restarts, calculate if the light should be on or off ON Time#Initialized DO event chkSun ENDON Calculate if the light should be on or off ON Time#Minute=%sunset% DO event chkSun ENDON ON Time#Minute=%mem2% DO event chkSun ENDON ON Time#Minute=%sunrise% DO event chkSun ENDON ON Time#Minute=%mem1% DO event chkSun ENDON Calculate if the light should be on or off on event#chkSun do Backlog Assume off var1 0; Trigger each event with the current time event chkSunrise=%time%; event chkSunset=%time%; event chkmorn=%time%; event chknight=%time%; event setPower End rule ENDON If before sunrise, turn on ON event#chkSunrise<%sunrise% DO var1 1 ENDON If past sunset, turn on ON event#chkSunset>=%sunset% DO var1 1 ENDON But if before Morning time ( mem1 ), do not turn on ON event#chkmorn<%mem1% DO var1 0 ENDON Or if after Night time ( mem2 ), do not turn on ON event#chknight>=%mem2% DO var1 0 ENDON Perform on/off state ON event#setPower DO Power1 %var1% ENDON Set variables for Morning (06h00) and Night (22h30) times Backlog mem1 360; mem2 1350 Turn on the rule sets Backlog Rule1 1; Rule2 1 Enable a PIR Switch only at night ~ Latitude and Longitude need to be set in config. Use PulseTime to specify the duration the light should remains on. Every PIR trigger will restart for that amount of time. SwitchMode1 14 PulseTime 60 Rule1 ON Switch1 # state = 1 DO Backlog event checksunrise =% time % ; event checksunset =% time % ENDON ON event # checksunrise <% sunrise % DO Power1 1 ENDON ON event # checksunset >% sunset % DO Power1 1 ENDON Control luminance switch with Timer ~ Background: Tasmota powers a Sonoff Basic attached to a TS-2561 Luminance Sensor. This switch toggles a lamp ON or OFF. The switch should work as below: i) during daytime (sunrise-sunset): ON when it is too dark (<150 lx) and OFF when it gets brighter (>175 lx). ii) during evenings it ignores the sensor and turns on at sunset and turns off after about 5 hours Approach: Used a combination of Clock Timers and Rule to do this. Timer 1: Power ON switch at Sunset Powers on the switch at sunset with an offset of 20 minutes. Repeats every day. Timer1 { \"Enable\" : 1 , \"Mode\" : 2 , \"Time\" : \"-00:20\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Timer 2: Power OFF switch at Night. Turns power OFF at 23.00hrs. Repeats every day. Timer2 { \"Enable\" : 1 , \"Mode\" : 0 , \"Time\" : \"23:00\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 0 } Timer 3: Trigger Luminance Rule at Sunrise Start watching the Lux sensor 15 minutes after sunrise. Timer3 { \"Enable\" : 1 , \"Mode\" : 1 , \"Time\" : \"00:15\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 3 } Rule 1: Main Rule to check Luminance If Luminance is less than 150lx, power ON. If it goes beyond 175lx, power OFF. Rule1 ON tele - TSL2561 # Illuminance < 150 DO Power1 1 ENDON ON tele - TSL2561 # Illuminance > 175 DO Power1 0 ENDON Rule1 1 ``` haskell ** Rule 2 :** Trigger Rule1 only in the Mornings This ensures that Rule1 is triggered when Timer3 starts ( in the morning ) and stops when Timer1 starts ( in the evenings ) . ``` haskell Rule2 ON Clock # Timer = 3 DO Rule1 1 ENDON ON Clock # Timer = 1 DO Rule1 0 ENDON Rule2 1 Automatically vary the color temperature of a CCT light ~ Background: Tasmota powers a CCT light which is adjustable from cool white to warm white. You want the color temperature to automatically vary between cool (CT=153) at midday to warm (CT=500) at midnight. Approach: Check that your timezone and DST (if applicable) are set correctly and the time is correctly set on your light using NTP. Create the two rules to scale the CT based on the time of day. If Wifi is unavailable or NTP can't determine the time of day then the light will default to the mid point for neutral white (CT=326). Adjusting the CT will switch the light on so Rule 2 disables and enables Rule 1 according to the state of the light. Rule 1: Set the CT according to the time of day. rule1 on Power1 # Boot do CT 326 endon on Time # Initialized do backlog event myCT =% time % endon on Time # Minute do backlog event myCT =% time % endon on event # myCT <= 720 do backlog scale1 % time % , 0 , 720 , 500 , 153 ; event updateCT endon on event # myCT > 720 do backlog scale1 % time % , 720 , 1440 , 153 , 500 ; event updateCT endon on event # updateCT do CT % var1 % endon rule1 1 Rule 2: Toggle rule 1 on and off with the light and also update the CT for the current time when the light is switched on. Rule2 on Power1 # State do backlog Rule1 % value % ; event myCT =% time % endon Rule2 1 Notes: When the light is powered up on it should change to neutral white for a few seconds while Wifi, MQTT and NTP are initialised then switch to the correct color temperature for the time of day. If the light is switched off in software then it will come back on with the previous CT then update to the current CT after a few seconds. If you have a RGBCCT light then the CT light may be Power2 rather than Power1. It is possible to use %sunrise% and %sunset% to adjust the CT if you set your latitude, longitude and elevation but it's much more complex especially at extreme Northern and Southern latitudes. Perform any action on single/double press (for switches AND buttons) ~ Rule ~ SwitchMode 5 Rule1 ON switch1 # state == 2 DO add1 1 ENDON ON switch1 # state == 2 DO Power1 2 ENDON ON var1 # state != 0 DO Backlog delay 6 ; var1 0 ENDON ON var1 # state == 2 DO publish cmnd / othertasmota / POWER toggle ENDON Rule1 on Result ~ each toggle of the switch triggers first condition and adds 1 to our variable (var1 in the example), each toggle of the switch toggles the associated relay ( Power1 2 - but can do anything else instead, Publish for example) when var1 changes to non zero, we set it back to 0 but after a Delay (arbitrarily chosen 6 here - 0.6 seconds) when var1 reaches 2 (i.e. the switch has been toggled twice within the last 0.6 seconds), desired action is triggered (here: Publish to othertasmota ) Every time you press the switch, your light toggles state (as it should). If you do press the switch twice in a rapid succession (i.e., double-click), you can trigger a different action (e.g., on a remote device). Enable or disable relay with a switch in Domoticz ~ When you want to send MQTT messages ( we use domoticz in this example ) and choose when you want the relay on or off, by simply sending HTTP commands to trigger an event. Initial Config: PushButton Doorbell (Sonoff Basic R1) GPIO14 - Switch4 (12) Connect the Switch to GND and the GPIO on your device. Be sure put a 4.7k resistor between VCC(3.3v) and the GPIO. This prevents ghost switching (capacitor is optional) See: YouTube Dont forget to change the IDX value Commands: Backlog SwitchTopic 0 ; SwitchMode4 2 ; SetOption0 0 ; PowerOnState 0 var1 1 Rule1 ON event # doorbell DO var1 % value % ENDON ON switch4 # state = 1 DO publish domoticz / in { \"idx\" : 11 , \"nvalue\" : 1 } ENDON ON switch4 # state = 1 DO Power1 % var1 % ENDON ON switch4 # state = 0 DO publish domoticz / in { \"idx\" : 11 , \"nvalue\" : 0 } ENDON ON switch4 # state = 0 DO Power1 0 ENDON Rule1 1 Usage: Turn off the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=0 Turn on the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=1 If your Tasmota device is password protected, which is most common, then use the following HTTP commands instead. Make sure you change <tasmotaUsername> and <tasmotaPassword> Off: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=0 On: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=1 Force automatic re-connection to MQTT server via SD DNS ~ In order to search for the MQTT server using SD-DNS service (a.k.a. Bonjour or Zero Network Configuration) the suggested configuration is to leave the MQTT Host field blank. The standard behavior of Tasmota is searches for _mqtt._tcp service resolve that to the proper IP address connect to it in case the connection is successful, retain the IP address and use that in the subsequent connections The above is not proper, though, in case you have a redundant MQTT (e.g., two MQTT server synchronized). In such case, when the active MQTT fails for any reason, the expected behavior is to achieve automatic re-connection to the other MQTT server. That can be easily configured defining the following rule on the device console: Rule1 ON Mqtt # Disconnected DO MqttHost 0 ENDON Rule1 1 If the MqttHost field already contains an IP, you have to delete it using the web interface or the following MQTT command: mosquitto_pub -h mqtt_server.local -t \"cmnd/mqttTopic/MqttHost\" -m '' Change distance to percentage ~ When measuring distance and you have the need to see it in percentage of distance. In the example 100% is everything below 69cm and 0% is everything above 128cm. This is used for showing fill percentage of a wood pellets storage. Rule1 ON tele - SR04 # distance DO Backlog var1 % value % ; event checklimit =% value % ; event senddistance ENDON ON event # checklimit > 128 DO var1 128 ENDON ON event # checklimit < 69 DO var1 68 ENDON ON event # senddistance DO Backlog SCALE1 % var1 % , 128 , 69 , 0 , 100 ; event pubdata ENDON ON event # pubdata DO publish tele / pannrum - temp / SENSOR % var1 % ENDON Rule1 1 Distinguish Switch1 and Switch2 (without the use of Relay1 and Relay2) ~ When two (or more) switches are defined as input and you want to distinguish these in the RESULT topic without the use of Relays, then consider the following rules. SwitchMode1 1 will make Switch1#state to be 1 when ON and 0 when OFF SwitchMode1 1 SwitchMode2 1 will make Switch2#state to be 1 when ON and 0 when OFF SwitchMode2 1 Publish json with key POWER1 and value %value% Rule1 ON switch1 # state DO publish stat / wemos - 4 / RESULT { \"POWER1\" : \"%value%\" } ENDON Publish json with key POWER2 and value %value% Rule2 ON switch2 # state DO publish stat / wemos - 4 / RESULT { \"POWER2\" : \"%value%\" } ENDON Enable Rules Backlog Rule1 1; Rule2 1 Output: RUL: SWITCH1#STATE performs \"publish stat/wemos-4/RESULT {\"POWER1\":\"1\"}\" MQT: stat/wemos-4/RESULT = {\"POWER1\":\"1\"} RUL: SWITCH2#STATE performs \"publish stat/wemos-4/RESULT {\"POWER2\":\"1\"}\" MQT: stat/wemos-4/RESULT = {\"POWER2\":\"1\"} RUL: SWITCH1#STATE performs \"publish stat/wemos-4/RESULT {\"POWER1\":\"0\"}\" MQT: stat/wemos-4/RESULT = {\"POWER1\":\"0\"} RUL: SWITCH2#STATE performs \"publish stat/wemos-4/RESULT {\"POWER2\":\"0\"}\" MQT: stat/wemos-4/RESULT = {\"POWER2\":\"0\"} RUL: SWITCH1#STATE performs \"publish stat/wemos-4/RESULT {\"POWER1\":\"1\"}\" MQT: stat/wemos-4/RESULT = {\"POWER1\":\"1\"} RUL: SWITCH1#STATE performs \"publish stat/wemos-4/RESULT {\"POWER1\":\"0\"}\" MQT: stat/wemos-4/RESULT = {\"POWER1\":\"0\"} Receiving state of anything that triggers SWITCH more than one time ~ With analog intercom doorbells you can take out info about ringing from speaker voltage. You can connect GPIO to it via opto-isolator and resistor to take out state. But even with those speaker voltage is dropping so it switches the device multiple times. MQT: cmnd/doorbell/POWER2 = OFF (retained) MQT: cmnd/doorbell/POWER2 = ON (retained) MQT: cmnd/doorbell/POWER2 = OFF (retained) MQT: cmnd/doorbell/POWER2 = ON (retained) MQT: cmnd/doorbell/POWER2 = OFF (retained) To solve it we can use rules. SwitchTopic 0 Rule1 on System # Boot DO var1 0 ENDON ON Switch2 # State DO Backlog add1 1 ; event START ENDON ON event # START DO event BELL =% var1 % ENDON ON event # BELL = 1.000 DO Backlog publish cmnd / bell / power on ; RuleTimer1 60 ENDON ON event # BELL = 0 DO publish cmnd / bell / power off ENDON ON Rules # Timer = 1 DO Backlog var1 0 ; event BELL = 0 ENDON Rule1 1 description: Disable SwitchTopic as it overrides rules for switches: SwitchTopic 0 on system boot set var1 to 0 on switch2 click (person pushing doorbell) - var1 += 1; trigger event START on START - set event BELL equal to var1 if event#BELL=1 (triggered first time) publish mqtt message ON and trigger RulesTimer1 for 60 seconds if event#BELL=0 publish mqtt message OFF on RulesTimer1 - reset var1 to 0, and call event#BELL. enable rule 1 In this case we have lock for 60 seconds for multiple people calls or to be resistant for speaker voltage drops. Prevent Wemos D1 mini load overcurrent ~ As a WS2812 24 led ring draws approximately 24x3x20 mA = 1.44A and the Wemos D1 mini powered from a PC's USB port can only provide up to 0.5A it would be nice to have some kind of mechanism in place to limit the amount of current to the WS2812 LEDring to 0.1A. This is still enough to light all 24 leds up to color 202020. Hardware Wemos D1 mini INA219 I 2 C sensor WS2812 LEDring with 24 LEDs powered by the Wemos D1 mini 5V thru the INA219 sensor Rule1 ON INA219 # Current > 0.100 DO Backlog Dimmer 10 ; Color 10 , 0 , 0 ENDON Rule1 on Result - When a user raises brightness to a level using more than 0.1A the rule kicks in and lowers the current by executing command Dimmer 10 and changes the color to Red with command Color 10,0,0 . Using dummy GPIO to send Serial codes to an MCU ~ By having a device that controls all its features through an MCU and reports the states in serial codes to the ESP8266 we have to create some rules to control it using the Web UI or standard Power commands. Rule1 ON Power1 # state = 1 DO serialsend5 55 AA00060005020400010213 ENDON ON Power1 # state = 0 DO serialsend5 55 AA00060005020400010011 ENDON ON Power2 # state = 1 DO serialsend5 55 AA00060005060400010217 ENDON ON Power2 # state = 0 DO serialsend5 55 AA00060005060400010015 ENDON Power1 controls the device, Power2 turn on and off the light on the device. Another rule was created to issue commands on boot so the serial interface works every time and to control the built in fan using Event triggers and have its state retained in an MQTT message for Home Assistant. Rule2 ON system # boot DO Backlog baudrate 9600 ; seriallog 2 ; serialsend5 55 aa000300010306 ENDON ON event # high DO Backlog serialsend5 55 AA00060005650400010175 ; publish2 stat / diffuser / FAN high ENDON ON event # low DO Backlog serialsend5 55 AA00060005650400010074 ; publish2 stat / diffuser / FAN low ENDON Arithmetic commands used with VAR ~ ADD ~ ADD1 to ADD5 : Add a value to VARx Syntax: ADDx value Usage: ADD1 15 Result: VAR1 = VAR1 + 15 SUBTRACT ~ SUB1 to SUB5 : Subtract a value from VARx Syntax: SUBx value Usage: SUB1 15 Result: VAR1 = VAR1 - 15 MULTIPLY ~ MULT1 to MULT5 : Multiply a value to VARx Syntax: MULTx value Usage: MULT1 15 Result: VAR1 = VAR1 * 15 SCALE A VALUE ~ SCALE1 to SCALE5 : Scale a value from a low and high limit to another low and high limit and store it in VARx (directly equivalent to MAP arduino command) Syntax: SCALEx value, fromLow, fromHigh, toLow, toHigh where, value : the number to scale fromLow : the lower bound of the value\u2019s current range fromHigh : the upper bound of the value\u2019s current range toLow : the lower bound of the value\u2019s target range toHigh : the upper bound of the value\u2019s target range (omitted values are taken as zero) Usage: SCALE1 15, 0, 100, 0, 1000 Result: VAR1 = 150 Transmit sensor value only when a delta is reached ~ Send only when the sensor value changes by a certain amount. Rule1 ON SI7021 # temperature >% var1 % DO Backlog var1 % value % ; publish stat / mqttTopic / temp % value % ; var2 % value % ; add1 2 ; sub2 2 ENDON ON SI7021 # temperature <% var2 % DO Backlog var2 % value % ; publish stat / mqttTopic / temp % value % ; var1 % value % ; add1 2 ; sub2 2 ENDON This example explains expands on the above example while matching typical sensor data. Helpful for HA tasmota integration sensors when polling and adding in delta value changes. Normal polling data below 23 : 58 : 41 MQT: tele / ds1820 / SENSOR = { \"Time\" : \"2021-01-13T23:58:41\" , \"DS18B20\" : { \"Id\" : \"030597946B04\" , \"Temperature\" : 20.9 }, \"TempUnit\" : \"C\" } The matching rule. Rule1 ON DS18B20 # temperature >% var1 % DO Backlog var1 % value % ; publish tele / ds1820 / SENSOR { \"Time\" : \"%timestamp%\" , \"DS18B20\" : { \"Id\" : \"030597946B04\" , \"Temperature\" :% value % }, \"TempUnit\" : \"C\" }; var2 % value % ; add1 0.5 ; sub2 0.5 ENDON ON DS18B20 # temperature <% var2 % DO Backlog var2 % value % ; publish tele / ds1820 / SENSOR { \"Time\" : \"%TIMESTAMP%\" , \"DS18B20\" : { \"Id\" : \"030597946B04\" , \"Temperature\" :% value % }, \"TempUnit\" : \"C\" }; var1 % value % ; add1 0.5 ; sub2 0.5 ENDON Adjust a value and send it over MQTT ~ This example adds 2 degrees to the measured temperature and then sends that value to an MQTT topic. Rule1 ON tele - SI7021 # temperature DO Backlog var1 % value % ; add1 2 ; event sendtemp ENDON ON event # sendtemp DO publish stat / mqttTopic / temp % var1 % ENDON Control relays via serial ~ This example switches connected relays over the software serial on and off. Write the following rules: rule1 ON SSerialReceived # Data = on DO Power1 1 ENDON ON SSerialReceived # Data = off DO Power1 0 ENDON receiving on and off results in MQT: tele/mqttTopic/RESULT = {\"SSerialReceived\":\"on\"} RUL: SSERIALRECEIVED#DATA=ON performs \"Power1 1\" MQT: stat/mqttTopic/RESULT = {\"POWER\":\"ON\"} MQT: stat/mqttTopic/POWER = ON MQT: tele/mqttTopic/RESULT = {\"SSerialReceived\":\"off\"} RUL: SSERIALRECEIVED#DATA=OFF performs \"Power1 0\" MQT: stat/mqttTopic/RESULT = {\"POWER\":\"OFF\"} MQT: stat/mqttTopic/POWER = OFF Processing JSON received from (Software)SerialBridge ~ When using SerialBridge (or SoftwareSerialBrigde) , the received string will be published to Rules as SerialReceived (or SSerialReceived) . If the string starts with a { then Tasmota will parse the string as a JSON and make the different keys available for Rules. For example with the following string {\"DeviceID\":\"TM182\",\"Temp\":25.3,\"Hum\":50} , it is possible to use any of the keys in the trigger. rule1 ON SSerialReceived#DeviceID DO var1 %value% ENDON ON SSerialReceived#Temp DO var2 %value% ENDON ON SSerialReceived#Hum DO publish /some/topic/%var1% {\"Temperature\":%var2%,\"Humidity\":%value%} ENDON The 1st and 2nd rules store the values for Device and Temp into variables. The last key triggers the 3rd rule, here re-publication on a different topic. Execution: 12:51:48.050 MQT: tele/nodemcu/SSERIALRECEIVED = {\"SSerialReceived\":{\"DeviceID\":\"TM182\",\"Temp\":25.3,\"Hum\":50}} 12:51:48.064 RUL: SSERIALRECEIVED#DEVICEID performs \"var1 TM182\" 12:51:48.071 MQT: stat/nodemcu/VAR = {\"Var1\":\"TM182\"} 12:51:48.083 RUL: SSERIALRECEIVED#TEMP performs \"var2 25.3\" 12:51:48.091 MQT: stat/nodemcu/VAR = {\"Var2\":\"25.3\"} 12:51:48.104 RUL: SSERIALRECEIVED#HUM performs \"publish /some/topic/TM182 {\"Temperature\":25.3,\"Humidity\":50}\" 12:51:48.110 MQT: /some/topic/TM182 = {\"Temperature\":25.3,\"Humidity\":50} Note It is important that the receive string strictly starts with the opening { . If other characters, such as spaces or new line are inserted before, Tasmota will not par as a JSON. Characters after the closing } are not a problem. Using BREAK to simulate IF..ELSEIF..ELSE..ENDIF ~ BREAK is an alternative to ENDON . BREAK will stop the execution for the triggers that follow. If a trigger that ends with BREAK fires, then the following triggers of that rule will not be executed. This allows to simulate IF..ELSEIF..ELSE..ENDIF Example: IF temp > 85 then VAR1 more85 ELSEIF temp > 83 then VAR1 more83 ELSEIF temp > 81 then VAR1 more81 ELSEIF temp = 81 then VAR1 equal81 ELSE VAR1 less81 ENDIF With the actual rules, if we use a set like the following: Rule1 ON event # temp > 85 DO VAR1 more85 ENDON ON event # temp > 83 DO VAR1 more83 ENDON ON event # temp > 81 DO VAR1 more81 ENDON ON event # temp = 81 DO VAR1 equal81 ENDON ON event # temp < 81 DO VAR1 less81 ENDON This is the output in the console: CMD: rule MQT: stat/living/RESULT = {\"Rule1\":\"ON\",\"Once\":\"ON\",\"StopOnError\":\"OFF\",\"Free\":322,\"Rules\":\"ON event#temp>85 do VAR1 more85 ENDON ON event#temp>83 do VAR1 more83 ENDON on event#temp>81 do VAR1 more81 ENDON on event#temp=81 do VAR1 equal81 ENDON on event#temp<81 DO VAR1 less81 ENDON\"} CMD: event temp=10 MQT: stat/living/RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP<81 performs \"VAR1 less81\" MQT: stat/living/RESULT = {\"Var1\":\"less81\"} CMD: event temp=100 MQT: stat/living/RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP>85 performs \"VAR1 more85\" MQT: stat/living/RESULT = {\"Var1\":\"more85\"} RUL: EVENT#TEMP>83 performs \"VAR1 more83\" MQT: stat/living/RESULT = {\"Var1\":\"more83\"} RUL: EVENT#TEMP>81 performs \"VAR1 more81\" MQT: stat/living/RESULT = {\"Var1\":\"more81\"} So, all the triggers where TEMP>100, are firing. With the BREAK statement the rule set can be changed to: Rule on event # temp > 85 do VAR1 more85 break on event # temp > 83 do VAR1 more83 break ON event # temp > 81 DO VAR1 more81 ENDON ON event # temp = 81 DO VAR1 equal81 ENDON ON event # temp < 81 DO VAR1 less81 ENDON Which will result in the following output: CMD: rule RSL: RESULT = {\"Rule1\":\"ON\",\"Once\":\"OFF\",\"StopOnError\":\"OFF\",\"Free\":321,\"Rules\":\"ON event#temp>85 do VAR1 more85 break ON event#temp>83 do VAR1 more83 break on event#temp>81 do VAR1 more81 ENDON on event#temp=81 do VAR1 equal81 ENDON on event#temp<81 DO VAR1 less81 ENDON\"} CMD: event temp=10 RSL: RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP<81 performs \"VAR1 less81\" RSL: RESULT = {\"Var1\":\"less81\"} CMD: event temp=100 RSL: RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP>85 performs \"VAR1 more85\" RSL: RESULT = {\"Var1\":\"more85\"} CMD: event temp=83 RSL: RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP>81 performs \"VAR1 more81\" RSL: RESULT = {\"Var1\":\"more81\"} Adjust PowerDelta according to current Power values ~ Power sensor reporting thresholds are set by a percentage change in the Power value by setting PowerDelta . Power changes from 10W to 11W (10%) may not be very interesting. But power changes from 1000W to 1100W (also 10%) could be very important. To avoid getting reports for small changes but ensuring that larger power swings are reported, a rule set can be used to create a gradient threshold based on the absolute power values. This rule also uses the one-shot feature of rules to avoid reporting of every small change within a threshold window. The rule (a ON/DO/ENDON rule in this the set) will trigger only once when a threshold is crossed. Backlog PowerDelta 0 ; Rule1 0 ; Rule1 5 Rule1 ON ENERGY # Power >= 35 DO Backlog PowerDelta 10 ; Status 8 BREAK ON ENERGY # Power >= 15 DO Backlog PowerDelta 25 ; Status 8 BREAK ON ENERGY # Power > 5 DO Backlog PowerDelta 35 ; Status 8 BREAK ON ENERGY # Power <= 5 DO PowerDelta 100 ENDON Rule1 1 Which translates (pseudo code): IF ENERGY # Power >= 35 // ENERGY # Power GE 35 DO Backlog PowerDelta 10 ; Status 8 ELSE IF ENERGY # Power >= 15 // ENERGY # Power GE 15 and LT 35 DO Backlog PowerDelta 25 ; Status 8 ELSE IF ENERGY # Power > 5 // ENERGY # Power GT 5 and LT 15 DO Backlog PowerDelta 35 ; Status 8 ELSE // ENERGY # Power changed ( i . e . LE 5 ) DO PowerDelta 100 Forward IR signals ~ Using one IR receiver and one sender (or both extender) you can simply forward signals from one to another using the following rule rule1 ON IRreceived # Data DO publish cmnd / irsideboard / irsend { Protocol:NEC , Bits: 32 , Data:% value % } ENDON Garage Door Opener ~ ( #3942 ) // Set the relay on time to signal the opener PulseTime 7 // Send ON and OFF as the switch is ON or OFF Backlog SwitchMode1 1 ; SwitchMode2 1 ; SwitchMode3 1 //No need to save changes on power cycle SetOption0 0 //Don\u2019t blindly run the door on power up PowerOnState 0 //One shot Detection off Backlog Rule1 0 ; Rule1 4 ; Rule2 0 ; Rule2 4 ; Rule2 0 ; Rule2 4 //Set Counter to measure the period between on and off, check if its blinking because of an obstruction Backlog CounterType 1 ; CounterDebounce 100 //So the door doesn't close if you send it an Open when it's already Opened, etc. // var1=1 Only When OPEN // var2=1 Only When CLOSED // var3=1 Only When OPENING // var4=1 Only When CLOSING Rule1 ON Switch1 # Boot = 1 DO Backlog delay 99 ; event Opened ENDON ON Switch2 # Boot = 1 DO Backlog delay 99 ; event Closed ENDON ON EVENT # OPEN DO Power1 % var2 % ENDON ON EVENT # CLOSE DO Power1 % var1 % ENDON ON EVENT # STOP DO Backlog Power1 % var3 % ; Power1 % var4 % ; event PState = STOP ENDON ON Switch1 # State = 1 DO event Opened ENDON ON Switch2 # State = 1 DO event Closed ENDON ON Switch1 # State = 0 DO event Closing ENDON ON Switch2 # State = 0 DO event Opening ENDON Rule2 ON event # Opened DO Backlog var 1 ; var2 0 ; var3 0 ; var4 0 ; ruletimer1 0 ; event PState = OPEN ENDON ON event # Closed DO Backlog var1 0 ; var2 1 ; var3 0 ; var4 0 ; ruletimer1 0 ; event PState = CLOSE ENDON ON event # Opening DO Backlog var1 0 ; var2 0 ; var3 1 ; var4 0 ; ruletimer1 15 ; event PState = OPENING ENDON ON event # Closing DO Backlog var1 0 ; var2 0 ; var3 0 ; var4 1 ; ruletimer1 15 ; event PState = CLOSING ENDON Rule3 ON counter # c1 > 1000 DO event PObstr = 0 ENDON ON counter # c1 < 1000 DO event PObstr = 1 ENDON ON event # PObstr DO publish stat / GarageDoor / OBSTR % value % ENDON ON event # PState DO publish stat / GarageDoor / STATE % value % ENDON ON rules # timer = 1 DO event PState = STOP ENDON //Turn on Rules Backlog Rule1 1 ; Rule2 1 ; Rule3 1 IR Remote Button Multi-press ~ For example, a remote control with one button to change speed. This rules simulates pressing the button three times to set the receiving device to the third speed setting. Specify the rule set The <trigger> can be a a condition or an event sent from another device or home automation hub. <topic> corresponds to the device transmitting the code (e.g., YTF IR Bridge ). This could also be modified to send an RF code from a Sonoff RF Bridge . The Delay may not be necessary in your environment or may need to be adjusted according to your device characteristics. Rule 1 ON Event # tora DO Backlog Publish cmnd /< topic >/ IRSend { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF30CF\" }; Delay 10 ENDON ON < trigger > DO Backlog Event tora ; Event tora ; Event tora ENDON Enable the Rule set Rule1 1 Two-way light switches without MQTT ~ Two Sonoff T1 3-gang light switches can be used at either end of a room by setting up one the master and the other as the slave. The master performs the switching of the power to the lights, while the slave just asks the master to toggle the power state. The master also turns the slave's relays on and off so that the LED indicators follow the master's state. Using the WebSend command, the two switches can talk to each other without an MQTT broker. It remains to be seen how reliable this is. Starting with the slave, the rule to toggle the master is pretty simple: Rule1 ON Event # sendPower DO WebSend [ 192.168 . 0.74 ] POWER % value % TOGGLE ENDON ON Button1 # State DO Event sendPower = 1 ENDON ON Button2 # State DO Event sendPower = 2 ENDON ON Button3 # State DO Event sendPower = 3 ENDON Rule1 1 Note that having a rule for the Button#State disables the power toggling of the slave's relay(s). This is desirable because we want the master to control the slave's relay state(s) according to its own as follows: Rule1 ON Event # sendPower DO WebSend [ 192.168 . 0.144 ] POWER % Var1 % % value % ENDON ON Power1 # state DO Backlog Var1 1 ; Event sendPower =% value % ENDON ON Power2 # state DO Backlog Var1 2 ; Event sendPower =% value % ENDON ON Power3 # state DO Backlog Var1 3 ; Event sendPower =% value % ENDON Rule1 1 Control remote light on switch double press ~ Toggling the switch controls local POWER state while toggling twice fast controls another device. Great with two SONOFF MINI in adjacent rooms, to control both rooms with either switch. SwitchMode 8 Rule1 ON switch1 # state = 3 DO websend [ ip / hostname of remote ] power1 toggle ENDON Rule1 1 Roller shutter push-button toggle ~ With a two relay device (e.g., Shelly 2.5) configured for a roller shutter, you can also connect push-buttons (configured as switch components in this example) and set them for inverted toggle behavior. Pressing a push-button once makes the roller shutter move in one direction. Pressing it again stops it. These rules each use a variable to remember the shutter state where 0 == Stopped and 1 == Moving . Backlog SwitchTopic 0 ; SwitchMode1 4 ; SwitchMode2 4 Rule1 ON Switch1 # State == 1 DO Add1 1 ENDON ON Var1 # State == 0 DO ShutterStop1 ENDON ON Var1 # State == 1 DO ShutterClose1 ENDON ON Var1 # State >= 2 DO Var1 0 ENDON ON Shutter1 # Close DO Var1 0 ENDON ON Switch2 # State == 1 DO Add2 1 ENDON ON Var2 # State == 0 DO ShutterStop1 ENDON ON Var2 # State == 1 DO ShutterOpen1 ENDON ON Var2 # State >= 2 DO Var2 0 ENDON ON Shutter1 # Open DO Var2 0 ENDON Rule1 1 Control a dimmer with one switch ~ This example is for GPIOs defined as switches not buttons Activate dimmer mode with Switchmode 11 and shorten long press time to 1 second ( Setoption32 10 ). A short press of the switch sends a TOGGLE message to toggle the dimmer. A long press sends repeated INC_DEC messages to increment the dimmer. If a second press of the switch follows the first press a INV message is sent to invert the function from increment to decrement and repeated INC_DEC messages are sent to decrement the dimmer. After releasing the switch a timeout message CLEAR resets the automation Backlog SwitchMode 11 ; SetOption32 10 ; Rule1 1 ; Rule1 on system # boot do var1 + ENDON on switch1 # state = 2 do POWER TOGGLE ENDON on switch1 # state = 4 do DIMMER % var1 % ENDON on switch1 # state = 7 do event upordown =% var1 % ENDON on event # upordown =+ do var1 - ENDON on event # upordown =- do var1 + ENDON Notice we use Rule which edits Rule1 rule set. They can be used interchangeably. Watchdog for Wi-Fi router or modem ~ The ping method requires #define USE_PING and Tasmota version 8.2.0.3 or newer The WebQuery method requires Tasmota version 10.0.0 or newer A Tasmota plug can check a remote host (router itself, something else connected to the router, or a site on the Internet) via an ICMP Ping or loading a URL and can power cycle the router or modem if the remote host isn't responding. In this example, an interval of 3 minutes is used. The simplest watchdog rule does not use variables: Rule1 ON Time # Minute | 3 DO backlog Ping4 192.168 . 1.10 ENDON ON Ping # 192.168 . 1.10 # Success == 0 DO Backlog Power1 0 ; Delay 10 ; Power1 1 ; ENDON Rule1 1 However, if the endpoint becomes unreachable for a long time, the watchdog will keep cycling it every three minutes. This could reduce the watchdog's relay lifetime to months, at most years. A safer option would be to use an exponential backoff algorithm. Var1 contains the current interval in minutes, which is tripled after each failed query, but limited to 1439 minutes (1 day). Rule1 ON system # boot do Var1 3 ENDON ON Var1 # State > 1439 DO Var1 1439 ENDON ON Time # Minute |% var1 % DO backlog Ping4 192.168 . 1.10 ENDON ON Ping # 192.168 . 1.10 # Success == 0 DO backlog Mult1 3 ; Power1 0 ; Delay 10 ; Power1 1 ENDON ON Ping # 192.168 . 1.10 # Success > 0 DO Var1 3 ENDON If your Tasmota doesn't have ping compiled in and your remote host has an HTTP server you can access, you can use WebQuery as below: Rule1 ON system # boot do Var1 3 ENDON ON Var1 # State > 1439 DO Var1 1439 ENDON ON Time # Minute |% var1 % DO backlog WebQuery http :/ 192.168 . 1.10 / GET ENDON ON WebQuery # Data $! Done DO backlog Mult1 3 ; Power1 0 ; Delay 10 ; Power1 1 ENDON ON WebQuery # Data = Done DO Var1 3 ENDON Triggering off the JSON response to webquery (and other commands) may require wrapping the command in backlog, as per example above Simple Thermostat Example ~ As example, to be used on a Sonoff TH10 with Sensor Si7021 This example turn on and off an output based on the temperature value and the upper set point and the lower set point. It waits until is enabled by pressing the button or by mqtt message 1 to mem1. This value is remembered. So if power cycle occurs, will resume operation. The set point values can be changed on the fly by mqtt or console commands If the Temperature sensor disconnects, the outputs will shutdown until the sensor is back again and will resume operation. When the device is power up, the thermostat also waits until the sensor value to resume operation. Initial Config: Available physical button as Switch1 Relay1 will be used the controller Rules must be used to control Relay so the pushbutton must only control Switch1 and not directly control the relay - For this we use SwitchMode1 3 as described below and create the necessary rules because the pushbutton control of the relay is only disabled when the rules are in place. Initial config on console: SwitchMode1 3 <- Use the switch1 as pushbutton (It will allow us to disable the link between the button and the relay by inserting a rule to dictate what the pushbutton will do - NOTE: Until rules are created the pushbutton will still control the relay! ) Rule1 1 <- turn on rules Rule1 4 <- turn off one-shot rule TelePeriod 60 <- check temp every minute SetOption26 1 <- use Power1 on mqtt messages SetOption0 0 <- dont save relay status on eeprom PowerOnState 0 <- start all relays off Mem1 0 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 Mem2 25 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 Mem3 23 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 Var1 0 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1 Rules ~ On boot start a watchdog timer to check temp sensor connection. Rule ON system # boot DO RuleTimer1 70 ENDON An available button is configured as switch to set thermostat ON or OFF Rule1 ON switch1 # state DO Backlog event toggling1 =% mem1 % ENDON ON event # toggling1 = 0 DO mem1 1 ENDON ON event # toggling1 = 1 DO mem1 0 ENDON Check temp sensor connection. If fails, set to off and turn off thermostat. Also continue checking Rule ON Rules # Timer = 1 DO Backlog var1 0 ; RuleTimer1 70 ; Power1 0 ENDON Resets checking timer if temperature is connected Rule ON tele - SI7021 # temperature DO Backlog var1 1 ; RuleTimer1 30 ; event ctrl_ready = 1 ; event temp_demand =% value % ENDON Thermostat control - upper limit and lower limit and enabled Rule1 ON event # ctrl_ready >% mem1 % DO var1 0 ENDON ON event # temp_demand >% mem2 % DO Power1 0 ENDON ON event # temp_demand <% mem3 % DO Power1 % var1 % ENDON Thermostat can be turned On by: pushing button by command on local console: mem1 1 by command on any other console: publish cmnd/mqttTopic/mem1 1 or MQTT at: cmnd/mqttTopic/mem1 1 Thermostat can be turned Off by: pushing button by command on local console: mem1 0 by command on any other console: publish cmnd/mqttTopic/mem1 0 or MQTT at: cmnd/mqttTopic/mem1 0 To get the status: mem1 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 mem2 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 mem3 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 var1 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1 Everything together: Initial config: RuleTimer1 must be greater that TelePeriod for expected results Backlog SwitchMode1 3 ; Rule 1 ; Rule 4 ; TelePeriod 60 ; SetOption26 1 ; SetOption0 0 ; poweronstate 0 ; mem1 0 ; mem2 25 ; mem3 23 ; var1 0 Rules Rule1 ON system # boot DO RuleTimer1 70 ENDON ON Switch1 # State DO event toggling1 =% mem1 % ENDON ON event # toggling1 = 0 DO mem1 1 ENDON ON event # toggling1 = 1 DO mem1 0 ENDON ON Rules # Timer = 1 DO Backlog var1 0 ; RuleTimer1 70 ; Power1 0 ENDON ON tele - SI7021 # temperature DO Backlog var1 1 ; RuleTimer1 70 ; event ctrl_ready = 1 ; event temp_demand =% value % ENDON ON event # ctrl_ready >% mem1 % DO var1 0 ENDON ON event # temp_demand >% mem2 % DO Power1 0 ENDON ON event # temp_demand <% mem3 % DO Power1 % var1 % ENDON Example rules without temp sensor to test the thermostat rules Rule1 ON system # boot DO RuleTimer1 70 ENDON ON Switch1 # State DO event toggling1 =% mem1 % ENDON ON event # toggling1 = 0 DO mem1 1 ENDON ON event # toggling1 = 1 DO mem1 0 ENDON ON Rules # Timer = 1 DO Backlog var1 0 ; RuleTimer1 70 ; Power1 0 ENDON ON event # temp DO Backlog var1 1 ; RuleTimer1 70 ; event ctrl_ready = 1 ; event temp_demand =% value % ENDON ON event # ctrl_ready >% mem1 % DO var1 0 ENDON ON event # temp_demand >% mem2 % DO Power1 0 ENDON ON event # temp_demand <% mem3 % DO Power1 % var1 % ENDON Tests: Push the button1. The thermostat changes to ENABLED (mem1=1) on console: event temp=20 (now the system receives like a tele message from temperature sensor) and will turn on the relay1 (to heat) on console: event temp=26 (the thermostat turn off the heater) on console: event temp=22 (the thermostat turn on the heater) wait more than a minute without using the event temp and the thermostat will turn off as there is no temperature value (like a sensor error or disconnection) will resume when using again the event temp console mem1 0, DISABLED, console mem1 1, ENABLED Timers: With the above the timers can be used to control mem1 and add a schedule to when the thermostat will be enabled Rule2 ON Clock#Timer=1 DO mem1 1 ENDON ON Clock#Timer=2 DO mem1 0 ENDON Solar heater control ~ In a swimming pool, a filter pump and a solar panel is installed. When the sun is shining, the pump should push water through the solar panel, to heat the pool. When it's night or cloudy, the pump should be off, to avoid cooling the pool water through the solar panel. The pump is controlled by a Sonoff TH10 with 2x DS18B20 sensors connected. 3 rules: Pump should start when solar panel is more than 2 deg warmer than the pool water Pump should stop when solar panel is less than 1 deg warmer than the pool water Pump should not start if the solar panel is below 25 deg Celsius. t1 : pool temp t2 : panel temp var1 : in valid panel temp range? var2 : off threshold temp for panel var3 : on threshold temp for panel mem3 : lowest valid panel temp mem3 25 rule1 ON DS18B20 - 1 # temperature DO event t1 =% value % ENDON ON DS18B20 - 2 # temperature DO event t2 =% value % ENDON ON event # t2 >% mem3 % DO var1 1 ENDON ON event # t2 <=% mem3 % DO var1 0 ENDON ON event # t1 DO Backlog var2 % value % ; add2 1 ENDON ON event # t1 DO Backlog var3 % value % ; add3 2 ENDON ON event # t2 >% var3 % DO Power1 % var1 % ENDON ON event # t2 <% var2 % DO Power1 0 ENDON To test the rule without having the sensors in place, simply enter the events for t1 and t2 in the console: Backlog event t1=21;event t2=30 And watch the relay turn on and off based on the values. Please note that this example does not support manual override or handles missing sensor data. Energy Saving Switch ~ Example of a switch controlling a light with a condition of a required amount of lux. When the switch is on, the light will turn on but only when you have less than 100 lux in that room. While if the switch is off the light will be off. Rule1 ON switch1 # state = 1 DO var1 100 ENDON ON switch1 # state = 0 DO Backlog var1 0 ; Power1 off ENDON ON APDS9960 # Ambient <% var1 % DO Power1 on ENDON Use of variables and tele- in Domoticz ~ Using variables allows for storing sensor results to be used in composing a single HA message like used with Domoticz. To prevent flooding Domoticz with messages we only want to send a message at TelePeriod time. This is achieved by prefixing the <SensorName> with the label tele- . This example will use a variable storing the temperature to be used together with humidity in one Domoticz MQTT message. Domoticz configured with a virtual sensor Temp+Hum using Idx 134 Rule Rule ON tele - am2301 - 12 # temperature DO var1 % value % ENDON ON tele - am2301 - 12 # humidity DO publish domoticz / in { \"idx\" : 134 , \"svalue\" : \"%var1%;%value%;1\" } ENDON Result - As a result of the tele- prefix the rules will be checked at TelePeriod time for sensor AM2301-12 Temperature and Humidity. The first rule will use the Temperature stored in %value% and save it in %var1% for future use. The second rule will use the Humidity stored in %value% and the Temperature stored in %var1% to compose a single MQTT message suitable for Domoticz. Publish Maximum Value from sensor in a time period ~ This rule stores the sensor value in var1 . When the current value is greater than the previous, var1 is updated. If the current value is smaller, var1 remains unchanged. Then every minute, var1 is published and reset. This results in publication of the maximum/peak value for the last minute. Useful, for example in a decibel meter, when the peak value is important, rather than the value that is occurring by chance at normal telemetry time. This example uses Analog Range mode (trigger analog#range ) which is a scaled output value (the raw analog value would be analog#a0 ). On ESP32 which supports multiple ADC inputs, the ADC index must be appended such as analog#range1 for ADC#1. Rule ON analog#range>%var1% DO VAR1 %value% ENDON ON Time#Minute DO Backlog publish shed/tele/maxdb %var1%; var1 0 ENDON Rule 1 1 RF Repeater / IR Repeater ~ In some applications, an RF-Repeater may come in handy to increase the range of RF based devices. We need to use RF reciever and RF transmitter modules with tasmota powered controllers. The following rule looks for data received by the RF receiver and re transmits the same over the transmitter. Rule1 on RfReceived # data do Rfsend { \"Data\" :% value % , \"Bits\" : 24 , \"Protocol\" : 1 , \"Pulse\" : 454 } endon Enable it with Rule1 1 A similar concept can also work for IR- Repeater. Connect IR receiver module and IR trnasmitter to Tasmotized device and the following rule retransmits any data over IR Rule1 on IrReceived # Data do IRsend { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" :% value % } endon Enable it with Rule1 1 The only catch is that the protocol needs to be setup in the rule. Most likely this can be taken care of by using a more complex rule maybe using variables. Would update in future","title":"Rules"},{"location":"Rules/#rule-syntax","text":"Rule definition syntax ON < trigger > DO < command > [ ENDON | BREAK ] ON - marks the beginning of a rule <trigger> - what condition needs to occur for the rule to trigger DO - statement marking end of trigger and beginning of command part <command> - command that is executed if the <trigger> condition is met ENDON - marks the end of a rule. It can be followed by another rule. BREAK - marks the end of a rule. BREAK will stop the execution of the remaining rules that follow this rule within the rule set. If a rule that ends with BREAK is triggered, the following rules in that rule set will not be executed. This allows the rules to somewhat simulate an \"IF/ELSE\" statement. Rule sets are defined by using the Rule<x> command. After defining a rule set, you have to enable it (turn it on) using Rule<x> 1 . Similarly you can disable the rule set using Rule<x> 0 . Note If bootloops are detected all rules will be disabled as a precaution. See SetOption36 . There are three separate rule sets called Rule1 , Rule2 and Rule3 . Each rule set can contain many rules. The number of rules that can fit in a rule set varies, but expect at least 1000 characters available per set. Additionally, rules are dynamically compressed, meaning they will be compressed automatically when doing so is required, but left uncompressed until that point. Whenever a rule set is enabled all the rules in it will be active. If the character count of the rules in one set actually exceeds the limit, start using the next rule set. If you have a long list of rules, verify the rules have all fit by inspecting the resulting log. Rules inside a rule set Rule<x> are concatenated and entered as a single statement. Rule < x > ON < trigger1 > DO < command > ENDON ON < trigger2 > DO < command > ENDON ... Spaces after ON , around DO , and before ENDON or BREAK are mandatory. A rule is not case sensitive.","title":"Rule Syntax"},{"location":"Rules/#rule-trigger","text":"Rule trigger names are derived from the JSON message displayed in the console. Each JSON level (all values enclosed in {...} ) is separated in the trigger with a # . A rule trigger can consist of: [TriggerName]#[ValueName] [TriggerName]#[ValueName][comparison][value] [SensorName]#[ValueName] [SensorName]#[ValueName][comparison][value] Tele-[SensorName]#[ValueName] [TriggerName1]#[TriggerName2]#[ValueName] [TriggerName1]#?#[ValueName] Use ? as a wildcard for a single trigger level. Rule will trigger on [TriggerName]#?#[Value] where ? is any value. Example Rule with a trigger of ZBReceived#?#Power=0 will trigger on {\"ZBReceived\":{\"0x4773\":{\"Power\":0}}} and on {\"ZBReceived\":{\"aqara_switch\":{\"Power\":0}}} both. Note Same trigger may be used in more than one rule. This may be required for some cases of using IF/ELSE since an IF statement cannot be used within a Backlog .","title":"Rule Trigger"},{"location":"Rules/#rule-command","text":"A rule command can be any command listed in the Commands list . The command's <parameter> can be replaced with %value% which will use the value of the trigger. ON Switch1#State DO Power %value% ENDON To accomplish a rule with one trigger but several commands, you need to use Backlog : ON <trigger> DO Backlog <command1>; <command2>; <command3> ENDON Appending new rule onto an existing rule set Use the + character to append a new rule to the rule set. For example: Existing Rule1: ON Rules#Timer=1 DO Mem2 %time% ENDON Rule to append: ON Button1#state DO POWER TOGGLE ENDON Command: Rule1 + ON button1#state DO POWER TOGGLE ENDON Resulting in Rule1 ON Rules # Timer = 1 DO Mem2 % time % ENDON ON Button1 # state DO POWER TOGGLE ENDON You can repeate the same trigger in rules. Rule ON Power2 # state = 1 DO Power1 1 ENDON ON Power2 # state = 1 DO RuleTimer1 100 ENDON","title":"Rule Command"},{"location":"Rules/#rule-variables","text":"There are thirty-two (32) available variables (single precision reals) in Tasmota: Var1..Var16 and Mem1..Mem16 . They provide a means to store the trigger %value% to be used in any rule. All Var will be empty strings when the program starts. The value of all Mem persists after a reboot. The value of a Var<x> and Mem<x> can be: any number any text %var1% to %var16% %mem1% to %mem16% %color% %deviceid% %macaddr% %sunrise% %sunset% %time% %timer1% to %timer16% %timestamp% %topic% %uptime% %utctime% %zbdevice% %zbgroup% %zbcluster% %zbendpoint% To set the value for Var<x> and Mem<x> use the command Var<x> <value> Mem<x> <value> The <value> can also be the value of the trigger of the rule. Set Var2 to the temperature of the AM2301 sensor - ON AM2301#Temperature DO Var2 %value% ENDON Set Var4 to Var2's value - ON Event#temp DO Var4 %Var2% ENDON Set Mem2 to the current time (minutes elapsed since midnight) - ON Rules#Timer=1 DO Mem2 %time% ENDON After a Wi-Fi reconnect event, publish a payload containing timestamps of when Wi-Fi was disconnected in From: and when Wi-Fi re-connected in To: to stat/topic/BLACKOUT . Rule1 ON wifi # disconnected DO Var1 % timestamp % ENDON ON wifi # connected DO Var2 % timestamp % ENDON ON mqtt # connected DO Publish stat / topic / BLACKOUT { \"From\" : \"%Var1%\" , \"To\" : \"%Var2%\" } ENDON","title":"Rule Variables"},{"location":"Rules/#conditional-rules","text":"This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem)","title":"Conditional Rules"},{"location":"Rules/#expressions-in-rules","text":"This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Beginning with Tasmota version 6.4.1.14, an optional feature for using mathematical expressions in rules was introduced.","title":"Expressions in Rules"},{"location":"Rules/#rule-cookbook","text":"","title":"Rule Cookbook"},{"location":"Rules/#long-press-on-a-switch","text":"This example is for GPIOs defined as switches not buttons Activate long press action with Switchmode 5 and shorten long press time to 2 seconds ( Setoption32 20 ). Backlog SwitchMode 5 ; SetOption32 20 Rule ON switch1 # state = 3 DO publish cmnd / tasmota02 / POWER 2 ENDON Long pressing on switch1 sends POWER 2 (toggle action) command to the tasmota02 device Notice we use Rule which edits Rule1 rule set. They can be used interchangeably. If your rule does not trigger there could some constraints, in this case if SwitchTopic has a value it will override rules for switches and will need to be disabled: SwitchTopic 0 .","title":"Long press on a switch"},{"location":"Rules/#send-mqtt-message-on-button-press","text":"When a button is pressed the user has the possibility to send a MQTT message based on FullTopic and ButtonTopic. This MQTT message is going to be received by the MQTT broker and if there is any other device(s) subscribed to that Topic, it will receive also that message. So this approach can be used for sending messages/commands to MQTT Broker to Home Automation System, and/or sending messages/commands to MQTT Broker to other device(s). A problem with this solution is that on a Sonoff 4CH all four buttons will be sending the same MQTT topic using only a different Power index number like cmnd/ButtonTopic/Power3 toggle . By using a rule a single button can send any MQTT message allowing for more flexibility. Disable ButtonTopic as it overrides rules for buttons: ButtonTopic 0","title":"Send MQTT message on button press"},{"location":"Rules/#usage-of-one-shot-once","text":"The rule command once option provides the possibility to trigger only once ON a slow change while the change is still within the bounds of the test. Rule ON ENERGY # Current > 0.100 DO publish tool / tablesaw / power 1 ENDON ON ENERGY # Current < 0.100 DO publish tool / tablesaw / power 0 ENDON This creates a rule to publish MQTT commands whenever a Sonoff POW has current passing through it. Used as is, it will publish MQTT commands repeatedly, over and over, while current is >0.100 ... but, executing another command: Rule 5 Now the MQTT message will be sent once, and only once, while the condition is met. This is perfect for thermostat on/off depending on temperature, bathroom extractor fan on/off depending on humidity, workshop dust collector on/off depending on whether some dust-producing machine is running. It meets the 'hard thermostat' requests that have been common.","title":"Usage of one-shot (once)"},{"location":"Rules/#use-a-potentiometer","text":"Connecting a potentiometer to the Analog A0 input and a rule can be used to control the dimmer state of any device. Hardware - Wemos D1 mini - Potentiometer of 2k2 connected to Gnd, A0 and 3V3 - WS2812 LED Rule ON analog # a0div10 DO dimmer % value % ENDON","title":"Use a potentiometer"},{"location":"Rules/#use-a-rotary-encoder","text":"You can capture in rules the value of a rotary encoder connected to 2 GPIOs configured as Rotary_a|<n> and Rotary_b|<n> . Optionally the button of the rotary encoder can be connected to another GPIO configured as Button|<n> . <n> must be the same to allow the encoder to manage 2 absolute counters from the same rotary encoder. To get triggers from the rotary encoder into rules, you must enable SetOption98 1 . The rotary encoder <n> provides a JSON in the form of {'Rotary<n>': {'Pos1': value, 'Pos2': value}} . You can use the following rules triggers: SetOption98 1 Rule1 ON Rotary1 # Pos1 DO something_with % value % ENDON ON Rotary1 # Pos2 DO something_with % value % ENDON","title":"Use a rotary encoder"},{"location":"Rules/#use-zigbee-to-control-tasmota-devices","text":"This setup uses a Zigbee gateway with an Ikea remote switch paired. Ikea switch's name was set with ZbName to make it more user friendly.","title":"Use Zigbee to control Tasmota devices"},{"location":"Rules/#button-single-press-double-press-and-hold","text":"This example show how to assign different behavior to a button other than Button1 . Button1 has special multi-press behaviors associated with it (see Note in Multi-Press Functions ), examples 1 and 2 cannot be applied to Button1.","title":"Button single press, double press and hold"},{"location":"Rules/#disable-switch-single-press-and-use-long-press","text":"SetOption11 0 Switches do not have double press feature [assuming a connected pushbutton configured as Switch1] single press: Does nothing (empty Delay commands) hold 2 secs: Toggle Power1 Backlog SwitchTopic1 0 ; SwitchMode1 5 ; SetOption32 20 Rule1 ON Switch1 # State = 3 DO Power1 2 ENDON ON Switch1 # State = 2 DO Delay ENDON Rule1 1","title":"Disable switch single press and use long press"},{"location":"Rules/#execute-several-commands-when-a-timer-expires","text":"The default Timer1..16 functionality allows for controlling one output to either off, on, toggle or blink. When rules are enabled the blink option will be replaced by rule functionality allowing much more flexibility. Configure timer5 for rule execution when activated: Timer5 { \"Enable\" : 1 , \"Mode\" : 0 , \"Time\" : \"16:00\" , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Action\" : 3 }","title":"Execute several commands when a Timer expires"},{"location":"Rules/#setting-variables","text":"Demonstrate the use of variables. Make sure to execute commands Rule 4 (Disable one-shot detection) first when trying the following example. Set a variable Rule ON event # setvar1 DO var1 % value % ENDON Command: event setvar1=1 View a variable rule ON event # getvar1 DO var1 ENDON Command: event getvar1 Toggle a variable Rule ON event # togglevar1 DO event toggling1 =% var1 % ENDON ON event # toggling1 < 1 DO event setvar1 = 1 ENDON ON event # toggling1 > 0 DO event setvar1 = 0 ENDON ON event # setvar1 DO var1 % value % ENDON Command: event togglevar1 Show Messages: Rule ON event # message DO publish stat / [ topic ] / log % value % ENDON Command: event message=INIT All event commands can be executed from: console: event anyname=number mqtt: cmnd/[topic]/event anyname=number Everything together: Rule1 ON event # togglevar1 DO event toggling1 =% var1 % ENDON ON event # toggling1 < 1 DO event setvar1 = 1 ENDON ON event # toggling1 > 0 DO event setvar1 = 0 ENDON ON event # setvar1 DO var1 % value % ENDON ON event # getvar1 DO var1 ENDON ON event # message DO publish stat / mqttTopic / log % value % ENDON The following won't work: Rule1 ON event#setvar1 DO Backlog var1 %value%; Power1 %var1% ENDON At least not as you probably would expect. The var1 value used by the Power1 command will be the value present before the Backlog command is executed. This is so, because the rule will replace %var1% BEFORE the Backlog commands are put in the Backlog command stream.","title":"Setting variables"},{"location":"Rules/#time-delayed-auto-off-switch","text":"","title":"Time-delayed Auto-off Switch"},{"location":"Rules/#time-delay-after-switch-off","text":"","title":"Time-delay After Switch Off"},{"location":"Rules/#auto-off-motion-sense-switch","text":"Example works fine on a Wemos D1 Mini. Used as night light with motion sensor or as ambient light on floor or kitchen. Connect an LED Strip WS2812 on D1 and the PIR on D2 and a LDR on A0 (voltage divider with 10k ohm resistor) SwitchMode1 1","title":"Auto-off Motion Sense Switch"},{"location":"Rules/#control-timers-from-a-switch","text":"Assuming that your switch is on GPIO00 and configured as Switch1 : Switchmode1 1 will make Switch1#state be 1 when ON and 0 when OFF If you don't set Switchmode1 or it is equal 0, it will only have Switch1#state=2 (toggle) and the rule will not work.","title":"Control Timers from a Switch"},{"location":"Rules/#toggle-relay-when-holding-button-for-2-seconds","text":"The following example is to explain how to catch and use the HOLD feature for buttons. Behavior: Disable Button1 Short Press and Toggle Relay1 only when holding button1 for 2 Seconds. Backlog ButtonTopic 0 ; SetOption1 1 ; SetOption32 20 Rule1 ON button1 # state = 3 DO Power1 2 ENDON ON button1 # state = 2 DO delay ENDON Rule1 1 Commands Explanation ButtonTopic 0 : (default) To not use topics for buttons SetOption1 1 : Allow only single, double and hold press button actions SetOption32 20 : Set key hold time from 0.1 to 10 seconds (20 = 2 seconds) Rule ON button1#state=3 DO Power1 2 ENDON : When holding the button1 for 2 seconds it will toggle relay 1 (state = 3 means HOLD) ON button1#state=2 DO delay ENDON : Do nothing when short pressing the button1 (state = 2 means TOGGLE) Rule1 1 : To enable rules NOTE: There is no state value for \"double press\" for Buttons. It is designed that double press will toggle the relay. See Multi-Press Functions for more information. In the case you do not want the double press feature you can configure your button as switch and also set SwitchMode that fits your use case (such as SwitchMode 5 to make the switch behave like a pushbutton) [SWITCH does not support double press] Another example but using switch instead of button: Backlog SwitchTopic1 0 ; SwitchMode1 5 ; SetOption32 20 Rule1 ON switch1 # state = 3 DO Power1 2 ENDON ON switch1 # state = 2 DO delay ENDON Rule1 1","title":"Toggle Relay when holding button for 2 seconds"},{"location":"Rules/#make-sure-light-is-on-at-night","text":"Using Timers, you can set a light to turn on and off to illuminate a street/patio by night. But if the device has no power at the trigger time, then, when it powers up, the light will be off all night. So, as a fail-safe, implement a conditional control to be checked at Tasmota Startup. Set Timers to turn on your light at Sunset and Turn off at sunrise. Use poweronstate 0 in order to start with lights off when powering up your device. Set the following rules: Rule1 ON Time # Initialized DO Backlog event checksunrise =% time % ; event checksunset =% time % ENDON ON event # checksunset >% sunset % DO Power1 1 ENDON ON event # checksunrise <% sunrise % DO Power1 1 ENDON The previous rules are conditionals that represent the following logic: IF %time%>%sunset DO Power1 1 / IF %time%<%sunrise DO Power1 1","title":"Make sure Light is on at night"},{"location":"Rules/#turn-on-light-before-dawn-and-at-dusk","text":"Turn on light at dusk until your nighttime and again in the morning before dawn. What if the sun sets after your nighttime, as in during the summer? Then the timer will turn off the light at \"night\", but then the Sunset timer will turn it on again, so it stays on all night.","title":"Turn On Light Before Dawn and At Dusk"},{"location":"Rules/#enable-a-pir-switch-only-at-night","text":"Latitude and Longitude need to be set in config. Use PulseTime to specify the duration the light should remains on. Every PIR trigger will restart for that amount of time. SwitchMode1 14 PulseTime 60 Rule1 ON Switch1 # state = 1 DO Backlog event checksunrise =% time % ; event checksunset =% time % ENDON ON event # checksunrise <% sunrise % DO Power1 1 ENDON ON event # checksunset >% sunset % DO Power1 1 ENDON","title":"Enable a PIR Switch only at night"},{"location":"Rules/#control-luminance-switch-with-timer","text":"Background: Tasmota powers a Sonoff Basic attached to a TS-2561 Luminance Sensor. This switch toggles a lamp ON or OFF. The switch should work as below: i) during daytime (sunrise-sunset): ON when it is too dark (<150 lx) and OFF when it gets brighter (>175 lx). ii) during evenings it ignores the sensor and turns on at sunset and turns off after about 5 hours Approach: Used a combination of Clock Timers and Rule to do this. Timer 1: Power ON switch at Sunset Powers on the switch at sunset with an offset of 20 minutes. Repeats every day. Timer1 { \"Enable\" : 1 , \"Mode\" : 2 , \"Time\" : \"-00:20\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Timer 2: Power OFF switch at Night. Turns power OFF at 23.00hrs. Repeats every day. Timer2 { \"Enable\" : 1 , \"Mode\" : 0 , \"Time\" : \"23:00\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 0 } Timer 3: Trigger Luminance Rule at Sunrise Start watching the Lux sensor 15 minutes after sunrise. Timer3 { \"Enable\" : 1 , \"Mode\" : 1 , \"Time\" : \"00:15\" , \"Window\" : 0 , \"Days\" : \"1111111\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 3 } Rule 1: Main Rule to check Luminance If Luminance is less than 150lx, power ON. If it goes beyond 175lx, power OFF. Rule1 ON tele - TSL2561 # Illuminance < 150 DO Power1 1 ENDON ON tele - TSL2561 # Illuminance > 175 DO Power1 0 ENDON Rule1 1 ``` haskell ** Rule 2 :** Trigger Rule1 only in the Mornings This ensures that Rule1 is triggered when Timer3 starts ( in the morning ) and stops when Timer1 starts ( in the evenings ) . ``` haskell Rule2 ON Clock # Timer = 3 DO Rule1 1 ENDON ON Clock # Timer = 1 DO Rule1 0 ENDON Rule2 1","title":"Control luminance switch with Timer"},{"location":"Rules/#automatically-vary-the-color-temperature-of-a-cct-light","text":"Background: Tasmota powers a CCT light which is adjustable from cool white to warm white. You want the color temperature to automatically vary between cool (CT=153) at midday to warm (CT=500) at midnight. Approach: Check that your timezone and DST (if applicable) are set correctly and the time is correctly set on your light using NTP. Create the two rules to scale the CT based on the time of day. If Wifi is unavailable or NTP can't determine the time of day then the light will default to the mid point for neutral white (CT=326). Adjusting the CT will switch the light on so Rule 2 disables and enables Rule 1 according to the state of the light. Rule 1: Set the CT according to the time of day. rule1 on Power1 # Boot do CT 326 endon on Time # Initialized do backlog event myCT =% time % endon on Time # Minute do backlog event myCT =% time % endon on event # myCT <= 720 do backlog scale1 % time % , 0 , 720 , 500 , 153 ; event updateCT endon on event # myCT > 720 do backlog scale1 % time % , 720 , 1440 , 153 , 500 ; event updateCT endon on event # updateCT do CT % var1 % endon rule1 1 Rule 2: Toggle rule 1 on and off with the light and also update the CT for the current time when the light is switched on. Rule2 on Power1 # State do backlog Rule1 % value % ; event myCT =% time % endon Rule2 1 Notes: When the light is powered up on it should change to neutral white for a few seconds while Wifi, MQTT and NTP are initialised then switch to the correct color temperature for the time of day. If the light is switched off in software then it will come back on with the previous CT then update to the current CT after a few seconds. If you have a RGBCCT light then the CT light may be Power2 rather than Power1. It is possible to use %sunrise% and %sunset% to adjust the CT if you set your latitude, longitude and elevation but it's much more complex especially at extreme Northern and Southern latitudes.","title":"Automatically vary the color temperature of a CCT light"},{"location":"Rules/#perform-any-action-on-singledouble-press-for-switches-and-buttons","text":"","title":"Perform any action on single/double press (for switches AND buttons)"},{"location":"Rules/#enable-or-disable-relay-with-a-switch-in-domoticz","text":"When you want to send MQTT messages ( we use domoticz in this example ) and choose when you want the relay on or off, by simply sending HTTP commands to trigger an event. Initial Config: PushButton Doorbell (Sonoff Basic R1) GPIO14 - Switch4 (12) Connect the Switch to GND and the GPIO on your device. Be sure put a 4.7k resistor between VCC(3.3v) and the GPIO. This prevents ghost switching (capacitor is optional) See: YouTube Dont forget to change the IDX value Commands: Backlog SwitchTopic 0 ; SwitchMode4 2 ; SetOption0 0 ; PowerOnState 0 var1 1 Rule1 ON event # doorbell DO var1 % value % ENDON ON switch4 # state = 1 DO publish domoticz / in { \"idx\" : 11 , \"nvalue\" : 1 } ENDON ON switch4 # state = 1 DO Power1 % var1 % ENDON ON switch4 # state = 0 DO publish domoticz / in { \"idx\" : 11 , \"nvalue\" : 0 } ENDON ON switch4 # state = 0 DO Power1 0 ENDON Rule1 1 Usage: Turn off the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=0 Turn on the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=1 If your Tasmota device is password protected, which is most common, then use the following HTTP commands instead. Make sure you change <tasmotaUsername> and <tasmotaPassword> Off: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=0 On: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=1","title":"Enable or disable relay with a switch in Domoticz"},{"location":"Rules/#force-automatic-re-connection-to-mqtt-server-via-sd-dns","text":"In order to search for the MQTT server using SD-DNS service (a.k.a. Bonjour or Zero Network Configuration) the suggested configuration is to leave the MQTT Host field blank. The standard behavior of Tasmota is searches for _mqtt._tcp service resolve that to the proper IP address connect to it in case the connection is successful, retain the IP address and use that in the subsequent connections The above is not proper, though, in case you have a redundant MQTT (e.g., two MQTT server synchronized). In such case, when the active MQTT fails for any reason, the expected behavior is to achieve automatic re-connection to the other MQTT server. That can be easily configured defining the following rule on the device console: Rule1 ON Mqtt # Disconnected DO MqttHost 0 ENDON Rule1 1 If the MqttHost field already contains an IP, you have to delete it using the web interface or the following MQTT command: mosquitto_pub -h mqtt_server.local -t \"cmnd/mqttTopic/MqttHost\" -m ''","title":"Force automatic re-connection to MQTT server via SD DNS"},{"location":"Rules/#change-distance-to-percentage","text":"When measuring distance and you have the need to see it in percentage of distance. In the example 100% is everything below 69cm and 0% is everything above 128cm. This is used for showing fill percentage of a wood pellets storage. Rule1 ON tele - SR04 # distance DO Backlog var1 % value % ; event checklimit =% value % ; event senddistance ENDON ON event # checklimit > 128 DO var1 128 ENDON ON event # checklimit < 69 DO var1 68 ENDON ON event # senddistance DO Backlog SCALE1 % var1 % , 128 , 69 , 0 , 100 ; event pubdata ENDON ON event # pubdata DO publish tele / pannrum - temp / SENSOR % var1 % ENDON Rule1 1","title":"Change distance to percentage"},{"location":"Rules/#distinguish-switch1-and-switch2-without-the-use-of-relay1-and-relay2","text":"When two (or more) switches are defined as input and you want to distinguish these in the RESULT topic without the use of Relays, then consider the following rules. SwitchMode1 1 will make Switch1#state to be 1 when ON and 0 when OFF SwitchMode1 1 SwitchMode2 1 will make Switch2#state to be 1 when ON and 0 when OFF SwitchMode2 1 Publish json with key POWER1 and value %value% Rule1 ON switch1 # state DO publish stat / wemos - 4 / RESULT { \"POWER1\" : \"%value%\" } ENDON Publish json with key POWER2 and value %value% Rule2 ON switch2 # state DO publish stat / wemos - 4 / RESULT { \"POWER2\" : \"%value%\" } ENDON Enable Rules Backlog Rule1 1; Rule2 1 Output: RUL: SWITCH1#STATE performs \"publish stat/wemos-4/RESULT {\"POWER1\":\"1\"}\" MQT: stat/wemos-4/RESULT = {\"POWER1\":\"1\"} RUL: SWITCH2#STATE performs \"publish stat/wemos-4/RESULT {\"POWER2\":\"1\"}\" MQT: stat/wemos-4/RESULT = {\"POWER2\":\"1\"} RUL: SWITCH1#STATE performs \"publish stat/wemos-4/RESULT {\"POWER1\":\"0\"}\" MQT: stat/wemos-4/RESULT = {\"POWER1\":\"0\"} RUL: SWITCH2#STATE performs \"publish stat/wemos-4/RESULT {\"POWER2\":\"0\"}\" MQT: stat/wemos-4/RESULT = {\"POWER2\":\"0\"} RUL: SWITCH1#STATE performs \"publish stat/wemos-4/RESULT {\"POWER1\":\"1\"}\" MQT: stat/wemos-4/RESULT = {\"POWER1\":\"1\"} RUL: SWITCH1#STATE performs \"publish stat/wemos-4/RESULT {\"POWER1\":\"0\"}\" MQT: stat/wemos-4/RESULT = {\"POWER1\":\"0\"}","title":"Distinguish Switch1 and Switch2 (without the use of Relay1 and Relay2)"},{"location":"Rules/#receiving-state-of-anything-that-triggers-switch-more-than-one-time","text":"With analog intercom doorbells you can take out info about ringing from speaker voltage. You can connect GPIO to it via opto-isolator and resistor to take out state. But even with those speaker voltage is dropping so it switches the device multiple times. MQT: cmnd/doorbell/POWER2 = OFF (retained) MQT: cmnd/doorbell/POWER2 = ON (retained) MQT: cmnd/doorbell/POWER2 = OFF (retained) MQT: cmnd/doorbell/POWER2 = ON (retained) MQT: cmnd/doorbell/POWER2 = OFF (retained) To solve it we can use rules. SwitchTopic 0 Rule1 on System # Boot DO var1 0 ENDON ON Switch2 # State DO Backlog add1 1 ; event START ENDON ON event # START DO event BELL =% var1 % ENDON ON event # BELL = 1.000 DO Backlog publish cmnd / bell / power on ; RuleTimer1 60 ENDON ON event # BELL = 0 DO publish cmnd / bell / power off ENDON ON Rules # Timer = 1 DO Backlog var1 0 ; event BELL = 0 ENDON Rule1 1 description: Disable SwitchTopic as it overrides rules for switches: SwitchTopic 0 on system boot set var1 to 0 on switch2 click (person pushing doorbell) - var1 += 1; trigger event START on START - set event BELL equal to var1 if event#BELL=1 (triggered first time) publish mqtt message ON and trigger RulesTimer1 for 60 seconds if event#BELL=0 publish mqtt message OFF on RulesTimer1 - reset var1 to 0, and call event#BELL. enable rule 1 In this case we have lock for 60 seconds for multiple people calls or to be resistant for speaker voltage drops.","title":"Receiving state of anything that triggers SWITCH more than one time"},{"location":"Rules/#prevent-wemos-d1-mini-load-overcurrent","text":"As a WS2812 24 led ring draws approximately 24x3x20 mA = 1.44A and the Wemos D1 mini powered from a PC's USB port can only provide up to 0.5A it would be nice to have some kind of mechanism in place to limit the amount of current to the WS2812 LEDring to 0.1A. This is still enough to light all 24 leds up to color 202020. Hardware Wemos D1 mini INA219 I 2 C sensor WS2812 LEDring with 24 LEDs powered by the Wemos D1 mini 5V thru the INA219 sensor Rule1 ON INA219 # Current > 0.100 DO Backlog Dimmer 10 ; Color 10 , 0 , 0 ENDON Rule1 on Result - When a user raises brightness to a level using more than 0.1A the rule kicks in and lowers the current by executing command Dimmer 10 and changes the color to Red with command Color 10,0,0 .","title":"Prevent Wemos D1 mini load overcurrent"},{"location":"Rules/#using-dummy-gpio-to-send-serial-codes-to-an-mcu","text":"By having a device that controls all its features through an MCU and reports the states in serial codes to the ESP8266 we have to create some rules to control it using the Web UI or standard Power commands. Rule1 ON Power1 # state = 1 DO serialsend5 55 AA00060005020400010213 ENDON ON Power1 # state = 0 DO serialsend5 55 AA00060005020400010011 ENDON ON Power2 # state = 1 DO serialsend5 55 AA00060005060400010217 ENDON ON Power2 # state = 0 DO serialsend5 55 AA00060005060400010015 ENDON Power1 controls the device, Power2 turn on and off the light on the device. Another rule was created to issue commands on boot so the serial interface works every time and to control the built in fan using Event triggers and have its state retained in an MQTT message for Home Assistant. Rule2 ON system # boot DO Backlog baudrate 9600 ; seriallog 2 ; serialsend5 55 aa000300010306 ENDON ON event # high DO Backlog serialsend5 55 AA00060005650400010175 ; publish2 stat / diffuser / FAN high ENDON ON event # low DO Backlog serialsend5 55 AA00060005650400010074 ; publish2 stat / diffuser / FAN low ENDON","title":"Using dummy GPIO to send Serial codes to an MCU"},{"location":"Rules/#arithmetic-commands-used-with-var","text":"","title":"Arithmetic commands used with VAR"},{"location":"Rules/#transmit-sensor-value-only-when-a-delta-is-reached","text":"Send only when the sensor value changes by a certain amount. Rule1 ON SI7021 # temperature >% var1 % DO Backlog var1 % value % ; publish stat / mqttTopic / temp % value % ; var2 % value % ; add1 2 ; sub2 2 ENDON ON SI7021 # temperature <% var2 % DO Backlog var2 % value % ; publish stat / mqttTopic / temp % value % ; var1 % value % ; add1 2 ; sub2 2 ENDON This example explains expands on the above example while matching typical sensor data. Helpful for HA tasmota integration sensors when polling and adding in delta value changes. Normal polling data below 23 : 58 : 41 MQT: tele / ds1820 / SENSOR = { \"Time\" : \"2021-01-13T23:58:41\" , \"DS18B20\" : { \"Id\" : \"030597946B04\" , \"Temperature\" : 20.9 }, \"TempUnit\" : \"C\" } The matching rule. Rule1 ON DS18B20 # temperature >% var1 % DO Backlog var1 % value % ; publish tele / ds1820 / SENSOR { \"Time\" : \"%timestamp%\" , \"DS18B20\" : { \"Id\" : \"030597946B04\" , \"Temperature\" :% value % }, \"TempUnit\" : \"C\" }; var2 % value % ; add1 0.5 ; sub2 0.5 ENDON ON DS18B20 # temperature <% var2 % DO Backlog var2 % value % ; publish tele / ds1820 / SENSOR { \"Time\" : \"%TIMESTAMP%\" , \"DS18B20\" : { \"Id\" : \"030597946B04\" , \"Temperature\" :% value % }, \"TempUnit\" : \"C\" }; var1 % value % ; add1 0.5 ; sub2 0.5 ENDON","title":"Transmit sensor value only when a delta is reached"},{"location":"Rules/#adjust-a-value-and-send-it-over-mqtt","text":"This example adds 2 degrees to the measured temperature and then sends that value to an MQTT topic. Rule1 ON tele - SI7021 # temperature DO Backlog var1 % value % ; add1 2 ; event sendtemp ENDON ON event # sendtemp DO publish stat / mqttTopic / temp % var1 % ENDON","title":"Adjust a value and send it over MQTT"},{"location":"Rules/#control-relays-via-serial","text":"This example switches connected relays over the software serial on and off. Write the following rules: rule1 ON SSerialReceived # Data = on DO Power1 1 ENDON ON SSerialReceived # Data = off DO Power1 0 ENDON receiving on and off results in MQT: tele/mqttTopic/RESULT = {\"SSerialReceived\":\"on\"} RUL: SSERIALRECEIVED#DATA=ON performs \"Power1 1\" MQT: stat/mqttTopic/RESULT = {\"POWER\":\"ON\"} MQT: stat/mqttTopic/POWER = ON MQT: tele/mqttTopic/RESULT = {\"SSerialReceived\":\"off\"} RUL: SSERIALRECEIVED#DATA=OFF performs \"Power1 0\" MQT: stat/mqttTopic/RESULT = {\"POWER\":\"OFF\"} MQT: stat/mqttTopic/POWER = OFF","title":"Control relays via serial"},{"location":"Rules/#processing-json-received-from-softwareserialbridge","text":"When using SerialBridge (or SoftwareSerialBrigde) , the received string will be published to Rules as SerialReceived (or SSerialReceived) . If the string starts with a { then Tasmota will parse the string as a JSON and make the different keys available for Rules. For example with the following string {\"DeviceID\":\"TM182\",\"Temp\":25.3,\"Hum\":50} , it is possible to use any of the keys in the trigger. rule1 ON SSerialReceived#DeviceID DO var1 %value% ENDON ON SSerialReceived#Temp DO var2 %value% ENDON ON SSerialReceived#Hum DO publish /some/topic/%var1% {\"Temperature\":%var2%,\"Humidity\":%value%} ENDON The 1st and 2nd rules store the values for Device and Temp into variables. The last key triggers the 3rd rule, here re-publication on a different topic. Execution: 12:51:48.050 MQT: tele/nodemcu/SSERIALRECEIVED = {\"SSerialReceived\":{\"DeviceID\":\"TM182\",\"Temp\":25.3,\"Hum\":50}} 12:51:48.064 RUL: SSERIALRECEIVED#DEVICEID performs \"var1 TM182\" 12:51:48.071 MQT: stat/nodemcu/VAR = {\"Var1\":\"TM182\"} 12:51:48.083 RUL: SSERIALRECEIVED#TEMP performs \"var2 25.3\" 12:51:48.091 MQT: stat/nodemcu/VAR = {\"Var2\":\"25.3\"} 12:51:48.104 RUL: SSERIALRECEIVED#HUM performs \"publish /some/topic/TM182 {\"Temperature\":25.3,\"Humidity\":50}\" 12:51:48.110 MQT: /some/topic/TM182 = {\"Temperature\":25.3,\"Humidity\":50} Note It is important that the receive string strictly starts with the opening { . If other characters, such as spaces or new line are inserted before, Tasmota will not par as a JSON. Characters after the closing } are not a problem.","title":"Processing JSON received from (Software)SerialBridge"},{"location":"Rules/#using-break-to-simulate-ifelseifelseendif","text":"BREAK is an alternative to ENDON . BREAK will stop the execution for the triggers that follow. If a trigger that ends with BREAK fires, then the following triggers of that rule will not be executed. This allows to simulate IF..ELSEIF..ELSE..ENDIF Example: IF temp > 85 then VAR1 more85 ELSEIF temp > 83 then VAR1 more83 ELSEIF temp > 81 then VAR1 more81 ELSEIF temp = 81 then VAR1 equal81 ELSE VAR1 less81 ENDIF With the actual rules, if we use a set like the following: Rule1 ON event # temp > 85 DO VAR1 more85 ENDON ON event # temp > 83 DO VAR1 more83 ENDON ON event # temp > 81 DO VAR1 more81 ENDON ON event # temp = 81 DO VAR1 equal81 ENDON ON event # temp < 81 DO VAR1 less81 ENDON This is the output in the console: CMD: rule MQT: stat/living/RESULT = {\"Rule1\":\"ON\",\"Once\":\"ON\",\"StopOnError\":\"OFF\",\"Free\":322,\"Rules\":\"ON event#temp>85 do VAR1 more85 ENDON ON event#temp>83 do VAR1 more83 ENDON on event#temp>81 do VAR1 more81 ENDON on event#temp=81 do VAR1 equal81 ENDON on event#temp<81 DO VAR1 less81 ENDON\"} CMD: event temp=10 MQT: stat/living/RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP<81 performs \"VAR1 less81\" MQT: stat/living/RESULT = {\"Var1\":\"less81\"} CMD: event temp=100 MQT: stat/living/RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP>85 performs \"VAR1 more85\" MQT: stat/living/RESULT = {\"Var1\":\"more85\"} RUL: EVENT#TEMP>83 performs \"VAR1 more83\" MQT: stat/living/RESULT = {\"Var1\":\"more83\"} RUL: EVENT#TEMP>81 performs \"VAR1 more81\" MQT: stat/living/RESULT = {\"Var1\":\"more81\"} So, all the triggers where TEMP>100, are firing. With the BREAK statement the rule set can be changed to: Rule on event # temp > 85 do VAR1 more85 break on event # temp > 83 do VAR1 more83 break ON event # temp > 81 DO VAR1 more81 ENDON ON event # temp = 81 DO VAR1 equal81 ENDON ON event # temp < 81 DO VAR1 less81 ENDON Which will result in the following output: CMD: rule RSL: RESULT = {\"Rule1\":\"ON\",\"Once\":\"OFF\",\"StopOnError\":\"OFF\",\"Free\":321,\"Rules\":\"ON event#temp>85 do VAR1 more85 break ON event#temp>83 do VAR1 more83 break on event#temp>81 do VAR1 more81 ENDON on event#temp=81 do VAR1 equal81 ENDON on event#temp<81 DO VAR1 less81 ENDON\"} CMD: event temp=10 RSL: RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP<81 performs \"VAR1 less81\" RSL: RESULT = {\"Var1\":\"less81\"} CMD: event temp=100 RSL: RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP>85 performs \"VAR1 more85\" RSL: RESULT = {\"Var1\":\"more85\"} CMD: event temp=83 RSL: RESULT = {\"Event\":\"Done\"} RUL: EVENT#TEMP>81 performs \"VAR1 more81\" RSL: RESULT = {\"Var1\":\"more81\"}","title":"Using BREAK to simulate IF..ELSEIF..ELSE..ENDIF"},{"location":"Rules/#adjust-powerdelta-according-to-current-power-values","text":"Power sensor reporting thresholds are set by a percentage change in the Power value by setting PowerDelta . Power changes from 10W to 11W (10%) may not be very interesting. But power changes from 1000W to 1100W (also 10%) could be very important. To avoid getting reports for small changes but ensuring that larger power swings are reported, a rule set can be used to create a gradient threshold based on the absolute power values. This rule also uses the one-shot feature of rules to avoid reporting of every small change within a threshold window. The rule (a ON/DO/ENDON rule in this the set) will trigger only once when a threshold is crossed. Backlog PowerDelta 0 ; Rule1 0 ; Rule1 5 Rule1 ON ENERGY # Power >= 35 DO Backlog PowerDelta 10 ; Status 8 BREAK ON ENERGY # Power >= 15 DO Backlog PowerDelta 25 ; Status 8 BREAK ON ENERGY # Power > 5 DO Backlog PowerDelta 35 ; Status 8 BREAK ON ENERGY # Power <= 5 DO PowerDelta 100 ENDON Rule1 1 Which translates (pseudo code): IF ENERGY # Power >= 35 // ENERGY # Power GE 35 DO Backlog PowerDelta 10 ; Status 8 ELSE IF ENERGY # Power >= 15 // ENERGY # Power GE 15 and LT 35 DO Backlog PowerDelta 25 ; Status 8 ELSE IF ENERGY # Power > 5 // ENERGY # Power GT 5 and LT 15 DO Backlog PowerDelta 35 ; Status 8 ELSE // ENERGY # Power changed ( i . e . LE 5 ) DO PowerDelta 100","title":"Adjust PowerDelta according to current Power values"},{"location":"Rules/#forward-ir-signals","text":"Using one IR receiver and one sender (or both extender) you can simply forward signals from one to another using the following rule rule1 ON IRreceived # Data DO publish cmnd / irsideboard / irsend { Protocol:NEC , Bits: 32 , Data:% value % } ENDON","title":"Forward IR signals"},{"location":"Rules/#garage-door-opener","text":"( #3942 ) // Set the relay on time to signal the opener PulseTime 7 // Send ON and OFF as the switch is ON or OFF Backlog SwitchMode1 1 ; SwitchMode2 1 ; SwitchMode3 1 //No need to save changes on power cycle SetOption0 0 //Don\u2019t blindly run the door on power up PowerOnState 0 //One shot Detection off Backlog Rule1 0 ; Rule1 4 ; Rule2 0 ; Rule2 4 ; Rule2 0 ; Rule2 4 //Set Counter to measure the period between on and off, check if its blinking because of an obstruction Backlog CounterType 1 ; CounterDebounce 100 //So the door doesn't close if you send it an Open when it's already Opened, etc. // var1=1 Only When OPEN // var2=1 Only When CLOSED // var3=1 Only When OPENING // var4=1 Only When CLOSING Rule1 ON Switch1 # Boot = 1 DO Backlog delay 99 ; event Opened ENDON ON Switch2 # Boot = 1 DO Backlog delay 99 ; event Closed ENDON ON EVENT # OPEN DO Power1 % var2 % ENDON ON EVENT # CLOSE DO Power1 % var1 % ENDON ON EVENT # STOP DO Backlog Power1 % var3 % ; Power1 % var4 % ; event PState = STOP ENDON ON Switch1 # State = 1 DO event Opened ENDON ON Switch2 # State = 1 DO event Closed ENDON ON Switch1 # State = 0 DO event Closing ENDON ON Switch2 # State = 0 DO event Opening ENDON Rule2 ON event # Opened DO Backlog var 1 ; var2 0 ; var3 0 ; var4 0 ; ruletimer1 0 ; event PState = OPEN ENDON ON event # Closed DO Backlog var1 0 ; var2 1 ; var3 0 ; var4 0 ; ruletimer1 0 ; event PState = CLOSE ENDON ON event # Opening DO Backlog var1 0 ; var2 0 ; var3 1 ; var4 0 ; ruletimer1 15 ; event PState = OPENING ENDON ON event # Closing DO Backlog var1 0 ; var2 0 ; var3 0 ; var4 1 ; ruletimer1 15 ; event PState = CLOSING ENDON Rule3 ON counter # c1 > 1000 DO event PObstr = 0 ENDON ON counter # c1 < 1000 DO event PObstr = 1 ENDON ON event # PObstr DO publish stat / GarageDoor / OBSTR % value % ENDON ON event # PState DO publish stat / GarageDoor / STATE % value % ENDON ON rules # timer = 1 DO event PState = STOP ENDON //Turn on Rules Backlog Rule1 1 ; Rule2 1 ; Rule3 1","title":"Garage Door Opener"},{"location":"Rules/#ir-remote-button-multi-press","text":"For example, a remote control with one button to change speed. This rules simulates pressing the button three times to set the receiving device to the third speed setting. Specify the rule set The <trigger> can be a a condition or an event sent from another device or home automation hub. <topic> corresponds to the device transmitting the code (e.g., YTF IR Bridge ). This could also be modified to send an RF code from a Sonoff RF Bridge . The Delay may not be necessary in your environment or may need to be adjusted according to your device characteristics. Rule 1 ON Event # tora DO Backlog Publish cmnd /< topic >/ IRSend { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF30CF\" }; Delay 10 ENDON ON < trigger > DO Backlog Event tora ; Event tora ; Event tora ENDON Enable the Rule set Rule1 1","title":"IR Remote Button Multi-press"},{"location":"Rules/#two-way-light-switches-without-mqtt","text":"Two Sonoff T1 3-gang light switches can be used at either end of a room by setting up one the master and the other as the slave. The master performs the switching of the power to the lights, while the slave just asks the master to toggle the power state. The master also turns the slave's relays on and off so that the LED indicators follow the master's state. Using the WebSend command, the two switches can talk to each other without an MQTT broker. It remains to be seen how reliable this is. Starting with the slave, the rule to toggle the master is pretty simple: Rule1 ON Event # sendPower DO WebSend [ 192.168 . 0.74 ] POWER % value % TOGGLE ENDON ON Button1 # State DO Event sendPower = 1 ENDON ON Button2 # State DO Event sendPower = 2 ENDON ON Button3 # State DO Event sendPower = 3 ENDON Rule1 1 Note that having a rule for the Button#State disables the power toggling of the slave's relay(s). This is desirable because we want the master to control the slave's relay state(s) according to its own as follows: Rule1 ON Event # sendPower DO WebSend [ 192.168 . 0.144 ] POWER % Var1 % % value % ENDON ON Power1 # state DO Backlog Var1 1 ; Event sendPower =% value % ENDON ON Power2 # state DO Backlog Var1 2 ; Event sendPower =% value % ENDON ON Power3 # state DO Backlog Var1 3 ; Event sendPower =% value % ENDON Rule1 1","title":"Two-way light switches without MQTT"},{"location":"Rules/#control-remote-light-on-switch-double-press","text":"Toggling the switch controls local POWER state while toggling twice fast controls another device. Great with two SONOFF MINI in adjacent rooms, to control both rooms with either switch. SwitchMode 8 Rule1 ON switch1 # state = 3 DO websend [ ip / hostname of remote ] power1 toggle ENDON Rule1 1","title":"Control remote light on switch double press"},{"location":"Rules/#roller-shutter-push-button-toggle","text":"With a two relay device (e.g., Shelly 2.5) configured for a roller shutter, you can also connect push-buttons (configured as switch components in this example) and set them for inverted toggle behavior. Pressing a push-button once makes the roller shutter move in one direction. Pressing it again stops it. These rules each use a variable to remember the shutter state where 0 == Stopped and 1 == Moving . Backlog SwitchTopic 0 ; SwitchMode1 4 ; SwitchMode2 4 Rule1 ON Switch1 # State == 1 DO Add1 1 ENDON ON Var1 # State == 0 DO ShutterStop1 ENDON ON Var1 # State == 1 DO ShutterClose1 ENDON ON Var1 # State >= 2 DO Var1 0 ENDON ON Shutter1 # Close DO Var1 0 ENDON ON Switch2 # State == 1 DO Add2 1 ENDON ON Var2 # State == 0 DO ShutterStop1 ENDON ON Var2 # State == 1 DO ShutterOpen1 ENDON ON Var2 # State >= 2 DO Var2 0 ENDON ON Shutter1 # Open DO Var2 0 ENDON Rule1 1","title":"Roller shutter push-button toggle"},{"location":"Rules/#control-a-dimmer-with-one-switch","text":"This example is for GPIOs defined as switches not buttons Activate dimmer mode with Switchmode 11 and shorten long press time to 1 second ( Setoption32 10 ). A short press of the switch sends a TOGGLE message to toggle the dimmer. A long press sends repeated INC_DEC messages to increment the dimmer. If a second press of the switch follows the first press a INV message is sent to invert the function from increment to decrement and repeated INC_DEC messages are sent to decrement the dimmer. After releasing the switch a timeout message CLEAR resets the automation Backlog SwitchMode 11 ; SetOption32 10 ; Rule1 1 ; Rule1 on system # boot do var1 + ENDON on switch1 # state = 2 do POWER TOGGLE ENDON on switch1 # state = 4 do DIMMER % var1 % ENDON on switch1 # state = 7 do event upordown =% var1 % ENDON on event # upordown =+ do var1 - ENDON on event # upordown =- do var1 + ENDON Notice we use Rule which edits Rule1 rule set. They can be used interchangeably.","title":"Control a dimmer with one switch"},{"location":"Rules/#watchdog-for-wi-fi-router-or-modem","text":"The ping method requires #define USE_PING and Tasmota version 8.2.0.3 or newer The WebQuery method requires Tasmota version 10.0.0 or newer A Tasmota plug can check a remote host (router itself, something else connected to the router, or a site on the Internet) via an ICMP Ping or loading a URL and can power cycle the router or modem if the remote host isn't responding. In this example, an interval of 3 minutes is used. The simplest watchdog rule does not use variables: Rule1 ON Time # Minute | 3 DO backlog Ping4 192.168 . 1.10 ENDON ON Ping # 192.168 . 1.10 # Success == 0 DO Backlog Power1 0 ; Delay 10 ; Power1 1 ; ENDON Rule1 1 However, if the endpoint becomes unreachable for a long time, the watchdog will keep cycling it every three minutes. This could reduce the watchdog's relay lifetime to months, at most years. A safer option would be to use an exponential backoff algorithm. Var1 contains the current interval in minutes, which is tripled after each failed query, but limited to 1439 minutes (1 day). Rule1 ON system # boot do Var1 3 ENDON ON Var1 # State > 1439 DO Var1 1439 ENDON ON Time # Minute |% var1 % DO backlog Ping4 192.168 . 1.10 ENDON ON Ping # 192.168 . 1.10 # Success == 0 DO backlog Mult1 3 ; Power1 0 ; Delay 10 ; Power1 1 ENDON ON Ping # 192.168 . 1.10 # Success > 0 DO Var1 3 ENDON If your Tasmota doesn't have ping compiled in and your remote host has an HTTP server you can access, you can use WebQuery as below: Rule1 ON system # boot do Var1 3 ENDON ON Var1 # State > 1439 DO Var1 1439 ENDON ON Time # Minute |% var1 % DO backlog WebQuery http :/ 192.168 . 1.10 / GET ENDON ON WebQuery # Data $! Done DO backlog Mult1 3 ; Power1 0 ; Delay 10 ; Power1 1 ENDON ON WebQuery # Data = Done DO Var1 3 ENDON Triggering off the JSON response to webquery (and other commands) may require wrapping the command in backlog, as per example above","title":"Watchdog for Wi-Fi router or modem"},{"location":"Rules/#simple-thermostat-example","text":"As example, to be used on a Sonoff TH10 with Sensor Si7021 This example turn on and off an output based on the temperature value and the upper set point and the lower set point. It waits until is enabled by pressing the button or by mqtt message 1 to mem1. This value is remembered. So if power cycle occurs, will resume operation. The set point values can be changed on the fly by mqtt or console commands If the Temperature sensor disconnects, the outputs will shutdown until the sensor is back again and will resume operation. When the device is power up, the thermostat also waits until the sensor value to resume operation. Initial Config: Available physical button as Switch1 Relay1 will be used the controller Rules must be used to control Relay so the pushbutton must only control Switch1 and not directly control the relay - For this we use SwitchMode1 3 as described below and create the necessary rules because the pushbutton control of the relay is only disabled when the rules are in place. Initial config on console: SwitchMode1 3 <- Use the switch1 as pushbutton (It will allow us to disable the link between the button and the relay by inserting a rule to dictate what the pushbutton will do - NOTE: Until rules are created the pushbutton will still control the relay! ) Rule1 1 <- turn on rules Rule1 4 <- turn off one-shot rule TelePeriod 60 <- check temp every minute SetOption26 1 <- use Power1 on mqtt messages SetOption0 0 <- dont save relay status on eeprom PowerOnState 0 <- start all relays off Mem1 0 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 Mem2 25 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 Mem3 23 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 Var1 0 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1","title":"Simple Thermostat Example"},{"location":"Rules/#solar-heater-control","text":"In a swimming pool, a filter pump and a solar panel is installed. When the sun is shining, the pump should push water through the solar panel, to heat the pool. When it's night or cloudy, the pump should be off, to avoid cooling the pool water through the solar panel. The pump is controlled by a Sonoff TH10 with 2x DS18B20 sensors connected. 3 rules: Pump should start when solar panel is more than 2 deg warmer than the pool water Pump should stop when solar panel is less than 1 deg warmer than the pool water Pump should not start if the solar panel is below 25 deg Celsius. t1 : pool temp t2 : panel temp var1 : in valid panel temp range? var2 : off threshold temp for panel var3 : on threshold temp for panel mem3 : lowest valid panel temp mem3 25 rule1 ON DS18B20 - 1 # temperature DO event t1 =% value % ENDON ON DS18B20 - 2 # temperature DO event t2 =% value % ENDON ON event # t2 >% mem3 % DO var1 1 ENDON ON event # t2 <=% mem3 % DO var1 0 ENDON ON event # t1 DO Backlog var2 % value % ; add2 1 ENDON ON event # t1 DO Backlog var3 % value % ; add3 2 ENDON ON event # t2 >% var3 % DO Power1 % var1 % ENDON ON event # t2 <% var2 % DO Power1 0 ENDON To test the rule without having the sensors in place, simply enter the events for t1 and t2 in the console: Backlog event t1=21;event t2=30 And watch the relay turn on and off based on the values. Please note that this example does not support manual override or handles missing sensor data.","title":"Solar heater control"},{"location":"Rules/#energy-saving-switch","text":"Example of a switch controlling a light with a condition of a required amount of lux. When the switch is on, the light will turn on but only when you have less than 100 lux in that room. While if the switch is off the light will be off. Rule1 ON switch1 # state = 1 DO var1 100 ENDON ON switch1 # state = 0 DO Backlog var1 0 ; Power1 off ENDON ON APDS9960 # Ambient <% var1 % DO Power1 on ENDON","title":"Energy Saving Switch"},{"location":"Rules/#use-of-variables-and-tele-in-domoticz","text":"Using variables allows for storing sensor results to be used in composing a single HA message like used with Domoticz. To prevent flooding Domoticz with messages we only want to send a message at TelePeriod time. This is achieved by prefixing the <SensorName> with the label tele- . This example will use a variable storing the temperature to be used together with humidity in one Domoticz MQTT message. Domoticz configured with a virtual sensor Temp+Hum using Idx 134 Rule Rule ON tele - am2301 - 12 # temperature DO var1 % value % ENDON ON tele - am2301 - 12 # humidity DO publish domoticz / in { \"idx\" : 134 , \"svalue\" : \"%var1%;%value%;1\" } ENDON Result - As a result of the tele- prefix the rules will be checked at TelePeriod time for sensor AM2301-12 Temperature and Humidity. The first rule will use the Temperature stored in %value% and save it in %var1% for future use. The second rule will use the Humidity stored in %value% and the Temperature stored in %var1% to compose a single MQTT message suitable for Domoticz.","title":"Use of variables and tele- in Domoticz"},{"location":"Rules/#publish-maximum-value-from-sensor-in-a-time-period","text":"This rule stores the sensor value in var1 . When the current value is greater than the previous, var1 is updated. If the current value is smaller, var1 remains unchanged. Then every minute, var1 is published and reset. This results in publication of the maximum/peak value for the last minute. Useful, for example in a decibel meter, when the peak value is important, rather than the value that is occurring by chance at normal telemetry time. This example uses Analog Range mode (trigger analog#range ) which is a scaled output value (the raw analog value would be analog#a0 ). On ESP32 which supports multiple ADC inputs, the ADC index must be appended such as analog#range1 for ADC#1. Rule ON analog#range>%var1% DO VAR1 %value% ENDON ON Time#Minute DO Backlog publish shed/tele/maxdb %var1%; var1 0 ENDON Rule 1 1","title":"Publish Maximum Value from sensor in a time period"},{"location":"Rules/#rf-repeater-ir-repeater","text":"In some applications, an RF-Repeater may come in handy to increase the range of RF based devices. We need to use RF reciever and RF transmitter modules with tasmota powered controllers. The following rule looks for data received by the RF receiver and re transmits the same over the transmitter. Rule1 on RfReceived # data do Rfsend { \"Data\" :% value % , \"Bits\" : 24 , \"Protocol\" : 1 , \"Pulse\" : 454 } endon Enable it with Rule1 1 A similar concept can also work for IR- Repeater. Connect IR receiver module and IR trnasmitter to Tasmotized device and the following rule retransmits any data over IR Rule1 on IrReceived # Data do IRsend { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" :% value % } endon Enable it with Rule1 1 The only catch is that the protocol needs to be setup in the rule. Most likely this can be taken care of by using a more complex rule maybe using variables. Would update in future","title":"RF Repeater / IR Repeater"},{"location":"SDS011/","text":"SDS011 air quality sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_NOVA_SDS #define USE_NOVA_SDS // Add support for SDS011 and SDS021 particle concentration sensor (+1k5 code) #define STARTING_OFFSET 30 // Turn on NovaSDS XX-seconds before tele_period is reached #endif Nova PM Sensor SDS011 can measure the air quality very accurately by measuring air particles or dust based on laser detection. Specifications: Voltage: 4.7 - 5.3V DC (5V DC with <20mV ripple advised) Power consumption: 70mA \u00b110mA (in operation), <4mA (laser and fan sleep mode) Measuring range: 0.0-999.9 \u03bcg/m3 PM2.5 and PM10 output See manufacturer site for more information. Configuration ~ Wiring ~ SDS011 ESP GND GND 5V 5V TX GPIO RX RX GPIO TX Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIO RX to SDS0X1 Tx (101) 2. GPIO TX to SDS0X1 Rx (70) To extend the lifetime of the sensor, you can use the command Sensor20 in association with setting TelePeriod for how often you want the fan to run and the sensor to be polled. Tasmota Main ~ After reboot of the device the displays the SDS011 measurements. OpenHab ~ Number Dust_Sensor_2_5 \"PM 2.5 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM2.5'])]\"} Number Dust_Sensor_10 \"PM 10 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM10'])]\"}","title":"SDS011 air quality sensor"},{"location":"SDS011/#sds011-air-quality-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_NOVA_SDS #define USE_NOVA_SDS // Add support for SDS011 and SDS021 particle concentration sensor (+1k5 code) #define STARTING_OFFSET 30 // Turn on NovaSDS XX-seconds before tele_period is reached #endif Nova PM Sensor SDS011 can measure the air quality very accurately by measuring air particles or dust based on laser detection. Specifications: Voltage: 4.7 - 5.3V DC (5V DC with <20mV ripple advised) Power consumption: 70mA \u00b110mA (in operation), <4mA (laser and fan sleep mode) Measuring range: 0.0-999.9 \u03bcg/m3 PM2.5 and PM10 output See manufacturer site for more information.","title":"SDS011 air quality sensor"},{"location":"SDS011/#configuration","text":"","title":"Configuration"},{"location":"SDS011/#wiring","text":"SDS011 ESP GND GND 5V 5V TX GPIO RX RX GPIO TX","title":"Wiring"},{"location":"SDS011/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIO RX to SDS0X1 Tx (101) 2. GPIO TX to SDS0X1 Rx (70) To extend the lifetime of the sensor, you can use the command Sensor20 in association with setting TelePeriod for how often you want the fan to run and the sensor to be polled.","title":"Tasmota Settings"},{"location":"SDS011/#tasmota-main","text":"After reboot of the device the displays the SDS011 measurements.","title":"Tasmota Main"},{"location":"SDS011/#openhab","text":"Number Dust_Sensor_2_5 \"PM 2.5 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM2.5'])]\"} Number Dust_Sensor_10 \"PM 10 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM10'])]\"}","title":"OpenHab"},{"location":"SHT30/","text":"SHT30 temperature sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_SHT3X #define USE_SHT3X // [I2cDriver15] Enable SHT3x (I2C address 0x44 or 0x45) or SHTC3 (I2C address 0x70) sensor (+0k7 code) #endif Wemos SHT30 Shield High Precision Humidity & Temperature (I 2 C) sensor From the Wemos SHT30 shield specs the SDA pin on the SHT30 shield is connected to D2 and the SCL pin to D1. Configuration ~ As a default the SHT30 uses I 2 C address 0x45 and is user changeable by short-circuiting the two soldering pads at the lower left-side of the sensor (see image below marked green). Also if no other I 2 C devices are connected to the Wemos it might be wise to short-circuit the three soldering pads at the upper left-side of the sensor (see image below marked red). This connects the pull-up resistors for I 2 C and biases the SCL and SDA pins to VCC. This is to avoid possible false detections of other sensors like VEML6070. Note: On the v2.1.0 board these pads are on the rear. Tasmota Settings ~ In the Configuration -> Configure Module page assign: D2 GPIO4 to I2C SDA D1 GPIO5 to I2C SCL After reboot of the device the temperature, humidity and dew point are displayed. Breakout Boards ~ Three versions are known to exist, they all share the same pinout. Lolin is the new name for Wemos going forward. v.1.0.0 - orignal design (retired) v.2.0.0 - detachable design v.2.1.0 - detachable design with TFT I2C connector","title":"SHT30 temperature sensor"},{"location":"SHT30/#sht30-temperature-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_SHT3X #define USE_SHT3X // [I2cDriver15] Enable SHT3x (I2C address 0x44 or 0x45) or SHTC3 (I2C address 0x70) sensor (+0k7 code) #endif Wemos SHT30 Shield High Precision Humidity & Temperature (I 2 C) sensor From the Wemos SHT30 shield specs the SDA pin on the SHT30 shield is connected to D2 and the SCL pin to D1.","title":"SHT30 temperature sensor"},{"location":"SHT30/#configuration","text":"As a default the SHT30 uses I 2 C address 0x45 and is user changeable by short-circuiting the two soldering pads at the lower left-side of the sensor (see image below marked green). Also if no other I 2 C devices are connected to the Wemos it might be wise to short-circuit the three soldering pads at the upper left-side of the sensor (see image below marked red). This connects the pull-up resistors for I 2 C and biases the SCL and SDA pins to VCC. This is to avoid possible false detections of other sensors like VEML6070. Note: On the v2.1.0 board these pads are on the rear.","title":"Configuration"},{"location":"SHT30/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: D2 GPIO4 to I2C SDA D1 GPIO5 to I2C SCL After reboot of the device the temperature, humidity and dew point are displayed.","title":"Tasmota Settings"},{"location":"SHT30/#breakout-boards","text":"Three versions are known to exist, they all share the same pinout. Lolin is the new name for Wemos going forward. v.1.0.0 - orignal design (retired) v.2.0.0 - detachable design v.2.1.0 - detachable design with TFT I2C connector","title":"Breakout Boards"},{"location":"SK6812/","text":"SK6812 RGBW Addressable LEDs ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_WS2812_HARDWARE NEO_HW_SK6812 #define USE_WS2812_CTYPE NEO_GRBW // Color type (NEO_RGB, NEO_GRB, NEO_BRG, NEO_RBG, NEO_RGBW, NEO_GRBW) Wiring with a level shifter is required. Look at WS2812B LEDs article for instructions. Tasmota Settings ~ In the Configuration -> Configure Module page, select the following: GPIOx to WS2812 Tasmota Main ~ After reboot of the device the color sliders and toggle button are displayed to control the LED. Set number of pixels used on your strip with Pixels x command Select whether use white in separate channel or blended with RGB colors . Configuration was done on a round 7 LED board and an ESP-01S Addressable LED adapter","title":"SK6812 RGBW Addressable LEDs"},{"location":"SK6812/#sk6812-rgbw-addressable-leds","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_WS2812_HARDWARE NEO_HW_SK6812 #define USE_WS2812_CTYPE NEO_GRBW // Color type (NEO_RGB, NEO_GRB, NEO_BRG, NEO_RBG, NEO_RGBW, NEO_GRBW) Wiring with a level shifter is required. Look at WS2812B LEDs article for instructions.","title":"SK6812 RGBW Addressable LEDs"},{"location":"SK6812/#tasmota-settings","text":"In the Configuration -> Configure Module page, select the following: GPIOx to WS2812","title":"Tasmota Settings"},{"location":"SK6812/#tasmota-main","text":"After reboot of the device the color sliders and toggle button are displayed to control the LED. Set number of pixels used on your strip with Pixels x command Select whether use white in separate channel or blended with RGB colors . Configuration was done on a round 7 LED board and an ESP-01S Addressable LED adapter","title":"Tasmota Main"},{"location":"SPS30/","text":"SPS30 Particulate sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_SPS30 // [I2cDriver30] Enable Sensiron SPS30 particle sensor (I2C address 0x69) (+1.7 code) Device information ~ The Sensirion SPS30 is a laser based, fan driven, MCERTS-certified particulate matter (PM) sensor with a I\u00b2C and UART interface ( datasheet ). The Tasmota driver implements the I\u00b2C interface. Mass Concentration Measurements ~ The device exposes the following data: Volumetric concentration (\u03bcg/m\u00b3): PM1.0, PM2.5, PM4 and PM10 Number concentration (binning, #/cm\u00b3): PM0.5, PM1.0, PM2.5, PM4 and PM10 Typical particle size (\u03bcm) Sampling ~ The module has a minimum sampling interval of 1 second in continuous mode (default). Automatic Cleaning ~ It implements an automatic fan cleaning routine, which sets the built-in fan speed to maximum for 10 seconds to clear out the detector chamber and accumulated dust on the fan blades. The default cleaning interval is 1 week of interrupted use, and resetting the sensor power also resets the built-in time counter for this. The current implementation does not support disabling this or setting a custom interval. Configuration ~ The sensor has a 5 pin JST ZHR type connector, with a 1.5mm pitch ( connector , datasheet ). Pin5 (SEL/Interface Select) must be shorted to Pin4/Ground to enable the I\u00b2C interface. The sensor and fan components require 5V VDD, so a 5V capable board (e.g. Wemos D1) or external power must be supplied. Finding appropriate connectors/cables for this module are somewhat cumbersome, SparkFun sells them with handy breadboard friendly breakout cables. Pin SPS30 ESP Comment 1 VDD + 5V \u00b1 10% 2 SDA GPIOx 5V and 3.3V compatible 3 SCL GPIOy 5V and 3.3V compatible 4 SEL - Pull to GRD to enable I\u00b2C 5 GND - Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After saving the board will reboot and the particulate measurements will be displayed on the main page.","title":"SPS30 Particulate sensor"},{"location":"SPS30/#sps30-particulate-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_SPS30 // [I2cDriver30] Enable Sensiron SPS30 particle sensor (I2C address 0x69) (+1.7 code)","title":"SPS30 Particulate sensor"},{"location":"SPS30/#device-information","text":"The Sensirion SPS30 is a laser based, fan driven, MCERTS-certified particulate matter (PM) sensor with a I\u00b2C and UART interface ( datasheet ). The Tasmota driver implements the I\u00b2C interface.","title":"Device information"},{"location":"SPS30/#mass-concentration-measurements","text":"The device exposes the following data: Volumetric concentration (\u03bcg/m\u00b3): PM1.0, PM2.5, PM4 and PM10 Number concentration (binning, #/cm\u00b3): PM0.5, PM1.0, PM2.5, PM4 and PM10 Typical particle size (\u03bcm)","title":"Mass Concentration Measurements"},{"location":"SPS30/#sampling","text":"The module has a minimum sampling interval of 1 second in continuous mode (default).","title":"Sampling"},{"location":"SPS30/#automatic-cleaning","text":"It implements an automatic fan cleaning routine, which sets the built-in fan speed to maximum for 10 seconds to clear out the detector chamber and accumulated dust on the fan blades. The default cleaning interval is 1 week of interrupted use, and resetting the sensor power also resets the built-in time counter for this. The current implementation does not support disabling this or setting a custom interval.","title":"Automatic Cleaning"},{"location":"SPS30/#configuration","text":"The sensor has a 5 pin JST ZHR type connector, with a 1.5mm pitch ( connector , datasheet ). Pin5 (SEL/Interface Select) must be shorted to Pin4/Ground to enable the I\u00b2C interface. The sensor and fan components require 5V VDD, so a 5V capable board (e.g. Wemos D1) or external power must be supplied. Finding appropriate connectors/cables for this module are somewhat cumbersome, SparkFun sells them with handy breadboard friendly breakout cables. Pin SPS30 ESP Comment 1 VDD + 5V \u00b1 10% 2 SDA GPIOx 5V and 3.3V compatible 3 SCL GPIOy 5V and 3.3V compatible 4 SEL - Pull to GRD to enable I\u00b2C 5 GND -","title":"Configuration"},{"location":"SPS30/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After saving the board will reboot and the particulate measurements will be displayed on the main page.","title":"Tasmota Settings"},{"location":"Safeboot/","text":"Safeboot Partition Layout ~ This page is specific to ESP32 and variants (not applicable to ESP8266) This feature was introduced in Tasmota v12 Safeboot partition layout is a new feature in Tasmota v12 that optimizes the use of Flash memory and allows for bigger filesystems and bigger firmware sizes. Before v12 ~ Tasmota used a standard partition layout consisting of 2 firmware partitions of equal sizes. One partition is active and is booted from, while the other partition receives the new code when an OTA (Over The Air) update occurs. This scheme is standard in ESP32 Arduino. Its main advantage is that it is very safe. If a power failure occurs during the OTA update, the device is not bricked and reboots on the untouched version. The main drawback is that it consumes a lot of flash space, enough to contains twice the firmware size. Example, standard Tasmota layout for 4MB flash: a fixed size 64KB system area 2x partitions of 1856KB each to receive Tasmota code a filesystem of 320KB Introducing Safeboot ~ We introduced a new variant of Tasmota called \"Safeboot\". It contains a minimal version of Tasmota used only for OTA, and a normal firmware. The main advantage is that it provides 1024KB of additional storage for firmware and/or filesystem. Example of new partition layout since v12: a fixed size 64KB system area a Safeboot partition of 832KB 1x partition of 2880KB to receive Tasmota code a filesystem of 320KB An alternate partition scheme is used in Sonoff Zigbee Bridge Pro: a fixed size 64KB system area a Safeboot partition of 832KB 1x partition of 1856KB to receive Tasmota code a filesystem of 1344KB Note: the Safeboot firmware is a reduced version of Tasmota containing only what's required for OTA updates (Web UI, MQTT, TLS...). However it does not save settings nor support initial Wi-Fi configuration.","title":"Safeboot Partition Layout"},{"location":"Safeboot/#safeboot-partition-layout","text":"This page is specific to ESP32 and variants (not applicable to ESP8266) This feature was introduced in Tasmota v12 Safeboot partition layout is a new feature in Tasmota v12 that optimizes the use of Flash memory and allows for bigger filesystems and bigger firmware sizes.","title":"Safeboot Partition Layout "},{"location":"Safeboot/#before-v12","text":"Tasmota used a standard partition layout consisting of 2 firmware partitions of equal sizes. One partition is active and is booted from, while the other partition receives the new code when an OTA (Over The Air) update occurs. This scheme is standard in ESP32 Arduino. Its main advantage is that it is very safe. If a power failure occurs during the OTA update, the device is not bricked and reboots on the untouched version. The main drawback is that it consumes a lot of flash space, enough to contains twice the firmware size. Example, standard Tasmota layout for 4MB flash: a fixed size 64KB system area 2x partitions of 1856KB each to receive Tasmota code a filesystem of 320KB","title":"Before v12"},{"location":"Safeboot/#introducing-safeboot","text":"We introduced a new variant of Tasmota called \"Safeboot\". It contains a minimal version of Tasmota used only for OTA, and a normal firmware. The main advantage is that it provides 1024KB of additional storage for firmware and/or filesystem. Example of new partition layout since v12: a fixed size 64KB system area a Safeboot partition of 832KB 1x partition of 2880KB to receive Tasmota code a filesystem of 320KB An alternate partition scheme is used in Sonoff Zigbee Bridge Pro: a fixed size 64KB system area a Safeboot partition of 832KB 1x partition of 1856KB to receive Tasmota code a filesystem of 1344KB Note: the Safeboot firmware is a reduced version of Tasmota containing only what's required for OTA updates (Web UI, MQTT, TLS...). However it does not save settings nor support initial Wi-Fi configuration.","title":"Introducing Safeboot"},{"location":"Scripting-Cookbook/","text":"","title":"Scripting Cookbook"},{"location":"Scripting-Language/","text":"Scripting ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_SCRIPT #define USE_SCRIPT // adds about 17k flash size, variable ram size #endif #ifdef USE_RULES #undef USE_RULES #endif Additional features are enabled by adding the following #define compiler directive parameters and then compiling the firmware. These parameters are explained further below in the article. Feature Description USE_BUTTON_EVENT enable >b section (detect button state changes) USE_SCRIPT_JSON_EXPORT enable >J section (publish JSON payload on TelePeriod ) USE_SCRIPT_SUB_COMMAND enables invoking named script subroutines via the Console or MQTT USE_SCRIPT_HUE enable >H section (Alexa Hue emulation) USE_HOMEKIT enable >h section (Siri Homekit support (ESP32 only), define must be given in platform_override see below) USE_SCRIPT_STATUS enable >U section (receive JSON payloads from cmd status) SCRIPT_POWER_SECTION enable >P section (execute on power changes) SUPPORT_MQTT_EVENT enables support for subscribe unsubscribe USE_SENDMAIL enable >m section and support for sending e-mail (on ESP32 you must add USE_ESP32MAIL) USE_SCRIPT_WEB_DISPLAY enable >W section (modify web UI) SCRIPT_FULL_WEBPAGE enable >w section (seperate full web page and webserver) USE_TOUCH_BUTTONS enable virtual touch button support with touch displays USE_WEBSEND_RESPONSE enable receiving the response of WebSend and WebQuery commands (received in section >E) SCRIPT_STRIP_COMMENTS enables stripping comments when attempting to paste a script that is too large to fit USE_ANGLE_FUNC add sin(x),acos(x) and sqrt(x) e.g. to allow calculation of horizontal cylinder volume USE_SCRIPT_FATFS_EXT enables additional FS commands USE_WEBCAM enables support ESP32 Webcam which is controlled by scripter cmds USE_FACE_DETECT enables face detecting in ESP32 Webcam USE_SCRIPT_TASK enables multitasking Task in ESP32 USE_LVGL enables support for LVGL USE_SCRIPT_GLOBVARS enables global variables and >G section USE_SML_M enables Smart Meter Interface SML_REPLACE_VARS enables posibility to replace the lines from the (SML) descriptor with Vars USE_SML_SCRIPT_CMD enables SML script cmds USE_SCRIPT_I2C enables I2C support USE_SCRIPT_SERIAL enables support for serial io cmds USE_LVGL enables support for LVGL USE_SCRIPT_TIMER enables up to 4 Arduino timers (so called tickers) SCRIPT_GET_HTTPS_JP enables reading HTTPS JSON WEB Pages (e.g. Tesla Powerwall) LARGE_ARRAYS enables arrays of up to 1000 entries instead of max 127 SCRIPT_LARGE_VNBUFF enables to use 4096 in stead of 256 bytes buffer for variable names USE_GOOGLE_CHARTS enables defintion of google charts within web section USE_FEXTRACT enables array extraction from database fxt(...) USE_SCRIPT_SPI enables support for SPI interface USE_DSIPLAY_DUMP enables to show epaper screen as BMP image in >w section Scripting Language for Tasmota is an alternative to Tasmota Rules . For ESP32 builds it is recommended to use Berry To enter a script, go to Consoles -> Edit Script in the Tasmota web UI menu (for version before 9.4, go to Configuration -> Edit script ) To save code space almost no error messages are provided. However it is taken care of that at least it should not crash on syntax errors. Features ~ Up to 50 variables (45 numeric and 5 strings - this may be changed by setting a compilation #define directive) Freely definable variable names (all variable names are intentionally case sensitive ) Nested if,then,else up to a level of 8 Math operators + , - , * , / , % , & , | , ^ , << , >> All operators may be used in the op= form, e.g., += Comparison operators == , != , > , >= , < , <= and , or support Hexadecimal numbers with prefix 0x are supported Strings support + and += operators Support for \\n \\r regular expressions on strings String comparison == , != String size is 19 characters (default). This can be increased or decreased by the optional parameter on the D section definition Script Interpreter ~ Execution is strictly sequential , line by line Evaluation is left to right with optional brackets All numbers are float , e.g., temp=hum*(100/37.5)+temp-(timer*hum%10) No spaces are allowed between math operators Comments start with ; Script buffer size ~ the script language normally shares script buffer with rules buffer which is 1536 chars. with below options script buffer size may be expanded. PVARS is size for permanent vars. Feature ESP ESP32 PVARS remarks fallback 1536 1536 50 no longer supported compression (default) 2560 2560 50 actual compression rate may vary #define USE_UFILESYS #define UFSYS_SIZE S S<=8192 S<=16384 1536 ESP must use 4M Flash use linker option -Wl,-Teagle.flash.4m2m.ld or SDCARD ESP32 can use any linker file, size of Filesystem depends on linker file #define EEP_SCRIPT_SIZE S #define USE_EEPROM #define USE_24C256 S<=8192 S<=16384 1536 for hardware eeprom only #define EEP_SCRIPT_SIZE 6200 #define USE_EEPROM S=6200 not supported 1536 script may be lost on OTA and serial flash, not on restart most useful definition for larger scripts would be ESP8266 ~ with 1M flash only default compressed mode should be used (or an SDCARD) a special compressed mode can enable up to 6200 chars by defining #define USE_EEPROM, #define EEP_SCRIPT_SIZE 6200 however this has some side effects. the script may be deleted on OTA or serial update and may have to be reinstalled after update. with 4M Flash best mode would be #define USE_UFILESYS with linker file \"eagle.flash.4m2m.ld\" ESP32 ~ with all linker files #define USE_UFILESYS script init error codes ~ after initialization the script reports some info in the console e.g: 20:21:28.259 Script: nv=51, tv=13, vns=279, vmem=3305, smem=4096 nv = number of used variables in total (numeric and strings) tv = number of used string variables vns = total size of name strings in bytes (may not exeed 255) or #define SCRIPT_LARGE_VNBUFF extents the size to 4095 vmem = used heap ram by the script (psram if available) smem = used script (text) memory (psram if available) if the script init fails an error code is reported: -1 = too many numerical variables defined -2 = too many string variables defined -3 = too many variables in total -4 = not enough memory -5 = variable name length too long in total -6 = too many arrays defined -7 = not enough memory you may increase the number of allowed variables with defines in user_config_override defaults and override defines: Number of total variables = 50 (#define MAXVARS) Number of string variables = 5 (#define MAXSVARS) Number of filters (arrays) = 5 (#define MAXFILT) Max string size = 20 (override with >D size up to 48) Optional external editor ~ you may use a special external editor with syntax highlighting to edit the scripts. (mac and pc) you may use any number of comments and indents to make it better readable. then with cmd r the script is transferred to the ESP and immediately started. (all comments and indents are removed before transferring) see further info and download here Console Commands ~ script <n> : 0 = switch script off; 1 = switch script on script ><cmdline> execute - Can be used to set variables, e.g., script >mintmp=15 - Multiple statements can be specified by separating each with a semicolon, e.g. script >mintmp=15;maxtemp=40 script?<var> queries a script variable var The script itself can't be specified because the size would not fit the MQTT buffers Script Sections ~ Section descriptors (e.g., >E ) are case sensitive a valid script must start with >D in the first line >D ssize ssize = optional max string size (default=19) define and init variables here, must be the first section, no other code allowed p:vname specifies permanent variables. The number of permanent variables is limited by Tasmota rules space (50 bytes) - numeric variables are 4 bytes; string variables are one byte longer than the length of string t:vname specifies countdown timers, if >0 they are decremented in seconds until zero is reached. see example below i:vname specifies auto increment counters if =0 (in seconds) g:vname specifies global variable which is linked to all global variables with the same definition on all devices in the homenet. when a variable is updated in one device it is instantly updated in all other devices. if a section >G exists it is executed when a variable is updated from another device (this is done via UDP-multicast, so not always reliable) m:vname specifies a median filter variable with 5 entries (for elimination of outliers) M:vname specifies a moving average filter variable with 8 entries (for smoothing data) (max 5 filters in total m+M) optional another filter length (1..127) can be given after the definition. Filter vars can be accessed also in indexed mode vname[x] (x = 1..N , x = 0 returns current array index pointer, x = -1 returns arry length, x = -2 returns array average) Using this filter, vars can be used as arrays, #define LARGE_ARRAYS allows for arrays up to 1000 entries array may also be permanent by specifying an extra :p m:p:vname defines a permanent array. Keep in mind however that in 1M Flash standard configurations you only have 50 bytes permanent storage which stands for a maximum of 12 numbers. (see list above for permanent storage in other configurations) arrays may also be preset in auto increment mode array=X sets the value at index array[0] and increments the index by 1. array = {x y z} sets 3 values in an array from index array[0] Tip Keep variable names as short as possible. The length of all variable names taken together may not exceed 256 characters. Memory is dynamically allocated as a result of the D section. Copying a string to a number or reverse is supported >B executed on BOOT time before sensors are initialized and on save script >BS executed on BOOT time after sensors are initialized >E Executed when a Tasmota MQTT RESULT message is received, e.g., on POWER change. Also Zigbee reports to this section. >F Executed every 100 ms >S Executed every second >R Executed on restart. p vars are saved automatically after this call >T Executed at least at TelePeriod time ( SENSOR and STATE ) but mostly faster up to every 100 ms, only put tele- vars in this section Remark: JSON variable names (like all others) may not contain math operators like - , you should set SetOption64 1 to replace - ( dash ) with _ ( underscore ). Zigbee sensors will not report to this section, use E instead. >H Alexa Hue interface (up to 32 virtual hue devices) ( example ) device , type , onVars Remark: hue values have a range from 0-65535. Divide by 182 to assign HSBcolors hue values. device device name type device type - E = extended color; S = switch onVars assign Hue \"on\" extended color parameters for hue, saturation, brightness, and color temperature (hue,sat,bri,ct) to scripter variables Example lamp1,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1,ct=ct1 >h passcode Siri Homekit interface (up to 16 virtual Homekit devices) passcode = 111-11-111 keep this format, numbers 0-9 name , type , opt , var1 , var2 ... name device name (max 23 characters) type device type (HAP_CID) - 7 = outlet, on/off - 5 = light, on/off,hue,sat,bri - 10 = sensor opt sensor type - 0 = Temperature,val - 1 = Humidity,val - 2 = Light level,val - 3 = Battery status,level,low battery,charging - 4 = Ambient light level with extended range -10000,+10000 - 5 = Contact Sensor (switch) var1 ... variable name (max 11 characters) the variables denote scripting variables that need to be set by script the special variables @px x (1..9) directly set, read power states e.g. relays @sx x (1..9) directly read switch state @bx x (1..9) directly read button state Example >h 111-11-111 outlet,7,0,@p1 lamp1,5,0,pwr,hue,sat,bri temperature,10,0,tval a restart is required after modification of descriptor! by faulty parameters the homekit dataset may get corrupted to reset the homekit dataset completely type in console script>hki(89) compilation: needs to add in linker to build_flags -DUSE_HOMEKIT lib_extra_dirs lib/libesp32_div >U JSON messages from cmd status arrive here >C HTML messages arrive here (on web user io event, (if defined USE_HTML_CALLBACK)) >G global variable updated section >P any power change triggers here (if defined SCRIPT_POWER_SECTION) >jp https webpage json parse arrives here >ti1 >ti2 >ti3 >ti4 ticker callback after timer expiration >b (note lower case) executed on button state change bt[x] read button state (x = 1.. MAX_KEYS ) Example >D tmp=0 >b tmp=bt[1] if tmp==0 then print falling edge of button1 endif if tmp==1 then print rising edge of button1 endif >J The lines in this section are published via MQTT in a JSON payload on TelePeriod . Requires compiling with #define USE_SCRIPT_JSON_EXPORT . >W The lines in this section are displayed in the web UI main page. Requires compiling with #define USE_SCRIPT_WEB_DISPLAY . You may put any html code here. Variables may be substituted using %var% HTML statements are displayed in the sensor section of the main page HTML statements preceded with a @ are displayed at the top of the page HTML statements preceded with a $ are displayed in the main section USER IO elements are displayed at the top of the page optionally these sections may be used >WS - HTML statements are displayed in the sensor section of the main page >WM - HTML statements are displayed in the main section of the main page for next loops are supported to repeat HTML code (precede with % char) %for var from to inc %next but this method is preferred: script subroutines may be called sub=name of subroutine, like normal subroutines %=#sub in this subroutine a web line may be sent by wcs (see below) thus allowing dynamic HTML pages =#sub(x) in any position of webline calls subroutine. this allows inserting content insa(array) in any position insert all elements from an array comma separated %/file calls a file from the file system and send its content to browser. in this file any cmds may apply. A web user interface may be generated containing any of the following elements: Button: bu(vn txt1 txt2) (up to 4 buttons may be defined in one row) vn = name of variable to hold button state txt1 = text of ON state of button txt2 = text of OFF state of button Pulldown: pd(vn label (xs) txt1 txt2 ... txtn) vn = name of variable to hold selected state label = label text xs = optional xs (default 200) txt1 = text of 1. entry txt2 = text of 2. entry and so on Checkbox: ck(vn txt (xs)) vn = name of variable to hold checkbox state txt = label text xs = optional xs (default 200) Slider: sl(min max vn ltxt mtxt rtxt) min = slider minimum value max = slider maximum value vn = name of variable to hold slider value ltxt = label left of slider mtxt = label middle of slider rtxt = label right of slider Text Input: tx(vn lbl (xs) (type min max)) vn = name of string variable to hold text state lbl = label text xs = optional xs (default 200) type min max = optional strings type = e.g \"datetime-local\" for date+time selector, min, max = date-time min max range Time Input: tm(vn lbl (xs)) vn = name of number variable to hold time HHMM as number e.g. 1900 means 19:00 lbl = label text xs = optional xs (default 70) Number Input: nm(min max step vn txt (xs) (prec)) min = number minimum value max = number maximum value step = number step value for up/down arrows vn = name of number variable to hold number txt = label text xs = optional xs (default 200) prec = optional number precision (default 1) special html options: so(flags) WSO_NOCENTER = 1 force elements not centered WSO_NODIV = 2 force elements not in extra \\<div> WSO_FORCEPLAIN = 4 send line in plain (no table elements) WSO_FORCEMAIN = 8 send lines in main mode ($ mode) Google Charts: google chart support requires arrays and to make sense also permanent arrays. Therefore on 4M Flash Systems the use of USE_UFILESYS is recommended while on 1 M Flash Systems the special EEPROM mode should be used (see above). other options may also be needed like LARGE_ARRAYS draws a google chart with up to 4 data sets per chart gc(T (size) array1 ... array4 \"name\" \"label1\" ... \"label4\" \"entrylabels\" \"header\" {\"maxy1\"} {\"maxy2\"}) T = type - b=barchart - c=columnchart - cs=columnchart stacked - C=combochart - p=piechart - l=linechart up to 4 lines with same scaling - l2=linechart with exactly 2 lines and 2 y scales (must be given at end) - lf2 like above but with splined lines - h=histogram - t=data table - g=simple gauges (must give extra 3 vars after header, yellow start, red start, maxval) - T=Timeline (special type arrays contains start,stop pairs in minutes timeofday) b,l,h type may have the '2' option to specify exactly 2 arrays with 2 y scales given at the end of parameter list. a very individual chart may be specified by splitting the chart definition and inserting the chart options directly see example below size = optional size, allows to use only part of an array, must be lower then array size array = up to 4 arrays of data name = name of chart label = label for up to the 4 datasets in chart entrylabel = labels of each x axis entry separated by '|' char (\"cntN\" starts numbering entries with the number N an optional /X generates numbers divided by X. Produce labels that cycle through the array indexes, starting with the number N. For instance, \"cnt6\" with an array of length 8 will produce the labels 6|7|0|1|2|3|4|5| Using \"cntN/X\" will then divide the numeric value of the label, so \"cnt6/2\" with an array of length 8 will produce the labels 3|3|0|0|1|1|2|2|) (\"wdh: before a week definition generates a week with full hours) header = visible header name of chart additionally you have to define the html frame to put the chart in (both lines must be preceded by a $ char) e.g. $<div id=\"chart1\"style=\"width:640px;height:480px;margin:0 auto\"></div> $gc(c array1 array2 \"wr\" \"pwr1\" \"pwr2\" \"mo|di|mi|do|fr|sa|so\" \"Solar feed\") you may define more then one chart. The charts id is chart1 ... chartN very customized chart definition: define a chart like above, but add a t to the definition this generates a google table from the arrays e.g.: &gc(lt array1 array2 \"wr\" \"pwr1\" \"pwr2\" \"mo|di|mi|do|fr|sa|so\") then define the options for the graph as from the doku of google e.g.: $var options = { $vAxes:{0:{maxValue:40,title:'Au\u00dfentemperatur'},1:{maxValue:60,title:'Solarspeicher'}}, $series:{0:{targetAxisIndex:0},1:{targetAxisIndex:1}}, $hAxis: {title: 'Wochenverlauf'}, $}; then gc(e) closes the definition $gc(e) >w ButtonLabel generates a button with the name \"ButtonLabel\" in Tasmota main menu. Clicking this button displays a web page with the HTML data of this section. all cmds like in >W apply here. these lines are refreshed frequently to show e.g. sensor values. lines preceded by $ are static and not refreshed and displayed below lines without $. this option also enables a full webserver interface when USE_UFILESYS is active. you may display files from the flash or SD filesystem by specifying the url: IP/ufs/path . (supported files: *.jpg, *.html, *.txt) >w1 >w2 >w3 >w4 >w5 >w6 some as above >w Requires compiling with #define SCRIPT_FULL_WEBPAGE . >M Smart Meter Interface If a variable does not exist, ??? is displayed for commands If a Tasmota SENSOR or STATUS or RESULT message is not generated or a Var does not exist the destination variable is NOT updated. Special Variables ~ (read only) upsecs = seconds since start uptime = minutes since start time = minutes since midnight sunrise = sunrise minutes since midnight sunset = sunset minutes since midnight tper = TelePeriod ( may be set also ) cbs = command text buffer size for tasmota cmds (default 256) ( may be set also ) tstamp = timestamp (local date and time) topic = mqtt topic gtopic = mqtt group topic lip = local ip as string luip = udp ip as string (from updating device when USE_SCRIPT_GLOBVARS defined) prefixn = prefix n = 1-3 frnm = friendly name dvnm = device name pwr[x] = power state (x = 1..N) npwr = number of tasmota power devices pc[x] = pulse counter value (x = 1..4) tbut[x] = touch screen button state (x = 1..N) sw[x] = switch state (x = 0..N) (Switch1 = sw[0] ) bt[x] = button state (x = 1..N) only valid in section b (if defined USE_BUTTON_EVENT) pin[x] = GPIO pin level (x = 0..16) pn[x] = GPIO for sensor code x. 99 if none pd[x] = defined sensor for GPIO x. 999 if none adc(fac (pin)) = get adc value (on ESP32 can select pin) fac is number of averaged samples (power of 2: 0..7) sht[x] = shutter position (x = 1..N) (if defined USE_SHUTTER) gtmp = global temperature ghum = global humidity gprs = global pressure pow(x y) = calculates exponential powers x^y (imprecise version only) med(n x) = calculates a 5 value median filter of x (2 filters possible n=0,1) int(x) = gets the integer part of x (like floor) hn(x) = converts x (0..255) to a hex nibble string hx(x) = converts x (0..65535) to a hex string hd(\"hstr\") = converts hex number string to a decimal number af(array index) = converts 4 bytes of an array at index index to float number hf(\"hstr\") = converts hex float number string to a decimal number hf(\"hstr\" r) = converts hex float number string (reverse byte order) to a decimal number st(svar c n) = string token - retrieve the n th element of svar delimited by c ins(s1 s2) = check if string s2 is contained in string s1, return -1 if not contained or position of contained string sl(svar) = gets the length of a string asc(svar) = gets the binary value of 1. char of a string sb(svar p n) = gets a substring from svar at position p (if p<0 counts from end) and length n is(num \"string1|string2|....|stringn|\") = defines a string array optionally preset with immediate strings separated by '|' (this immediate string may be up to 255 chars long) num = 0 read only string array, num > 0 number of elements in read write string array is[index] = gets string index from string array, if read-write also write string of index is1(..) , is2(...) string array see above is1[x] , is2[x] string array see above rr() = returns the reset reason of last restart (as string) s2hms(S) , converts seconds to HH:MM:SS string sin(x) = calculates the sinus(x) (if defined USE_ANGLE_FUNC) cos(x) = calculates the cosinus(x) (if defined USE_ANGLE_FUNC) acos(x) = calculates the acos(x) (if defined USE_ANGLE_FUNC) sqrt(x) = calculates the sqrt(x) (if defined USE_ANGLE_FUNC) abs(x) = calculates the absolute value of x mpt(x) = measure pulse time, x>=0 defines pin to use, -1 returns low pulse time,-2 return high pulse time (if defined USE_ANGLE_FUNC) rnd(x) = return a random number between 0 and x, (seed may be set by rnd(-x)) sf(F) = sets the CPU Frequency (ESP32) to 80,160,240 Mhz, returns current Freq. s(x) = explicit conversion from number x to string may be preceded by precision digits e.g. s(2.2x) = use 2 digits before and after decimal point I2C support #define USE_SCRIPT_I2C ia(AA) , ia2(AA) test and set I2C device with adress AA (on BUS 1 or 2), returns 1 if device is present iw(aa val) , iw1(aa val) , iw2(aa val) , iw3(aa val) write val to register aa (1..3 bytes) ir(aa) , ir1(aa) , ir2(aa) , ir3(aa) read 1..3 bytes from register aa Serial IO support #define USE_SCRIPT_SERIAL so(RXPIN TXPIN BR) open serial port with RXPIN, TXPIN and baud rate BR with 8N1 serial mode (-1 for pin means don't use) so(RXPIN TXPIN BR MMM) open serial port with RXPIN, TXPIN and baud rate BR and serial mode e.g 7E2 (all 3 modechars must be specified) so(RXPIN TXPIN BR MMM BSIZ) open serial port with RXPIN, TXPIN and baud rate BR and serial mode e.g 7E2 (all 3 modechars must be specified) and serial IRW buffer size sc() close serial port sw(STR) write the string STR to serial port swb(NUM) write the number char code NUM to serial port sa() returns number of bytes available on port sr() read a string from serial port, all available chars up to string size sr(X) read a string from serial port until charcode X, all available chars up to string size or until charcode X srb() read a number char code from serial port sp() read a number char code from serial port, don't remove it from serial input (peek) sra(ARRAY (flags)) fill an array from serial port, if USE_SML_M is enabled and Array size is 8 it is assumed to be a MODBUS request and the checksum is evaluated, if OK 8 is returned, else -2, or if flags is set Modbus response is assumed and checksum is calculated, 0 = standard Modbus, 1 = Rec BMA mode, return -2 on checksum error a sra(ARRAY (flags)) fill an array from serial port, if USE_SML_M is enabled and Array size is 8 it is assumed to be a MODBUS request and the checksum is evaluated, if OK 8 is returned, else -2, or if flags is set Modbus response is assumed and ckum is calculated, 0 = standard Modbus, 1 = Rec BMA mode swa(ARRAY len (flags)) send len bytes of an array to serial port, if flags is set Modbus cmd is assumed and cksum is calculated, 0 = standard Modbus, 1 = Rec BMA mode smw(ADDR MODE NUMBER) send a value with checksum to MODBUS Address, MODE 0 = uint16, 1 = uint32, 3 = float SPI IO support #define USE_SCRIPT_SPI spi(0 SCLK MOSI MISO) defines a software SPI port with pin numbers used for SCLK, MOSI, MISO. spi(0 -1 freq) defines a hardware SPI port with pin numbers defined by Tasmota GPIO definition with bus frequency in Mhz. spi(0 -2 freq) defines a hardware SPI port 2 on ESP32 with pin numbers defined by Tasmota GPIO definition. spi(1 N GPIO) sets the CS pin with index N (1..4) to pin Nr GPIO. spi(2 N ARRAY LEN S) sends and receives an ARRAY with len values with S (1..3) (8,16,24 bits) if N==-1 cs is ignored ttget(TNUM SEL) get tasmota timer setting from timer TNUM (1 .. 16) SEL: 0 = time 1 = time window 2 = repeat 3 = days 4 = device 5 = power 6 = mode 7 = arm mqtts = MQTT connection status: 0 = disconnected, >0 = connected wbut = button status of watch side button (if defined USE_TTGO_WATCH) wdclk = double tapped on display (if defined USE_TTGO_WATCH) wtch(sel) = gets state from touch panel sel=0 => touched, sel=1 => x position, sel=2 => y position (if defined USE_TTGO_WATCH) slp(time) = sleep time in seconds, pos values => light sleep, neg values => deep sleep (if defined USE_TTGO_WATCH) pl(\"path\") = play mp3 audio from filesystem (if defined USE_I2S_AUDIO or USE_TTGO_WATCH or USE_M5STACK_CORE2) say(\"text\") = plays specified text to speech (if defined USE_I2S_AUDIO or USE_TTGO_WATCH or USE_M5STACK_CORE2) c2ps(sel val) = gets, sets values on ESP32 CORE2 sel=0 green led, sel=1 vibration motor, sel=2,3,4 get touch button state 1,2,3 (if defined USE_M5STACK_CORE2) rec(path seconds) = rec n seconds wav audio file from i2s microphone to filesystem path (if defined USE_I2S_AUDIO or USE_M5STACK_CORE2) pwmN(-pin freq) = defines a pwm channel N (1..N) with pin Nr and frequency (pin 0 being -64, N=5 with esp8266 and N=8 with esp32) pwmN(val) = outputs a pwm signal on channel N (1..N) with val (0-1023) wifis = Wi-Fi connection status: 0 = disconnected, >0 = connected wcs = send this line to webpage (WebContentSend) wcf = flushes the web buffer (WSContentFlush) wfs = send this file to webpage rapp = append this line to MQTT (ResponseAppend) wm = contains source of web request code e.g. 0 = Sensor display (FUNC_WEB_SENSOR) acp(dst src) = copy array knx(code value) = sends a number value to KNX sml(m 0 bd) = set SML baud rate of Meter m to bd (baud) (if defined USE_SML_SCRIPT_CMD) sml(m 1 htxt) = send SML Hex string htxt as binary to Meter m (if defined USE_SML_SCRIPT_CMD) sml(m 2) = reads serial data received by Meter m into string (if m<0 reads hex values, else asci values)(if defined USE_SML_SCRIPT_CMD) sml(m 3 hstr) = inserts SML Hexstring variable hstr as binary to Meter m in Output stream e.g. for special MODBUS cmds, hstr must be a string variable NO string constant (if defined USE_SML_SCRIPT_CMD) sml[n] = get value of SML energy register n (if defined USE_SML_SCRIPT_CMD) smls[m] = get value of SML meter string info of meter m (if defined USE_SML_SCRIPT_CMD) smlv[n] = get SML decode valid status of line n (1..N), returns 1 if line decoded. n=0 resets all status codes to zero (if defined USE_SML_SCRIPT_CMD) smld(m) = call decoder of meter m smlj = read or write variable, when 0 disables MQTT output of SML. enrg[n] = get value of energy register n 0=total, 1..3 voltage of phase 1..3, 4..6 current of phase 1..3, 7..9 power of phase 1..3 (if defined USE_ENERGY_SENSOR) gjp(\"host\" \"path\") = trigger HTTPS JSON page read as used by Tesla Powerwall (if defined SCRIPT_GET_HTTPS_JP) gwr(\"del\" index) = gets non JSON element from webresponse del = delimiter char or string, index = n\u00b4th element (if defined USE_WEBSEND_RESPONSE) http(\"url\" \"payload\") = does a GET or POST request on an URL (http:// is internally added) tsN(ms) = set up to 4 timers (N=1..4) to millisecond time on expiration triggers section >tiN (if defined USE_SCRIPT_TIMER) hours = hours mins = mins secs = seconds day = day of month wday = day of week (Sunday=1,Monday=2;Tuesday=3;Wednesday=4,Thursday=5,Friday=6,Saturday=7) month = month year = year epoch = epoch time (from 2019-1-1 00:00) epoffs = set epoch offset, (must be no longer then 2 years to fit into single float with second precision) eres = result of >E section set this var to 1 in section >E to tell Tasmota event is handled (prevents MQTT) The following variables are cleared after reading true: chg[var] = true if a variables value was changed (numeric vars only) upd[var] = true if a variable was updated boot = true on BOOT tinit = true on time init tset = true on time set mqttc = true on mqtt connect mqttd = true on mqtt disconnect wific = true on Wi-Fi connect wifid = true on Wi-Fi disconnect System variables (for debugging) stack = stack size heap = free heap size pheap = PSRAM free heap size (ESP32) core = current core (0 or 1) (ESP32) ram = used ram size slen = script length freq = cpu frequency micros = running microseconds millis = running milliseconds loglvl = loglevel of script cmds ( may be set also ) Remarks: If you define a variable with the same name as a special variable that special variable is discarded Commands ~ => <command> Execute cmd with MQTT output enabled -> <command> Execute cmd with MQTT output disabled, recursion disabled. Do not send MQTT or log messages (i.e., silent execute - useful to reduce traffic) +> <command> Execute cmd with MQTT output enabled, recursion enabled. Warning Recursion : If you execute a tasmota cmd in an >E section and this cmd itself executes >E you will get an infinite loop. this is disabled normally and enabled by the +> in case you know what you are doing Variable Substitution - A single percent sign must be given as %% - Variable replacement within commands is allowed using %varname% . Optionally, the decimal places precision for numeric values may be specified by placing a digit ( %Nvarname% , N = 0..9 ) in front of the substitution variable (e.g., Humidity: %3hum%%% will output Humidity: 43.271% ) - instead of variables arbitrary calculations my be inserted by bracketing %N(formula)% - Linefeed and carriage return may be defined by \\n and \\r Special commands: print or =>print prints to the log for debugging A Tasmota MQTT RESULT message invokes the script's E section. Add print statements to debug a script. Example >E slider=Dimmer power=POWER if upd[slider]>0 then print slider updated %slider% endif if upd[power]>0 then print power updated %power% endif break exits a section or terminates a for next loop dpx sets decimal precision to x (0-9) dpx.y sets preceding digits to x and decimal precision to y (0-9) dp(x y) sets preceding digits to x and decimal precision to y svars save permanent vars delay(x) pauses x milliseconds (should be as short as possible) beep(f l) (ESP32) beeps with a passive piezo beeper. beep(-f 0) attaches PIN f to the beeper, beep(f l) starts a sound with frequency f (Hz) and len l (ms). f=0 stops the sound. spin(x b) set GPIO x (0..16) to value b (0,1). Only bit 0 of b is used - even values set the GPIO to 0 and uneven values set the GPIO to 1 spinm(x m) set GPIO x (0..16) to mode m (input=0, output=1, input with pullup=2,alternatively b may be: O=out, I=in, P=in with pullup) ws2812(array dstoffset) copies an array (defined with m:vname ) to the WS2812 LED chain. The array length should be defined as long as the number of pixels. Color is coded as 24 bit RGB. optionally the destination offset in the LED chain may be given if dstoffset is flagged by 0x1000, 2 values 16 bits each in an array are used for 32 bit RGBW pixels hsvrgb(h s v) converts hue (0..360), saturation (0..100) and value (0..100) to RGB color dt display text command (if #define USE_DISPLAY) Subroutines and Parameters #name names a subroutine. Subroutine is called with =#name #name(param) names a subroutine with a parameter. Each parameter variable must be declared in the '>D' section. A subroutine with multiple parameters is declared as '#name(p1 p2 p3)', i.e. spaces between parameters. A subroutine is invoked with =#name(param) or '=#name(p1 p2) Invoking a subroutine sets the parameter variable to the corresponding expression of the invocation. This means that parameter variables have script wide scope, i.e. they are not local variables to the subroutine. Subroutines end with the next # or > line or break. Subroutine invocations may be nested (each level uses about 600 bytes stack space, so nesting level should not exeed 4). Parameters can be numbers or strings and on type mismatch are converted. If #define USE_SCRIPT_SUB_COMMAND is included in your user_config_override.h , a subroutine may be invoked via the Console or MQTT using the subroutine's name. For example, a declared subroutine #SETLED(num) may be invoked by typing SETLED 1 in the Console. The parameter 1 is passed into the num argument. This also works with string parameters. since Tasmota capitalizes all commands you must use upper case labels. It is possible to \"replace\" internal Tasmota commands. For example, if a #POWER1(num) subroutine is declared, the command POWER1 is processed in the scripter instead of in the main Tasmota code. String parameter should be passed within double quotas: CUSTOMCMD \"Some string here\" =(svar) executes a routine whose name is passed as a string in a variable (dynamic or self modifying code). The string has to start with > or =# for the routine to be executed. a subroutine may return a value (number or string): return var a subroutine is called with: var=#sub(x) when returning a value or =#sub(x) when not returning a value D svar=\"=#subroutine\" S =(svar) #subroutine print subroutine was executed For loop (loop count must not be less than 1, no direct nesting supported) for var <from> <to> <inc> next Switch selector (numeric or string) switch x case a case b ends Conditional Statements There are two syntax alternatives. You may NOT mix both formats. if a==b and x==y or k==i then = do this else = do that endif or if a==b and x==y or k==i { = do this } else { = do that } Remarks: The last closing bracket must be on a separate line Calculations are permitted in conditional expressions, e.g., if var1-var2==var3*var4 Conditional expressions may be enclosed in parentheses. The statement must be on a single line. e.g., if ((a==b) and ((c==d) or (c==e)) and (s!=\"x\")) mapping function mp(x str1 str2 ... str ) It addresses a standard task with less code and much flexibility: mapping an arbitrary incoming numeric value into the allowed range. The numeric value x passed as the first parameter is compared to the rules in the order they are provided as subsequent sting parameters. If the value matches the criteria, the defined value is returned. Subsequent rules are skipped. If x matches none of the rules, x is returned unchanged. Rules consist of one of the comparison operators < > = followed by a numeric value v1, optionally followed by a colon and another numeric value v2. <|>|=v1[:v2] Example 1: <8:0 - this rule reads: If x is less than 8, return 0. Example 2: >100 - this rule reads: If x is greater than 100, return 100. Example 3: y=mp(x <8:0 >100) Assigns 0 to y if x is less than 8. Assigns 100 to y if x is greater than 100. Assigns x to y for all values of x that do not meet the above criteria (8 to 100). The above code of example 3 does the same as the following code - with just one line of code and 15 characters less: y=x if x<8 { y=0 } if x>100 { y=100 } E-mail #define USE_SENDMAIL Enabling this feature also enables Tasmota TLS as sendmail uses SSL. sendmail [server:port:user:passwd:from:to:subject] msg Example sendmail [smtp.gmail.com:465:user:passwd:<sender@gmail.com>:<rec@gmail.com>:alarm] %string% Remark: A number of e-mail servers (such as Gmail) require the receiver's e-mail address to be enclosed by angle brackets < ... > as in example above. Most other e-mail servers also accept this format. While ESP8266 sendmail needs brackets, ESP32 sendmail inserts brackets itself so you should not specify brackets here. Warning Don't use your Google account password with GMAIL SMTP server. You must create an Application specific password The following parameters can be specified during compilation via #define directives in user_config_override.h : * EMAIL_SERVER * EMAIL_PORT * EMAIL_USER * EMAIL_PASSWORD * EMAIL_FROM To use any of these values, pass an * as its corresponding argument placeholder. Example sendmail [*:*:*:*:*:<rec@gmail.com>:theSubject] theMessage Instead of passing the msg as a string constant, the body of the e-mail message may also be composed using the script m (note lower case) section. The specified text in this script section must end with an # character. sendmail will use the m section if * is passed as the msg parameter. in this >m section you may also specify email attachments. @/filename specifies a file to be attached (if file system is present) &arrayname specifies an array attachment (as tab delimited text, no file system needed) $N attach a webcam picture from rambuffer number N (usually 1) See [Scripting Cookbook Example].(#send-e-mail) Subscribe, Unsubscribe #define SUPPORT_MQTT_EVENT subscribe and unsubscribe commands are supported. In contrast to rules, no event is generated but the event name specifies a variable defined in D section and this variable is automatically set on transmission of the subscribed item within a script the subscribe cmd must be send with +> instead of => the MQTT decoder may be configured for more space in user config overwrite by #define MQTT_EVENT_MSIZE xxx (default is 256) #define MQTT_EVENT_JSIZE xxx (default is 400) File System Support #define USE_UFILESYS optional for SD_CARD: #define USE_SDCARD #define SDCARD_CS_PIN X X = GPIO of card chip select SD card uses standard hardware SPI GPIO: mosi,miso,sclk depending on used linker file you get a flash file system with the same functionality but very low capacity (e.g. 2 MB) A maximum of four files may be open at a time e.g., allows for logging sensors to a tab delimited file and then downloading the file ( see Sensor Logging example ) The script itself is also stored on the file system with a default size of 8192 characters fr=fo(\"fname\" m) open file fname, mode 0=read, 1=write, 2=append (returns file reference (0-3) or -1 for error) (alternatively m may be: r=read, w=write, a=append) res=fw(\"text\" fr) writes text to (the end of) file fr, returns number of bytes written res=fr(svar fr) reads a string into svar, returns bytes read. String is read until delimiter (\\t \\n \\r) or eof fc(fr) close file ff(fr) flush file, writes cached data and updates directory fd(\"fname\") delete file fname frn(\"spath\" \"dpath\") rename a file flx(fname) create download link for file (x=1 or 2) fname = file name of file to download fsm return 1 if filesystem is mounted, (valid SD card found) res=fsi(sel) gets file system information, sel=0 returns total media size, sel=1 returns free space both in kB fra(array fr) reads array from open file with fr (assumes tab delimited entries) fwa(array fr) writes array to open file with fr (writes tab delimited entries) fz(fr) returns file size fa(fr) returns number of available bytes in open file stream fs(fr pos) seek to file position pos fwb(byte fr) write byte to file frb(fr) read byte from file frw(fr url) read file from web url fxt(fr ts_from ts_to col_offs accum array1 array2 ... arrayn) read arrays from csv file from timestamp to timestamp with column offset and accumulate values into arrays1 .. N, assumes csv file with timestamp in 1. column and data values in colums 2 to n.(#define USE_FEXTRACT) fxto(... same as above with time optimized access cts(tstamp flg) convert timestamp to German locale format back and forth flg=0 to webformat, 1 to German format tso(tstamp day flag) add time offset in days to timestamp optional flg = char 0 zo zero time HH:MM:SS tsn(tstamp) convert timestamp to seconds Extended commands (+0,9k flash) #define USE_SCRIPT_FATFS_EXT fmd(\"fname\") make directory fname frd(\"fname\") remove directory fname fx(\"fname\") check if file fname exists fe(\"fname\") execute script fname (max 2048 bytes, script must start with the '>' character on the first line) ESP32 real Multitasking support #define USE_SCRIPT_TASK enables support for multitasking scripts res=ct(num timer core (prio) (stack)) creates a task num (1 or 2) with optional priority and stack size which is executed every timer (ms) time on core 0 or 1 the sections are named >t1 for task 1 >t2 for task 2 Example >D >B ; create task 1 every 1000 ms on core 0 ct(1 1000 0) ; create task 2 every 3000 ms on core 1 ct(2 3000 1) >t1 print task1 on core %core% >t2 print task2 on core %core% minimal LVGL support #define USE_LVGL to test LVGL a few functions are implemented: lvgl(sel ...) general lvgl call each object gets a concurrent number 1 ... N with which you can reference the object sel = 0 => initialize LVGL with current display sel = 1 => clear screen sel = 2 xp yp xs ys text => create a button. the button press is reported in section >lvb sel = 3 xp yp xs ys => create a slider. the slider move is reported in section >lvs sel = 4 xp yp xs ys min max => create a gauge. set = 5 objnr value => set gauge value. sel = 6 xp yp xs ys text => create a label. sel = 7 objnr text => set label text sel = 8 create a keyboard, just get a look and feel sel = 50 => get obj nr from caller in callback >lvb or >lvs sel = 51 => get event nr from caller in callback >lvb or >lvs sel = 52 => get slider value from caller in callback >lvs minimal LVGL support #define USE_LVGL to test LVGL a few functions are implemented: lvgl(sel ...) general lvgl call each object gets a concurrent number 1 ... N with which you can reference the object sel = 0 => initialize LVGL with current display sel = 1 => clear screen sel = 2 xp yp xs ys text => create a button. the button press is reported in section >lvb sel = 3 xp yp xs ys => create a slider. the slider move is reported in section >lvs sel = 4 xp yp xs ys min max => create a gauge. set = 5 objnr value => set gauge value. sel = 6 xp yp xs ys text => create a label. sel = 7 objnr text => set label text sel = 8 create a keyboard, just get a look and feel sel = 50 => get obj nr from caller in callback >lvb or >lvs sel = 51 => get event nr from caller in callback >lvb or >lvs sel = 52 => get slider value from caller in callback >lvs ESP32 Webcam support #define USE_WEBCAM Template for AI THINKER CAM : remarks: - GPIO0 zero must be disconnected from any wire after programming because this pin drives the cam clock and does not tolerate any capacitive load - Only boards with PSRAM should be used. To enable PSRAM board should be se set to esp32cam in common32 of platform_override.ini board = esp32cam - To speed up cam processing CPU frequency should be better set to 240Mhz in common32 of platform_override.ini board_build.f_cpu = 240000000L file system extension: fwp(pnum fr) write picture from RAM buffer number pnum to SD card file with file reference fr specific webcam commands: res=wc(sel p1 p2) control webcam, sel = function selector p1 ... optional parameters res=wc(0 pres) init webcam with picture resolution pres, returns 0 when error, 2 when PSRAM found, else 1 pres * 0 = FRAMESIZE_QQVGA, // 160x120 * 1 = FRAMESIZE_QQVGA2, // 128x160 * 2 = FRAMESIZE_QCIF, // 176x144 * 3 = FRAMESIZE_HQVGA, // 240x176 * 4 = FRAMESIZE_QVGA, // 320x240 * 5 = FRAMESIZE_CIF, // 400x296 * 6 = FRAMESIZE_VGA, // 640x480 * 7 = FRAMESIZE_SVGA, // 800x600 * 8 = FRAMESIZE_XGA, // 1024x768 * 9 = FRAMESIZE_SXGA, // 1280x1024 * 10 = FRAMESIZE_UXGA, // 1600x1200 res=wc(1 bnum) capture picture to rambuffer bnum (1..4), returns framesize of picture or 0 when error res=wc(2 sel p1) execute various controls, details below. res=wc(3) gets picture width res=wc(4) gets picture height res=wc(5 p) start stop streaming 0=stop, 1=start res=wc(6 p) start stop motion detector, p=0 => stop detector, p=T start detector with picture every T ms, -1 get picture difference, -2 get picture brightness res=wc(7 p) start stop face detector, p=0 => stop detector, p=T start detector with picture every T ms, -1 get number of faces found in picture (USE_FACE_DETECT must be defined) control cmds sel = * 0 fs = set frame size (see above for constants) * 1 se = set special effect 0 = no effect 1 = negative 2 = black and white 3 = reddish 4 = greenish 5 = blue 6 = retro 2 fl = set horizontal flip 0,1 3 mi = set vertical mirror 0,1 to read a value without setting pass -1 extensions to the email system on ESP32 #define SEND_EMAIL and #define USE_ESP32MAIL enables specific ESP32 mail server this server can handle more mail servers by supporting START_TLS remark: mail addresses must not be enclosed with <> because the server inserts them automatically this server also supports email attachments in the >m section you may write &/file.txt to attach a file from SD card $N N=1..4 to attach a picture from picture RAM buffer number N displaying webcam pictures in WEBUI you may display a webcam picture by giving the name /wc.jpg?p=N (1..4) for RAM picturebuffer N \"<img src=\"/wc.jpg?p=1\" alt=\"webcam image\" >\" you may also provide the picture size (h and v have to be preset before) \"<img src=\"/wc.jpg?p=1\" alt=\"webcam image\" style=\"width:%w%px;height:%h%px;\">\" if you precede the line by & char the image is displayed in the main section, else in the sensor tab section the webcam stream can be specified by the following line lip is a system variable containing the local device ip \"&<br>\" \"&<img src=\"http://%lip%:81/stream\" style=\"width:%w%px;height:%h%px\">\" \"&<br><center>webcam stream\" remark: the Flash illumination LED is connected to GPIO4 Example >D res=0 w=0 h=0 mot=0 bri=0 >B ; init cam with QVGA res=wc(0 4) ; get pixel size w=wc(3) h=wc(4) ; start motion detector, picture every 1000 ms mot=wc(6 1000) >S if wific>0 then ; when wifi up, start stream res=wc(5 1) endif ; get motion detect diff value mot=wc(6 -1) ; get picture brightnes bri=wc(6 -2) >W <center>motion diff = %mot%<br> <center>brightness = %bri%<br> ; show stream on WEBUI &<br> &<img src=\"http://%lip%:81/stream\" style=\"width:%w%px;height:%h%px\"> &<br><center>webcam stream Scripting Cookbook ~ Scripting Language Example ~ a valid script must start with >D in the first line! some samples still contain comment lines before >D. This is no longer valid! **Actually this code is too large**. This is only meant to show some of the possibilities >D ; define all vars here p:mintmp=10 (p:means permanent) p:maxtmp=30 t:timer1=30 (t:means countdown timer) t:mt=0 i:count=0 (i:means auto counter) hello=\"hello world\" string=\"xxx\" url=\"[_IP_]\"; hum=0 temp=0 zigbeetemp=0 timer=0 dimmer=0 sw=0 rssi=0 param=0 col=\"\" ocol=\"\" chan1=0 chan2=0 chan3=0 ahum=0 atemp=0 tcnt=0 hour=0 state=1 m:med5=0 M:movav=0 ; define array with 10 entries m:array=0 10 >B string=hello+\"how are you?\" print BOOT executed print %hello% =>mp3track 1 ; list gpio pin definitions for cnt 0 16 1 tmp=pd[cnt] print %cnt% = %tmp% next ; get gpio pin for relais 1 tmp=pn[21] print relais 1 is on pin %tmp% ; pulse relais over raw gpio spin(tmp 1) delay(100) spin(tmp 0) ; raw pin level print level of gpio1 %pin[1]% ; pulse over tasmota cmd =>power 1 delay(100) =power 0 >T hum=BME280#Humidity temp=BME280#Temperature rssi=Wifi#RSSI string=SleepMode ; add to median filter median=temp ; add to moving average filter movav=hum ; show filtered results print %median% %movav% if chg[rssi]>0 then print rssi changed to %rssi% endif if temp>30 and hum>70 then print damn hot! endif =#siren(5) ; loop nesting workaround ; by using subroutine #siren(num) for cnt 1 num 1 =#stone next #stone for tone 2000 1000 -20 beep(tone 10); delay(12) next >S ; every second but not completely reliable time here ; use upsecs and uptime or best t: for reliable timers ; arrays array[1]=4 array[2]=5 tmp=array[1]+array[2] ; call subrountines with parameters =#sub1(\"hallo\") =#sub2(999) ; stop timer after expired if timer1==0 then timer1=-1 print timer1 expired endif ; auto counter with restart if count=10 then print 10 seconds over count=0 endif if upsecs%5==0 then print %upsecs% (every 5 seconds) endif ; not recommended for reliable timers timer+=1 if timer>=5 then print 5 seconds over (may be) timer=0 endif dimmer+=1 if dimmer>100 then dimmer=0 endif =>dimmer %dimmer% =>WebSend %url% dimmer %dimmer% ; show on display dp0 dt [c1l1f1s2p20] dimmer=%dimmer% print %upsecs% %uptime% %time% %sunrise% %sunset% %tstamp% if time>sunset and time<sunrise then ; night time if pwr[1]==0 then =>power1 1 endif else ; day time if pwr[1]>0 then =>power1 0 endif endif ; clr display on boot if boot>0 then dt [z] endif ; frost warning if ((temp<0 or zigbeetemp<0) and mt<=0) then =#sendmail(\"frost alert\") ; alarm only every 5 minutes mt=300 =mp3track 2 endif ; var has been updated if upd[hello]>0 then print %hello% endif ; send to Thingspeak every 60 seconds ; average data in between if upsecs%60==0 then ahum>=tcnt atemp>=tcnt =WebSend [_IP_]/update?key=_token_&field1=%atemp%&field2=%ahum% tcnt=0 atemp=0 ahum=0 else ahum+=hum atemp+=temp tcnt+=1 endif hour=int(time/60) if chg[hour]>0 then ; exactly every hour print full hour reached endif if time5 { print more then 5 minutes after midnight } else { print less then 5 minutes after midnight } ; publish abs hum every teleperiod time if mqtts>0 and upsecs%tper==0 then ; calc abs humidity tmp=pow(2.718281828 (17.67*temp)/(temp+243.5)) tmp=(6.112*tmp*hum*18.01534)/((273.15+temp)*8.31447215) ; publish median filtered value =>Publish tele/%topic%/SENSOR {\"Script\":{\"abshum\":%med(0 tmp)%}} endif ;switch case state machine switch state case 1 print state=%state% , start state+=1 case 2 print state=%state% state+=1 case 3 print state=%state% , reset state=1 ends ; subroutines #sub1(string) print sub1: %string% #sub2(param) print sub2: %param% #sendmail(string) =>sendmail [smtp.gmail.com:465:user:passwd:<sender@gmail.de:<rec@gmail.de:alarm] %string% >E print event executed! ; Assign temperature from a Zigbee sensor zigbeetemp=ZbReceived#0x2342#Temperature ; get HSBColor 1. component tmp=st(HSBColor , 1) ; check if switch changed state sw=sw[1] if chg[sw]>0 then =>power1 %sw% endif hello=\"event occured\" ; check for Color change (Color is a string) col=Color ; color change needs 2 string vars if col!=ocol then ocol=col print color changed %col% endif ; or check change of color channels chan1=Channel[1] chan2=Channel[2] chan3=Channel[3] if chg[chan1]>0 or chg[chan2]>0 or chg[chan3]>0 then = color has changed endif ; compose color string for red col=hn(255)+hn(0)+hn(0) =color %col% >R print restarting now Sensor Logging ~ ; define all vars here ; reserve large strings >D 48 hum=0 temp=0 fr=0 res=0 cnt=0 ; moving average for 60 seconds M:mhum=0 60 M:mtemp=0 60 str=\"\" >B ; set sensor file download link ;fl1(\"slog.txt\") ; delete file in case we want to start fresh ;fd(\"slog.txt\") ; list all files in root directory fr=fo(\"/\" 0) for cnt 1 20 1 res=fr(str fr) if res>0 then print %cnt% : %str% else break endif next fc(fr) >T ; get sensor values temp=BME280#Temperature hum=BME280#Humidity >S ; average sensor values every second mhum=hum mtemp=temp ; write average to sensor log every minute if upsecs%60==0 then ; open file for write fr=fo(\"slog.txt\" 1) ; compose string for tab delimited file entry str=s(upsecs)+\"\\t\"+s(mhum)+\"\\t\"+s(mtemp)+\"\\n\" ; write string to log file res=fw(str fr) ; close file fc(fr) endif >R global variables example ~ make temperature and humidity of an SHT sensor public all devices in the local network may use the global variables needs #define USE_SCRIPT_GLOBVARS Sender: >D g:temp=0 g:hum=0 >T temp=SHT3X_0x44#Temperature hum=SHT3X_0x44#Humidity Receiver(s) displays the value on a display >D g:temp=0 g:hum=0 >S dt [l1c1p10]temp=%temp% C dt [l2c1p10]hum=%hum% %% e-Paper 29 Display with SGP30 and BME280 ~ Some variables are set from ioBroker >D hum=0 temp=0 press=0 ahum=0 tvoc=0 eco2=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 tmp=0 ; preset units in case they are not available punit=\"hPa\" tunit=\"C\" >B ;reset auto draw dt [zD0] ;clr display and draw a frame dt [x0y20h296x0y40h296] >T ; get telemetry sensor values temp=BME280#Temperature hum=BME280#Humidity press=BME280#Pressure tvoc=SGP30#TVOC eco2=SGP30#eCO2 ahum=SGP30#aHumidity tunit=TempUnit punit=PressureUnit >S ; update display every [`TelePeriod`](Commands#teleperiod) if upsecs%tper==0 then dp2 dt [f1p7x0y5]%temp% %tunit% dt [p5x70y5]%hum% %%[x250y5t] dt [p11x140y5]%press% %punit% dt [p10x30y25]TVOC: %tvoc% ppb dt [p10x160y25]eCO2: %eco2% ppm dt [p10c26l5]ahum: %ahum% g^m3 dp0 dt [p25c1l5]WR 1 (Dach) : %wr1% W dt [p25c1l6]WR 2 (Garage): %-wr3% W dt [p25c1l7]WR 3 (Garten): %-wr2% W dt [p25c1l8]Aussentemperatur: %otmp% C dt [x170y95r120:30f2p6x185y100] %pwl% %% ; now update screen dt [d] endif >E >R e-Paper 42 Display with SHT31 and BME280 ~ This script shows 2 graphs on an 4.2 inch e-Paper display: 1. some local sensors, and 2. power statistics The first graph is the battery level of a solar battery (Tesla PowerWall 2) The second graph shows the solar yield of the roof panels in Watts Another special feature is that this script displays daily and weekly averages (via moving average) of all power IO of the house. it sends an email every Sunday night with the weekly data it displays a google bar chart on the webui with values for each weekday of the last week ESP32 CPU with SD card Since the display is a full update panel it is updated only once a minute Some values (like power meters) are set remotely from ioBroker >D hum=0 temp=0 press=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 ez1=0 sez1=0 M:mez1=0 7 ezh=0 sezh=0 M:mezh=0 7 vzh=0 svzh=0 M:mvzh=0 7 wd=0 res=0 hr=0 t1=0 res=0 >B ->setoption64 1 tper=30 dt [IzD0] dt [zG10352:5:40:-350:80:10080:0:100f3x360y40]100 %%[x360y115]0 %% dt [f1x100y25]Powerwall - 7 Tage[f1x360y75] 0 %% dt [G10353:5:140:-350:80:10080:0:5000f3x360y140]+5000 W[x360y215]0 W dt [f1x70y125]Volleinspeisung - 7 Tage[f1x360y180] 0 W dt [p13x10y230]WR 1,2,3: dt [p13x10y245]H-Einsp.: dt [p13x10y260]H-Verbr.: dt [p13x10y275]D-Einsp.: dt [d] dt [Gr0:/g0_sav.txt:] dt [Gr1:/g1_sav.txt:] beep(-25 0) beep(1000 100) >T press=BMP280#Pressure temp=SHT3X_0x44#Temperature hum=SHT3X_0x44#Humidity >S if upsecs%60==0 then dp2 dt [f1p7x0y5]%temp% C dt [x0y20h400x250y5T][x350t][f1p10x70y5]%hum% %% dt [p10x140y5]%press% hPa dp0 dt [p5x360y75]%pwl% %% dt [p6x360y180]%wr1%W dt [g0:%pwl%g1:%wr1%] dt [p24x75y230] %wr1% W : %-wr2% W : %-wr3% W dt [p-10x75y245]%ezh% kWh dt [p-10x75y260]%vzh% kWh dt [p-10x75y275]%ez1% kWh t1=mezh*7 dt [p-10x150y245]: %t1% kWh t1=mvzh*7 dt [p-10x150y260]: %t1% kWh t1=mez1*7 dt [p-10x150y275]: %t1% kWh dp1 t1=ezh-sezh dt [p12x250y245]: %t1% kWh t1=vzh-svzh dt [p12x250y260]: %t1% kWh t1=ez1-sez1 dt [p12x250y275]: %t1% kWh dp0 dt [f2p5x320y250] %otmp%C dt [d] print updating display endif hr=hours if chg[hr]>0 and hr==0 then mez1=ez1-sez1 sez1=ez1 mezh=ezh-sezh sezh=ezh mvzh=vzh-svzh svzh=vzh endif if sezh==0 then sez1=ez1 sezh=ezh svzh=vzh endif wd=wday if chg[wd]>0 and wd==1 then =>sendmail [*:*:*:*:*:user.tasmota@gmail.com: Wochenbericht]* print sending email endif if upsecs%300==0 then =#savgraf print saving graph endif #savgraf dt [Gs0:/g0_sav.txt:] dt [Gs1:/g1_sav.txt:] >m Wochenbericht Einspeisung und Verbrauch<br><br> w1=%mez1[1]%,%mez1[2]%,%mez1[3]%,%mez1[4]%,%mez1[5]%,%mez1[6]%,%mez1[7]%,%mez1[8]%<br> w2=%mezh[1]%,%mezh[2]%,%mezh[3]%,%mezh[4]%,%mezh[5]%,%mezh[6]%,%mezh[7]%,%mezh[8]%<br> w3=%mvzh[1]%,%mvzh[2]%,%mvzh[3]%,%mvzh[4]%,%mvzh[5]%,%mvzh[6]%,%mvzh[7]%,%mvzh[8]%<br> # >W &<br><div id=\"container\"style=\"width:640px;height:480px;margin:0 auto\"></div><br> &<script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"></script> &<script type=\"text/javascript\">google.charts.load('current',{packages:['corechart']});</script> &<script language=\"JavaScript\">function drawChart(){var data= &google.visualization.arrayToDataTable([ &['weekday','Power'],['Mo',%mvzh[1]%],['Di',%mvzh[2]%],['Mi',%mvzh[3]%],['Do',%mvzh[4]%], &['Fr',%mvzh[5]%],['Sa',%mvzh[6]%],['So',%mvzh[7]%]]); &var options={title:'daily solar feed',isStacked:true}; &var chart=new &google.visualization.ColumnChart(document.getElementById('container'));chart.draw(data,options);} &google.charts.setOnLoadCallback(drawChart);</script> # ILI 9488 Color LCD Display with BMP280 and VL5310X ~ Shows various BMP280 energy graphs Turn display on and off using VL5310X proximity sensor to prevent burn-in Some variables are set from ioBroker >D temp=0 press=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 tmp=0 dist=0 punit=\"hPa\" tunit=\"C\" hour=0 >B dt [z] // define 2 graphs, 2. has 3 tracks dt [zCi1G2656:5:20:400:80:1440:-5000:5000:3Ci7f3x410y20]+5000 W[x410y95]-5000 W [Ci7f1x70y3] Zweirichtungsz~80hler - 24 Stunden dt [Ci1G2657:5:120:400:80:1440:0:5000:3Ci7f3x410y120]+5000 W[x410y195]0 W [Ci7f1x70y103] Wechselrichter 1-3 - 24 Stunden dt [Ci1G2658:5:120:400:80:1440:0:5000:16][Ci1G2659:5:120:400:80:1440:0:5000:5] dt [f1s1b0:260:260:100&#8203;:50:2:11:4:2:Rel 1:b1:370:260:100&#8203;:50:2:11:4:2:Dsp off:] =>mp3volume 100 =>mp3track 4 >T ; get some telemetry values temp=BMP280#Temperature press=BMP280#Pressure tunit=TempUnit punit=PressureUnit dist=VL53L0X#Distance ; check proximity sensor to turn display on and off to prevent burn-in if dist>300 then if pwr[2]>0 then =>power2 0 endif else if pwr[2]==0 then =>power2 1 endif endif >S ; update graph every teleperiod if upsecs%tper==0 then dp2 dt [f1Ci3x40y260w30Ci1] dt [Ci7x120y220t] dt [Ci7x180y220T] dt [Ci7p8x120y240]%temp% %tunit% dt [Ci7x120y260]%press% %punit% dt [Ci7x120y280]%dist% mm dp0 dt [g0:%zwz%g1:%wr1%g2:%-wr2%g3:%-wr3%] if zwz0 then dt [p-8x410y55Ci2Bi0]%zwz% W else dt [p-8x410y55Ci3Bi0]%zwz% W endif dt [p-8x410y140Ci3Bi0]%wr1% W dt [p-8x410y155Ci16Bi0]%-wr2% W dt [p-8x410y170Ci5Bi0]%-wr3% W endif ; chime every full hour hour=int(time/60) if chg[hour]>0 then ->mp3track 4 endif >E >R LED Bar Display with WS2812 LED Chain ~ Used to display home's solar power input/output (+-5000 Watts) >D m:array=0 60 ;defines array for 60 led pixels cnt=0 val=0 ind=0 ; rgb values for grid colr1=0x050000 colr2=0x050100 colg1=0x000300 colg2=0x020300 ledbar=0 blue=64 pixels=60 steps=10 div=0 tog=0 max=5000 min=-5000 pos=0 >B div=pixels/steps =#prep ws2812(array) ; ledbar is set from broker >S if ledbar<min then ledbar=min endif if ledbar>max then ledbar=max endif pos=(ledbar/max)*(pixels/2) if ledbar>0 then pos+=(pixels/2) if pospixels-1 then pos=pixels endif else pos+=(pixels/2)+1 if pospixels-1 then pos=1 endif endif if pos<1 or pos>pixels then pos=1 endif =#prep if ledbar==0 then array[pos]=blue array[pos-1]=blue else array[pos]=blue endif ; only used if power is off ; so lets may be used normally if on if pwr[1]==0 then ws2812(array) endif ; subroutine for grid #prep for cnt 1 pixels 1 ind+=1 if ind>div then ind=1 tog^=1 endif if cnt<=pixels/2 then if tog>0 then val=colr1 else val=colr2 endif else if tog>0 then val=colg1 else val=colg2 endif endif array[cnt]=val next >R Multiple IR Receiver Synchronization ~ Shows how a Magic Home with IR receiver works Synchronizes 2 Magic Home devices by also sending the commands to a second Magic Home via WebSend Script example using if then else ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] >D 25 istr=\"\" ws=\"WebSend [_IP_]\" ; event section >E ; get ir data istr=IrReceived#Data ; on if istr==\"0x00F7C03F\" then ->wakeup ->%ws% wakeup endif ; off if istr==\"0x00F740BF\" then ->power1 0 ->%ws% power1 0 endif ;white if istr==\"0x00F7E01F\" then ->color 000000ff ->%ws% color 000000ff endif ;red if istr==\"0x00F720DF\" then ->color ff000000 ->%ws% color ff000000 endif ;green if istr==\"0x00F7A05F\" then ->color 00ff0000 ->%ws% color 00ff0000 endif ;blue if istr==\"0x00F7609F\" then ->color 0000ff00 ->%ws% color 0000ff00 endif ; dimmer up if istr==\"0x00F700FF\" then ->dimmer + ->%ws% dimmer + endif ;dimmer down if istr==\"0x00F7807F\" then ->dimmer - ->%ws% dimmer - endif istr=\"\" Script example using switch case ends ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] >D 25 istr=\"\" ws=\"WebSend [_IP_]\" ; event section >E ; get ir data istr=IrReceived#Data switch istr ; on case \"0x00F7C03F\" ->wakeup ->%ws% wakeup ;off case \"0x00F740BF\" ->power1 0 ->%ws% power1 0 ;white case \"0x00F7E01F\" ->color 000000ff ->%ws% color 000000ff ;red case \"0x00F720DF\" ->color ff000000 ->%ws% color ff000000 ;green case \"0x00F7A05F\" ->color 00ff0000 ->%ws% color 00ff0000 ;blue case \"0x00F7609F\" ->color 0000ff00 ->%ws% color 0000ff00 ; dimmer up case \"0x00F700FF\" ->dimmer + ->%ws% dimmer + ; dimmer down case \"0x00F7807F\" ->dimmer - ->%ws% dimmer - ends istr=\"\" Fast Polling ~ ; expand default string length to be able to hold `WebSend [xxx.xxx.xxx.xxx]` >D 25 sw=0 ws=\"WebSend [_IP_]\" timer=0 hold=0 toggle=0 >B ; gpio 5 button input spinm(5,0) ; fast section 100ms >F sw=pin[5] ; 100 ms timer timer+=1 ; 3 seconds long press ; below 0,5 short press if sw==0 and timer5 and timer<30 then ; short press ;print short press toggle^=1 =>%ws% power1 %toggle% endif if sw>0 then ;pressed if timer>30 then ; hold hold=1 ;print hold=%timer% if toggle>0 then =>%ws% dimmer + else =>%ws% dimmer - endif endif else timer=0 hold=0 endif Web UI ~ An example to show how to implement a web UI. This example controls a light via WebSend >D dimmer=0 sw=0 color=\"\" col1=\"\" red=0 green=0 blue=0 ww=0 >F color=hn(red)+hn(green)+hn(blue)+hn(ww) if color!=col1 then col1=color =>websend [192.168.178.75] color %color% endif if chg[dimmer]>0 then =>websend [192.168.178.75] dimmer %dimmer% endif if chg[sw]>0 then =>websend [192.168.178.75] power1 %sw% endif >W bu(sw \"Light on\" \"Light off\") ck(sw \"Light on/off \") sl(0 100 dimmer \"0\" \"Dimmer\" \"100\") sl(0 255 red \"0\" \"red\" \"255\") sl(0 255 green \"0\" \"green\" \"255\") sl(0 255 blue \"0\" \"blue\" \"255\") sl(0 255 ww \"0\" \"warm white\" \"255\") tx(color \"color: \") Hue Emulation ~ An example to show how to respond to Alexa requests via Hue Emulation When Alexa sends on/off, dimmer, and color (via hsb), send commands to a MagicHome device >D pwr1=0 hue1=0 sat1=0 bri1=0 tmp=0 >E if upd[hue1]>0 or upd[sat1]>0 or upd[bri1]>0 then tmp=hue1/182 ->websend [192.168.178.84] hsbcolor %tmp%,%sat1%,%bri1% endif if upd[pwr1]>0 then ->websend [192.168.178.84] power1 %pwr1% endif >H ; on,hue,sat,bri,ct livingroom,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1 Alexa Controlled MCP230xx I 2 C GPIO Expander ~ Uses Tasmota's Hue Emulation capabilities for Alexa interface ; define vars >D p:p1=0 p:p2=0 p:p3=0 p:p4=0 ; init ports >B ->sensor29 0,5,0 ->sensor29 1,5,0 ->sensor29 2,5,0 ->sensor29 3,5,0 ->sensor29 0,%0p1% ->sensor29 1,%0p2% ->sensor29 2,%0p3% ->sensor29 3,%0p4% ; define Alexa virtual devices >H port1,S,on=p1 port2,S,on=p2 port3,S,on=p3 port4,S,on=p4 ; handle events >E print EVENT if upd[p1]>0 then ->sensor29 0,%0p1% endif if upd[p2]>0 then ->sensor29 1,%0p2% endif if upd[p3]>0 then ->sensor29 2,%0p3% endif if upd[p4]>0 then ->sensor29 3,%0p4% endif =#pub ; publish routine #pub =>publish stat/%topic%/RESULT {\"MCP23XX\":{\"p1\":%0p1%,\"p2\":%0p2%,\"p3\":%0p3%,\"p4\":%0p4%}} svars ; web interface >W bu(p1 \"p1 on\" \"p1 off\")bu(p2 \"p2 on\" \"p2 off\")bu(p3 \"p3 on\" \"p3 off\")bu(p4 \"p4 on\" \"p4 off\") Retrieve network gateway IP Address ~ >D gw=\"\" ; Request Status information. The response will trigger the `U` section >B +>status 5 ; Read the status JSON payload >U gw=StatusNET#Gateway print %gw% Send e-mail ~ >D 25 day1=0 et=0 to=\"<mrx@gmail.com>\" >T et=ENERGY#Total >S ; send at midnight day1=day if chg[day1]>0 then =>sendmail [*:*:*:*:*:%to%:energy report]* endif >m email report at %tstamp% your power consumption today was %et% KWh # Send power reading with formatted time stamp via websend ~ Some web APIs require certain formats (e.g. date & time) to be provided. This example illustrates how to reformat the timestamp and embed it in the get payload. On ESP8266 based devices this is limited to unsecured http (no \"s\") connections! Don't use this for sensitive data! >D 42 ;long string required for key y=0 m=0 d=0 key=\"yourkey\" id=\"yourSystemID\" ws=\"WebSend [pvoutput.org]\" et=0 p=0 >T et=ENERGY#Total p=ENERGY#Power ; every 5 minutes if upsecs%300==0 then y=sb(tstamp 0 4) m=sb(tstamp 5 2) d=sb(tstamp 8 2) =>%ws%/service/r2/addstatus.jsp?key=%key%&sid=%id%&d=%1.0(y)%%2.0(m)%%2.0(d)%&t=%1(sb(tstamp 11 5))%&v2=%s(2.0p)% endif Switching and Dimming By Recognizing Mains Power Frequency ~ Switching in Tasmota is usually done by High/Low (+3.3V/GND) changes on a GPIO. However, for devices like the Moes QS-WiFi-D01 Dimmer , this is achieved by a pulse frequency when connected to the GPIO, and these pulses are captured by Counter1 in Tasmota. When the light is OFF and there is a short period of pulses - then turn the light ON at the previous dimmer level. When the light is ON and there is a short period of pulses - then turn the light OFF . When there is a longer period of pulses (i.e., HOLD ) - toggle dimming direction and then adjust the brightness level as long as the button is pressed or until the limits are reached. Issue 6085 In the Data Section D at the beginning of the Script the following initialization variables may be changed: dim multiplier = 0..2.55 set the dimming increment value dim lower limit = range for the dimmer value for push-button operation (set according to your bulb); min 0 dim upper limit = range for the dimmer value for push-button operation (set according to your bulb); max 100 start dim level = initial dimmer level after power-up or restart; max 100 >D sw=0 tmp=0 cnt=0 tmr=0 hold=0 powert=0 slider=0 dim=\"\" shortprl=2 ;short press lo limit shortpru=10;short press up limit dimdir=0 ;dim direction 0/1 dimstp=2 ;dim step/speed 1 to 5 dimmlp=2.2 ;dim multiplier dimll=15 ;dim lower limit dimul=95 ;dim upper limit dimval=70 ;start dim level >B print \"WiFi-Dimmer-Script-v0.2\" =>Counter1 0 =>Baudrate 9600 ; boot sequence =#senddim(dimval) delay(1000) =#senddim(0) >F cnt=pc[1] if chg[cnt]>0 ; sw pressed then sw=1 else sw=0 ; sw not pressed endif ; 100ms timer tmr+=1 ; short press if sw==0 and tmr>shortprl and tmr<shortpru then powert^=1 ; change light on/off if powert==1 then =#senddim(dimval) else =#senddim(0) endif endif ; long press if sw>0 then if hold==0 then ; change dim direction dimdir^=1 endif if tmr>shortpru then hold=1 if powert>0 ; dim when on & hold then if dimdir>0 then ; increase dim level dimval+=dimstp if dimval>dimul then ; upper limit dimval=dimul endif =#senddim(dimval) else ; decrease dim level dimval-=dimstp if dimval<dimll then ; lower limit dimval=dimll endif =#senddim(dimval) endif endif endif else tmr=0 hold=0 endif >E slider=Dimmer ; slider change if chg[slider]>0 then ; dim according slider if slider>0 then dimval=slider =#senddim(dimval) else powert=0 =#senddim(0) endif endif if pwr[1]==1 ; on/off webui then powert=1 =#senddim(dimval) else powert=0 =#senddim(0) endif ; subroutine dim #senddim(tmp) dim=\"FF55\"+hn(tmp*dimmlp)+\"05DC0A\" =>SerialSend5 %dim% =>Dimmer %tmp% # Dual display example ~ >D >B ; load sh1106 driver dt [S2/SH1106_desc.txt:] ; clear screen, switch to LCD font; set auto draw dt [zf4s1D1] dt [S1:] >S ; switch to display 2 dt [S2:] ; show time dt [x20y20t] ; switch back to display 1 dt [S1:] read I2C example (AXP192) ~ >D volt=0 curr=0 found=0 >B ; check device on I2C bus Nr.2 found=ia2(0x34) >S ; if found read registers, (this example takes 2ms to read both values) if found>0 { volt=ir(0x5a)<<4|ir(0x5b)*1.7/1000 curr=ir(0x58)<<4|ir(0x59)*0.625 } >W ; show on webui Bus Voltage{m}%volt% V Bus Current{m}%curr% mA Multiplexing a single adc with CD4067 breakout ~ >D ; this script works with an CD4067 breakout to multiplex a single ADC channel ; of an ESP IP=192.168.178.177 SB=8192 res=0 cnt=0 mcnt=0 m:mux=0 16 >B ; define output pins for multiplexer spinm(12 O) spinm(13 O) spinm(14 O) spinm(15 O) ; define string array with 16 entries res=is1(16 \"\") is1[1]=\"Azalea\" is1[2]=\"Aster\" is1[3]=\"Bougainvillea\" is1[4]=\"Camellia\" is1[5]=\"Carnation\" is1[6]=\"Chrysanthemum\" is1[7]=\"Clematis\" is1[8]=\"Daffodil\" is1[9]=\"Dahlia\" is1[10]=\"Daisy\" is1[11]=\"Edelweiss\" is1[12]=\"Fuchsia\" is1[13]=\"Gladiolus\" is1[14]=\"Iris\" is1[15]=\"Lily\" is1[16]=\"Periwinkle\" >F ; get adc value into array, average 4 values ; this is for ESP32 here on pin 32 mux[mcnt+1]=adc(4 32) ; this is for ESP8266 it has only 1 ADC input ; mux[mcnt+1]=adc(4) mcnt+=1 if mcnt>=16 then mcnt=0 endif ; set multiplexer spin(12 mcnt) spin(13 mcnt/2) spin(14 mcnt/4) spin(15 mcnt/8) ; display web UI #wsub if wm==0 then for cnt 1 16 1 wcs {s}Ch %0cnt%: %is1[cnt]%{m}%mux[cnt]% %%{e} next endif #rsub rap ,\"CD4067\":{ for cnt 1 16 1 rap \"%is1[cnt]%\":%mux[cnt]% if cnt<16 then rap , endif next rap } >J ; send to mqtt ; call json subroutine %=#rsub >W ; call web subroutine %=#wsub Image gallery of various Tasmota scripts ~ Internet radio ~ Webcam with multiple options ~ Energy collector ~ Energy display main menu ~ Energy display one day of database ~ Energy display last week of database ~ Energy display last weeks of database ~ environment sensor ~ timer main menu ~ timer setup ~","title":"Scripting Language"},{"location":"Scripting-Language/#scripting","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_SCRIPT #define USE_SCRIPT // adds about 17k flash size, variable ram size #endif #ifdef USE_RULES #undef USE_RULES #endif Additional features are enabled by adding the following #define compiler directive parameters and then compiling the firmware. These parameters are explained further below in the article. Feature Description USE_BUTTON_EVENT enable >b section (detect button state changes) USE_SCRIPT_JSON_EXPORT enable >J section (publish JSON payload on TelePeriod ) USE_SCRIPT_SUB_COMMAND enables invoking named script subroutines via the Console or MQTT USE_SCRIPT_HUE enable >H section (Alexa Hue emulation) USE_HOMEKIT enable >h section (Siri Homekit support (ESP32 only), define must be given in platform_override see below) USE_SCRIPT_STATUS enable >U section (receive JSON payloads from cmd status) SCRIPT_POWER_SECTION enable >P section (execute on power changes) SUPPORT_MQTT_EVENT enables support for subscribe unsubscribe USE_SENDMAIL enable >m section and support for sending e-mail (on ESP32 you must add USE_ESP32MAIL) USE_SCRIPT_WEB_DISPLAY enable >W section (modify web UI) SCRIPT_FULL_WEBPAGE enable >w section (seperate full web page and webserver) USE_TOUCH_BUTTONS enable virtual touch button support with touch displays USE_WEBSEND_RESPONSE enable receiving the response of WebSend and WebQuery commands (received in section >E) SCRIPT_STRIP_COMMENTS enables stripping comments when attempting to paste a script that is too large to fit USE_ANGLE_FUNC add sin(x),acos(x) and sqrt(x) e.g. to allow calculation of horizontal cylinder volume USE_SCRIPT_FATFS_EXT enables additional FS commands USE_WEBCAM enables support ESP32 Webcam which is controlled by scripter cmds USE_FACE_DETECT enables face detecting in ESP32 Webcam USE_SCRIPT_TASK enables multitasking Task in ESP32 USE_LVGL enables support for LVGL USE_SCRIPT_GLOBVARS enables global variables and >G section USE_SML_M enables Smart Meter Interface SML_REPLACE_VARS enables posibility to replace the lines from the (SML) descriptor with Vars USE_SML_SCRIPT_CMD enables SML script cmds USE_SCRIPT_I2C enables I2C support USE_SCRIPT_SERIAL enables support for serial io cmds USE_LVGL enables support for LVGL USE_SCRIPT_TIMER enables up to 4 Arduino timers (so called tickers) SCRIPT_GET_HTTPS_JP enables reading HTTPS JSON WEB Pages (e.g. Tesla Powerwall) LARGE_ARRAYS enables arrays of up to 1000 entries instead of max 127 SCRIPT_LARGE_VNBUFF enables to use 4096 in stead of 256 bytes buffer for variable names USE_GOOGLE_CHARTS enables defintion of google charts within web section USE_FEXTRACT enables array extraction from database fxt(...) USE_SCRIPT_SPI enables support for SPI interface USE_DSIPLAY_DUMP enables to show epaper screen as BMP image in >w section Scripting Language for Tasmota is an alternative to Tasmota Rules . For ESP32 builds it is recommended to use Berry To enter a script, go to Consoles -> Edit Script in the Tasmota web UI menu (for version before 9.4, go to Configuration -> Edit script ) To save code space almost no error messages are provided. However it is taken care of that at least it should not crash on syntax errors.","title":"Scripting"},{"location":"Scripting-Language/#features","text":"Up to 50 variables (45 numeric and 5 strings - this may be changed by setting a compilation #define directive) Freely definable variable names (all variable names are intentionally case sensitive ) Nested if,then,else up to a level of 8 Math operators + , - , * , / , % , & , | , ^ , << , >> All operators may be used in the op= form, e.g., += Comparison operators == , != , > , >= , < , <= and , or support Hexadecimal numbers with prefix 0x are supported Strings support + and += operators Support for \\n \\r regular expressions on strings String comparison == , != String size is 19 characters (default). This can be increased or decreased by the optional parameter on the D section definition","title":"Features"},{"location":"Scripting-Language/#script-sections","text":"Section descriptors (e.g., >E ) are case sensitive a valid script must start with >D in the first line >D ssize ssize = optional max string size (default=19) define and init variables here, must be the first section, no other code allowed p:vname specifies permanent variables. The number of permanent variables is limited by Tasmota rules space (50 bytes) - numeric variables are 4 bytes; string variables are one byte longer than the length of string t:vname specifies countdown timers, if >0 they are decremented in seconds until zero is reached. see example below i:vname specifies auto increment counters if =0 (in seconds) g:vname specifies global variable which is linked to all global variables with the same definition on all devices in the homenet. when a variable is updated in one device it is instantly updated in all other devices. if a section >G exists it is executed when a variable is updated from another device (this is done via UDP-multicast, so not always reliable) m:vname specifies a median filter variable with 5 entries (for elimination of outliers) M:vname specifies a moving average filter variable with 8 entries (for smoothing data) (max 5 filters in total m+M) optional another filter length (1..127) can be given after the definition. Filter vars can be accessed also in indexed mode vname[x] (x = 1..N , x = 0 returns current array index pointer, x = -1 returns arry length, x = -2 returns array average) Using this filter, vars can be used as arrays, #define LARGE_ARRAYS allows for arrays up to 1000 entries array may also be permanent by specifying an extra :p m:p:vname defines a permanent array. Keep in mind however that in 1M Flash standard configurations you only have 50 bytes permanent storage which stands for a maximum of 12 numbers. (see list above for permanent storage in other configurations) arrays may also be preset in auto increment mode array=X sets the value at index array[0] and increments the index by 1. array = {x y z} sets 3 values in an array from index array[0] Tip Keep variable names as short as possible. The length of all variable names taken together may not exceed 256 characters. Memory is dynamically allocated as a result of the D section. Copying a string to a number or reverse is supported >B executed on BOOT time before sensors are initialized and on save script >BS executed on BOOT time after sensors are initialized >E Executed when a Tasmota MQTT RESULT message is received, e.g., on POWER change. Also Zigbee reports to this section. >F Executed every 100 ms >S Executed every second >R Executed on restart. p vars are saved automatically after this call >T Executed at least at TelePeriod time ( SENSOR and STATE ) but mostly faster up to every 100 ms, only put tele- vars in this section Remark: JSON variable names (like all others) may not contain math operators like - , you should set SetOption64 1 to replace - ( dash ) with _ ( underscore ). Zigbee sensors will not report to this section, use E instead. >H Alexa Hue interface (up to 32 virtual hue devices) ( example ) device , type , onVars Remark: hue values have a range from 0-65535. Divide by 182 to assign HSBcolors hue values. device device name type device type - E = extended color; S = switch onVars assign Hue \"on\" extended color parameters for hue, saturation, brightness, and color temperature (hue,sat,bri,ct) to scripter variables Example lamp1,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1,ct=ct1 >h passcode Siri Homekit interface (up to 16 virtual Homekit devices) passcode = 111-11-111 keep this format, numbers 0-9 name , type , opt , var1 , var2 ... name device name (max 23 characters) type device type (HAP_CID) - 7 = outlet, on/off - 5 = light, on/off,hue,sat,bri - 10 = sensor opt sensor type - 0 = Temperature,val - 1 = Humidity,val - 2 = Light level,val - 3 = Battery status,level,low battery,charging - 4 = Ambient light level with extended range -10000,+10000 - 5 = Contact Sensor (switch) var1 ... variable name (max 11 characters) the variables denote scripting variables that need to be set by script the special variables @px x (1..9) directly set, read power states e.g. relays @sx x (1..9) directly read switch state @bx x (1..9) directly read button state Example >h 111-11-111 outlet,7,0,@p1 lamp1,5,0,pwr,hue,sat,bri temperature,10,0,tval a restart is required after modification of descriptor! by faulty parameters the homekit dataset may get corrupted to reset the homekit dataset completely type in console script>hki(89) compilation: needs to add in linker to build_flags -DUSE_HOMEKIT lib_extra_dirs lib/libesp32_div >U JSON messages from cmd status arrive here >C HTML messages arrive here (on web user io event, (if defined USE_HTML_CALLBACK)) >G global variable updated section >P any power change triggers here (if defined SCRIPT_POWER_SECTION) >jp https webpage json parse arrives here >ti1 >ti2 >ti3 >ti4 ticker callback after timer expiration >b (note lower case) executed on button state change bt[x] read button state (x = 1.. MAX_KEYS ) Example >D tmp=0 >b tmp=bt[1] if tmp==0 then print falling edge of button1 endif if tmp==1 then print rising edge of button1 endif >J The lines in this section are published via MQTT in a JSON payload on TelePeriod . Requires compiling with #define USE_SCRIPT_JSON_EXPORT . >W The lines in this section are displayed in the web UI main page. Requires compiling with #define USE_SCRIPT_WEB_DISPLAY . You may put any html code here. Variables may be substituted using %var% HTML statements are displayed in the sensor section of the main page HTML statements preceded with a @ are displayed at the top of the page HTML statements preceded with a $ are displayed in the main section USER IO elements are displayed at the top of the page optionally these sections may be used >WS - HTML statements are displayed in the sensor section of the main page >WM - HTML statements are displayed in the main section of the main page for next loops are supported to repeat HTML code (precede with % char) %for var from to inc %next but this method is preferred: script subroutines may be called sub=name of subroutine, like normal subroutines %=#sub in this subroutine a web line may be sent by wcs (see below) thus allowing dynamic HTML pages =#sub(x) in any position of webline calls subroutine. this allows inserting content insa(array) in any position insert all elements from an array comma separated %/file calls a file from the file system and send its content to browser. in this file any cmds may apply. A web user interface may be generated containing any of the following elements: Button: bu(vn txt1 txt2) (up to 4 buttons may be defined in one row) vn = name of variable to hold button state txt1 = text of ON state of button txt2 = text of OFF state of button Pulldown: pd(vn label (xs) txt1 txt2 ... txtn) vn = name of variable to hold selected state label = label text xs = optional xs (default 200) txt1 = text of 1. entry txt2 = text of 2. entry and so on Checkbox: ck(vn txt (xs)) vn = name of variable to hold checkbox state txt = label text xs = optional xs (default 200) Slider: sl(min max vn ltxt mtxt rtxt) min = slider minimum value max = slider maximum value vn = name of variable to hold slider value ltxt = label left of slider mtxt = label middle of slider rtxt = label right of slider Text Input: tx(vn lbl (xs) (type min max)) vn = name of string variable to hold text state lbl = label text xs = optional xs (default 200) type min max = optional strings type = e.g \"datetime-local\" for date+time selector, min, max = date-time min max range Time Input: tm(vn lbl (xs)) vn = name of number variable to hold time HHMM as number e.g. 1900 means 19:00 lbl = label text xs = optional xs (default 70) Number Input: nm(min max step vn txt (xs) (prec)) min = number minimum value max = number maximum value step = number step value for up/down arrows vn = name of number variable to hold number txt = label text xs = optional xs (default 200) prec = optional number precision (default 1) special html options: so(flags) WSO_NOCENTER = 1 force elements not centered WSO_NODIV = 2 force elements not in extra \\<div> WSO_FORCEPLAIN = 4 send line in plain (no table elements) WSO_FORCEMAIN = 8 send lines in main mode ($ mode) Google Charts: google chart support requires arrays and to make sense also permanent arrays. Therefore on 4M Flash Systems the use of USE_UFILESYS is recommended while on 1 M Flash Systems the special EEPROM mode should be used (see above). other options may also be needed like LARGE_ARRAYS draws a google chart with up to 4 data sets per chart gc(T (size) array1 ... array4 \"name\" \"label1\" ... \"label4\" \"entrylabels\" \"header\" {\"maxy1\"} {\"maxy2\"}) T = type - b=barchart - c=columnchart - cs=columnchart stacked - C=combochart - p=piechart - l=linechart up to 4 lines with same scaling - l2=linechart with exactly 2 lines and 2 y scales (must be given at end) - lf2 like above but with splined lines - h=histogram - t=data table - g=simple gauges (must give extra 3 vars after header, yellow start, red start, maxval) - T=Timeline (special type arrays contains start,stop pairs in minutes timeofday) b,l,h type may have the '2' option to specify exactly 2 arrays with 2 y scales given at the end of parameter list. a very individual chart may be specified by splitting the chart definition and inserting the chart options directly see example below size = optional size, allows to use only part of an array, must be lower then array size array = up to 4 arrays of data name = name of chart label = label for up to the 4 datasets in chart entrylabel = labels of each x axis entry separated by '|' char (\"cntN\" starts numbering entries with the number N an optional /X generates numbers divided by X. Produce labels that cycle through the array indexes, starting with the number N. For instance, \"cnt6\" with an array of length 8 will produce the labels 6|7|0|1|2|3|4|5| Using \"cntN/X\" will then divide the numeric value of the label, so \"cnt6/2\" with an array of length 8 will produce the labels 3|3|0|0|1|1|2|2|) (\"wdh: before a week definition generates a week with full hours) header = visible header name of chart additionally you have to define the html frame to put the chart in (both lines must be preceded by a $ char) e.g. $<div id=\"chart1\"style=\"width:640px;height:480px;margin:0 auto\"></div> $gc(c array1 array2 \"wr\" \"pwr1\" \"pwr2\" \"mo|di|mi|do|fr|sa|so\" \"Solar feed\") you may define more then one chart. The charts id is chart1 ... chartN very customized chart definition: define a chart like above, but add a t to the definition this generates a google table from the arrays e.g.: &gc(lt array1 array2 \"wr\" \"pwr1\" \"pwr2\" \"mo|di|mi|do|fr|sa|so\") then define the options for the graph as from the doku of google e.g.: $var options = { $vAxes:{0:{maxValue:40,title:'Au\u00dfentemperatur'},1:{maxValue:60,title:'Solarspeicher'}}, $series:{0:{targetAxisIndex:0},1:{targetAxisIndex:1}}, $hAxis: {title: 'Wochenverlauf'}, $}; then gc(e) closes the definition $gc(e) >w ButtonLabel generates a button with the name \"ButtonLabel\" in Tasmota main menu. Clicking this button displays a web page with the HTML data of this section. all cmds like in >W apply here. these lines are refreshed frequently to show e.g. sensor values. lines preceded by $ are static and not refreshed and displayed below lines without $. this option also enables a full webserver interface when USE_UFILESYS is active. you may display files from the flash or SD filesystem by specifying the url: IP/ufs/path . (supported files: *.jpg, *.html, *.txt) >w1 >w2 >w3 >w4 >w5 >w6 some as above >w Requires compiling with #define SCRIPT_FULL_WEBPAGE . >M Smart Meter Interface If a variable does not exist, ??? is displayed for commands If a Tasmota SENSOR or STATUS or RESULT message is not generated or a Var does not exist the destination variable is NOT updated.","title":"Script Sections"},{"location":"Scripting-Language/#special-variables","text":"(read only) upsecs = seconds since start uptime = minutes since start time = minutes since midnight sunrise = sunrise minutes since midnight sunset = sunset minutes since midnight tper = TelePeriod ( may be set also ) cbs = command text buffer size for tasmota cmds (default 256) ( may be set also ) tstamp = timestamp (local date and time) topic = mqtt topic gtopic = mqtt group topic lip = local ip as string luip = udp ip as string (from updating device when USE_SCRIPT_GLOBVARS defined) prefixn = prefix n = 1-3 frnm = friendly name dvnm = device name pwr[x] = power state (x = 1..N) npwr = number of tasmota power devices pc[x] = pulse counter value (x = 1..4) tbut[x] = touch screen button state (x = 1..N) sw[x] = switch state (x = 0..N) (Switch1 = sw[0] ) bt[x] = button state (x = 1..N) only valid in section b (if defined USE_BUTTON_EVENT) pin[x] = GPIO pin level (x = 0..16) pn[x] = GPIO for sensor code x. 99 if none pd[x] = defined sensor for GPIO x. 999 if none adc(fac (pin)) = get adc value (on ESP32 can select pin) fac is number of averaged samples (power of 2: 0..7) sht[x] = shutter position (x = 1..N) (if defined USE_SHUTTER) gtmp = global temperature ghum = global humidity gprs = global pressure pow(x y) = calculates exponential powers x^y (imprecise version only) med(n x) = calculates a 5 value median filter of x (2 filters possible n=0,1) int(x) = gets the integer part of x (like floor) hn(x) = converts x (0..255) to a hex nibble string hx(x) = converts x (0..65535) to a hex string hd(\"hstr\") = converts hex number string to a decimal number af(array index) = converts 4 bytes of an array at index index to float number hf(\"hstr\") = converts hex float number string to a decimal number hf(\"hstr\" r) = converts hex float number string (reverse byte order) to a decimal number st(svar c n) = string token - retrieve the n th element of svar delimited by c ins(s1 s2) = check if string s2 is contained in string s1, return -1 if not contained or position of contained string sl(svar) = gets the length of a string asc(svar) = gets the binary value of 1. char of a string sb(svar p n) = gets a substring from svar at position p (if p<0 counts from end) and length n is(num \"string1|string2|....|stringn|\") = defines a string array optionally preset with immediate strings separated by '|' (this immediate string may be up to 255 chars long) num = 0 read only string array, num > 0 number of elements in read write string array is[index] = gets string index from string array, if read-write also write string of index is1(..) , is2(...) string array see above is1[x] , is2[x] string array see above rr() = returns the reset reason of last restart (as string) s2hms(S) , converts seconds to HH:MM:SS string sin(x) = calculates the sinus(x) (if defined USE_ANGLE_FUNC) cos(x) = calculates the cosinus(x) (if defined USE_ANGLE_FUNC) acos(x) = calculates the acos(x) (if defined USE_ANGLE_FUNC) sqrt(x) = calculates the sqrt(x) (if defined USE_ANGLE_FUNC) abs(x) = calculates the absolute value of x mpt(x) = measure pulse time, x>=0 defines pin to use, -1 returns low pulse time,-2 return high pulse time (if defined USE_ANGLE_FUNC) rnd(x) = return a random number between 0 and x, (seed may be set by rnd(-x)) sf(F) = sets the CPU Frequency (ESP32) to 80,160,240 Mhz, returns current Freq. s(x) = explicit conversion from number x to string may be preceded by precision digits e.g. s(2.2x) = use 2 digits before and after decimal point I2C support #define USE_SCRIPT_I2C ia(AA) , ia2(AA) test and set I2C device with adress AA (on BUS 1 or 2), returns 1 if device is present iw(aa val) , iw1(aa val) , iw2(aa val) , iw3(aa val) write val to register aa (1..3 bytes) ir(aa) , ir1(aa) , ir2(aa) , ir3(aa) read 1..3 bytes from register aa Serial IO support #define USE_SCRIPT_SERIAL so(RXPIN TXPIN BR) open serial port with RXPIN, TXPIN and baud rate BR with 8N1 serial mode (-1 for pin means don't use) so(RXPIN TXPIN BR MMM) open serial port with RXPIN, TXPIN and baud rate BR and serial mode e.g 7E2 (all 3 modechars must be specified) so(RXPIN TXPIN BR MMM BSIZ) open serial port with RXPIN, TXPIN and baud rate BR and serial mode e.g 7E2 (all 3 modechars must be specified) and serial IRW buffer size sc() close serial port sw(STR) write the string STR to serial port swb(NUM) write the number char code NUM to serial port sa() returns number of bytes available on port sr() read a string from serial port, all available chars up to string size sr(X) read a string from serial port until charcode X, all available chars up to string size or until charcode X srb() read a number char code from serial port sp() read a number char code from serial port, don't remove it from serial input (peek) sra(ARRAY (flags)) fill an array from serial port, if USE_SML_M is enabled and Array size is 8 it is assumed to be a MODBUS request and the checksum is evaluated, if OK 8 is returned, else -2, or if flags is set Modbus response is assumed and checksum is calculated, 0 = standard Modbus, 1 = Rec BMA mode, return -2 on checksum error a sra(ARRAY (flags)) fill an array from serial port, if USE_SML_M is enabled and Array size is 8 it is assumed to be a MODBUS request and the checksum is evaluated, if OK 8 is returned, else -2, or if flags is set Modbus response is assumed and ckum is calculated, 0 = standard Modbus, 1 = Rec BMA mode swa(ARRAY len (flags)) send len bytes of an array to serial port, if flags is set Modbus cmd is assumed and cksum is calculated, 0 = standard Modbus, 1 = Rec BMA mode smw(ADDR MODE NUMBER) send a value with checksum to MODBUS Address, MODE 0 = uint16, 1 = uint32, 3 = float SPI IO support #define USE_SCRIPT_SPI spi(0 SCLK MOSI MISO) defines a software SPI port with pin numbers used for SCLK, MOSI, MISO. spi(0 -1 freq) defines a hardware SPI port with pin numbers defined by Tasmota GPIO definition with bus frequency in Mhz. spi(0 -2 freq) defines a hardware SPI port 2 on ESP32 with pin numbers defined by Tasmota GPIO definition. spi(1 N GPIO) sets the CS pin with index N (1..4) to pin Nr GPIO. spi(2 N ARRAY LEN S) sends and receives an ARRAY with len values with S (1..3) (8,16,24 bits) if N==-1 cs is ignored ttget(TNUM SEL) get tasmota timer setting from timer TNUM (1 .. 16) SEL: 0 = time 1 = time window 2 = repeat 3 = days 4 = device 5 = power 6 = mode 7 = arm mqtts = MQTT connection status: 0 = disconnected, >0 = connected wbut = button status of watch side button (if defined USE_TTGO_WATCH) wdclk = double tapped on display (if defined USE_TTGO_WATCH) wtch(sel) = gets state from touch panel sel=0 => touched, sel=1 => x position, sel=2 => y position (if defined USE_TTGO_WATCH) slp(time) = sleep time in seconds, pos values => light sleep, neg values => deep sleep (if defined USE_TTGO_WATCH) pl(\"path\") = play mp3 audio from filesystem (if defined USE_I2S_AUDIO or USE_TTGO_WATCH or USE_M5STACK_CORE2) say(\"text\") = plays specified text to speech (if defined USE_I2S_AUDIO or USE_TTGO_WATCH or USE_M5STACK_CORE2) c2ps(sel val) = gets, sets values on ESP32 CORE2 sel=0 green led, sel=1 vibration motor, sel=2,3,4 get touch button state 1,2,3 (if defined USE_M5STACK_CORE2) rec(path seconds) = rec n seconds wav audio file from i2s microphone to filesystem path (if defined USE_I2S_AUDIO or USE_M5STACK_CORE2) pwmN(-pin freq) = defines a pwm channel N (1..N) with pin Nr and frequency (pin 0 being -64, N=5 with esp8266 and N=8 with esp32) pwmN(val) = outputs a pwm signal on channel N (1..N) with val (0-1023) wifis = Wi-Fi connection status: 0 = disconnected, >0 = connected wcs = send this line to webpage (WebContentSend) wcf = flushes the web buffer (WSContentFlush) wfs = send this file to webpage rapp = append this line to MQTT (ResponseAppend) wm = contains source of web request code e.g. 0 = Sensor display (FUNC_WEB_SENSOR) acp(dst src) = copy array knx(code value) = sends a number value to KNX sml(m 0 bd) = set SML baud rate of Meter m to bd (baud) (if defined USE_SML_SCRIPT_CMD) sml(m 1 htxt) = send SML Hex string htxt as binary to Meter m (if defined USE_SML_SCRIPT_CMD) sml(m 2) = reads serial data received by Meter m into string (if m<0 reads hex values, else asci values)(if defined USE_SML_SCRIPT_CMD) sml(m 3 hstr) = inserts SML Hexstring variable hstr as binary to Meter m in Output stream e.g. for special MODBUS cmds, hstr must be a string variable NO string constant (if defined USE_SML_SCRIPT_CMD) sml[n] = get value of SML energy register n (if defined USE_SML_SCRIPT_CMD) smls[m] = get value of SML meter string info of meter m (if defined USE_SML_SCRIPT_CMD) smlv[n] = get SML decode valid status of line n (1..N), returns 1 if line decoded. n=0 resets all status codes to zero (if defined USE_SML_SCRIPT_CMD) smld(m) = call decoder of meter m smlj = read or write variable, when 0 disables MQTT output of SML. enrg[n] = get value of energy register n 0=total, 1..3 voltage of phase 1..3, 4..6 current of phase 1..3, 7..9 power of phase 1..3 (if defined USE_ENERGY_SENSOR) gjp(\"host\" \"path\") = trigger HTTPS JSON page read as used by Tesla Powerwall (if defined SCRIPT_GET_HTTPS_JP) gwr(\"del\" index) = gets non JSON element from webresponse del = delimiter char or string, index = n\u00b4th element (if defined USE_WEBSEND_RESPONSE) http(\"url\" \"payload\") = does a GET or POST request on an URL (http:// is internally added) tsN(ms) = set up to 4 timers (N=1..4) to millisecond time on expiration triggers section >tiN (if defined USE_SCRIPT_TIMER) hours = hours mins = mins secs = seconds day = day of month wday = day of week (Sunday=1,Monday=2;Tuesday=3;Wednesday=4,Thursday=5,Friday=6,Saturday=7) month = month year = year epoch = epoch time (from 2019-1-1 00:00) epoffs = set epoch offset, (must be no longer then 2 years to fit into single float with second precision) eres = result of >E section set this var to 1 in section >E to tell Tasmota event is handled (prevents MQTT) The following variables are cleared after reading true: chg[var] = true if a variables value was changed (numeric vars only) upd[var] = true if a variable was updated boot = true on BOOT tinit = true on time init tset = true on time set mqttc = true on mqtt connect mqttd = true on mqtt disconnect wific = true on Wi-Fi connect wifid = true on Wi-Fi disconnect System variables (for debugging) stack = stack size heap = free heap size pheap = PSRAM free heap size (ESP32) core = current core (0 or 1) (ESP32) ram = used ram size slen = script length freq = cpu frequency micros = running microseconds millis = running milliseconds loglvl = loglevel of script cmds ( may be set also ) Remarks: If you define a variable with the same name as a special variable that special variable is discarded","title":"Special Variables"},{"location":"Scripting-Language/#commands","text":"=> <command> Execute cmd with MQTT output enabled -> <command> Execute cmd with MQTT output disabled, recursion disabled. Do not send MQTT or log messages (i.e., silent execute - useful to reduce traffic) +> <command> Execute cmd with MQTT output enabled, recursion enabled. Warning Recursion : If you execute a tasmota cmd in an >E section and this cmd itself executes >E you will get an infinite loop. this is disabled normally and enabled by the +> in case you know what you are doing Variable Substitution - A single percent sign must be given as %% - Variable replacement within commands is allowed using %varname% . Optionally, the decimal places precision for numeric values may be specified by placing a digit ( %Nvarname% , N = 0..9 ) in front of the substitution variable (e.g., Humidity: %3hum%%% will output Humidity: 43.271% ) - instead of variables arbitrary calculations my be inserted by bracketing %N(formula)% - Linefeed and carriage return may be defined by \\n and \\r Special commands: print or =>print prints to the log for debugging A Tasmota MQTT RESULT message invokes the script's E section. Add print statements to debug a script. Example >E slider=Dimmer power=POWER if upd[slider]>0 then print slider updated %slider% endif if upd[power]>0 then print power updated %power% endif break exits a section or terminates a for next loop dpx sets decimal precision to x (0-9) dpx.y sets preceding digits to x and decimal precision to y (0-9) dp(x y) sets preceding digits to x and decimal precision to y svars save permanent vars delay(x) pauses x milliseconds (should be as short as possible) beep(f l) (ESP32) beeps with a passive piezo beeper. beep(-f 0) attaches PIN f to the beeper, beep(f l) starts a sound with frequency f (Hz) and len l (ms). f=0 stops the sound. spin(x b) set GPIO x (0..16) to value b (0,1). Only bit 0 of b is used - even values set the GPIO to 0 and uneven values set the GPIO to 1 spinm(x m) set GPIO x (0..16) to mode m (input=0, output=1, input with pullup=2,alternatively b may be: O=out, I=in, P=in with pullup) ws2812(array dstoffset) copies an array (defined with m:vname ) to the WS2812 LED chain. The array length should be defined as long as the number of pixels. Color is coded as 24 bit RGB. optionally the destination offset in the LED chain may be given if dstoffset is flagged by 0x1000, 2 values 16 bits each in an array are used for 32 bit RGBW pixels hsvrgb(h s v) converts hue (0..360), saturation (0..100) and value (0..100) to RGB color dt display text command (if #define USE_DISPLAY) Subroutines and Parameters #name names a subroutine. Subroutine is called with =#name #name(param) names a subroutine with a parameter. Each parameter variable must be declared in the '>D' section. A subroutine with multiple parameters is declared as '#name(p1 p2 p3)', i.e. spaces between parameters. A subroutine is invoked with =#name(param) or '=#name(p1 p2) Invoking a subroutine sets the parameter variable to the corresponding expression of the invocation. This means that parameter variables have script wide scope, i.e. they are not local variables to the subroutine. Subroutines end with the next # or > line or break. Subroutine invocations may be nested (each level uses about 600 bytes stack space, so nesting level should not exeed 4). Parameters can be numbers or strings and on type mismatch are converted. If #define USE_SCRIPT_SUB_COMMAND is included in your user_config_override.h , a subroutine may be invoked via the Console or MQTT using the subroutine's name. For example, a declared subroutine #SETLED(num) may be invoked by typing SETLED 1 in the Console. The parameter 1 is passed into the num argument. This also works with string parameters. since Tasmota capitalizes all commands you must use upper case labels. It is possible to \"replace\" internal Tasmota commands. For example, if a #POWER1(num) subroutine is declared, the command POWER1 is processed in the scripter instead of in the main Tasmota code. String parameter should be passed within double quotas: CUSTOMCMD \"Some string here\" =(svar) executes a routine whose name is passed as a string in a variable (dynamic or self modifying code). The string has to start with > or =# for the routine to be executed. a subroutine may return a value (number or string): return var a subroutine is called with: var=#sub(x) when returning a value or =#sub(x) when not returning a value D svar=\"=#subroutine\" S =(svar) #subroutine print subroutine was executed For loop (loop count must not be less than 1, no direct nesting supported) for var <from> <to> <inc> next Switch selector (numeric or string) switch x case a case b ends Conditional Statements There are two syntax alternatives. You may NOT mix both formats. if a==b and x==y or k==i then = do this else = do that endif or if a==b and x==y or k==i { = do this } else { = do that } Remarks: The last closing bracket must be on a separate line Calculations are permitted in conditional expressions, e.g., if var1-var2==var3*var4 Conditional expressions may be enclosed in parentheses. The statement must be on a single line. e.g., if ((a==b) and ((c==d) or (c==e)) and (s!=\"x\")) mapping function mp(x str1 str2 ... str ) It addresses a standard task with less code and much flexibility: mapping an arbitrary incoming numeric value into the allowed range. The numeric value x passed as the first parameter is compared to the rules in the order they are provided as subsequent sting parameters. If the value matches the criteria, the defined value is returned. Subsequent rules are skipped. If x matches none of the rules, x is returned unchanged. Rules consist of one of the comparison operators < > = followed by a numeric value v1, optionally followed by a colon and another numeric value v2. <|>|=v1[:v2] Example 1: <8:0 - this rule reads: If x is less than 8, return 0. Example 2: >100 - this rule reads: If x is greater than 100, return 100. Example 3: y=mp(x <8:0 >100) Assigns 0 to y if x is less than 8. Assigns 100 to y if x is greater than 100. Assigns x to y for all values of x that do not meet the above criteria (8 to 100). The above code of example 3 does the same as the following code - with just one line of code and 15 characters less: y=x if x<8 { y=0 } if x>100 { y=100 } E-mail #define USE_SENDMAIL Enabling this feature also enables Tasmota TLS as sendmail uses SSL. sendmail [server:port:user:passwd:from:to:subject] msg Example sendmail [smtp.gmail.com:465:user:passwd:<sender@gmail.com>:<rec@gmail.com>:alarm] %string% Remark: A number of e-mail servers (such as Gmail) require the receiver's e-mail address to be enclosed by angle brackets < ... > as in example above. Most other e-mail servers also accept this format. While ESP8266 sendmail needs brackets, ESP32 sendmail inserts brackets itself so you should not specify brackets here. Warning Don't use your Google account password with GMAIL SMTP server. You must create an Application specific password The following parameters can be specified during compilation via #define directives in user_config_override.h : * EMAIL_SERVER * EMAIL_PORT * EMAIL_USER * EMAIL_PASSWORD * EMAIL_FROM To use any of these values, pass an * as its corresponding argument placeholder. Example sendmail [*:*:*:*:*:<rec@gmail.com>:theSubject] theMessage Instead of passing the msg as a string constant, the body of the e-mail message may also be composed using the script m (note lower case) section. The specified text in this script section must end with an # character. sendmail will use the m section if * is passed as the msg parameter. in this >m section you may also specify email attachments. @/filename specifies a file to be attached (if file system is present) &arrayname specifies an array attachment (as tab delimited text, no file system needed) $N attach a webcam picture from rambuffer number N (usually 1) See [Scripting Cookbook Example].(#send-e-mail) Subscribe, Unsubscribe #define SUPPORT_MQTT_EVENT subscribe and unsubscribe commands are supported. In contrast to rules, no event is generated but the event name specifies a variable defined in D section and this variable is automatically set on transmission of the subscribed item within a script the subscribe cmd must be send with +> instead of => the MQTT decoder may be configured for more space in user config overwrite by #define MQTT_EVENT_MSIZE xxx (default is 256) #define MQTT_EVENT_JSIZE xxx (default is 400) File System Support #define USE_UFILESYS optional for SD_CARD: #define USE_SDCARD #define SDCARD_CS_PIN X X = GPIO of card chip select SD card uses standard hardware SPI GPIO: mosi,miso,sclk depending on used linker file you get a flash file system with the same functionality but very low capacity (e.g. 2 MB) A maximum of four files may be open at a time e.g., allows for logging sensors to a tab delimited file and then downloading the file ( see Sensor Logging example ) The script itself is also stored on the file system with a default size of 8192 characters fr=fo(\"fname\" m) open file fname, mode 0=read, 1=write, 2=append (returns file reference (0-3) or -1 for error) (alternatively m may be: r=read, w=write, a=append) res=fw(\"text\" fr) writes text to (the end of) file fr, returns number of bytes written res=fr(svar fr) reads a string into svar, returns bytes read. String is read until delimiter (\\t \\n \\r) or eof fc(fr) close file ff(fr) flush file, writes cached data and updates directory fd(\"fname\") delete file fname frn(\"spath\" \"dpath\") rename a file flx(fname) create download link for file (x=1 or 2) fname = file name of file to download fsm return 1 if filesystem is mounted, (valid SD card found) res=fsi(sel) gets file system information, sel=0 returns total media size, sel=1 returns free space both in kB fra(array fr) reads array from open file with fr (assumes tab delimited entries) fwa(array fr) writes array to open file with fr (writes tab delimited entries) fz(fr) returns file size fa(fr) returns number of available bytes in open file stream fs(fr pos) seek to file position pos fwb(byte fr) write byte to file frb(fr) read byte from file frw(fr url) read file from web url fxt(fr ts_from ts_to col_offs accum array1 array2 ... arrayn) read arrays from csv file from timestamp to timestamp with column offset and accumulate values into arrays1 .. N, assumes csv file with timestamp in 1. column and data values in colums 2 to n.(#define USE_FEXTRACT) fxto(... same as above with time optimized access cts(tstamp flg) convert timestamp to German locale format back and forth flg=0 to webformat, 1 to German format tso(tstamp day flag) add time offset in days to timestamp optional flg = char 0 zo zero time HH:MM:SS tsn(tstamp) convert timestamp to seconds Extended commands (+0,9k flash) #define USE_SCRIPT_FATFS_EXT fmd(\"fname\") make directory fname frd(\"fname\") remove directory fname fx(\"fname\") check if file fname exists fe(\"fname\") execute script fname (max 2048 bytes, script must start with the '>' character on the first line) ESP32 real Multitasking support #define USE_SCRIPT_TASK enables support for multitasking scripts res=ct(num timer core (prio) (stack)) creates a task num (1 or 2) with optional priority and stack size which is executed every timer (ms) time on core 0 or 1 the sections are named >t1 for task 1 >t2 for task 2 Example >D >B ; create task 1 every 1000 ms on core 0 ct(1 1000 0) ; create task 2 every 3000 ms on core 1 ct(2 3000 1) >t1 print task1 on core %core% >t2 print task2 on core %core% minimal LVGL support #define USE_LVGL to test LVGL a few functions are implemented: lvgl(sel ...) general lvgl call each object gets a concurrent number 1 ... N with which you can reference the object sel = 0 => initialize LVGL with current display sel = 1 => clear screen sel = 2 xp yp xs ys text => create a button. the button press is reported in section >lvb sel = 3 xp yp xs ys => create a slider. the slider move is reported in section >lvs sel = 4 xp yp xs ys min max => create a gauge. set = 5 objnr value => set gauge value. sel = 6 xp yp xs ys text => create a label. sel = 7 objnr text => set label text sel = 8 create a keyboard, just get a look and feel sel = 50 => get obj nr from caller in callback >lvb or >lvs sel = 51 => get event nr from caller in callback >lvb or >lvs sel = 52 => get slider value from caller in callback >lvs minimal LVGL support #define USE_LVGL to test LVGL a few functions are implemented: lvgl(sel ...) general lvgl call each object gets a concurrent number 1 ... N with which you can reference the object sel = 0 => initialize LVGL with current display sel = 1 => clear screen sel = 2 xp yp xs ys text => create a button. the button press is reported in section >lvb sel = 3 xp yp xs ys => create a slider. the slider move is reported in section >lvs sel = 4 xp yp xs ys min max => create a gauge. set = 5 objnr value => set gauge value. sel = 6 xp yp xs ys text => create a label. sel = 7 objnr text => set label text sel = 8 create a keyboard, just get a look and feel sel = 50 => get obj nr from caller in callback >lvb or >lvs sel = 51 => get event nr from caller in callback >lvb or >lvs sel = 52 => get slider value from caller in callback >lvs ESP32 Webcam support #define USE_WEBCAM Template for AI THINKER CAM : remarks: - GPIO0 zero must be disconnected from any wire after programming because this pin drives the cam clock and does not tolerate any capacitive load - Only boards with PSRAM should be used. To enable PSRAM board should be se set to esp32cam in common32 of platform_override.ini board = esp32cam - To speed up cam processing CPU frequency should be better set to 240Mhz in common32 of platform_override.ini board_build.f_cpu = 240000000L file system extension: fwp(pnum fr) write picture from RAM buffer number pnum to SD card file with file reference fr specific webcam commands: res=wc(sel p1 p2) control webcam, sel = function selector p1 ... optional parameters res=wc(0 pres) init webcam with picture resolution pres, returns 0 when error, 2 when PSRAM found, else 1 pres * 0 = FRAMESIZE_QQVGA, // 160x120 * 1 = FRAMESIZE_QQVGA2, // 128x160 * 2 = FRAMESIZE_QCIF, // 176x144 * 3 = FRAMESIZE_HQVGA, // 240x176 * 4 = FRAMESIZE_QVGA, // 320x240 * 5 = FRAMESIZE_CIF, // 400x296 * 6 = FRAMESIZE_VGA, // 640x480 * 7 = FRAMESIZE_SVGA, // 800x600 * 8 = FRAMESIZE_XGA, // 1024x768 * 9 = FRAMESIZE_SXGA, // 1280x1024 * 10 = FRAMESIZE_UXGA, // 1600x1200 res=wc(1 bnum) capture picture to rambuffer bnum (1..4), returns framesize of picture or 0 when error res=wc(2 sel p1) execute various controls, details below. res=wc(3) gets picture width res=wc(4) gets picture height res=wc(5 p) start stop streaming 0=stop, 1=start res=wc(6 p) start stop motion detector, p=0 => stop detector, p=T start detector with picture every T ms, -1 get picture difference, -2 get picture brightness res=wc(7 p) start stop face detector, p=0 => stop detector, p=T start detector with picture every T ms, -1 get number of faces found in picture (USE_FACE_DETECT must be defined) control cmds sel = * 0 fs = set frame size (see above for constants) * 1 se = set special effect 0 = no effect 1 = negative 2 = black and white 3 = reddish 4 = greenish 5 = blue 6 = retro 2 fl = set horizontal flip 0,1 3 mi = set vertical mirror 0,1 to read a value without setting pass -1 extensions to the email system on ESP32 #define SEND_EMAIL and #define USE_ESP32MAIL enables specific ESP32 mail server this server can handle more mail servers by supporting START_TLS remark: mail addresses must not be enclosed with <> because the server inserts them automatically this server also supports email attachments in the >m section you may write &/file.txt to attach a file from SD card $N N=1..4 to attach a picture from picture RAM buffer number N displaying webcam pictures in WEBUI you may display a webcam picture by giving the name /wc.jpg?p=N (1..4) for RAM picturebuffer N \"<img src=\"/wc.jpg?p=1\" alt=\"webcam image\" >\" you may also provide the picture size (h and v have to be preset before) \"<img src=\"/wc.jpg?p=1\" alt=\"webcam image\" style=\"width:%w%px;height:%h%px;\">\" if you precede the line by & char the image is displayed in the main section, else in the sensor tab section the webcam stream can be specified by the following line lip is a system variable containing the local device ip \"&<br>\" \"&<img src=\"http://%lip%:81/stream\" style=\"width:%w%px;height:%h%px\">\" \"&<br><center>webcam stream\" remark: the Flash illumination LED is connected to GPIO4 Example >D res=0 w=0 h=0 mot=0 bri=0 >B ; init cam with QVGA res=wc(0 4) ; get pixel size w=wc(3) h=wc(4) ; start motion detector, picture every 1000 ms mot=wc(6 1000) >S if wific>0 then ; when wifi up, start stream res=wc(5 1) endif ; get motion detect diff value mot=wc(6 -1) ; get picture brightnes bri=wc(6 -2) >W <center>motion diff = %mot%<br> <center>brightness = %bri%<br> ; show stream on WEBUI &<br> &<img src=\"http://%lip%:81/stream\" style=\"width:%w%px;height:%h%px\"> &<br><center>webcam stream","title":"Commands"},{"location":"Scripting-Language/#scripting-cookbook","text":"","title":"Scripting Cookbook"},{"location":"Scripting-Language/#scripting-language-example","text":"a valid script must start with >D in the first line! some samples still contain comment lines before >D. This is no longer valid! **Actually this code is too large**. This is only meant to show some of the possibilities >D ; define all vars here p:mintmp=10 (p:means permanent) p:maxtmp=30 t:timer1=30 (t:means countdown timer) t:mt=0 i:count=0 (i:means auto counter) hello=\"hello world\" string=\"xxx\" url=\"[_IP_]\"; hum=0 temp=0 zigbeetemp=0 timer=0 dimmer=0 sw=0 rssi=0 param=0 col=\"\" ocol=\"\" chan1=0 chan2=0 chan3=0 ahum=0 atemp=0 tcnt=0 hour=0 state=1 m:med5=0 M:movav=0 ; define array with 10 entries m:array=0 10 >B string=hello+\"how are you?\" print BOOT executed print %hello% =>mp3track 1 ; list gpio pin definitions for cnt 0 16 1 tmp=pd[cnt] print %cnt% = %tmp% next ; get gpio pin for relais 1 tmp=pn[21] print relais 1 is on pin %tmp% ; pulse relais over raw gpio spin(tmp 1) delay(100) spin(tmp 0) ; raw pin level print level of gpio1 %pin[1]% ; pulse over tasmota cmd =>power 1 delay(100) =power 0 >T hum=BME280#Humidity temp=BME280#Temperature rssi=Wifi#RSSI string=SleepMode ; add to median filter median=temp ; add to moving average filter movav=hum ; show filtered results print %median% %movav% if chg[rssi]>0 then print rssi changed to %rssi% endif if temp>30 and hum>70 then print damn hot! endif =#siren(5) ; loop nesting workaround ; by using subroutine #siren(num) for cnt 1 num 1 =#stone next #stone for tone 2000 1000 -20 beep(tone 10); delay(12) next >S ; every second but not completely reliable time here ; use upsecs and uptime or best t: for reliable timers ; arrays array[1]=4 array[2]=5 tmp=array[1]+array[2] ; call subrountines with parameters =#sub1(\"hallo\") =#sub2(999) ; stop timer after expired if timer1==0 then timer1=-1 print timer1 expired endif ; auto counter with restart if count=10 then print 10 seconds over count=0 endif if upsecs%5==0 then print %upsecs% (every 5 seconds) endif ; not recommended for reliable timers timer+=1 if timer>=5 then print 5 seconds over (may be) timer=0 endif dimmer+=1 if dimmer>100 then dimmer=0 endif =>dimmer %dimmer% =>WebSend %url% dimmer %dimmer% ; show on display dp0 dt [c1l1f1s2p20] dimmer=%dimmer% print %upsecs% %uptime% %time% %sunrise% %sunset% %tstamp% if time>sunset and time<sunrise then ; night time if pwr[1]==0 then =>power1 1 endif else ; day time if pwr[1]>0 then =>power1 0 endif endif ; clr display on boot if boot>0 then dt [z] endif ; frost warning if ((temp<0 or zigbeetemp<0) and mt<=0) then =#sendmail(\"frost alert\") ; alarm only every 5 minutes mt=300 =mp3track 2 endif ; var has been updated if upd[hello]>0 then print %hello% endif ; send to Thingspeak every 60 seconds ; average data in between if upsecs%60==0 then ahum>=tcnt atemp>=tcnt =WebSend [_IP_]/update?key=_token_&field1=%atemp%&field2=%ahum% tcnt=0 atemp=0 ahum=0 else ahum+=hum atemp+=temp tcnt+=1 endif hour=int(time/60) if chg[hour]>0 then ; exactly every hour print full hour reached endif if time5 { print more then 5 minutes after midnight } else { print less then 5 minutes after midnight } ; publish abs hum every teleperiod time if mqtts>0 and upsecs%tper==0 then ; calc abs humidity tmp=pow(2.718281828 (17.67*temp)/(temp+243.5)) tmp=(6.112*tmp*hum*18.01534)/((273.15+temp)*8.31447215) ; publish median filtered value =>Publish tele/%topic%/SENSOR {\"Script\":{\"abshum\":%med(0 tmp)%}} endif ;switch case state machine switch state case 1 print state=%state% , start state+=1 case 2 print state=%state% state+=1 case 3 print state=%state% , reset state=1 ends ; subroutines #sub1(string) print sub1: %string% #sub2(param) print sub2: %param% #sendmail(string) =>sendmail [smtp.gmail.com:465:user:passwd:<sender@gmail.de:<rec@gmail.de:alarm] %string% >E print event executed! ; Assign temperature from a Zigbee sensor zigbeetemp=ZbReceived#0x2342#Temperature ; get HSBColor 1. component tmp=st(HSBColor , 1) ; check if switch changed state sw=sw[1] if chg[sw]>0 then =>power1 %sw% endif hello=\"event occured\" ; check for Color change (Color is a string) col=Color ; color change needs 2 string vars if col!=ocol then ocol=col print color changed %col% endif ; or check change of color channels chan1=Channel[1] chan2=Channel[2] chan3=Channel[3] if chg[chan1]>0 or chg[chan2]>0 or chg[chan3]>0 then = color has changed endif ; compose color string for red col=hn(255)+hn(0)+hn(0) =color %col% >R print restarting now","title":"Scripting Language Example"},{"location":"Scripting-Language/#sensor-logging","text":"; define all vars here ; reserve large strings >D 48 hum=0 temp=0 fr=0 res=0 cnt=0 ; moving average for 60 seconds M:mhum=0 60 M:mtemp=0 60 str=\"\" >B ; set sensor file download link ;fl1(\"slog.txt\") ; delete file in case we want to start fresh ;fd(\"slog.txt\") ; list all files in root directory fr=fo(\"/\" 0) for cnt 1 20 1 res=fr(str fr) if res>0 then print %cnt% : %str% else break endif next fc(fr) >T ; get sensor values temp=BME280#Temperature hum=BME280#Humidity >S ; average sensor values every second mhum=hum mtemp=temp ; write average to sensor log every minute if upsecs%60==0 then ; open file for write fr=fo(\"slog.txt\" 1) ; compose string for tab delimited file entry str=s(upsecs)+\"\\t\"+s(mhum)+\"\\t\"+s(mtemp)+\"\\n\" ; write string to log file res=fw(str fr) ; close file fc(fr) endif >R","title":"Sensor Logging"},{"location":"Scripting-Language/#global-variables-example","text":"make temperature and humidity of an SHT sensor public all devices in the local network may use the global variables needs #define USE_SCRIPT_GLOBVARS Sender: >D g:temp=0 g:hum=0 >T temp=SHT3X_0x44#Temperature hum=SHT3X_0x44#Humidity Receiver(s) displays the value on a display >D g:temp=0 g:hum=0 >S dt [l1c1p10]temp=%temp% C dt [l2c1p10]hum=%hum% %%","title":"global variables example"},{"location":"Scripting-Language/#e-paper-29-display-with-sgp30-and-bme280","text":"Some variables are set from ioBroker >D hum=0 temp=0 press=0 ahum=0 tvoc=0 eco2=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 tmp=0 ; preset units in case they are not available punit=\"hPa\" tunit=\"C\" >B ;reset auto draw dt [zD0] ;clr display and draw a frame dt [x0y20h296x0y40h296] >T ; get telemetry sensor values temp=BME280#Temperature hum=BME280#Humidity press=BME280#Pressure tvoc=SGP30#TVOC eco2=SGP30#eCO2 ahum=SGP30#aHumidity tunit=TempUnit punit=PressureUnit >S ; update display every [`TelePeriod`](Commands#teleperiod) if upsecs%tper==0 then dp2 dt [f1p7x0y5]%temp% %tunit% dt [p5x70y5]%hum% %%[x250y5t] dt [p11x140y5]%press% %punit% dt [p10x30y25]TVOC: %tvoc% ppb dt [p10x160y25]eCO2: %eco2% ppm dt [p10c26l5]ahum: %ahum% g^m3 dp0 dt [p25c1l5]WR 1 (Dach) : %wr1% W dt [p25c1l6]WR 2 (Garage): %-wr3% W dt [p25c1l7]WR 3 (Garten): %-wr2% W dt [p25c1l8]Aussentemperatur: %otmp% C dt [x170y95r120:30f2p6x185y100] %pwl% %% ; now update screen dt [d] endif >E >R","title":"e-Paper 29 Display with SGP30 and BME280"},{"location":"Scripting-Language/#e-paper-42-display-with-sht31-and-bme280","text":"This script shows 2 graphs on an 4.2 inch e-Paper display: 1. some local sensors, and 2. power statistics The first graph is the battery level of a solar battery (Tesla PowerWall 2) The second graph shows the solar yield of the roof panels in Watts Another special feature is that this script displays daily and weekly averages (via moving average) of all power IO of the house. it sends an email every Sunday night with the weekly data it displays a google bar chart on the webui with values for each weekday of the last week ESP32 CPU with SD card Since the display is a full update panel it is updated only once a minute Some values (like power meters) are set remotely from ioBroker >D hum=0 temp=0 press=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 ez1=0 sez1=0 M:mez1=0 7 ezh=0 sezh=0 M:mezh=0 7 vzh=0 svzh=0 M:mvzh=0 7 wd=0 res=0 hr=0 t1=0 res=0 >B ->setoption64 1 tper=30 dt [IzD0] dt [zG10352:5:40:-350:80:10080:0:100f3x360y40]100 %%[x360y115]0 %% dt [f1x100y25]Powerwall - 7 Tage[f1x360y75] 0 %% dt [G10353:5:140:-350:80:10080:0:5000f3x360y140]+5000 W[x360y215]0 W dt [f1x70y125]Volleinspeisung - 7 Tage[f1x360y180] 0 W dt [p13x10y230]WR 1,2,3: dt [p13x10y245]H-Einsp.: dt [p13x10y260]H-Verbr.: dt [p13x10y275]D-Einsp.: dt [d] dt [Gr0:/g0_sav.txt:] dt [Gr1:/g1_sav.txt:] beep(-25 0) beep(1000 100) >T press=BMP280#Pressure temp=SHT3X_0x44#Temperature hum=SHT3X_0x44#Humidity >S if upsecs%60==0 then dp2 dt [f1p7x0y5]%temp% C dt [x0y20h400x250y5T][x350t][f1p10x70y5]%hum% %% dt [p10x140y5]%press% hPa dp0 dt [p5x360y75]%pwl% %% dt [p6x360y180]%wr1%W dt [g0:%pwl%g1:%wr1%] dt [p24x75y230] %wr1% W : %-wr2% W : %-wr3% W dt [p-10x75y245]%ezh% kWh dt [p-10x75y260]%vzh% kWh dt [p-10x75y275]%ez1% kWh t1=mezh*7 dt [p-10x150y245]: %t1% kWh t1=mvzh*7 dt [p-10x150y260]: %t1% kWh t1=mez1*7 dt [p-10x150y275]: %t1% kWh dp1 t1=ezh-sezh dt [p12x250y245]: %t1% kWh t1=vzh-svzh dt [p12x250y260]: %t1% kWh t1=ez1-sez1 dt [p12x250y275]: %t1% kWh dp0 dt [f2p5x320y250] %otmp%C dt [d] print updating display endif hr=hours if chg[hr]>0 and hr==0 then mez1=ez1-sez1 sez1=ez1 mezh=ezh-sezh sezh=ezh mvzh=vzh-svzh svzh=vzh endif if sezh==0 then sez1=ez1 sezh=ezh svzh=vzh endif wd=wday if chg[wd]>0 and wd==1 then =>sendmail [*:*:*:*:*:user.tasmota@gmail.com: Wochenbericht]* print sending email endif if upsecs%300==0 then =#savgraf print saving graph endif #savgraf dt [Gs0:/g0_sav.txt:] dt [Gs1:/g1_sav.txt:] >m Wochenbericht Einspeisung und Verbrauch<br><br> w1=%mez1[1]%,%mez1[2]%,%mez1[3]%,%mez1[4]%,%mez1[5]%,%mez1[6]%,%mez1[7]%,%mez1[8]%<br> w2=%mezh[1]%,%mezh[2]%,%mezh[3]%,%mezh[4]%,%mezh[5]%,%mezh[6]%,%mezh[7]%,%mezh[8]%<br> w3=%mvzh[1]%,%mvzh[2]%,%mvzh[3]%,%mvzh[4]%,%mvzh[5]%,%mvzh[6]%,%mvzh[7]%,%mvzh[8]%<br> # >W &<br><div id=\"container\"style=\"width:640px;height:480px;margin:0 auto\"></div><br> &<script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"></script> &<script type=\"text/javascript\">google.charts.load('current',{packages:['corechart']});</script> &<script language=\"JavaScript\">function drawChart(){var data= &google.visualization.arrayToDataTable([ &['weekday','Power'],['Mo',%mvzh[1]%],['Di',%mvzh[2]%],['Mi',%mvzh[3]%],['Do',%mvzh[4]%], &['Fr',%mvzh[5]%],['Sa',%mvzh[6]%],['So',%mvzh[7]%]]); &var options={title:'daily solar feed',isStacked:true}; &var chart=new &google.visualization.ColumnChart(document.getElementById('container'));chart.draw(data,options);} &google.charts.setOnLoadCallback(drawChart);</script> #","title":"e-Paper 42 Display with SHT31 and BME280"},{"location":"Scripting-Language/#ili-9488-color-lcd-display-with-bmp280-and-vl5310x","text":"Shows various BMP280 energy graphs Turn display on and off using VL5310X proximity sensor to prevent burn-in Some variables are set from ioBroker >D temp=0 press=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 tmp=0 dist=0 punit=\"hPa\" tunit=\"C\" hour=0 >B dt [z] // define 2 graphs, 2. has 3 tracks dt [zCi1G2656:5:20:400:80:1440:-5000:5000:3Ci7f3x410y20]+5000 W[x410y95]-5000 W [Ci7f1x70y3] Zweirichtungsz~80hler - 24 Stunden dt [Ci1G2657:5:120:400:80:1440:0:5000:3Ci7f3x410y120]+5000 W[x410y195]0 W [Ci7f1x70y103] Wechselrichter 1-3 - 24 Stunden dt [Ci1G2658:5:120:400:80:1440:0:5000:16][Ci1G2659:5:120:400:80:1440:0:5000:5] dt [f1s1b0:260:260:100&#8203;:50:2:11:4:2:Rel 1:b1:370:260:100&#8203;:50:2:11:4:2:Dsp off:] =>mp3volume 100 =>mp3track 4 >T ; get some telemetry values temp=BMP280#Temperature press=BMP280#Pressure tunit=TempUnit punit=PressureUnit dist=VL53L0X#Distance ; check proximity sensor to turn display on and off to prevent burn-in if dist>300 then if pwr[2]>0 then =>power2 0 endif else if pwr[2]==0 then =>power2 1 endif endif >S ; update graph every teleperiod if upsecs%tper==0 then dp2 dt [f1Ci3x40y260w30Ci1] dt [Ci7x120y220t] dt [Ci7x180y220T] dt [Ci7p8x120y240]%temp% %tunit% dt [Ci7x120y260]%press% %punit% dt [Ci7x120y280]%dist% mm dp0 dt [g0:%zwz%g1:%wr1%g2:%-wr2%g3:%-wr3%] if zwz0 then dt [p-8x410y55Ci2Bi0]%zwz% W else dt [p-8x410y55Ci3Bi0]%zwz% W endif dt [p-8x410y140Ci3Bi0]%wr1% W dt [p-8x410y155Ci16Bi0]%-wr2% W dt [p-8x410y170Ci5Bi0]%-wr3% W endif ; chime every full hour hour=int(time/60) if chg[hour]>0 then ->mp3track 4 endif >E >R","title":"ILI 9488 Color LCD Display with BMP280 and VL5310X"},{"location":"Scripting-Language/#led-bar-display-with-ws2812-led-chain","text":"Used to display home's solar power input/output (+-5000 Watts) >D m:array=0 60 ;defines array for 60 led pixels cnt=0 val=0 ind=0 ; rgb values for grid colr1=0x050000 colr2=0x050100 colg1=0x000300 colg2=0x020300 ledbar=0 blue=64 pixels=60 steps=10 div=0 tog=0 max=5000 min=-5000 pos=0 >B div=pixels/steps =#prep ws2812(array) ; ledbar is set from broker >S if ledbar<min then ledbar=min endif if ledbar>max then ledbar=max endif pos=(ledbar/max)*(pixels/2) if ledbar>0 then pos+=(pixels/2) if pospixels-1 then pos=pixels endif else pos+=(pixels/2)+1 if pospixels-1 then pos=1 endif endif if pos<1 or pos>pixels then pos=1 endif =#prep if ledbar==0 then array[pos]=blue array[pos-1]=blue else array[pos]=blue endif ; only used if power is off ; so lets may be used normally if on if pwr[1]==0 then ws2812(array) endif ; subroutine for grid #prep for cnt 1 pixels 1 ind+=1 if ind>div then ind=1 tog^=1 endif if cnt<=pixels/2 then if tog>0 then val=colr1 else val=colr2 endif else if tog>0 then val=colg1 else val=colg2 endif endif array[cnt]=val next >R","title":"LED Bar Display with WS2812 LED Chain"},{"location":"Scripting-Language/#multiple-ir-receiver-synchronization","text":"Shows how a Magic Home with IR receiver works Synchronizes 2 Magic Home devices by also sending the commands to a second Magic Home via WebSend Script example using if then else ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] >D 25 istr=\"\" ws=\"WebSend [_IP_]\" ; event section >E ; get ir data istr=IrReceived#Data ; on if istr==\"0x00F7C03F\" then ->wakeup ->%ws% wakeup endif ; off if istr==\"0x00F740BF\" then ->power1 0 ->%ws% power1 0 endif ;white if istr==\"0x00F7E01F\" then ->color 000000ff ->%ws% color 000000ff endif ;red if istr==\"0x00F720DF\" then ->color ff000000 ->%ws% color ff000000 endif ;green if istr==\"0x00F7A05F\" then ->color 00ff0000 ->%ws% color 00ff0000 endif ;blue if istr==\"0x00F7609F\" then ->color 0000ff00 ->%ws% color 0000ff00 endif ; dimmer up if istr==\"0x00F700FF\" then ->dimmer + ->%ws% dimmer + endif ;dimmer down if istr==\"0x00F7807F\" then ->dimmer - ->%ws% dimmer - endif istr=\"\" Script example using switch case ends ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] >D 25 istr=\"\" ws=\"WebSend [_IP_]\" ; event section >E ; get ir data istr=IrReceived#Data switch istr ; on case \"0x00F7C03F\" ->wakeup ->%ws% wakeup ;off case \"0x00F740BF\" ->power1 0 ->%ws% power1 0 ;white case \"0x00F7E01F\" ->color 000000ff ->%ws% color 000000ff ;red case \"0x00F720DF\" ->color ff000000 ->%ws% color ff000000 ;green case \"0x00F7A05F\" ->color 00ff0000 ->%ws% color 00ff0000 ;blue case \"0x00F7609F\" ->color 0000ff00 ->%ws% color 0000ff00 ; dimmer up case \"0x00F700FF\" ->dimmer + ->%ws% dimmer + ; dimmer down case \"0x00F7807F\" ->dimmer - ->%ws% dimmer - ends istr=\"\"","title":"Multiple IR Receiver Synchronization"},{"location":"Scripting-Language/#fast-polling","text":"; expand default string length to be able to hold `WebSend [xxx.xxx.xxx.xxx]` >D 25 sw=0 ws=\"WebSend [_IP_]\" timer=0 hold=0 toggle=0 >B ; gpio 5 button input spinm(5,0) ; fast section 100ms >F sw=pin[5] ; 100 ms timer timer+=1 ; 3 seconds long press ; below 0,5 short press if sw==0 and timer5 and timer<30 then ; short press ;print short press toggle^=1 =>%ws% power1 %toggle% endif if sw>0 then ;pressed if timer>30 then ; hold hold=1 ;print hold=%timer% if toggle>0 then =>%ws% dimmer + else =>%ws% dimmer - endif endif else timer=0 hold=0 endif","title":"Fast Polling"},{"location":"Scripting-Language/#web-ui","text":"An example to show how to implement a web UI. This example controls a light via WebSend >D dimmer=0 sw=0 color=\"\" col1=\"\" red=0 green=0 blue=0 ww=0 >F color=hn(red)+hn(green)+hn(blue)+hn(ww) if color!=col1 then col1=color =>websend [192.168.178.75] color %color% endif if chg[dimmer]>0 then =>websend [192.168.178.75] dimmer %dimmer% endif if chg[sw]>0 then =>websend [192.168.178.75] power1 %sw% endif >W bu(sw \"Light on\" \"Light off\") ck(sw \"Light on/off \") sl(0 100 dimmer \"0\" \"Dimmer\" \"100\") sl(0 255 red \"0\" \"red\" \"255\") sl(0 255 green \"0\" \"green\" \"255\") sl(0 255 blue \"0\" \"blue\" \"255\") sl(0 255 ww \"0\" \"warm white\" \"255\") tx(color \"color: \")","title":"Web UI"},{"location":"Scripting-Language/#hue-emulation","text":"An example to show how to respond to Alexa requests via Hue Emulation When Alexa sends on/off, dimmer, and color (via hsb), send commands to a MagicHome device >D pwr1=0 hue1=0 sat1=0 bri1=0 tmp=0 >E if upd[hue1]>0 or upd[sat1]>0 or upd[bri1]>0 then tmp=hue1/182 ->websend [192.168.178.84] hsbcolor %tmp%,%sat1%,%bri1% endif if upd[pwr1]>0 then ->websend [192.168.178.84] power1 %pwr1% endif >H ; on,hue,sat,bri,ct livingroom,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1","title":"Hue Emulation"},{"location":"Scripting-Language/#alexa-controlled-mcp230xx-i2c-gpio-expander","text":"Uses Tasmota's Hue Emulation capabilities for Alexa interface ; define vars >D p:p1=0 p:p2=0 p:p3=0 p:p4=0 ; init ports >B ->sensor29 0,5,0 ->sensor29 1,5,0 ->sensor29 2,5,0 ->sensor29 3,5,0 ->sensor29 0,%0p1% ->sensor29 1,%0p2% ->sensor29 2,%0p3% ->sensor29 3,%0p4% ; define Alexa virtual devices >H port1,S,on=p1 port2,S,on=p2 port3,S,on=p3 port4,S,on=p4 ; handle events >E print EVENT if upd[p1]>0 then ->sensor29 0,%0p1% endif if upd[p2]>0 then ->sensor29 1,%0p2% endif if upd[p3]>0 then ->sensor29 2,%0p3% endif if upd[p4]>0 then ->sensor29 3,%0p4% endif =#pub ; publish routine #pub =>publish stat/%topic%/RESULT {\"MCP23XX\":{\"p1\":%0p1%,\"p2\":%0p2%,\"p3\":%0p3%,\"p4\":%0p4%}} svars ; web interface >W bu(p1 \"p1 on\" \"p1 off\")bu(p2 \"p2 on\" \"p2 off\")bu(p3 \"p3 on\" \"p3 off\")bu(p4 \"p4 on\" \"p4 off\")","title":"Alexa Controlled MCP230xx I2C GPIO Expander"},{"location":"Scripting-Language/#retrieve-network-gateway-ip-address","text":">D gw=\"\" ; Request Status information. The response will trigger the `U` section >B +>status 5 ; Read the status JSON payload >U gw=StatusNET#Gateway print %gw%","title":"Retrieve network gateway IP Address"},{"location":"Scripting-Language/#send-e-mail","text":">D 25 day1=0 et=0 to=\"<mrx@gmail.com>\" >T et=ENERGY#Total >S ; send at midnight day1=day if chg[day1]>0 then =>sendmail [*:*:*:*:*:%to%:energy report]* endif >m email report at %tstamp% your power consumption today was %et% KWh #","title":"Send e-mail"},{"location":"Scripting-Language/#send-power-reading-with-formatted-time-stamp-via-websend","text":"Some web APIs require certain formats (e.g. date & time) to be provided. This example illustrates how to reformat the timestamp and embed it in the get payload. On ESP8266 based devices this is limited to unsecured http (no \"s\") connections! Don't use this for sensitive data! >D 42 ;long string required for key y=0 m=0 d=0 key=\"yourkey\" id=\"yourSystemID\" ws=\"WebSend [pvoutput.org]\" et=0 p=0 >T et=ENERGY#Total p=ENERGY#Power ; every 5 minutes if upsecs%300==0 then y=sb(tstamp 0 4) m=sb(tstamp 5 2) d=sb(tstamp 8 2) =>%ws%/service/r2/addstatus.jsp?key=%key%&sid=%id%&d=%1.0(y)%%2.0(m)%%2.0(d)%&t=%1(sb(tstamp 11 5))%&v2=%s(2.0p)% endif","title":"Send power reading with formatted time stamp via websend"},{"location":"Scripting-Language/#switching-and-dimming-by-recognizing-mains-power-frequency","text":"Switching in Tasmota is usually done by High/Low (+3.3V/GND) changes on a GPIO. However, for devices like the Moes QS-WiFi-D01 Dimmer , this is achieved by a pulse frequency when connected to the GPIO, and these pulses are captured by Counter1 in Tasmota. When the light is OFF and there is a short period of pulses - then turn the light ON at the previous dimmer level. When the light is ON and there is a short period of pulses - then turn the light OFF . When there is a longer period of pulses (i.e., HOLD ) - toggle dimming direction and then adjust the brightness level as long as the button is pressed or until the limits are reached. Issue 6085 In the Data Section D at the beginning of the Script the following initialization variables may be changed: dim multiplier = 0..2.55 set the dimming increment value dim lower limit = range for the dimmer value for push-button operation (set according to your bulb); min 0 dim upper limit = range for the dimmer value for push-button operation (set according to your bulb); max 100 start dim level = initial dimmer level after power-up or restart; max 100 >D sw=0 tmp=0 cnt=0 tmr=0 hold=0 powert=0 slider=0 dim=\"\" shortprl=2 ;short press lo limit shortpru=10;short press up limit dimdir=0 ;dim direction 0/1 dimstp=2 ;dim step/speed 1 to 5 dimmlp=2.2 ;dim multiplier dimll=15 ;dim lower limit dimul=95 ;dim upper limit dimval=70 ;start dim level >B print \"WiFi-Dimmer-Script-v0.2\" =>Counter1 0 =>Baudrate 9600 ; boot sequence =#senddim(dimval) delay(1000) =#senddim(0) >F cnt=pc[1] if chg[cnt]>0 ; sw pressed then sw=1 else sw=0 ; sw not pressed endif ; 100ms timer tmr+=1 ; short press if sw==0 and tmr>shortprl and tmr<shortpru then powert^=1 ; change light on/off if powert==1 then =#senddim(dimval) else =#senddim(0) endif endif ; long press if sw>0 then if hold==0 then ; change dim direction dimdir^=1 endif if tmr>shortpru then hold=1 if powert>0 ; dim when on & hold then if dimdir>0 then ; increase dim level dimval+=dimstp if dimval>dimul then ; upper limit dimval=dimul endif =#senddim(dimval) else ; decrease dim level dimval-=dimstp if dimval<dimll then ; lower limit dimval=dimll endif =#senddim(dimval) endif endif endif else tmr=0 hold=0 endif >E slider=Dimmer ; slider change if chg[slider]>0 then ; dim according slider if slider>0 then dimval=slider =#senddim(dimval) else powert=0 =#senddim(0) endif endif if pwr[1]==1 ; on/off webui then powert=1 =#senddim(dimval) else powert=0 =#senddim(0) endif ; subroutine dim #senddim(tmp) dim=\"FF55\"+hn(tmp*dimmlp)+\"05DC0A\" =>SerialSend5 %dim% =>Dimmer %tmp% #","title":"Switching and Dimming By Recognizing Mains Power Frequency"},{"location":"Scripting-Language/#dual-display-example","text":">D >B ; load sh1106 driver dt [S2/SH1106_desc.txt:] ; clear screen, switch to LCD font; set auto draw dt [zf4s1D1] dt [S1:] >S ; switch to display 2 dt [S2:] ; show time dt [x20y20t] ; switch back to display 1 dt [S1:]","title":"Dual display example"},{"location":"Scripting-Language/#read-i2c-example-axp192","text":">D volt=0 curr=0 found=0 >B ; check device on I2C bus Nr.2 found=ia2(0x34) >S ; if found read registers, (this example takes 2ms to read both values) if found>0 { volt=ir(0x5a)<<4|ir(0x5b)*1.7/1000 curr=ir(0x58)<<4|ir(0x59)*0.625 } >W ; show on webui Bus Voltage{m}%volt% V Bus Current{m}%curr% mA","title":"read I2C example (AXP192)"},{"location":"Scripting-Language/#multiplexing-a-single-adc-with-cd4067-breakout","text":">D ; this script works with an CD4067 breakout to multiplex a single ADC channel ; of an ESP IP=192.168.178.177 SB=8192 res=0 cnt=0 mcnt=0 m:mux=0 16 >B ; define output pins for multiplexer spinm(12 O) spinm(13 O) spinm(14 O) spinm(15 O) ; define string array with 16 entries res=is1(16 \"\") is1[1]=\"Azalea\" is1[2]=\"Aster\" is1[3]=\"Bougainvillea\" is1[4]=\"Camellia\" is1[5]=\"Carnation\" is1[6]=\"Chrysanthemum\" is1[7]=\"Clematis\" is1[8]=\"Daffodil\" is1[9]=\"Dahlia\" is1[10]=\"Daisy\" is1[11]=\"Edelweiss\" is1[12]=\"Fuchsia\" is1[13]=\"Gladiolus\" is1[14]=\"Iris\" is1[15]=\"Lily\" is1[16]=\"Periwinkle\" >F ; get adc value into array, average 4 values ; this is for ESP32 here on pin 32 mux[mcnt+1]=adc(4 32) ; this is for ESP8266 it has only 1 ADC input ; mux[mcnt+1]=adc(4) mcnt+=1 if mcnt>=16 then mcnt=0 endif ; set multiplexer spin(12 mcnt) spin(13 mcnt/2) spin(14 mcnt/4) spin(15 mcnt/8) ; display web UI #wsub if wm==0 then for cnt 1 16 1 wcs {s}Ch %0cnt%: %is1[cnt]%{m}%mux[cnt]% %%{e} next endif #rsub rap ,\"CD4067\":{ for cnt 1 16 1 rap \"%is1[cnt]%\":%mux[cnt]% if cnt<16 then rap , endif next rap } >J ; send to mqtt ; call json subroutine %=#rsub >W ; call web subroutine %=#wsub","title":"Multiplexing a single adc with CD4067 breakout"},{"location":"Scripting-Language/#image-gallery-of-various-tasmota-scripts","text":"","title":"Image gallery of various Tasmota scripts"},{"location":"Scripting-Language/#internet-radio","text":"","title":"Internet radio"},{"location":"Scripting-Language/#webcam-with-multiple-options","text":"","title":"Webcam with multiple options"},{"location":"Scripting-Language/#energy-collector","text":"","title":"Energy collector"},{"location":"Scripting-Language/#energy-display-main-menu","text":"","title":"Energy display main menu"},{"location":"Scripting-Language/#energy-display-one-day-of-database","text":"","title":"Energy display one day of database"},{"location":"Scripting-Language/#energy-display-last-week-of-database","text":"","title":"Energy display last week of database"},{"location":"Scripting-Language/#energy-display-last-weeks-of-database","text":"","title":"Energy display last weeks of database"},{"location":"Scripting-Language/#environment-sensor","text":"","title":"environment sensor"},{"location":"Scripting-Language/#timer-main-menu","text":"","title":"timer main menu"},{"location":"Scripting-Language/#timer-setup","text":"","title":"timer setup"},{"location":"Securing-your-IoT-from-hacking/","text":"General Weaknesses ~ Whenever you add devices to your network you generate additional points of potential intrusion. This is not only valid for your mobile phones and computers, but also for you Smart TV, you Alexa, or all of your SONOFF devices (ESP8266). There are following potential risks you have to mitigate: Someone is able to communicate with your device ( Scenario 1 ) Someone hacks your device and is able to log in into your WLAN. (why is this a problem? Scanario 2 ) Someone hacks your device and is able to read and change any value on your MQTT server (why is this a problem? Scanario 3 ) Someone hacks your network and can interact with your devices (why is this a problem? Scanario 4 ) Someone hacks your device and use it for different things like mail bot or DOS (Denial of Service) device or WLAN jammer (why is this a problem? Scanario 5 ) Scenario 1 ~ It is possible to set a password to the webadmin interface , however ESP8266 devices SHALL not be exposed to internet or accessible to other network clients. (e.g. users in the same network) [1] [2] . Scenario 2 ~ If someone is able to get your WLAN key, he can login into your network, if he is nearby and scan for any traffic and for any devices. Many communication is not encrypted in your WLAN by default. Therefore be part of your WLAN gives the attacker a great opportunity to screw-up the rest of your infrastructure. Also be part of your WLAN does mean, that the attacker can use your IP-Address and your traffic to do nasty things. Scenario 3 ~ If you can hack an ESP82xx device, you might get access to the keys stored in the device. For example, the MQTT password allows you to read ALL of your devices and change any device at any time. With the information of the MQTT-Server user/password, it might be not required anymore to physically be in your WLAN. Maybe your MQTT Server is publicly accessible. Then the attacker can control your home from any place. Update: Beginning with version 6.0.0, passwords are not directly exposed through the serial connection or web interface in configuration mode. Therefore it is now less simple, however still possible to obtain the MQTT or WLAN password from a device. Such can be accomplished by downloading a configuration backup via the web UI of the device and decoding it using the decode-config.py script found in the Tasmota tools folder. Scenario 4 ~ It might happen, that e.g. your Samsung SmartTV is not as secure as it should be and an attacker gets access to your network. Now he can listen to any traffic and maybe can make changes on all of your IoT devices. Scenario 5 ~ If someone uses your device to spam mail or do a DOS attack the impact at your home is minimal. You might have more outbound traffic, but maybe you don't recognize this either. But thousands of hacked IoT devices can generate tremendous trouble even at the largest internet providers. I hope these five typical scenarios ( the list is not complete) give you some idea, why you should take care, even if you're not a terrorist and normally nobody is interested into hacking you personally. Securing your WLAN ~ That you should have a WLAN key and use WPA2 for encryption is a \"no brainer\". This is a minimum requirement. Now think about someone can extract the password from the device. E.g. because the device is in the garden and someone with a Laptop and some USB stuff can connect and extract information. The hacker will get the key. The ONLY possible preventive action to mitigate worst case scenario is to have a second WLAN, like the \"FritzBox Guest WLAN\". Many other routers offer similar things. This guest WLAN has no access to your private WLAN. Additionally, there are some interesting switched you can configure for the WLAN. At the FritzRouter you can configure \"network separation\" . At Fritz this is done by DISABLE \"The wireless devices connected with the guest access can communicate with each other\" . This does mean, that a device in the network can not interact with any other device in the WLAN. It can only communicate with the Internet. This simple configuration prevents any attacker to do nasty stuff on YOUR network. Now we have to take care, that the attacker is not creating a Bot-Net and sending e.g., Spam-Mails. Normally a device in the \"guest WLAN\" can use any internet service. For our IoT devices and for any new device we can create a Router rule, that ONLY MQTT is allowed to our server and any other traffic is blocked. This is a great configuration because it limits the options what a hacker can do. If you have a FritzBox following configuration has to be created to get this working: Create Profile to block all communication except MQTT and NTP Time services. Internet -> Filters -> List -> \"Add Network Application\" \"New Protocol\" (Add four rules, This will block all but UDP123 for Timeserver and 8883 for MQTT Server) TCP from any to Port 1 to 8882 TCP from any to Port 8884 to 65636 UDP from any to Port 1 to 122 UDP from any to Port 124 to 65636 Create a list of \"websites\" your IoT devices are allowed to access. Internet -> Filters -> List -> \"Permitted web sites\" -> EDIT yourserver 01.de.pool.ntp.org Replace with the full qualified name of your router in the Internet. NTP server - Use the one you have defined in Tasmota to be the timeserver. Create a profile you can attach to your IoT devices. Internet -> Filters -> Access profiles -> \"new Access profile\" \"Filter Web sites\" DISABLE \"Allow HTTPS queries\" SELECT \"Permit web sites (whitelist) Now you will probably ask two questions: How can I communicate with my MQTT Server in my personal WLAN if only traffic into the internet is allowed? How can I access the WebConsole of my devices to upload new Firmware and/or make investigations? The first topic will be solved by exposing your MQTT server to the Internet (no worries, can be done securely). The second topic has only a workaround. If you want access to your devices you need to change the configuration temporary on your router and ENABLE \"The wireless devices connected with the guest access can communicate with each other\" . Secondly, you must login with your Laptop into the GuestWLAN to be able to communicate. If the Webserver is running you should be able to connect and upload e.g. a new firmware. Securing your Communication ~ In the world of IoT devices and more and more devices in a network, it is essential to use encryption ALL the time. The Tasmota project is able to enable encryption for MQTT. This is great. But it cannot enable encryption on the WebServer. This is bad. As a conclusion, the Webserver must be switched OFF all the time and only be switched ON for administrative purpose. This also disables the feature to change the Relay Status with an HTTP REST call. But this option is insecure anyway and should be avoided. Now let's work on the MQTT configuration. Also here an attacker can get access to user and password. To minimize the impact EVERY and really EVERY device must have a unique USER and a unique password. If you don't follow this rule the attacker get one device he can control ALL devices. With the USER/PASSWORD he now can control the one device he already holds in his hands. ok, no big deal. How to configure Mosquitto? In general, Tasmota stores data in stat/ /+ and tele/ /+. or cmnd/ /+ to control something. If we use the as username we can make some quite nice and straight forward configuration. Example: Topic: ESP_123456 User: ESP_123456 (must be the same to Topic) password: 987654321 Configuration file: /etc/mosquitte/conf.d/jp.acl user root topic read # topic write # pattern read cmnd/%u/# pattern write stat/%u/# pattern write tele/%u/# My user root is allowed to do everything. This is used in my home-automation to control all devices and listen to all devices. The \"pattern\" is used for ALL other users and the %u is a substitute. The great thing is that the device can read its configuration but cannot write to it. And the status information it posts to the /status/ but is not able to read it afterward. With this minimal configuration, Tasmota devices are running. To add the different user to Mosquitto the following two commands work fine. There is also a re-read available, but a restart works better for me. sudo mosquitto_passwd -b /etc/mosquitto/conf.d/jp.pw ESP_123456 987654321 sudo /etc/init.d/mosquitto restart If this is running, we switch the Mosquitto to secure communication on Port 8883 and disable all insecure options. /etc/mosquitto/conf.d/user.conf #User Config password_file /etc/mosquitto/conf.d/jp.pw acl_file /etc/mosquitto/conf.d/jp.acl allow_anonymous false listener 8883 cafile /etc/mosquitto/certs/ca.crt certfile /etc/mosquitto/certs/server.crt keyfile /etc/mosquitto/certs/server.key require_certificate false How to generate the certificates in mosquitto please look at: Mosquitto SSL Configuration - MQTT TLS Security Adding TLS to connect to Mosquitto Internet of Things messaging MQTT with TLS Enable Secure Communication with TLS and the Mosquitto Broker SSL/TLS on Tasmota ~ TLS article explains how to set it up in Tasmota Self-signed-Mosquitto article explain how to set up Tasmota with certificate-based TLS authentication on a local installation of Mosquitto. Disable unsecured fallback WiFi (WifiManager) ~ Type WifiConfig into the tasmota console. If this parameter is set to 2, you might want to change it after completing the setup of your device since in case your Wifi SSID is not available (i.e. access point dies or WLAN jammer is used as in Scanario 5 ), the WiFiManager will jump into action and make your tasmota devices available using an unsecured access point. Some less risky options would be: 0/4/5. Currently the default WiFiConfig value is (WIFI_RETRY) which means that device retries other AP without rebooting. (For details, see Wi-Fi commands ). Home Assistant OS MQTT Add-On ~ If you are using Home Assistant OS MQTT add-on with Tasmota integration the devices will need write access to the tasmota/discovery/# topic. Add the following to the ACL file (user section or general section): topic write tasmota/discovery/# . For completeness' sake, below is a snippet of the ACL file with the full recommended structure. ######## ######## General section # Commented out all general rules. # topic readwrite homeassistant/# # topic write tasmota/discovery/# ######## ######## ######## User section user sonoff-living-fan-2 # This is used when SetOption19 1 is used. topic readwrite homeassistant/# # This is used when SetOption19 0 is used. topic write tasmota/discovery/# ######## ######## ######## Pattern Section # https://tasmota.github.io/docs/Securing-your-IoT-from-hacking/ pattern read cmnd/%u/# pattern write stat/%u/# pattern write tele/%u/# ########","title":"Securing your IoT from hacking"},{"location":"Securing-your-IoT-from-hacking/#general-weaknesses","text":"Whenever you add devices to your network you generate additional points of potential intrusion. This is not only valid for your mobile phones and computers, but also for you Smart TV, you Alexa, or all of your SONOFF devices (ESP8266). There are following potential risks you have to mitigate: Someone is able to communicate with your device ( Scenario 1 ) Someone hacks your device and is able to log in into your WLAN. (why is this a problem? Scanario 2 ) Someone hacks your device and is able to read and change any value on your MQTT server (why is this a problem? Scanario 3 ) Someone hacks your network and can interact with your devices (why is this a problem? Scanario 4 ) Someone hacks your device and use it for different things like mail bot or DOS (Denial of Service) device or WLAN jammer (why is this a problem? Scanario 5 )","title":"General Weaknesses"},{"location":"Securing-your-IoT-from-hacking/#securing-your-wlan","text":"That you should have a WLAN key and use WPA2 for encryption is a \"no brainer\". This is a minimum requirement. Now think about someone can extract the password from the device. E.g. because the device is in the garden and someone with a Laptop and some USB stuff can connect and extract information. The hacker will get the key. The ONLY possible preventive action to mitigate worst case scenario is to have a second WLAN, like the \"FritzBox Guest WLAN\". Many other routers offer similar things. This guest WLAN has no access to your private WLAN. Additionally, there are some interesting switched you can configure for the WLAN. At the FritzRouter you can configure \"network separation\" . At Fritz this is done by DISABLE \"The wireless devices connected with the guest access can communicate with each other\" . This does mean, that a device in the network can not interact with any other device in the WLAN. It can only communicate with the Internet. This simple configuration prevents any attacker to do nasty stuff on YOUR network. Now we have to take care, that the attacker is not creating a Bot-Net and sending e.g., Spam-Mails. Normally a device in the \"guest WLAN\" can use any internet service. For our IoT devices and for any new device we can create a Router rule, that ONLY MQTT is allowed to our server and any other traffic is blocked. This is a great configuration because it limits the options what a hacker can do. If you have a FritzBox following configuration has to be created to get this working: Create Profile to block all communication except MQTT and NTP Time services. Internet -> Filters -> List -> \"Add Network Application\" \"New Protocol\" (Add four rules, This will block all but UDP123 for Timeserver and 8883 for MQTT Server) TCP from any to Port 1 to 8882 TCP from any to Port 8884 to 65636 UDP from any to Port 1 to 122 UDP from any to Port 124 to 65636 Create a list of \"websites\" your IoT devices are allowed to access. Internet -> Filters -> List -> \"Permitted web sites\" -> EDIT yourserver 01.de.pool.ntp.org Replace with the full qualified name of your router in the Internet. NTP server - Use the one you have defined in Tasmota to be the timeserver. Create a profile you can attach to your IoT devices. Internet -> Filters -> Access profiles -> \"new Access profile\" \"Filter Web sites\" DISABLE \"Allow HTTPS queries\" SELECT \"Permit web sites (whitelist) Now you will probably ask two questions: How can I communicate with my MQTT Server in my personal WLAN if only traffic into the internet is allowed? How can I access the WebConsole of my devices to upload new Firmware and/or make investigations? The first topic will be solved by exposing your MQTT server to the Internet (no worries, can be done securely). The second topic has only a workaround. If you want access to your devices you need to change the configuration temporary on your router and ENABLE \"The wireless devices connected with the guest access can communicate with each other\" . Secondly, you must login with your Laptop into the GuestWLAN to be able to communicate. If the Webserver is running you should be able to connect and upload e.g. a new firmware.","title":"Securing your WLAN"},{"location":"Securing-your-IoT-from-hacking/#securing-your-communication","text":"In the world of IoT devices and more and more devices in a network, it is essential to use encryption ALL the time. The Tasmota project is able to enable encryption for MQTT. This is great. But it cannot enable encryption on the WebServer. This is bad. As a conclusion, the Webserver must be switched OFF all the time and only be switched ON for administrative purpose. This also disables the feature to change the Relay Status with an HTTP REST call. But this option is insecure anyway and should be avoided. Now let's work on the MQTT configuration. Also here an attacker can get access to user and password. To minimize the impact EVERY and really EVERY device must have a unique USER and a unique password. If you don't follow this rule the attacker get one device he can control ALL devices. With the USER/PASSWORD he now can control the one device he already holds in his hands. ok, no big deal. How to configure Mosquitto? In general, Tasmota stores data in stat/ /+ and tele/ /+. or cmnd/ /+ to control something. If we use the as username we can make some quite nice and straight forward configuration. Example: Topic: ESP_123456 User: ESP_123456 (must be the same to Topic) password: 987654321 Configuration file: /etc/mosquitte/conf.d/jp.acl user root topic read # topic write # pattern read cmnd/%u/# pattern write stat/%u/# pattern write tele/%u/# My user root is allowed to do everything. This is used in my home-automation to control all devices and listen to all devices. The \"pattern\" is used for ALL other users and the %u is a substitute. The great thing is that the device can read its configuration but cannot write to it. And the status information it posts to the /status/ but is not able to read it afterward. With this minimal configuration, Tasmota devices are running. To add the different user to Mosquitto the following two commands work fine. There is also a re-read available, but a restart works better for me. sudo mosquitto_passwd -b /etc/mosquitto/conf.d/jp.pw ESP_123456 987654321 sudo /etc/init.d/mosquitto restart If this is running, we switch the Mosquitto to secure communication on Port 8883 and disable all insecure options. /etc/mosquitto/conf.d/user.conf #User Config password_file /etc/mosquitto/conf.d/jp.pw acl_file /etc/mosquitto/conf.d/jp.acl allow_anonymous false listener 8883 cafile /etc/mosquitto/certs/ca.crt certfile /etc/mosquitto/certs/server.crt keyfile /etc/mosquitto/certs/server.key require_certificate false How to generate the certificates in mosquitto please look at: Mosquitto SSL Configuration - MQTT TLS Security Adding TLS to connect to Mosquitto Internet of Things messaging MQTT with TLS Enable Secure Communication with TLS and the Mosquitto Broker","title":"Securing your Communication"},{"location":"Securing-your-IoT-from-hacking/#ssltls-on-tasmota","text":"TLS article explains how to set it up in Tasmota Self-signed-Mosquitto article explain how to set up Tasmota with certificate-based TLS authentication on a local installation of Mosquitto.","title":"SSL/TLS on Tasmota"},{"location":"Securing-your-IoT-from-hacking/#disable-unsecured-fallback-wifi-wifimanager","text":"Type WifiConfig into the tasmota console. If this parameter is set to 2, you might want to change it after completing the setup of your device since in case your Wifi SSID is not available (i.e. access point dies or WLAN jammer is used as in Scanario 5 ), the WiFiManager will jump into action and make your tasmota devices available using an unsecured access point. Some less risky options would be: 0/4/5. Currently the default WiFiConfig value is (WIFI_RETRY) which means that device retries other AP without rebooting. (For details, see Wi-Fi commands ).","title":"Disable unsecured fallback WiFi (WifiManager)"},{"location":"Securing-your-IoT-from-hacking/#home-assistant-os-mqtt-add-on","text":"If you are using Home Assistant OS MQTT add-on with Tasmota integration the devices will need write access to the tasmota/discovery/# topic. Add the following to the ACL file (user section or general section): topic write tasmota/discovery/# . For completeness' sake, below is a snippet of the ACL file with the full recommended structure. ######## ######## General section # Commented out all general rules. # topic readwrite homeassistant/# # topic write tasmota/discovery/# ######## ######## ######## User section user sonoff-living-fan-2 # This is used when SetOption19 1 is used. topic readwrite homeassistant/# # This is used when SetOption19 0 is used. topic write tasmota/discovery/# ######## ######## ######## Pattern Section # https://tasmota.github.io/docs/Securing-your-IoT-from-hacking/ pattern read cmnd/%u/# pattern write stat/%u/# pattern write tele/%u/# ########","title":"Home Assistant OS MQTT Add-On"},{"location":"Self-signed-Mosquitto/","text":"This feature is not included in precompiled binaries To use it you must compile your build . The following guide will walk you through the setup of Tasmota with your own instance of Mosquitto Server with Certificate-based TLS encryption and a Self-signed CA (Certificate Authority). Benefits ~ The following setup provides stronger security in communication between your devices and your MQTT server. - No cloud usage ~ Many people might prefer cloud-based solutions, such as AWS IOT . Nonetheless, running local MQTT provides various benefits like no internet requirements, no data sharing with third parties and lower latencies. - Maximum security ~ This setup is designed with 'security first' in mind. Communication is done over TLS 1.2 tunnels, using client certificates to authenticate each device. Strong encryption is particularly valuable considering that ESP8266-based Tasmota devices can only connect using WPA2 with preshared keys. Because WPA2 Personal has known security weaknesses, the MQTT strong TLS configuration is encouraged in this scenario. Caveats ~ Certificate-based MQTT-TLS requires each Tasmota device to have its own distinct Private Key and Certificate (~800 bytes). Although you could imagine to use the same Private Key in all your devices, this is considered as a very bad practice. You are warned! During TLS handshake, a secondary stack of 5.3k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes. How to configure? ~ Ideally we will work on three systems: 1. CA machine : a secure, possibly air-gap system, where you generate your certificates; 2. Server Machine : the machine running your MQTT server. We will assume it is running some Debian-based distribution (i.e. Ubuntu Server), though the steps could be adapted to different OSes; 3. Compiling Machine : the machine used to compile your customized Tasmota firmware. This machine might be the same Server Machine , though I would not recommend it. !!! failure \"Security notice\" Private keys, and in particular the CA private key should reside on a secure, possibly air-gapped system. Securing your CA and procedures for managing private keys exceeds the scope of this guide, but we assume you follow best security practices. There are several figures below containing command sequences that need to be executed in a POSIX shell. The intention is that text in the figure windows will be selected and copied, then pasted into a terminal window. These commands will not work if pasted into a Windows command prompt. Linux and Windows ~ The description below is written mainly from the perspective of someone using a Linux OS. Information is also provided for those working on a Windows OS, but a Linux command shell (e.g. sh or bash ) is assumed for much of the work. Cygwin is a good choice for this purpose. It's not impossible to do perform these tasks in native Windows without a POSIX shell, although that is beyond the scope of this document. A Cygwin installation should include the git package (Devel category) and openssl package (Net category). Additional packages will be required as discussed later if BearSSL is to be installed. 1. Prepare your CA (on Server Machine ) ~ We will use Easy-RSA for easy management of the CA and certificates. Some modification are required to match our configuration. 1.1. Prepare Easy-RSA : ~ Get a copy of Easy-RSA and add a reduced x509 extension definition for Tasmota. Certificates obtained using standard client definitions are too big and results in failure when storing them on Tasmota devices. git clone https://github.com/OpenVPN/easy-rsa.git cd easy-rsa/easyrsa3 # Define reduced x509 extension for Tasmota cat <<EOF > x509-types/tasmota # X509 extensions for a Tasmota client basicConstraints = critical,CA:FALSE subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always keyUsage = critical,digitalSignature EOF Windows users may have trouble running EasyRSA natively. If that happens, it's also possible to install Cygwin, and work from a Cygwin terminal window. One note of caution: The easyrsa shell script may wind up with the wrong line endings if git is not configured to checkout line endings \"as is\". When this happens, the shell script will not run in Cygwin, and this problem may be fixed by using the tr program to delete carriage returns in the script file: mv easyrsa tmprsa tr -d '\\r' <tmprsa >easyrsa 1.2. Define your certificate information ~ The commands below may be copied and pasted into a terminal window, then the resulting file, vars edited as appropriate. # Define your info cat <<EOF > vars # Define X509 DN mode. # This is used to adjust what elements are included in the Subject field as the DN # (this is the \"Distinguished Name.\") # Note that in cn_only mode the Organizational fields further below aren't used. # # Choices are: # cn_only - use just a CN value # org - use the \"traditional\" Country/Province/City/Org/OU/email/CN format set_var EASYRSA_DN \"org\" # Organizational fields (used with 'org' mode and ignored in 'cn_only' mode.) # These are the default values for fields which will be placed in the # certificate. Don't leave any of these fields blank, although interactively # you may omit any specific field by typing the \".\" symbol (not valid for # email.) set_var EASYRSA_REQ_COUNTRY \"UK\" set_var EASYRSA_REQ_PROVINCE \"London\" set_var EASYRSA_REQ_CITY \"London\" set_var EASYRSA_REQ_ORG \"myorg\" set_var EASYRSA_REQ_EMAIL \"info@myorg.com\" set_var EASYRSA_REQ_OU \"MQTT\" # Choose a size in bits for your keypairs. The recommended value is 2048. Using # 2048-bit keys is considered more than sufficient for many years into the # future. Larger keysizes will slow down TLS negotiation and make key/DH param # generation take much longer. Values up to 4096 should be accepted by most # software. Only used when the crypto alg is rsa (see below.) set_var EASYRSA_KEY_SIZE 2048 # The default crypto mode is rsa; ec can enable elliptic curve support. # Note that not all software supports ECC, so use care when enabling it. # Choices for crypto alg are: (each in lower-case) # * rsa # * ec # * ed set_var EASYRSA_ALGO rsa # Define the named curve, used in ec & ed modes: set_var EASYRSA_CURVE prime256v1 # In how many days should the root CA key expire? set_var EASYRSA_CA_EXPIRE 3650 # In how many days should certificates expire? set_var EASYRSA_CERT_EXPIRE 1800 # Cryptographic digest to use. # Do not change this default unless you understand the security implications. # Valid choices include: md5, sha1, sha256, sha224, sha384, sha512 #set_var EASYRSA_DIGEST \"sha256\" EOF This creates a configuration file named vars -- the default file which the easyrsa shell script looks for. If the configuration is to be changed there are two options. First, vars can simply be edited to reflect the new configuration. However, if multiple configurations are often used, it may be easier to use a different file for each configuation, and the configuration specified on the command line. For example, to use a configuration file named vars3 , the command would look like this (the config file spec must come before other arguments): ./easyrsa --vars=./vars3 <remaining arguments> Note that the file is specified as ./<filename> , not <filename> . This required because the specified file will be sourced in the EasyRSA shell script, and it's assumed that the current directory is not part of the search path (that would be a security concern). 1.3. Initialize and generate the CA and the server certificates: ~ When generating the server (aka broker) certificate, it is crucial that the Common Name (CN) be set correctly. Failing to do this will result in Tasmota devices refusing to make TLS connections to the server. Each Tasmota device needs to be configured with the host name of the server. This is done via the MQTT_HOST macro in user_config_override.h , and/or in the device's MQTT Configuration web page. The host name string must meet two requirements: - The Tasmota device must be able to resolve the name, which might require access to a DNS server. - This string must match the Common Name (CN) in the broker's certificate -- exactly. Consider a situation where the device is running on an isolated WiFi network with no access to a DNS server. In this case, it may be necessary to specify the MQTT Host as a numeric IP address (e.g. 192.168.2.3 ). For this example, the CN in the host's certificate must be the string 192.168.2.3 . To generate the root CA and server certificates, issue these commands. This example assumes the server's hostname and server certificate CN is mqtt.myorg.com . # Reset PKI ./easyrsa init-pki # Build CA following instructions ./easyrsa build-ca # Request server certificate following instructions ./easyrsa gen-req mqtt.myorg.com # Sign certificate for server ./easyrsa sign-req server mqtt.myorg.com 1.4. Change key types (EC is required for tasmota devices) ~ This example shows editing of the vars file, although a second configuration file could be created for EC keys as explained previously. sed -i '/^set_var\\ EASYRSA_ALGO/ s/rsa/ec/' vars 1.5. Copy the following files to the Server Machine ~ ./pki/ca.crt --> CA certificate file ./pki/issued/mqtt.myorg.com.crt --> Server certificate file ./pki/private/mqtt.myorg.com.key --> Server private Key file 1.6. (Optional step for full certificate validation) ~ Copy ./pki/ca.crt to your Compiling Machine Install and build BearSSL (see below for help with building BearSSL on Windows machines). git clone https://www.bearssl.org/git/BearSSL cd BearSSL make tools Convert the root certificate into a format suitable for inclusion in the Tasmota build. This be will easier if the brssl ( brssl.exe in Cygwin) executable is copied into the the easyrsa3 directory first. Then, these two commands may be executed from the easyrsa3 directory verbatim to generate the required header files. ./brssl ta pki/ca.crt | sed -e 's/TA0/PROGMEM TA0/' -e '/br_x509/,+999 d' > local_ca_data.h ./brssl ta pki/ca.crt | sed -e '1,/br_x509/ d' -e '/};/,+999 d' >local_ca_descriptor.h 2. Configure your Tasmotabuild (on Compiling Machine ) ~ Refer to your preferred way to custom compile Tasmota. Modify the default configuration following one of 2.1 or 2.2 solutions (Easier or Advanced): 2.1. Easier: Using fingerprint validation ~ Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS // #define USE_MQTT_TLS_CA_CERT // Force full CA validation instead of fingerprints, slower, but simpler to use. (+2.2k code, +1.9k mem during connection handshake) #define USE_MQTT_AWS_IOT // This includes the LetsEncrypt CA in tasmota_ca.ino for verifying server certificates #define USE_MQTT_TLS_FORCE_EC_CIPHER // Force Elliptic Curve cipher (higher security) required by some servers (automatically enabled with USE_MQTT_AWS_IOT) (+11.4k code, +0.4k mem) #define MQTT_FINGERPRINT1 \"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\" // [MqttFingerprint1] (auto-learn) #define MQTT_FINGERPRINT2 \"DA 39 A3 EE 5E 6B 4B 0D 32 55 BF EF 95 60 18 90 AF D8 07 09\" // [MqttFingerprint2] (invalid) #endif 2.2. Advanced: Using Full certificate validation ~ Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #define USE_MQTT_TLS_CA_CERT // Force full CA validation instead of fingerprints, slower, but simpler to use. (+2.2k code, +1.9k mem during connection handshake) #define USE_MQTT_AWS_IOT // This will include LetsEncrypt CA, as well as our CA, in tasmota_ca.ino for verifying server certificates #define USE_MQTT_TLS_FORCE_EC_CIPHER // Force Elliptic Curve cipher (higher security) required by some servers (automatically enabled with USE_MQTT_AWS_IOT) (+11.4k code, +0.4k mem) #define INCLUDE_LOCAL_CA_CERT #endif Copy or move the files created in step 1.6 above ( local_ca_data.h and local_ca_descriptor.h ) to the $TASMOTAROOT/tasmota directory. If desired, the two built-in certificates for Let's Encrypt and Amazon AWS may be omitted from the build by defining these macros in user_config_overrirde.h : #define OMIT_LETS_ENCRYPT_CERT #define OMIT_AWS_CERT 3. Build your Tasmota Binaries, flash and configure your devices ~ Initially at least, build the binaries with the web server enabled. Pull up the web page on each device and check the configuration. In particular check the following settings. WiFi Host Name MQTT Host -- must be resolvable, and match the Common Name on the server's certificate MQTT Port -- this often does not come up as defined in the configuration file, and must be changed to 8883 MQTT Topic 4. Configure your network ~ The Common Name (CN) in the server's certificate will either be a resolvable name (like mqtt.myorg.com ), or the IP address string for the server (e.g. 192.168.2.3 ). The host name assigned to the server must match this CN, unless an IP address string is used in the server certificate CN, in which case the host name can be anything. These next two items are only necessary where the CN is not an IP address string. Configure your router to resolve the Tasmota device's MQTT Host Name (e.g. mqtt.myorg.com ) to your Server Machine . Configure your Server Machine hostname to the same name (e.g. mqtt.myorg.com ). In all cases, check these Tasmota guidelines about Securing your IoT . 5. Install and configure Mosquitto on your server ~ Install Mosquitto Linux ~ sudo apt-get install Mosquitto Windows ~ Download and run the Windows installer from https://www.mosquitto.org/ . Mosquitto may be installed either as a program or service. The main difference is in how mosquitto is started. As a program, it must be started by a user every time, but as a service it can be automatically started by the OS during boot. 5.1 Configuration ~ Copy the files from CA Machine to the following locations on a Linux server machine: /etc/mosquitto/ca_certificates/ca.crt /etc/mosquitto/certs/mqtt.myorg.com.crt /etc/mosquitto/certs/mqtt.myorg.com.key and to here on a Windows server machine (requires Administrative priveledges): C:\\Program Files\\mosquitto\\ca.crt C:\\Program Files\\mosquitto\\mqtt.myorg.com.crt C:\\Program Files\\mosquitto\\mqtt.myorg.com.key On Windows, if preferred, one or two subdirectories within the mosquitto installation directory can be created to hold the certificates. That might make it easier to restrict access to a private key in plain text form. There are two options for configuring the server's private key. It can be converted to plain text form ( .pem ) as shown below, or left encrypted ( .key ). If left encrypted, the password will need to be entered by hand every time the server is started. This will not be feasible if mosquitto is to be run as a service. Security risks can be minimzed by setting tight permissions on the files, as shown below. Convert the private key to plain text format like this: openssl rsa -in mqtt.myorg.com.key -out mqtt.myorg.com.pem File Permissions: Linux ~ Ensure the files have owner mosquitto:mosquitto and permissions -r-------- . Also ensure ca_certificates and certs directories have owner mosquitto:mosquitto and permissions dr-x------ . File Permissions: Windows ~ It should be possible to configure permissions so that only the SYSTEM user can read the private key file, and when mosquitto is run as a service, it runs under the SYSTEM account. How to do this is currently beyond the scope of this guide. 5.3 Configure and start the server ~ Edit /etc/mosquitto/conf.d/default.conf as following: protocol mqtt allow_anonymous false listener 8884 socket_domain ipv4 # Certs and Keys cafile /etc/mosquitto/ca_certificates/ca.crt certfile /etc/mosquitto/certs/mqtt.myorg.com.crt keyfile /etc/mosquitto/certs/mqtt.myorg.com.pem require_certificate true use_identity_as_username true On a Windows machine, the configuration file is C:\\Program Files\\mosquitto\\mosquitto.conf , and the paths to the certificate and key files should be set accordingly using standard Windows path syntax. To start Mosquitto on Linux: sudo service mosquitto Start To start Mosquitto on Windows, either use the services snap-in ( services.msc ), or from an Administrator command prompt: net start mosquitto 6. - Generate and configure certificates for your devices ~ !!! failure \"Repeated step\" Repeat the following 6.x steps once for every device, changing tasmota_name for each device. You will be prompted for a private key password for each device. After entering the new password (twice for verification), you will also be prompted for the private key password of the root CA certificate. 6.1 Generate the client certificates ~ export TAS=tasmota_name # Request tasmota certs (will ask for password) ./easyrsa gen-req $TAS # Sign certificate for Tasmota ./easyrsa sign-req tasmota $TAS 6.2 Convert certificate keys to Tasmota compatible format ~ The new certificate must be converted to Tasmota commands which can be entered into the device's web console. Credentials are composed of two distinct parts: Private Key - this is the secret that will allow your device to prove its identity, and consists of 32 bytes (256 bits). Consider this as sensitive as a password. Public Key - this allows others to encrypt messages which can only be decrypted with the Private Key, and contains 256 bytes (2048 bits). Both of these must be loaded into flash in the Tasmota device. This is done by entering TLSKey commands in the device's web console. This step must be performed on the machine where the device certificates were created, from within the easyrsa3 directory. The following commands will generate a shell script, gen-tlskeys , which will perform the necessary work. cat >gen-tlskeys <<'EOF' # Decrypt private key (will ask for a password), then extract TLSKey1 (private) and TLSKey2 (public) values if [ \"$#\" -ne 1 ] ; then echo \"Usage: gen-tasmota-cert <device-certificate-name>\" exit 1 fi if [ ! -f pki/private/$1.key ] ; then echo \"Could not find private key file pki/private/$1.key\" exit 1 fi if [ ! -f pki/issued/$1.crt ] ; then echo \"Could not find public key file pki/issued/$1.crt\" exit 1 fi openssl ec -in ./pki/private/$1.key -outform PEM | \\ openssl ec -inform PEM -outform DER | openssl asn1parse -inform DER | \\ head -3 | tail -1 | awk -F':' '{ print $4 }' | xxd -r -p | base64 | \\ echo -e \"----\\n\\nCopy the following commands and paste them into the device's web console\\n\\n---\\n\\nTLSKey1 $(</dev/stdin)\" && \\ openssl x509 -in ./pki/issued/$1.crt -inform PEM -outform DER | \\ openssl base64 -e -in - -A|echo -e \"\\n\\nTlskey2 $(</dev/stdin)\" EOF chmod 755 gen-tlskeys Now, for each device, simply enter this command. As above, the variable ( $TAS ) is set to the name of the device's certificate. Output will consist of two Tasmota device commands printed to the terminal window; these must be copied and pasted into the device's web console. ./gen-tlskeys $TAS The TLSKey1 command contains the device's private key in plain text (unencrypted) format, so don't keep it around any longer than necessary. 6.3 Access your device's web console and configure the keys. ~ Run the TLSKey1 and TLSKey2 commands as obtained in the previous output. Open each of the files, copy the text and paste it into the web console. 6.4 Verify the device is connecting as expected. ~ Building BearSSL on Windows machines ~ This can be a challenging task, and a method to accomplish this through Cygwin is described here. Here are the issues that need to be fixed before BearSSL will build under Cygwin. Many of them are related to the differences between Windows and Linux when it comes to programming socket I/O. - Commands for compiling and linking are gcc , not cc - Additional compiler flags are required to compile and link socket I/O code - A Windows socket library ( libws2_32 ) must be included in the link edit step when building the brssl executable - A local implementation of a missing function ( inet_ntop ) must be added to the build The current git master branch of BearSSL is required -- the 0.6 version available as a gzipped tar archive will not work. An up-to-date version of gcc in Cygwin is also required -- old versions may experience an internal compiler error when building BearSSL. Start by installing Cygwin, selecting the gcc and make packages in the Devel category, and the openssl package in the Net category. Open a Cygwin terminal window and change to the directory where BearSSL source was cloned. To access a Windows letter drive such as F:\\somepath in Cygwin, use the path /cygdrive/f/somepath . All of the necessary patches are easily made by copying and pasting this set of commands into the Cygwin terminal window. This will create files needed to patch the BearSSL build. First, change to the top level BearSSL directory in the Cytwin window. After selecting the text in the window below, click in the Cygwin window and hit Control-Insert to paste, or right-click in the window and select Paste from the drop-down menu. You may need to hit Enter after doing this. cat >edit-Unix-mk.sed <<'EOF' 1 a \\# Modified for building on Cygwin systems /^CC.*=.*cc/ c \\CC = gcc /^LDDLL.*=.*cc/ c \\LDDLL = gcc /^LD.*=.*cc/ c \\LD = gcc /^CFLAGS.*=/ s/-fPIC/-DWINVER=0x0501 -DEWOULDBLOCK=EAGAIN/ /^LDOUT.*=/ a \\BRSSL_EXT_LIBS = -lws2_32 EOF cat >extraTargets <<'EOF' $(OBJDIR)$Pinet_ntop$O: tools$Pinet_ntop.c $(HEADERSTOOLS) $(CC) $(CFLAGS) $(INCFLAGS) $(CCOUT)$(OBJDIR)$Pinet_ntop$O tools$Pinet_ntop.c $(BRSSL): $(BEARSSLLIB) $(OBJBRSSL) $(LD) $(LDFLAGS) $(LDOUT)$(BRSSL) $(OBJBRSSL) $(BEARSSLLIB) $(BRSSL_EXT_LIBS) EOF cat >tools/inet_ntop.c <<'EOF' #ifdef _WIN32 #include <stdio.h> #include <stdlib.h> #include <string.h> #include <stdint.h> #include <errno.h> #include <signal.h> #include <winsock2.h> #include <ws2tcpip.h> const char *inet_ntop(int af, const void *src, char *dst, int cnt) { if (af == AF_INET) { struct sockaddr_in in; memset(&in, 0, sizeof(in)); in.sin_family = AF_INET; memcpy(&in.sin_addr, src, sizeof(struct in_addr)); getnameinfo((struct sockaddr *)&in, sizeof(struct sockaddr_in), dst, cnt, NULL, 0, NI_NUMERICHOST); return dst; } else if (af == AF_INET6) { struct sockaddr_in6 in; memset(&in, 0, sizeof(in)); in.sin6_family = AF_INET6; memcpy(&in.sin6_addr, src, sizeof(struct in_addr6)); getnameinfo((struct sockaddr *)&in, sizeof(struct sockaddr_in6), dst, cnt, NULL, 0, NI_NUMERICHOST); return dst; } return NULL; } #endif EOF cat >patch-bearssl <<'EOF' sed -f edit-Unix-mk.sed conf/Unix.mk >conf/Cygwin.mk sed -e '/^OBJBRSSL = / a \\ $(OBJDIR)$Pinet_ntop$O \\\\' mk/Rules.mk >Rules.tmp cat Rules.tmp extraTargets >mk/Rules.mk rm -f Rules.tmp cp -f tools/brssl.h brssl.tmp sed -e '/^#include.*bearssl\\.h/ a \\const char *inet_ntop(int,const void*,char*,int);' brssl.tmp >tools/brssl.h rm -f brssl.tmp EOF chmod 755 patch-bearssl Check to make sure that the file extraTargets contains a leading tab character, not spaces on the $(CC) and $(LD) lines. Executing the following commands should get the job done: ./patch-bearssl make tools CONF=Cygwin The resulting brssl.exe file will be found in the build directory, and should be copied to the top level EasyRSA directory.","title":"Self signed Mosquitto"},{"location":"Self-signed-Mosquitto/#benefits","text":"The following setup provides stronger security in communication between your devices and your MQTT server.","title":"Benefits"},{"location":"Self-signed-Mosquitto/#-no-cloud-usage","text":"Many people might prefer cloud-based solutions, such as AWS IOT . Nonetheless, running local MQTT provides various benefits like no internet requirements, no data sharing with third parties and lower latencies.","title":"- No cloud usage"},{"location":"Self-signed-Mosquitto/#-maximum-security","text":"This setup is designed with 'security first' in mind. Communication is done over TLS 1.2 tunnels, using client certificates to authenticate each device. Strong encryption is particularly valuable considering that ESP8266-based Tasmota devices can only connect using WPA2 with preshared keys. Because WPA2 Personal has known security weaknesses, the MQTT strong TLS configuration is encouraged in this scenario.","title":"- Maximum security"},{"location":"Self-signed-Mosquitto/#caveats","text":"Certificate-based MQTT-TLS requires each Tasmota device to have its own distinct Private Key and Certificate (~800 bytes). Although you could imagine to use the same Private Key in all your devices, this is considered as a very bad practice. You are warned! During TLS handshake, a secondary stack of 5.3k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. If you see memory going below 15KB, you may experience crashes.","title":"Caveats"},{"location":"Self-signed-Mosquitto/#how-to-configure","text":"Ideally we will work on three systems: 1. CA machine : a secure, possibly air-gap system, where you generate your certificates; 2. Server Machine : the machine running your MQTT server. We will assume it is running some Debian-based distribution (i.e. Ubuntu Server), though the steps could be adapted to different OSes; 3. Compiling Machine : the machine used to compile your customized Tasmota firmware. This machine might be the same Server Machine , though I would not recommend it. !!! failure \"Security notice\" Private keys, and in particular the CA private key should reside on a secure, possibly air-gapped system. Securing your CA and procedures for managing private keys exceeds the scope of this guide, but we assume you follow best security practices. There are several figures below containing command sequences that need to be executed in a POSIX shell. The intention is that text in the figure windows will be selected and copied, then pasted into a terminal window. These commands will not work if pasted into a Windows command prompt.","title":"How to configure?"},{"location":"Self-signed-Mosquitto/#linux-and-windows","text":"The description below is written mainly from the perspective of someone using a Linux OS. Information is also provided for those working on a Windows OS, but a Linux command shell (e.g. sh or bash ) is assumed for much of the work. Cygwin is a good choice for this purpose. It's not impossible to do perform these tasks in native Windows without a POSIX shell, although that is beyond the scope of this document. A Cygwin installation should include the git package (Devel category) and openssl package (Net category). Additional packages will be required as discussed later if BearSSL is to be installed.","title":"Linux and Windows"},{"location":"Self-signed-Mosquitto/#1-prepare-your-ca-on-server-machine","text":"We will use Easy-RSA for easy management of the CA and certificates. Some modification are required to match our configuration.","title":"1. Prepare your CA (on Server Machine)"},{"location":"Self-signed-Mosquitto/#2-configure-your-tasmotabuild-on-compiling-machine","text":"Refer to your preferred way to custom compile Tasmota. Modify the default configuration following one of 2.1 or 2.2 solutions (Easier or Advanced):","title":"2. Configure your Tasmotabuild (on Compiling Machine)"},{"location":"Self-signed-Mosquitto/#3-build-your-tasmota-binaries-flash-and-configure-your-devices","text":"Initially at least, build the binaries with the web server enabled. Pull up the web page on each device and check the configuration. In particular check the following settings. WiFi Host Name MQTT Host -- must be resolvable, and match the Common Name on the server's certificate MQTT Port -- this often does not come up as defined in the configuration file, and must be changed to 8883 MQTT Topic","title":"3. Build your Tasmota Binaries, flash and configure your devices"},{"location":"Self-signed-Mosquitto/#4-configure-your-network","text":"The Common Name (CN) in the server's certificate will either be a resolvable name (like mqtt.myorg.com ), or the IP address string for the server (e.g. 192.168.2.3 ). The host name assigned to the server must match this CN, unless an IP address string is used in the server certificate CN, in which case the host name can be anything. These next two items are only necessary where the CN is not an IP address string. Configure your router to resolve the Tasmota device's MQTT Host Name (e.g. mqtt.myorg.com ) to your Server Machine . Configure your Server Machine hostname to the same name (e.g. mqtt.myorg.com ). In all cases, check these Tasmota guidelines about Securing your IoT .","title":"4. Configure your network"},{"location":"Self-signed-Mosquitto/#5-install-and-configure-mosquitto-on-your-server","text":"Install Mosquitto","title":"5. Install and configure Mosquitto on your server"},{"location":"Self-signed-Mosquitto/#6-generate-and-configure-certificates-for-your-devices","text":"!!! failure \"Repeated step\" Repeat the following 6.x steps once for every device, changing tasmota_name for each device. You will be prompted for a private key password for each device. After entering the new password (twice for verification), you will also be prompted for the private key password of the root CA certificate.","title":"6. - Generate and configure certificates for your devices"},{"location":"Self-signed-Mosquitto/#building-bearssl-on-windows-machines","text":"This can be a challenging task, and a method to accomplish this through Cygwin is described here. Here are the issues that need to be fixed before BearSSL will build under Cygwin. Many of them are related to the differences between Windows and Linux when it comes to programming socket I/O. - Commands for compiling and linking are gcc , not cc - Additional compiler flags are required to compile and link socket I/O code - A Windows socket library ( libws2_32 ) must be included in the link edit step when building the brssl executable - A local implementation of a missing function ( inet_ntop ) must be added to the build The current git master branch of BearSSL is required -- the 0.6 version available as a gzipped tar archive will not work. An up-to-date version of gcc in Cygwin is also required -- old versions may experience an internal compiler error when building BearSSL. Start by installing Cygwin, selecting the gcc and make packages in the Devel category, and the openssl package in the Net category. Open a Cygwin terminal window and change to the directory where BearSSL source was cloned. To access a Windows letter drive such as F:\\somepath in Cygwin, use the path /cygdrive/f/somepath . All of the necessary patches are easily made by copying and pasting this set of commands into the Cygwin terminal window. This will create files needed to patch the BearSSL build. First, change to the top level BearSSL directory in the Cytwin window. After selecting the text in the window below, click in the Cygwin window and hit Control-Insert to paste, or right-click in the window and select Paste from the drop-down menu. You may need to hit Enter after doing this. cat >edit-Unix-mk.sed <<'EOF' 1 a \\# Modified for building on Cygwin systems /^CC.*=.*cc/ c \\CC = gcc /^LDDLL.*=.*cc/ c \\LDDLL = gcc /^LD.*=.*cc/ c \\LD = gcc /^CFLAGS.*=/ s/-fPIC/-DWINVER=0x0501 -DEWOULDBLOCK=EAGAIN/ /^LDOUT.*=/ a \\BRSSL_EXT_LIBS = -lws2_32 EOF cat >extraTargets <<'EOF' $(OBJDIR)$Pinet_ntop$O: tools$Pinet_ntop.c $(HEADERSTOOLS) $(CC) $(CFLAGS) $(INCFLAGS) $(CCOUT)$(OBJDIR)$Pinet_ntop$O tools$Pinet_ntop.c $(BRSSL): $(BEARSSLLIB) $(OBJBRSSL) $(LD) $(LDFLAGS) $(LDOUT)$(BRSSL) $(OBJBRSSL) $(BEARSSLLIB) $(BRSSL_EXT_LIBS) EOF cat >tools/inet_ntop.c <<'EOF' #ifdef _WIN32 #include <stdio.h> #include <stdlib.h> #include <string.h> #include <stdint.h> #include <errno.h> #include <signal.h> #include <winsock2.h> #include <ws2tcpip.h> const char *inet_ntop(int af, const void *src, char *dst, int cnt) { if (af == AF_INET) { struct sockaddr_in in; memset(&in, 0, sizeof(in)); in.sin_family = AF_INET; memcpy(&in.sin_addr, src, sizeof(struct in_addr)); getnameinfo((struct sockaddr *)&in, sizeof(struct sockaddr_in), dst, cnt, NULL, 0, NI_NUMERICHOST); return dst; } else if (af == AF_INET6) { struct sockaddr_in6 in; memset(&in, 0, sizeof(in)); in.sin6_family = AF_INET6; memcpy(&in.sin6_addr, src, sizeof(struct in_addr6)); getnameinfo((struct sockaddr *)&in, sizeof(struct sockaddr_in6), dst, cnt, NULL, 0, NI_NUMERICHOST); return dst; } return NULL; } #endif EOF cat >patch-bearssl <<'EOF' sed -f edit-Unix-mk.sed conf/Unix.mk >conf/Cygwin.mk sed -e '/^OBJBRSSL = / a \\ $(OBJDIR)$Pinet_ntop$O \\\\' mk/Rules.mk >Rules.tmp cat Rules.tmp extraTargets >mk/Rules.mk rm -f Rules.tmp cp -f tools/brssl.h brssl.tmp sed -e '/^#include.*bearssl\\.h/ a \\const char *inet_ntop(int,const void*,char*,int);' brssl.tmp >tools/brssl.h rm -f brssl.tmp EOF chmod 755 patch-bearssl Check to make sure that the file extraTargets contains a leading tab character, not spaces on the $(CC) and $(LD) lines. Executing the following commands should get the job done: ./patch-bearssl make tools CONF=Cygwin The resulting brssl.exe file will be found in the build directory, and should be copied to the top level EasyRSA directory.","title":"Building BearSSL on Windows machines"},{"location":"Sensor-API/","text":"Tasmota sensor API documentation for sensor driver development. Important things to consider ~ There are several I 2 C sensor examples you can take from the development codebase when writing your own and you are encouraged to do this as it is a quick and easy way to see how things fit together. The Tasmota firmware is essentially intended for ESP8266/ESP8285 Wi-Fi SoC based devices and commits to the main development branch will be subject to review based on whether or not what you intend to develop or add to the existing code is relevant to the general ESP device users. That being said, there is a lot of development going into the firmware which extends the functionality of standard off the shelf Sonoff devices. The firmware in itself is also useful for boards such as the WeMos ESP82xx boards. More technically inclined individuals who use generic ESP82xx modules in their own circuits to provide more access to pins and the ability to add more sensors and hardware external to the device or the generic ESP82xx module circuits can also take advantage of Tasmota. The resources on the ESP82xx are finite. Most devices ship with 1MByte SPI flash which means for the generic device users, the code generally needs to be less than 502KBytes to ensure that OTA (Over The Air) flash functionality (which is the main reason why people use this firmware) remains available. RAM is also limited to an absolute maximum of 80KBytes. This memory is divided into heap (used by global variables and Strings) and stack (used by local variables) where stack space is just 4KBytes. Given the above resource constraints it's important to keep your code as small as possible, as fast running as possible, and use as little RAM as possible. You need to think about these resource constraints all the time whilst doing any development you wish to add to the firmware functionality - Face the fact that microcontroller development isn't as close a relative to standard computer programming as you'd expect. You will be adding code to an existing framework which requires you to adhere to some simple but strict rules such as not having any infinite loops like you would have in your generic Arduino code and try to avoid using the delay() functions when writing your code as this will cause the entire firmware to be subjected to the delays you have added - Infinite loops will cause the firmware to lock up completely! If your sensor has configuration options please make these available by using the SensorXX framework which is already incorporated in the base code - This may not stop you from using a web-based configuration interface but since web-based configuration takes up a lot of code space in flash it is very important to make this optional by means of a compiler directive or a #define in the configuration file and as such something you need to keep in mind during your development and debugging - The more progressively optional additional features are in your driver the smaller the basic codebase can be for minimalist implementations. Whilst developing drivers for devices that use the I 2 C bus always consider other devices already supported in the codebase which may use the same address range. This could mean you need to find a unique way of differentiating your device detection from other devices on the same address range (e.g. querying a model-specific register) and/or disabling by #undef existing devices if yours is selected with a #define statement and in such cases always provide a warning to the user during compile time using the #warning pragma such as including #warning **** Turned off conflicting drivers SHT and VEML6070 **** in your code. DO NOT ADD WEB INTERFACE FOR SENSOR CONFIGURATION if your sensor requires additional user configuration. The reason for this is the additional program memory required but most importantly the amount of RAM required to even create minimal user interfaces. Running out of RAM during runtime will lead to abnormal behaviour of your driver and/or other drivers or the entire firmware! See sensors such as the MCP23008/MCP23017 driver on more information on how to implement SensorXX commands instead! While developing you might want to enable additional debugging provided by file xdrv_99_debug.ino using #define USE_DEBUG_DRIVER which provides some commands for managing configuration settings and CPU timing. In addition you can enable define PROFILE_XSNS_SENSOR_EVERY_SECOND to profile your drivers duration. Do not assume others will know immediately how to use your addition and know that you will need to write a Wiki for it in the end. Managing a Forked Branch ~ If you plan to submit a PR bigger than a simple change in one file, here is a short intro about how to do a clean PR. fork the Tasmota repository in Github git clone https://github.com/<github_user>/Tasmota.git and work on your local copy git remote add upstream https://github.com/arendst/Tasmota.git git checkout development git checkout -b <temp_branch> to create a working branch where you can push commits git push --set-upstream origin <temp_branch> work on your local version and push as many commits as you want When you think it is ready to merge and submit a PR: git checkout development to go back to the main branch git pull upstream development to update all the latest changes git push to update your fork git checkout -b <pr_branch> to create a new branch for the final PR git push --set-upstream origin <pr_branch> Merge the edits but be sure to remove the history of your local commits git merge --squash <temp_branch> git commit -m \"Message\" Now you have a clean single commit from which you can create the PR on the Tasmota Github. Directory/file structure ~ Sensor libraries are located in the lib/ directory. Sensor drivers are located in the tasmota/ directory. The filename of the sensor driver is xsns_<driver_ID>_<driver_name>.ino , e.g. xsns_05_ds18b20.ino where <driver_ID> is a unique number between 01 and 90 and <driver_name> is a human-readable name of the driver. Using generic libraries from external sources for sensors should be avoided as far as possible as they usually include code for other platforms and are not always written in an optimized way. API structure ~ Pre-processor directives ~ Conditional compiling of a sensor driver is achieved by adding a pre-processor directive of the scheme USE_<driver_name> in my_user_config.h . Accordingly the driver code has to be wrapped in #ifdef USE_<driver_name> ... #endif // USE_<driver_name> . Any Sensor driver must contain a pre-processor directive defining the driver ID by the scheme #define XSNS_<driver_ID> . Callback function ~ Any sensor driver needs a callback function following the scheme // Conditional compilation of driver #ifdef USE_<driver_name> // Define driver ID #define XSNS_<driver_ID> <driver_ID> /** * The callback function Xsns<driver_ID>() interfaces Tasmota with the sensor driver. * * It provides the Tasmota callback IDs. * * @param byte callback_id Tasmota function ID. * @return boolean Return value. * @pre None. * @post None. * */ boolean Xsns < driverID > ( byte callback_id ) { // Set return value to `false` boolean result = false ; // Check if I2C interface mode // if(i2c_flg) { // Check which callback ID is called by Tasmota switch ( callback_id ) { case FUNC_INIT : break ; case FUNC_EVERY_50_MSECOND : break ; case FUNC_EVERY_SECOND : break ; case FUNC_JSON_APPEND : break ; #ifdef USE_WEBSERVER case FUNC_WEB_APPEND : break ; #endif // USE_WEBSERVER case FUNC_SAVE_BEFORE_RESTART : break ; case FUNC_COMMAND : break ; } // } // if(i2c_flg) // Return boolean result return result ; } #endif // USE_<driver_name> Callback IDs ~ FUNC_INIT This callback ID is called when sensor drivers should be initialized. FUNC_EVERY_50_MSECOND This callback ID is called every 50 milliseconds, e.g. for near real-time operation FUNC_EVERY_SECOND This callback ID is called every second. It can be useful for anything that you need to do on a per second basis and is commonly used as an entry point to detect a driver or initialize an externally driven device such as a sensor, relay board or other forms of input/output required by your driver. You would normally want to make sure you've detected and initialised before it is used by JSON_APPEND , etc. so that its ready to serve data. The generally accepted way to use this would be to detect your sensor and once this is done set a sensor value accordingly so that the function does not use unnecessary resources during future calls, for example: void MySensorDetect () { if ( MySensorDetected ) { return ; } /* * Perform the code which needs to be completed to * detect your sensor and then set MySensorDetected to * a non-zero value which will prevent this section * of your code to re-run every time the function is * called. * * Under normal circumstances you'd not need to do * re-detect or initialise your sensor once it has been * done */ } Setting a flag that the driver was successful in detecting the attached chip/board via I 2 C or SPI will prevent it from continuously trying to initialize an already initialized device. When writing your function responsible for detecting an externally connected I 2 C device try to create a method by which you read or write to specific registers that would be applicable to that specific I 2 C device only as to confirm a positive detect for the device. If this is not done extensively it will lead to some drivers getting false detects for a different device type simply because it shares the same I 2 C address. Unless your driver is specifically going to use the entire array of addresses provisioned by the manufacturer please consider using a #define USE_MYCHIPNAME_ADDR in the my_user_config.h so that the user may specify the address on which to expect the device. This is of course only applicable to drivers that are not enabled by default in any of the pre-built binaries. I 2 C address auto-detection example #define MPR121_I2C_ADDR_1ST 0x5A /** 1st I2C address of sensor model **/ #define MPR121_I2C_ADDR_NUM 4 /** Number of sensors/I2C addresses **/ #define MPR121_I2C_ID_REG 0x5D /** Sensor model specific ID register **/ #define MPR121_I2C_ID_VAL 0x24 /** Sensor model specific ID register value **/ /* Sensor data struct type declaration/default definition */ typedef struct { bool connected = false ; /** Status if sensor is connected at I2C address */ bool running = false ; /** Running state of sensor */ . . . } mpr121 ; // Declare array of sensor data structs mpr121 mpr121 [ MPR121_I2C_ADDR_NUM ]; // Sensor specific init function void mpr121_init () { bool anyConnected = false ; // Loop through I2C addresses for ( uint8_t i = 0 ; i < MPR121_I2C_ADDR_NUM ); i ++ ) { // Check if sensor is connected on I2C address mpr121 [ i ]. connected = ( MPR121_I2C_ID_VAL == I2cRead8 ( MPR121_I2C_ADDR_1ST + i , MPR121_I2C_ID_REG ); if ( mpr121 [ i ]. connected ) { anyConnected = true ; // Log sensor found snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121-%d \" D_FOUND_AT \" 0x%X\" ), i , MPR121_I2C_ADDR_1ST + i ); AddLog ( LOG_LEVEL_INFO ); // Initialize sensor . . . // Set running to true mpr121 [ i ]. running = true ; } } if ( ! anyConnected ){ snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121: No sensors found\" )); AddLog ( LOG_LEVEL_INFO ); } } Four advanced methods to use FUNC_EVERY_SECOND (Food for thought) : If a sensor needs an action which takes a long time, like more than 100mS, the action will be started here for a future follow-up. Using the uptime variable for testing like (uptime &1) will happen every 2 seconds. An example is the DS18B20 driver where readings (conversions they call it) can take up to 800mS from the initial request. If a sensor needed the previous action it is now time to gather the information and store it in a safe place to be used by FUNC_JSON_APPEND and/or FUNC_WEB_APPEND . Using the else function of the previous test (uptime &1) will happen every 2 seconds too but just 1 second later than the previous action. If a sensor does not respond for 10 times the sensor detection flag could be reset which will stop further processing until the sensor is re-detected. This is currently not being used actively as some users complain about disappearing sensors for whatever reason - Could be hardware related but easier to make Tasmota a little more flexible. Making re-detection of a sensor possible by executing this once every 100 seconds (94 == (uptime %100)) a re-attached sensor can be detected without a restart of Tasmota. The 94 given in this example should be different for every sensor driver to make sure not all sensors start detection at the same time. Using the drivers index number should be a good starting point. FUNC_PREP_BEFORE_TELEPERIOD NOTE: This callback ID is deprecated as sensors should prepare for more regular updates due to \"realtime\" rule execution. Use FUNC_EVERY_SECOND instead. See examples used in xsns_05_ds18x20.ino and xsns_09_bmp.ino where updated sensor data is stored in preparation to calls to FUNC_JSON_APPEND and FUNC_WEB_APPEND. FUNC_JSON_APPEND This callback ID is called when TelePeriod is due to append telemetry data to the MQTT JSON string or at approximately every 2 seconds when a rule is checked, e.g. snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); FUNC_WEB_APPEND This callback ID is called every millisecond when HTML code should be added to the Tasmota web-interface main page, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"%s{s}MPR121%c Button%d{m}%d{e}\" ), mqtt_data , pS -> id [ i ], j , BITC ( i , j )); It should be wrapped in #ifdef USE_WEBSERVER ... #endif // USE_WEBSERVER FUNC_SAVE_BEFORE_RESTART This callback ID is called to allow a sensor to prepare for saving configuration changes. To be used to save volatile data just before a restart. Variables can be appended to struct SYSCFG {} Settings in file tasmota/settings.h . FUNC_COMMAND This callback ID is called when a sensor specific command Sensor<xx> or Driver<xx> is executed where xx is the sensor index. case FUNC_COMMAND : if ( XSNS_ < driver_ID > == XdrvMailbox . index ) { result = < driver_name > Command () { ... }; // Return true on success } break ; // Data struct of FUNC_COMMAND ID struct XDRVMAILBOX { uint16_t valid ; // ??? uint16_t index ; // Sensor index uint16_t data_len ; // Length of command string uint16_t payload16 ; // 16 bit unsigned int of payload if it could be converted, otherwise 0 int16_t payload ; // 16 bit signed int of payload if it could be converted, otherwise 0 uint8_t grpflg ; // ??? uint8_t notused ; // ??? char * topic ; // Command topic char * data ; // Command string/value - length of which is defined by data_len } XdrvMailbox ; If your driver needs to accept multiple parameters for SensorXX and/or DriverXX please consider using comma delimited formatting and use the already written subStr() function declared in support.ino to parse through the parameters you need. An example of those could be SensorXX reset // The reset parameter may be intercepted using: if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"RESET\" )) { // Note 1 used for param number MyDriverName_Reset (); return serviced ; } Or in the case of multiple parameters SensorXX mode , 1 if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"MODE\" )) { // Note 1 used for param number uint8_t mode = atoi ( subStr ( sub_string , XdrvMailbox . data , \",\" , 2 ); // Note 2 used for param number } Useful functions ~ MQTT ~ void MqttPublishPrefixTopic_P ( uint8_t prefix , const char * subtopic , boolean retained ) This function publishes MQTT messages immediately, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); MqttPublishPrefixTopic_P ( RESULT_OR_STAT , mqtt_data ); Logging ~ void AddLog ( byte loglevel ) This function adds log messages stored in log_data to the local logging system, e.g. snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121(%c) \" D_FOUND_AT \" 0x%X\" ), pS -> id [ i ], pS -> i2c_addr [ i ]); AddLog ( LOG_LEVEL_INFO ); void AddLogSerial ( byte loglevel ) This function adds a log message to the local logging system dumping the serial buffer as hex information, e.g. AddLogSerial ( LOG_LEVEL_INFO ); void AddLogMissed ( char * sensor , uint8_t misses ) This function adds a log message to the local logging system about missed sensor reads. I 2 C Interface ~ bool I2cValidRead8 ( uint8_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16 ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16 ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16LE ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16_LE ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead24 ( int32_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead ( uint8_t addr , uint8_t reg , uint8_t size ) These functions return true if 1, 2, 3 or size bytes can be read from the I 2 C address addr and register reg into *data . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little-endian byte order while functions without LE read machine byte order. uint8_t I2cRead8 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16 ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16LE ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16_LE ( uint8_t addr , uint8_t reg ) int32_t I2cRead24 ( uint8_t addr , uint8_t reg ) These functions return 1, 2 or 3 bytes from the I 2 C address addr and register reg . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little endian byte order while functions without LE read machine byte order. bool I2cWrite8 ( uint8_t addr , uint8_t reg , uint8_t val ) bool I2cWrite16 ( uint8_t addr , uint8_t reg , uint16_t val ) bool I2cWrite ( uint8_t addr , uint8_t reg , uint32_t val , uint8_t size ) These functions return true after successfully writing 1, 2 or size bytes to the I 2 C address addr and register reg . int8_t I2cReadBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) int8_t I2cWriteBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) These functions copy len bytes from/to *reg_data starting at I 2 C address addr and register reg . void I2cScan ( char * devs , unsigned int devs_len ) This functions writes a list of I 2 C addresses in use into the string *dev with maximum length devs_len . bool I2cDevice ( byte addr ) This functions checks if the I 2 C address addr is in use. Useful pre-processor directives ~ PSTR(\"string\") This pre-processor directive saves RAM by storing strings in flash instead of RAM. const char MyTextStaticVariable [] PROGMEM = \"string\" ; This pre-processor directive saves RAM by storing strings in flash instead of RAM. You may then reference them directly (if the type matches the parameter required) or force it to 4 byte alignment by using the variable as FPSTR(MyTextStaticVariable) Keeping ESP8266 code compact ~ Below are various tips and tricks to keep ESP8266 code compact and save both Flash and Memory. Flash code is limited to 1024k but keep in mind that to allow OTA upgrade, you need Flash memory to contain two firmwares at the same time. To go beyond 512k, you typically use tasmota-minimal as an intermediate firmware. tasmota-minimal takes roughly 360k, so it's safe not to go uint32_t beyond 620k of Flash. Memory is even more limited: 80k. With Arduino Core and basic Tasmota, there are 25k-30k left of heap space. Heap memory is very precious, running out of memory will generally cause a crash. About ESP8266 ~ ESP8266 is based on Xtensa instruction set . Xtensa is a 32 bits RISC processor core, containing 16 x 32 bits registers. ESP8266 supports integer operations, including 32x32 multiplication. It does not contain an FPU for floating point operations, nor integer divisions. Contrary to classical RISC processors, all instructions are 24 bits wide instead of 32 bits. To increase code compactness, some instructions have a 16 bits version used whenever possible by gcc. If you want to see what assembly is generated by gcc, in file platform.ini , at the section used to compile (ex: [core_2_6_1] ) in section build_flags add: -save-temps=obj -fverbose-asm Gcc will store <file>.s in the same folder as the .o file, typically in .pioenvs/ . First example ~ Let's take a basic function: uint32_t Example ( uint32_t a , uint32_t b ) { return a + b ; } Below is the generated assembly. Function names are mangled using standard C++, i.e. their name derive from their arguments and return types: _Z7Examplejj: add.n a2 , a2 , a3 #, a, b ret.n As you can see, this is the simplest function we can think of. Register A2 holds the first argument and is used for return value. A3 holds the second argument. uint8_t or uint32_t ? ~ uint32_t Example ( uint32_t a , uint32_t b ) { uint8_t c = a + b ; return c ; } Assembly: _Z7Examplejj: add.n a2 , a2 , a3 # tmp52, a, b extui a2 , a2 , 0 , 8 #, tmp52 ret.n Whenever gcc needs to convert from uin32_t to uint8_t , it uses an extra instruction extui <reg>, <reg>, 0, 8 . Whenever you allocate uint8_t as a local variable, it will anyways allocate 32 bits on the stack. In conclusion you can easily use uint32_t in many places in the code. The main reason to force uint8_t are: in structures, to save memory. This is the only place where uint8_t will take 1 byte and the compiler will try to pack as much as 4 uint8_t in 32 bits when you want to ensure that the value can never exceed 255. Beware though that the compiler will just chunk the last 8 bits of a 32 bits value and will not report any overflow. Loops ~ Should you use uint8_t or uint32_t for loops? Let's try: uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < 10 ; i ++ ) { a += b ; } for ( uint32_t j = 0 ; j < 10 ; j ++ ) { a += b ; } return a ; } Assembly: _Z7Examplejj: movi.n a3 , 0 # ivtmp$7334, <- loop 1 .L2031: add.n a2 , a2 , a3 # a, a, ivtmp$7334 addi.n a3 , a3 , 1 # ivtmp$7334, ivtmp$7334, bnei a3 , 10 , .L2031 # ivtmp$7334,, movi.n a3 , 0 # j, <- loop 2 .L2033: add.n a2 , a2 , a3 # a, a, j addi.n a3 , a3 , 1 # j, j, bnei a3 , 10 , .L2033 # j,, ret.n As you can see here, both loops generate the same assembly for fixed size loops. Let's now see for variable size loops. uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < b ; i ++ ) { a += i ; } for ( uint32_t j = 0 ; j < b ; j ++ ) { a += j ; } return a ; } Assembly: _Z7Examplejj: movi.n a4 , 0 # i, <- loop 1 j .L2030 # .L2031: add.n a2 , a2 , a4 # a, a, i addi.n a4 , a4 , 1 # tmp48, i, extui a4 , a4 , 0 , 8 # i, tmp48 <- extra 32 to 8 bits conversion .L2030: bltu a4 , a3 , .L2031 # i, b, movi.n a4 , 0 # j, <- loop 2 j .L2032 # .L2033: add.n a2 , a2 , a4 # a, a, j addi.n a4 , a4 , 1 # j, j, .L2032: bne a4 , a3 , .L2033 # j, b, ret.n In the first loop, the register a4 needs to be converted from 32 bits to 8 bits in each iteration. Again, there is no definitive rule, but keep in mind that using uint8_t can sometimes increase code size compared to uint32_t . Floats, not doubles! ~ ESP8266 does not have a FPU (Floating Point Unit), all floating point operations are emulated in software and provided in libm.a . The linker removes any unused functions, so we need to limit the number of floating point function calls. Rule 1 : use ints where you can, avoid floating point operations. Rule 2 : if you really need floating point, always use float , never ever use double . Let's now see why. float fits in 32 bits, with a mantissa of 20 bits, exponent of TODO. The mantissa is 20 bits wide, which provides enough precision for most of our needs. float is 32 bits wide and fits in a single register, whereas double is 64 bits and requires 2 registers. float Examplef ( float a , float b ) { return sinf ( a ) * ( b + 0.4f ) - 3.5f ; } Assembly: .literal .LC1012 , 0x3ecccccd < - 0 .4f .literal .LC1013 , 0x40600000 < - 3 .5f _Z8Examplefff: addi sp , sp , -16 #,, <- reserve 16 bytes on stack s32i.n a0 , sp , 12 #, <- save a0 (return address) on stack s32i.n a12 , sp , 8 #, <- save a12 on stack, to free for local var s32i.n a13 , sp , 4 #, <- save a13 on stack, to free for local var mov.n a13 , a3 # b, b <- a3 holds 'b', save to a13 call0 sinf # <- calc sin of a2 (a) l32r a3 , .LC1012 #, <- load 0.4f in a3 mov.n a12 , a2 # D.171139, <- save result 'sin(a)' to a12 mov.n a2 , a13 #, b <- move a13 (second arg: b) to a2 call0 __addsf3 # <- add floats a2 and a3, result to a2 mov.n a3 , a2 # D.171139, <- copy result to a3 mov.n a2 , a12 #, D.171139 <- load a2 with a12: sin(a) call0 __mulsf3 # <- multiply 'sin(a)*(b+0.4f)' l32r a3 , .LC1013 #, <- load a3 with 3.5f call0 __subsf3 # <- substract l32i.n a0 , sp , 12 #, <- restore a0 (return address) l32i.n a12 , sp , 8 #, <- restore a12 l32i.n a13 , sp , 4 #, <- restore a13 addi sp , sp , 16 #,, <- free stack ret.n < - return Now with double : double Exampled ( double a , double b ) { return sin ( a ) * ( b + 0.4 ) - 3.5 ; } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 < - 0 .4 .literal .LC1015 , 0x00000000 , 0x400c0000 < - 3 .5 _Z8Exampleddd: addi sp , sp , -32 #,, s32i.n a0 , sp , 28 #, s32i.n a12 , sp , 24 #, s32i.n a13 , sp , 20 #, s32i.n a14 , sp , 16 #, s32i.n a15 , sp , 12 #, mov.n a14 , a4 #, mov.n a15 , a5 #, call0 sin # l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, mov.n a12 , a2 #, mov.n a13 , a3 #, mov.n a2 , a14 #, mov.n a3 , a15 #, call0 __adddf3 # mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # l32i.n a0 , sp , 28 #, l32i.n a12 , sp , 24 #, l32i.n a13 , sp , 20 #, l32i.n a14 , sp , 16 #, l32i.n a15 , sp , 12 #, addi sp , sp , 32 #,, ret.n As you can see the double needs to move many more registers around. Examplef (float) is 84 bytes, Exampled (double) is 119 bytes (+42% code size). Actually it's even worse, sin is larger than float version sinf . Also, never forget to explicitly tag literals as float: always put 1.5f and not 1.5 . Let's see the impact: float Examplef2 ( float a , float b ) { return sinf ( a ) * ( b + 0.4 ) - 3.5 ; // same as above with double literals } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 .literal .LC1015 , 0x00000000 , 0x400c0000 .align 4 .global _Z9Examplef2ff .type _Z9Examplef2ff , @function _Z9Examplef2ff: addi sp , sp , -16 #,, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a13 , sp , 4 #, s32i.n a14 , sp , 0 #, mov.n a14 , a3 # b, b call0 sinf # call0 __extendsfdf2 # <- extend float to double mov.n a12 , a2 #, mov.n a2 , a14 #, b mov.n a13 , a3 #, call0 __extendsfdf2 # <- extend float to double l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, call0 __adddf3 # <- add double mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # <- multiply double l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # <- substract double call0 __truncdfsf2 # <- truncate double to float l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n The last example takes 143 bytes, which is even worse than the double version, because of conversions from float to double and back. Internally, if you don't force float literals, gcc will make all intermediate compute in double and convert to float in the end. This is usually what is wanted: compute with maximum precision and truncate at the last moment. But for ESP8266 we want the opposite: most compact code. String concatenation ~ Let's start with an easy example: void ExampleStringConcat ( String & s ) { s += \"suffix\" ; } Assembly (25 bytes): .LC1024: .string \"suffix\" .literal .LC1025 , .LC1024 _Z19ExampleStringConcatR6String: l32r a3 , .LC1025 #, addi sp , sp , -16 #,, s32i.n a0 , sp , 12 #, call0 _ZN6String6concatEPKc # l32i.n a0 , sp , 12 #, addi sp , sp , 16 #,, ret.n If you need to add more complex strings, do not concatenate using native c++ concat: void ExampleStringConcat2 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" + String ( a ) + \",\" + String ( b ) + \"]\" ; } Assembly (122 bytes!): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1027 , .LC1026 .literal .LC1028 , .LC231 .literal .LC1030 , .LC1029 _Z20ExampleStringConcat2R6Stringhh: addi sp , sp , -64 #,, s32i.n a13 , sp , 52 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1027 #, s32i.n a12 , sp , 56 #, mov.n a12 , a2 # s, s addi.n a2 , sp , 12 #,, s32i.n a0 , sp , 60 #, s32i.n a14 , sp , 48 #, extui a14 , a4 , 0 , 8 # b, b call0 _ZN6StringC2EPKc # . <- allocate String movi.n a4 , 0xa #, addi a2 , sp , 24 #,, mov.n a3 , a13 #, a call0 _ZN6StringC1Ehh # <- allocate String addi a3 , sp , 24 #,, addi.n a2 , sp , 12 #,, call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1028 #, call0 _ZplRK15StringSumHelperPKc # movi.n a4 , 0xa #, mov.n a13 , a2 # D.171315, mov.n a3 , a14 #, b mov.n a2 , sp #, call0 _ZN6StringC1Ehh # <- allocate String mov.n a3 , sp #, mov.n a2 , a13 #, D.171315 call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1030 #, call0 _ZplRK15StringSumHelperPKc # mov.n a3 , a2 # D.171315, mov.n a2 , a12 #, s call0 _ZN6String6concatERKS_ # mov.n a2 , sp #, call0 _ZN6StringD1Ev # <- destructor addi a2 , sp , 24 #,, call0 _ZN6StringD1Ev # <- destructor addi.n a2 , sp , 12 #,, call0 _ZN6StringD2Ev # <- destructor l32i.n a0 , sp , 60 #, l32i.n a12 , sp , 56 #, l32i.n a13 , sp , 52 #, l32i.n a14 , sp , 48 #, addi sp , sp , 64 #,, ret.n Instead use native String concat: void ExampleStringConcat3 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" ; s += a ; s += \",\" ; s += b ; s += \"]\" ; } Assembly (69 bytes, -43%): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1031 , .LC1026 .literal .LC1032 , .LC231 .literal .LC1033 , .LC1029 _Z20ExampleStringConcat3R6Stringhh: addi sp , sp , -16 #,, s32i.n a13 , sp , 4 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1031 #, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a14 , sp , 0 #, mov.n a12 , a2 # s, s extui a14 , a4 , 0 , 8 # b, b call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a13 #, a mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1032 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a14 #, b mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1033 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n Extension to (v)snprintf() ~ Tasmota code uses extensively snprintf() to build Web UI, MQTT messages and logs. However there are some limitations. First we use a stripped down version of (v)snprintf() to save a big amount of code size; and types like float or uint64 or not supported. Second Arduino core often uses high level objects like IPAddress that are not natively supported by snprintf() . GCC libc normally includes a way to extend printf to new data types, but again the reduced lib in Arduino does not provide such a standard extension mechanism. We have now build an extension mechanism to snprintf() to allow for simpler code and less flash space. How to use ~ All extensions are using %_<x> where <x> is one of the following: Warning : most high-level values must be passed by address %_X : support for uint64_t . Example: uint64_t u64 = 0x1122334455667788LL; ext_snprintf(PSTR(\"Int64 = 0x%_X\"), &u64); %_I : support for IPv4 ip address in the form of uint32_t . Note: it is passed by value, not by address. Example: uint32_t ip = 0x10203040; ext_snprintf(PSTR(\"IP = 0x%_I\"), ip); %_f or %*_f or %<number>_f : support for float . Note: float must be passed by address (otherwise it is silently converted to double and creates alignment issues on the stack). When using %*_f , the first argument specifies the number d of decimal for the float , as a signed int. d can also be directly coded in the format ex: %2_f of %-2_f . If d > 0 we output exactly d decimals (even zeros), if d < 0 we output d decimals but remove any trailing zeros. Default value is -2 (2 decimals). Example: char s[128]; float fl = 3.14; ext_snprintf(s, sizeof(s), PSTR(\"f1=%*_f f2=%*_f f3=%4_f f4=%-4_f\"), 4, &fl, -4, &fl, &fl, &fl); // outputs: // \"f1=3.1400 f2=3.14 f3=3.1400 f4=3.14\" %*_H : prints an array of bytes as Hex (uppercase). The first argument is the length in bytes of the array (if zero or negative, it outputs an empty string). The second argument is the pointer to the array of bytes. The pointer can be null if the length is zero or negative. The pointer can be in PROGMEM. Note: %_H will output an empty string because it is missing the length. Example: char s[16]; const uint8_t b[] PROGMEM = { 0x00, 0x01, 0x80, 0xFF }; ext_snprintf(s, sizeof(s), PSTR(\"Hex=%*_H\"), sizeof(b), b); // outputs: // \"Hex=000180FF\" %_B : this is equivalent to %*_H but directly takes an SBuffer() object. Example: char s[16]; SBuffer b(8); // statically allocate 8 bytes b.add8(0x5A); b.add8(0xA5); ext_snprintf(s, sizeof(s), PSTR(\"Hex=%_B\"), &b); // outputs: // \"Hex=5AA5\" Code size reduction ~ Floats ~ It is not needed to call explicitly dtostrfd() anymore: Before: int ResponseAppendTHD(float f_temperature, float f_humidity) { char temperature[FLOATSZ]; dtostrfd(f_temperature, Settings.flag2.temperature_resolution, temperature); char humidity[FLOATSZ]; dtostrfd(f_humidity, Settings.flag2.humidity_resolution, humidity); char dewpoint[FLOATSZ]; dtostrfd(CalcTempHumToDew(f_temperature, f_humidity), Settings.flag2.temperature_resolution, dewpoint); return ResponseAppend_P(PSTR(\"\\\"\" D_JSON_TEMPERATURE \"\\\":%s,\\\"\" D_JSON_HUMIDITY \"\\\":%s,\\\"\" D_JSON_DEWPOINT \"\\\":%s\"), temperature, humidity, dewpoint); } Assembly (117 bytes): _Z17ResponseAppendTHDff: addi sp , sp , -64 #,, s32i.n a0 , sp , 60 #, s32i.n a12 , sp , 56 #, s32i.n a13 , sp , 52 #, s32i.n a14 , sp , 48 #, mov.n a13 , a3 # f_humidity, f_humidity mov.n a14 , a2 # f_temperature, f_temperature call0 __extendsfdf2 # l32r a12 , .LC658 #, tmp57 addi a5 , sp , 32 #,, addmi a12 , a12 , 0x500 # tmp60, tmp57, l32i a4 , a12 , 188 # Settings, Settings extui a4 , a4 , 30 , 2 #, Settings, call0 _Z8dtostrfddhPc # mov.n a2 , a13 #, f_humidity call0 __extendsfdf2 # l32i a4 , a12 , 188 # Settings, Settings addi a5 , sp , 16 #,, extui a4 , a4 , 28 , 2 #, Settings,, call0 _Z8dtostrfddhPc # mov.n a3 , a13 #, f_humidity mov.n a2 , a14 #, f_temperature call0 _Z16CalcTempHumToDewff # call0 __extendsfdf2 # l32i a4 , a12 , 188 # Settings, Settings mov.n a5 , sp #, extui a4 , a4 , 30 , 2 #, Settings, call0 _Z8dtostrfddhPc # l32r a2 , .LC659 #, addi a3 , sp , 32 #,, addi a4 , sp , 16 #,, mov.n a5 , sp #, call0 _Z16ResponseAppend_PPKcz # l32i.n a0 , sp , 60 #, l32i.n a12 , sp , 56 #, l32i.n a13 , sp , 52 #, l32i.n a14 , sp , 48 #, addi sp , sp , 64 #,, ret.n After: int ResponseAppendTHD ( float f_temperature , float f_humidity ) { float dewpoint = CalcTempHumToDew ( f_temperature , f_humidity ); return ResponseAppend_P ( PSTR ( \" \\\" \" D_JSON_TEMPERATURE \" \\\" :%*_f, \\\" \" D_JSON_HUMIDITY \" \\\" :%*_f, \\\" \" D_JSON_DEWPOINT \" \\\" :%*_f\" ), Settings . flag2 . temperature_resolution , & f_temperature , Settings . flag2 . humidity_resolution , & f_humidity , Settings . flag2 . temperature_resolution , & dewpoint ); } Assembly (61 bytes): _Z17ResponseAppendTHDff: addi sp , sp , -64 #,, s32i.n a0 , sp , 60 #, s32i.n a3 , sp , 36 # f_humidity, f_humidity s32i.n a2 , sp , 32 # f_temperature, f_temperature call0 _Z16CalcTempHumToDewff # s32i.n a2 , sp , 16 # dewpoint, l32r a2 , .LC658 #, tmp51 addi a4 , sp , 32 #,, addmi a2 , a2 , 0x500 # tmp54, tmp51, l32i a5 , a2 , 188 # Settings, Settings addi a2 , sp , 16 # tmp68,, extui a7 , a5 , 30 , 2 # D.156427, Settings, s32i.n a2 , sp , 0 #, tmp68 l32r a2 , .LC659 #, addi a6 , sp , 36 #,, mov.n a3 , a7 #, D.156427 extui a5 , a5 , 28 , 2 #, Settings,, call0 _Z16ResponseAppend_PPKcz # l32i.n a0 , sp , 60 #, addi sp , sp , 64 #,, ret.n","title":"Sensor API"},{"location":"Sensor-API/#important-things-to-consider","text":"There are several I 2 C sensor examples you can take from the development codebase when writing your own and you are encouraged to do this as it is a quick and easy way to see how things fit together. The Tasmota firmware is essentially intended for ESP8266/ESP8285 Wi-Fi SoC based devices and commits to the main development branch will be subject to review based on whether or not what you intend to develop or add to the existing code is relevant to the general ESP device users. That being said, there is a lot of development going into the firmware which extends the functionality of standard off the shelf Sonoff devices. The firmware in itself is also useful for boards such as the WeMos ESP82xx boards. More technically inclined individuals who use generic ESP82xx modules in their own circuits to provide more access to pins and the ability to add more sensors and hardware external to the device or the generic ESP82xx module circuits can also take advantage of Tasmota. The resources on the ESP82xx are finite. Most devices ship with 1MByte SPI flash which means for the generic device users, the code generally needs to be less than 502KBytes to ensure that OTA (Over The Air) flash functionality (which is the main reason why people use this firmware) remains available. RAM is also limited to an absolute maximum of 80KBytes. This memory is divided into heap (used by global variables and Strings) and stack (used by local variables) where stack space is just 4KBytes. Given the above resource constraints it's important to keep your code as small as possible, as fast running as possible, and use as little RAM as possible. You need to think about these resource constraints all the time whilst doing any development you wish to add to the firmware functionality - Face the fact that microcontroller development isn't as close a relative to standard computer programming as you'd expect. You will be adding code to an existing framework which requires you to adhere to some simple but strict rules such as not having any infinite loops like you would have in your generic Arduino code and try to avoid using the delay() functions when writing your code as this will cause the entire firmware to be subjected to the delays you have added - Infinite loops will cause the firmware to lock up completely! If your sensor has configuration options please make these available by using the SensorXX framework which is already incorporated in the base code - This may not stop you from using a web-based configuration interface but since web-based configuration takes up a lot of code space in flash it is very important to make this optional by means of a compiler directive or a #define in the configuration file and as such something you need to keep in mind during your development and debugging - The more progressively optional additional features are in your driver the smaller the basic codebase can be for minimalist implementations. Whilst developing drivers for devices that use the I 2 C bus always consider other devices already supported in the codebase which may use the same address range. This could mean you need to find a unique way of differentiating your device detection from other devices on the same address range (e.g. querying a model-specific register) and/or disabling by #undef existing devices if yours is selected with a #define statement and in such cases always provide a warning to the user during compile time using the #warning pragma such as including #warning **** Turned off conflicting drivers SHT and VEML6070 **** in your code. DO NOT ADD WEB INTERFACE FOR SENSOR CONFIGURATION if your sensor requires additional user configuration. The reason for this is the additional program memory required but most importantly the amount of RAM required to even create minimal user interfaces. Running out of RAM during runtime will lead to abnormal behaviour of your driver and/or other drivers or the entire firmware! See sensors such as the MCP23008/MCP23017 driver on more information on how to implement SensorXX commands instead! While developing you might want to enable additional debugging provided by file xdrv_99_debug.ino using #define USE_DEBUG_DRIVER which provides some commands for managing configuration settings and CPU timing. In addition you can enable define PROFILE_XSNS_SENSOR_EVERY_SECOND to profile your drivers duration. Do not assume others will know immediately how to use your addition and know that you will need to write a Wiki for it in the end.","title":"Important things to consider"},{"location":"Sensor-API/#managing-a-forked-branch","text":"If you plan to submit a PR bigger than a simple change in one file, here is a short intro about how to do a clean PR. fork the Tasmota repository in Github git clone https://github.com/<github_user>/Tasmota.git and work on your local copy git remote add upstream https://github.com/arendst/Tasmota.git git checkout development git checkout -b <temp_branch> to create a working branch where you can push commits git push --set-upstream origin <temp_branch> work on your local version and push as many commits as you want When you think it is ready to merge and submit a PR: git checkout development to go back to the main branch git pull upstream development to update all the latest changes git push to update your fork git checkout -b <pr_branch> to create a new branch for the final PR git push --set-upstream origin <pr_branch> Merge the edits but be sure to remove the history of your local commits git merge --squash <temp_branch> git commit -m \"Message\" Now you have a clean single commit from which you can create the PR on the Tasmota Github.","title":"Managing a Forked Branch"},{"location":"Sensor-API/#directoryfile-structure","text":"Sensor libraries are located in the lib/ directory. Sensor drivers are located in the tasmota/ directory. The filename of the sensor driver is xsns_<driver_ID>_<driver_name>.ino , e.g. xsns_05_ds18b20.ino where <driver_ID> is a unique number between 01 and 90 and <driver_name> is a human-readable name of the driver. Using generic libraries from external sources for sensors should be avoided as far as possible as they usually include code for other platforms and are not always written in an optimized way.","title":"Directory/file structure"},{"location":"Sensor-API/#api-structure","text":"","title":"API structure"},{"location":"Sensor-API/#pre-processor-directives","text":"Conditional compiling of a sensor driver is achieved by adding a pre-processor directive of the scheme USE_<driver_name> in my_user_config.h . Accordingly the driver code has to be wrapped in #ifdef USE_<driver_name> ... #endif // USE_<driver_name> . Any Sensor driver must contain a pre-processor directive defining the driver ID by the scheme #define XSNS_<driver_ID> .","title":"Pre-processor directives"},{"location":"Sensor-API/#callback-function","text":"Any sensor driver needs a callback function following the scheme // Conditional compilation of driver #ifdef USE_<driver_name> // Define driver ID #define XSNS_<driver_ID> <driver_ID> /** * The callback function Xsns<driver_ID>() interfaces Tasmota with the sensor driver. * * It provides the Tasmota callback IDs. * * @param byte callback_id Tasmota function ID. * @return boolean Return value. * @pre None. * @post None. * */ boolean Xsns < driverID > ( byte callback_id ) { // Set return value to `false` boolean result = false ; // Check if I2C interface mode // if(i2c_flg) { // Check which callback ID is called by Tasmota switch ( callback_id ) { case FUNC_INIT : break ; case FUNC_EVERY_50_MSECOND : break ; case FUNC_EVERY_SECOND : break ; case FUNC_JSON_APPEND : break ; #ifdef USE_WEBSERVER case FUNC_WEB_APPEND : break ; #endif // USE_WEBSERVER case FUNC_SAVE_BEFORE_RESTART : break ; case FUNC_COMMAND : break ; } // } // if(i2c_flg) // Return boolean result return result ; } #endif // USE_<driver_name>","title":"Callback function"},{"location":"Sensor-API/#callback-ids","text":"FUNC_INIT This callback ID is called when sensor drivers should be initialized. FUNC_EVERY_50_MSECOND This callback ID is called every 50 milliseconds, e.g. for near real-time operation FUNC_EVERY_SECOND This callback ID is called every second. It can be useful for anything that you need to do on a per second basis and is commonly used as an entry point to detect a driver or initialize an externally driven device such as a sensor, relay board or other forms of input/output required by your driver. You would normally want to make sure you've detected and initialised before it is used by JSON_APPEND , etc. so that its ready to serve data. The generally accepted way to use this would be to detect your sensor and once this is done set a sensor value accordingly so that the function does not use unnecessary resources during future calls, for example: void MySensorDetect () { if ( MySensorDetected ) { return ; } /* * Perform the code which needs to be completed to * detect your sensor and then set MySensorDetected to * a non-zero value which will prevent this section * of your code to re-run every time the function is * called. * * Under normal circumstances you'd not need to do * re-detect or initialise your sensor once it has been * done */ } Setting a flag that the driver was successful in detecting the attached chip/board via I 2 C or SPI will prevent it from continuously trying to initialize an already initialized device. When writing your function responsible for detecting an externally connected I 2 C device try to create a method by which you read or write to specific registers that would be applicable to that specific I 2 C device only as to confirm a positive detect for the device. If this is not done extensively it will lead to some drivers getting false detects for a different device type simply because it shares the same I 2 C address. Unless your driver is specifically going to use the entire array of addresses provisioned by the manufacturer please consider using a #define USE_MYCHIPNAME_ADDR in the my_user_config.h so that the user may specify the address on which to expect the device. This is of course only applicable to drivers that are not enabled by default in any of the pre-built binaries. I 2 C address auto-detection example #define MPR121_I2C_ADDR_1ST 0x5A /** 1st I2C address of sensor model **/ #define MPR121_I2C_ADDR_NUM 4 /** Number of sensors/I2C addresses **/ #define MPR121_I2C_ID_REG 0x5D /** Sensor model specific ID register **/ #define MPR121_I2C_ID_VAL 0x24 /** Sensor model specific ID register value **/ /* Sensor data struct type declaration/default definition */ typedef struct { bool connected = false ; /** Status if sensor is connected at I2C address */ bool running = false ; /** Running state of sensor */ . . . } mpr121 ; // Declare array of sensor data structs mpr121 mpr121 [ MPR121_I2C_ADDR_NUM ]; // Sensor specific init function void mpr121_init () { bool anyConnected = false ; // Loop through I2C addresses for ( uint8_t i = 0 ; i < MPR121_I2C_ADDR_NUM ); i ++ ) { // Check if sensor is connected on I2C address mpr121 [ i ]. connected = ( MPR121_I2C_ID_VAL == I2cRead8 ( MPR121_I2C_ADDR_1ST + i , MPR121_I2C_ID_REG ); if ( mpr121 [ i ]. connected ) { anyConnected = true ; // Log sensor found snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121-%d \" D_FOUND_AT \" 0x%X\" ), i , MPR121_I2C_ADDR_1ST + i ); AddLog ( LOG_LEVEL_INFO ); // Initialize sensor . . . // Set running to true mpr121 [ i ]. running = true ; } } if ( ! anyConnected ){ snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121: No sensors found\" )); AddLog ( LOG_LEVEL_INFO ); } } Four advanced methods to use FUNC_EVERY_SECOND (Food for thought) : If a sensor needs an action which takes a long time, like more than 100mS, the action will be started here for a future follow-up. Using the uptime variable for testing like (uptime &1) will happen every 2 seconds. An example is the DS18B20 driver where readings (conversions they call it) can take up to 800mS from the initial request. If a sensor needed the previous action it is now time to gather the information and store it in a safe place to be used by FUNC_JSON_APPEND and/or FUNC_WEB_APPEND . Using the else function of the previous test (uptime &1) will happen every 2 seconds too but just 1 second later than the previous action. If a sensor does not respond for 10 times the sensor detection flag could be reset which will stop further processing until the sensor is re-detected. This is currently not being used actively as some users complain about disappearing sensors for whatever reason - Could be hardware related but easier to make Tasmota a little more flexible. Making re-detection of a sensor possible by executing this once every 100 seconds (94 == (uptime %100)) a re-attached sensor can be detected without a restart of Tasmota. The 94 given in this example should be different for every sensor driver to make sure not all sensors start detection at the same time. Using the drivers index number should be a good starting point. FUNC_PREP_BEFORE_TELEPERIOD NOTE: This callback ID is deprecated as sensors should prepare for more regular updates due to \"realtime\" rule execution. Use FUNC_EVERY_SECOND instead. See examples used in xsns_05_ds18x20.ino and xsns_09_bmp.ino where updated sensor data is stored in preparation to calls to FUNC_JSON_APPEND and FUNC_WEB_APPEND. FUNC_JSON_APPEND This callback ID is called when TelePeriod is due to append telemetry data to the MQTT JSON string or at approximately every 2 seconds when a rule is checked, e.g. snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); FUNC_WEB_APPEND This callback ID is called every millisecond when HTML code should be added to the Tasmota web-interface main page, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"%s{s}MPR121%c Button%d{m}%d{e}\" ), mqtt_data , pS -> id [ i ], j , BITC ( i , j )); It should be wrapped in #ifdef USE_WEBSERVER ... #endif // USE_WEBSERVER FUNC_SAVE_BEFORE_RESTART This callback ID is called to allow a sensor to prepare for saving configuration changes. To be used to save volatile data just before a restart. Variables can be appended to struct SYSCFG {} Settings in file tasmota/settings.h . FUNC_COMMAND This callback ID is called when a sensor specific command Sensor<xx> or Driver<xx> is executed where xx is the sensor index. case FUNC_COMMAND : if ( XSNS_ < driver_ID > == XdrvMailbox . index ) { result = < driver_name > Command () { ... }; // Return true on success } break ; // Data struct of FUNC_COMMAND ID struct XDRVMAILBOX { uint16_t valid ; // ??? uint16_t index ; // Sensor index uint16_t data_len ; // Length of command string uint16_t payload16 ; // 16 bit unsigned int of payload if it could be converted, otherwise 0 int16_t payload ; // 16 bit signed int of payload if it could be converted, otherwise 0 uint8_t grpflg ; // ??? uint8_t notused ; // ??? char * topic ; // Command topic char * data ; // Command string/value - length of which is defined by data_len } XdrvMailbox ; If your driver needs to accept multiple parameters for SensorXX and/or DriverXX please consider using comma delimited formatting and use the already written subStr() function declared in support.ino to parse through the parameters you need. An example of those could be SensorXX reset // The reset parameter may be intercepted using: if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"RESET\" )) { // Note 1 used for param number MyDriverName_Reset (); return serviced ; } Or in the case of multiple parameters SensorXX mode , 1 if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"MODE\" )) { // Note 1 used for param number uint8_t mode = atoi ( subStr ( sub_string , XdrvMailbox . data , \",\" , 2 ); // Note 2 used for param number }","title":"Callback IDs"},{"location":"Sensor-API/#useful-functions","text":"","title":"Useful functions"},{"location":"Sensor-API/#mqtt","text":"void MqttPublishPrefixTopic_P ( uint8_t prefix , const char * subtopic , boolean retained ) This function publishes MQTT messages immediately, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); MqttPublishPrefixTopic_P ( RESULT_OR_STAT , mqtt_data );","title":"MQTT"},{"location":"Sensor-API/#logging","text":"void AddLog ( byte loglevel ) This function adds log messages stored in log_data to the local logging system, e.g. snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121(%c) \" D_FOUND_AT \" 0x%X\" ), pS -> id [ i ], pS -> i2c_addr [ i ]); AddLog ( LOG_LEVEL_INFO ); void AddLogSerial ( byte loglevel ) This function adds a log message to the local logging system dumping the serial buffer as hex information, e.g. AddLogSerial ( LOG_LEVEL_INFO ); void AddLogMissed ( char * sensor , uint8_t misses ) This function adds a log message to the local logging system about missed sensor reads.","title":"Logging"},{"location":"Sensor-API/#i2c-interface","text":"bool I2cValidRead8 ( uint8_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16 ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16 ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16LE ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16_LE ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead24 ( int32_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead ( uint8_t addr , uint8_t reg , uint8_t size ) These functions return true if 1, 2, 3 or size bytes can be read from the I 2 C address addr and register reg into *data . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little-endian byte order while functions without LE read machine byte order. uint8_t I2cRead8 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16 ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16LE ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16_LE ( uint8_t addr , uint8_t reg ) int32_t I2cRead24 ( uint8_t addr , uint8_t reg ) These functions return 1, 2 or 3 bytes from the I 2 C address addr and register reg . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little endian byte order while functions without LE read machine byte order. bool I2cWrite8 ( uint8_t addr , uint8_t reg , uint8_t val ) bool I2cWrite16 ( uint8_t addr , uint8_t reg , uint16_t val ) bool I2cWrite ( uint8_t addr , uint8_t reg , uint32_t val , uint8_t size ) These functions return true after successfully writing 1, 2 or size bytes to the I 2 C address addr and register reg . int8_t I2cReadBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) int8_t I2cWriteBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) These functions copy len bytes from/to *reg_data starting at I 2 C address addr and register reg . void I2cScan ( char * devs , unsigned int devs_len ) This functions writes a list of I 2 C addresses in use into the string *dev with maximum length devs_len . bool I2cDevice ( byte addr ) This functions checks if the I 2 C address addr is in use.","title":"I2C Interface"},{"location":"Sensor-API/#useful-pre-processor-directives","text":"PSTR(\"string\") This pre-processor directive saves RAM by storing strings in flash instead of RAM. const char MyTextStaticVariable [] PROGMEM = \"string\" ; This pre-processor directive saves RAM by storing strings in flash instead of RAM. You may then reference them directly (if the type matches the parameter required) or force it to 4 byte alignment by using the variable as FPSTR(MyTextStaticVariable)","title":"Useful pre-processor directives"},{"location":"Sensor-API/#keeping-esp8266-code-compact","text":"Below are various tips and tricks to keep ESP8266 code compact and save both Flash and Memory. Flash code is limited to 1024k but keep in mind that to allow OTA upgrade, you need Flash memory to contain two firmwares at the same time. To go beyond 512k, you typically use tasmota-minimal as an intermediate firmware. tasmota-minimal takes roughly 360k, so it's safe not to go uint32_t beyond 620k of Flash. Memory is even more limited: 80k. With Arduino Core and basic Tasmota, there are 25k-30k left of heap space. Heap memory is very precious, running out of memory will generally cause a crash.","title":"Keeping ESP8266 code compact"},{"location":"Sensor-API/#about-esp8266","text":"ESP8266 is based on Xtensa instruction set . Xtensa is a 32 bits RISC processor core, containing 16 x 32 bits registers. ESP8266 supports integer operations, including 32x32 multiplication. It does not contain an FPU for floating point operations, nor integer divisions. Contrary to classical RISC processors, all instructions are 24 bits wide instead of 32 bits. To increase code compactness, some instructions have a 16 bits version used whenever possible by gcc. If you want to see what assembly is generated by gcc, in file platform.ini , at the section used to compile (ex: [core_2_6_1] ) in section build_flags add: -save-temps=obj -fverbose-asm Gcc will store <file>.s in the same folder as the .o file, typically in .pioenvs/ .","title":"About ESP8266"},{"location":"Sensor-API/#first-example","text":"Let's take a basic function: uint32_t Example ( uint32_t a , uint32_t b ) { return a + b ; } Below is the generated assembly. Function names are mangled using standard C++, i.e. their name derive from their arguments and return types: _Z7Examplejj: add.n a2 , a2 , a3 #, a, b ret.n As you can see, this is the simplest function we can think of. Register A2 holds the first argument and is used for return value. A3 holds the second argument.","title":"First example"},{"location":"Sensor-API/#uint8_t-or-uint32_t","text":"uint32_t Example ( uint32_t a , uint32_t b ) { uint8_t c = a + b ; return c ; } Assembly: _Z7Examplejj: add.n a2 , a2 , a3 # tmp52, a, b extui a2 , a2 , 0 , 8 #, tmp52 ret.n Whenever gcc needs to convert from uin32_t to uint8_t , it uses an extra instruction extui <reg>, <reg>, 0, 8 . Whenever you allocate uint8_t as a local variable, it will anyways allocate 32 bits on the stack. In conclusion you can easily use uint32_t in many places in the code. The main reason to force uint8_t are: in structures, to save memory. This is the only place where uint8_t will take 1 byte and the compiler will try to pack as much as 4 uint8_t in 32 bits when you want to ensure that the value can never exceed 255. Beware though that the compiler will just chunk the last 8 bits of a 32 bits value and will not report any overflow.","title":"uint8_t or uint32_t ?"},{"location":"Sensor-API/#loops","text":"Should you use uint8_t or uint32_t for loops? Let's try: uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < 10 ; i ++ ) { a += b ; } for ( uint32_t j = 0 ; j < 10 ; j ++ ) { a += b ; } return a ; } Assembly: _Z7Examplejj: movi.n a3 , 0 # ivtmp$7334, <- loop 1 .L2031: add.n a2 , a2 , a3 # a, a, ivtmp$7334 addi.n a3 , a3 , 1 # ivtmp$7334, ivtmp$7334, bnei a3 , 10 , .L2031 # ivtmp$7334,, movi.n a3 , 0 # j, <- loop 2 .L2033: add.n a2 , a2 , a3 # a, a, j addi.n a3 , a3 , 1 # j, j, bnei a3 , 10 , .L2033 # j,, ret.n As you can see here, both loops generate the same assembly for fixed size loops. Let's now see for variable size loops. uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < b ; i ++ ) { a += i ; } for ( uint32_t j = 0 ; j < b ; j ++ ) { a += j ; } return a ; } Assembly: _Z7Examplejj: movi.n a4 , 0 # i, <- loop 1 j .L2030 # .L2031: add.n a2 , a2 , a4 # a, a, i addi.n a4 , a4 , 1 # tmp48, i, extui a4 , a4 , 0 , 8 # i, tmp48 <- extra 32 to 8 bits conversion .L2030: bltu a4 , a3 , .L2031 # i, b, movi.n a4 , 0 # j, <- loop 2 j .L2032 # .L2033: add.n a2 , a2 , a4 # a, a, j addi.n a4 , a4 , 1 # j, j, .L2032: bne a4 , a3 , .L2033 # j, b, ret.n In the first loop, the register a4 needs to be converted from 32 bits to 8 bits in each iteration. Again, there is no definitive rule, but keep in mind that using uint8_t can sometimes increase code size compared to uint32_t .","title":"Loops"},{"location":"Sensor-API/#floats-not-doubles","text":"ESP8266 does not have a FPU (Floating Point Unit), all floating point operations are emulated in software and provided in libm.a . The linker removes any unused functions, so we need to limit the number of floating point function calls. Rule 1 : use ints where you can, avoid floating point operations. Rule 2 : if you really need floating point, always use float , never ever use double . Let's now see why. float fits in 32 bits, with a mantissa of 20 bits, exponent of TODO. The mantissa is 20 bits wide, which provides enough precision for most of our needs. float is 32 bits wide and fits in a single register, whereas double is 64 bits and requires 2 registers. float Examplef ( float a , float b ) { return sinf ( a ) * ( b + 0.4f ) - 3.5f ; } Assembly: .literal .LC1012 , 0x3ecccccd < - 0 .4f .literal .LC1013 , 0x40600000 < - 3 .5f _Z8Examplefff: addi sp , sp , -16 #,, <- reserve 16 bytes on stack s32i.n a0 , sp , 12 #, <- save a0 (return address) on stack s32i.n a12 , sp , 8 #, <- save a12 on stack, to free for local var s32i.n a13 , sp , 4 #, <- save a13 on stack, to free for local var mov.n a13 , a3 # b, b <- a3 holds 'b', save to a13 call0 sinf # <- calc sin of a2 (a) l32r a3 , .LC1012 #, <- load 0.4f in a3 mov.n a12 , a2 # D.171139, <- save result 'sin(a)' to a12 mov.n a2 , a13 #, b <- move a13 (second arg: b) to a2 call0 __addsf3 # <- add floats a2 and a3, result to a2 mov.n a3 , a2 # D.171139, <- copy result to a3 mov.n a2 , a12 #, D.171139 <- load a2 with a12: sin(a) call0 __mulsf3 # <- multiply 'sin(a)*(b+0.4f)' l32r a3 , .LC1013 #, <- load a3 with 3.5f call0 __subsf3 # <- substract l32i.n a0 , sp , 12 #, <- restore a0 (return address) l32i.n a12 , sp , 8 #, <- restore a12 l32i.n a13 , sp , 4 #, <- restore a13 addi sp , sp , 16 #,, <- free stack ret.n < - return Now with double : double Exampled ( double a , double b ) { return sin ( a ) * ( b + 0.4 ) - 3.5 ; } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 < - 0 .4 .literal .LC1015 , 0x00000000 , 0x400c0000 < - 3 .5 _Z8Exampleddd: addi sp , sp , -32 #,, s32i.n a0 , sp , 28 #, s32i.n a12 , sp , 24 #, s32i.n a13 , sp , 20 #, s32i.n a14 , sp , 16 #, s32i.n a15 , sp , 12 #, mov.n a14 , a4 #, mov.n a15 , a5 #, call0 sin # l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, mov.n a12 , a2 #, mov.n a13 , a3 #, mov.n a2 , a14 #, mov.n a3 , a15 #, call0 __adddf3 # mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # l32i.n a0 , sp , 28 #, l32i.n a12 , sp , 24 #, l32i.n a13 , sp , 20 #, l32i.n a14 , sp , 16 #, l32i.n a15 , sp , 12 #, addi sp , sp , 32 #,, ret.n As you can see the double needs to move many more registers around. Examplef (float) is 84 bytes, Exampled (double) is 119 bytes (+42% code size). Actually it's even worse, sin is larger than float version sinf . Also, never forget to explicitly tag literals as float: always put 1.5f and not 1.5 . Let's see the impact: float Examplef2 ( float a , float b ) { return sinf ( a ) * ( b + 0.4 ) - 3.5 ; // same as above with double literals } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 .literal .LC1015 , 0x00000000 , 0x400c0000 .align 4 .global _Z9Examplef2ff .type _Z9Examplef2ff , @function _Z9Examplef2ff: addi sp , sp , -16 #,, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a13 , sp , 4 #, s32i.n a14 , sp , 0 #, mov.n a14 , a3 # b, b call0 sinf # call0 __extendsfdf2 # <- extend float to double mov.n a12 , a2 #, mov.n a2 , a14 #, b mov.n a13 , a3 #, call0 __extendsfdf2 # <- extend float to double l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, call0 __adddf3 # <- add double mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # <- multiply double l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # <- substract double call0 __truncdfsf2 # <- truncate double to float l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n The last example takes 143 bytes, which is even worse than the double version, because of conversions from float to double and back. Internally, if you don't force float literals, gcc will make all intermediate compute in double and convert to float in the end. This is usually what is wanted: compute with maximum precision and truncate at the last moment. But for ESP8266 we want the opposite: most compact code.","title":"Floats, not doubles!"},{"location":"Sensor-API/#string-concatenation","text":"Let's start with an easy example: void ExampleStringConcat ( String & s ) { s += \"suffix\" ; } Assembly (25 bytes): .LC1024: .string \"suffix\" .literal .LC1025 , .LC1024 _Z19ExampleStringConcatR6String: l32r a3 , .LC1025 #, addi sp , sp , -16 #,, s32i.n a0 , sp , 12 #, call0 _ZN6String6concatEPKc # l32i.n a0 , sp , 12 #, addi sp , sp , 16 #,, ret.n If you need to add more complex strings, do not concatenate using native c++ concat: void ExampleStringConcat2 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" + String ( a ) + \",\" + String ( b ) + \"]\" ; } Assembly (122 bytes!): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1027 , .LC1026 .literal .LC1028 , .LC231 .literal .LC1030 , .LC1029 _Z20ExampleStringConcat2R6Stringhh: addi sp , sp , -64 #,, s32i.n a13 , sp , 52 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1027 #, s32i.n a12 , sp , 56 #, mov.n a12 , a2 # s, s addi.n a2 , sp , 12 #,, s32i.n a0 , sp , 60 #, s32i.n a14 , sp , 48 #, extui a14 , a4 , 0 , 8 # b, b call0 _ZN6StringC2EPKc # . <- allocate String movi.n a4 , 0xa #, addi a2 , sp , 24 #,, mov.n a3 , a13 #, a call0 _ZN6StringC1Ehh # <- allocate String addi a3 , sp , 24 #,, addi.n a2 , sp , 12 #,, call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1028 #, call0 _ZplRK15StringSumHelperPKc # movi.n a4 , 0xa #, mov.n a13 , a2 # D.171315, mov.n a3 , a14 #, b mov.n a2 , sp #, call0 _ZN6StringC1Ehh # <- allocate String mov.n a3 , sp #, mov.n a2 , a13 #, D.171315 call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1030 #, call0 _ZplRK15StringSumHelperPKc # mov.n a3 , a2 # D.171315, mov.n a2 , a12 #, s call0 _ZN6String6concatERKS_ # mov.n a2 , sp #, call0 _ZN6StringD1Ev # <- destructor addi a2 , sp , 24 #,, call0 _ZN6StringD1Ev # <- destructor addi.n a2 , sp , 12 #,, call0 _ZN6StringD2Ev # <- destructor l32i.n a0 , sp , 60 #, l32i.n a12 , sp , 56 #, l32i.n a13 , sp , 52 #, l32i.n a14 , sp , 48 #, addi sp , sp , 64 #,, ret.n Instead use native String concat: void ExampleStringConcat3 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" ; s += a ; s += \",\" ; s += b ; s += \"]\" ; } Assembly (69 bytes, -43%): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1031 , .LC1026 .literal .LC1032 , .LC231 .literal .LC1033 , .LC1029 _Z20ExampleStringConcat3R6Stringhh: addi sp , sp , -16 #,, s32i.n a13 , sp , 4 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1031 #, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a14 , sp , 0 #, mov.n a12 , a2 # s, s extui a14 , a4 , 0 , 8 # b, b call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a13 #, a mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1032 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a14 #, b mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1033 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n","title":"String concatenation"},{"location":"Sensor-API/#extension-to-vsnprintf","text":"Tasmota code uses extensively snprintf() to build Web UI, MQTT messages and logs. However there are some limitations. First we use a stripped down version of (v)snprintf() to save a big amount of code size; and types like float or uint64 or not supported. Second Arduino core often uses high level objects like IPAddress that are not natively supported by snprintf() . GCC libc normally includes a way to extend printf to new data types, but again the reduced lib in Arduino does not provide such a standard extension mechanism. We have now build an extension mechanism to snprintf() to allow for simpler code and less flash space.","title":"Extension to (v)snprintf()"},{"location":"Sensor-API/#how-to-use","text":"All extensions are using %_<x> where <x> is one of the following: Warning : most high-level values must be passed by address %_X : support for uint64_t . Example: uint64_t u64 = 0x1122334455667788LL; ext_snprintf(PSTR(\"Int64 = 0x%_X\"), &u64); %_I : support for IPv4 ip address in the form of uint32_t . Note: it is passed by value, not by address. Example: uint32_t ip = 0x10203040; ext_snprintf(PSTR(\"IP = 0x%_I\"), ip); %_f or %*_f or %<number>_f : support for float . Note: float must be passed by address (otherwise it is silently converted to double and creates alignment issues on the stack). When using %*_f , the first argument specifies the number d of decimal for the float , as a signed int. d can also be directly coded in the format ex: %2_f of %-2_f . If d > 0 we output exactly d decimals (even zeros), if d < 0 we output d decimals but remove any trailing zeros. Default value is -2 (2 decimals). Example: char s[128]; float fl = 3.14; ext_snprintf(s, sizeof(s), PSTR(\"f1=%*_f f2=%*_f f3=%4_f f4=%-4_f\"), 4, &fl, -4, &fl, &fl, &fl); // outputs: // \"f1=3.1400 f2=3.14 f3=3.1400 f4=3.14\" %*_H : prints an array of bytes as Hex (uppercase). The first argument is the length in bytes of the array (if zero or negative, it outputs an empty string). The second argument is the pointer to the array of bytes. The pointer can be null if the length is zero or negative. The pointer can be in PROGMEM. Note: %_H will output an empty string because it is missing the length. Example: char s[16]; const uint8_t b[] PROGMEM = { 0x00, 0x01, 0x80, 0xFF }; ext_snprintf(s, sizeof(s), PSTR(\"Hex=%*_H\"), sizeof(b), b); // outputs: // \"Hex=000180FF\" %_B : this is equivalent to %*_H but directly takes an SBuffer() object. Example: char s[16]; SBuffer b(8); // statically allocate 8 bytes b.add8(0x5A); b.add8(0xA5); ext_snprintf(s, sizeof(s), PSTR(\"Hex=%_B\"), &b); // outputs: // \"Hex=5AA5\"","title":"How to use"},{"location":"Sensor-API/#code-size-reduction","text":"","title":"Code size reduction"},{"location":"Sensor-Configuration/","text":"","title":"Sensor Configuration"},{"location":"Serial-to-TCP-Bridge/","text":"Serial to TCP Bridge ~ This feature is included only in tasmota-zbbridge and tasmota-zbbrdgpro binaries When compiling your build add the following to user_config_override.h : #ifndef USE_TCP_BRIDGE #define USE_TCP_BRIDGE // Add support for Serial to TCP bridge (+1.3k code) #endif Connect to a serial device over the network, also known as ser2net This feature can be used to add a \"serial to network\" functionality to a device that is otherwise serial only. You connect the device to a ESP8266/ESP32 and Tasmota will bridge between serial and network. This is commonly used with a CCxxxx Zigbee based module to connect it to a remote ZHA or zigbee2mqtt instance. Commands ~ TCPBaudRate <x> : sets the baud rate for serial (only 8N1 mode), min 1200 , max 115200 by 1200 increments. TCPStart <port> : listens to port <port> . This features supports 2 parallel TCP connections, which can be useful if you need a terminal + a specific protocol (like XMODEM). The 3rd connection will disconnect an previous connection. The number of parallel connections is a compile-time option. Note that this can be accessed by any host on the network and may have security implications. TCPStart <port>,<ip address> : listens to port <port> , but only allows connections from the provided IPv4 address. Any connections from a different host will be immediately closed. TCPStart 0 or TCPStart : shuts down the TCP server and disconnects any existing connection(s). For security reasons, the TCP bridge is not started at boot, and requires an explicit TCPStart command (this can be automated with Rules). Configuration ~ First assign two GPIOs to TCP Tx (208) and TCP Rx (209) types in the \"Configure Module\" page. The Rx/Tx are relative to the ESP device. For example with ESP01's hardware serial, set GPIO1 as TCP Tx and GPIO3 as TCP Rx. Then set baud rate with TCPBaudRate and port with TCPStart . You can add a rule to start the TCP server at boot. To do this for port 8888 and allow connections only from host 192.168.0.10 , run Rule1 ON System#Boot do TCPStart 8888,192.168.0.10 endon then enable with Rule1 1 and restart the device. Additional resources ~ PR Sonoff ZBBridge reference","title":"Serial to TCP Bridge"},{"location":"Serial-to-TCP-Bridge/#serial-to-tcp-bridge","text":"This feature is included only in tasmota-zbbridge and tasmota-zbbrdgpro binaries When compiling your build add the following to user_config_override.h : #ifndef USE_TCP_BRIDGE #define USE_TCP_BRIDGE // Add support for Serial to TCP bridge (+1.3k code) #endif Connect to a serial device over the network, also known as ser2net This feature can be used to add a \"serial to network\" functionality to a device that is otherwise serial only. You connect the device to a ESP8266/ESP32 and Tasmota will bridge between serial and network. This is commonly used with a CCxxxx Zigbee based module to connect it to a remote ZHA or zigbee2mqtt instance.","title":"Serial to TCP Bridge"},{"location":"Serial-to-TCP-Bridge/#commands","text":"TCPBaudRate <x> : sets the baud rate for serial (only 8N1 mode), min 1200 , max 115200 by 1200 increments. TCPStart <port> : listens to port <port> . This features supports 2 parallel TCP connections, which can be useful if you need a terminal + a specific protocol (like XMODEM). The 3rd connection will disconnect an previous connection. The number of parallel connections is a compile-time option. Note that this can be accessed by any host on the network and may have security implications. TCPStart <port>,<ip address> : listens to port <port> , but only allows connections from the provided IPv4 address. Any connections from a different host will be immediately closed. TCPStart 0 or TCPStart : shuts down the TCP server and disconnects any existing connection(s). For security reasons, the TCP bridge is not started at boot, and requires an explicit TCPStart command (this can be automated with Rules).","title":"Commands"},{"location":"Serial-to-TCP-Bridge/#configuration","text":"First assign two GPIOs to TCP Tx (208) and TCP Rx (209) types in the \"Configure Module\" page. The Rx/Tx are relative to the ESP device. For example with ESP01's hardware serial, set GPIO1 as TCP Tx and GPIO3 as TCP Rx. Then set baud rate with TCPBaudRate and port with TCPStart . You can add a rule to start the TCP server at boot. To do this for port 8888 and allow connections only from host 192.168.0.10 , run Rule1 ON System#Boot do TCPStart 8888,192.168.0.10 endon then enable with Rule1 1 and restart the device.","title":"Configuration"},{"location":"Serial-to-TCP-Bridge/#additional-resources","text":"PR Sonoff ZBBridge reference","title":"Additional resources"},{"location":"SetOption36/","text":"SetOption36 is deprecated in favour of using the sleep command to use either Dynamic or Normal sleep as from Tasmota version 6.3.0.15. Click here for Dynamic Sleep","title":"SetOption36"},{"location":"SetOption37/","text":"SetOption37 is used for re-mapping the RGBW c W w channels. This transformation happens right before the hardware-specific output, so all the advanced features (schemes, hsb setting, etc.) works with the original, un-mapped values. The main reason for this option is to provide support for bulbs whose physical wiring is almost the usual/standard one, but the channels are arranged in a different way. For technical reasons this transformation isn't a full N-to-N mapping, it can only the re-arrange the channels, which is equivalent to map the (R,G,B,W c ,W w ) channels to one of their permutations. The required permutation can be configured via SetOption37 n , where n is the systematic index of the permutation, a number from the [0 .. 119] interval, from 0=(R,G,B,W c ,W w ) to 119=(W w ,W c ,B,G,R): Idx Perm. Idx Perm. Idx Perm. Idx Perm. 0 R,G,B,W c ,W w 1 R,G,B,W w ,W c 2 R,G,W c ,B,W w 3 R,G,W c ,W w ,B 4 R,G,W w ,B,W c 5 R,G,W w ,W c ,B 6 R,B,G,W c ,W w 7 R,B,G,W w ,W c 8 R,B,W c ,G,W w 9 R,B,W c ,W w ,G 10 R,B,W w ,G,W c 11 R,B,W w ,W c ,G 12 R,W c ,G,B,W w 13 R,W c ,G,W w ,B 14 R,W c ,B,G,W w 15 R,W c ,B,W w ,G 16 R,W c ,W w ,G,B 17 R,W c ,W w ,B,G 18 R,W w ,G,B,W c 19 R,W w ,G,W c ,B 20 R,W w ,B,G,W c 21 R,W w ,B,W c ,G 22 R,W w ,W c ,G,B 23 R,W w ,W c ,B,G 24 G,R,B,W c ,W w 25 G,R,B,W w ,W c 26 G,R,W c ,B,W w 27 G,R,W c ,W w ,B 28 G,R,W w ,B,W c 29 G,R,W w ,W c ,B 30 G,B,R,W c ,W w 31 G,B,R,W w ,W c 32 G,B,W c ,R,W w 33 G,B,W c ,W w ,R 34 G,B,W w ,R,W c 35 G,B,W w ,W c ,R 36 G,W c ,R,B,W w 37 G,W c ,R,W w ,B 38 G,W c ,B,R,W w 39 G,W c ,B,W w ,R 40 G,W c ,W w ,R,B 41 G,W c ,W w ,B,R 42 G,W w ,R,B,W c 43 G,W w ,R,W c ,B 44 G,W w ,B,R,W c 45 G,W w ,B,W c ,R 46 G,W w ,W c ,R,B 47 G,W w ,W c ,B,R 48 B,R,G,W c ,W w 49 B,R,G,W w ,W c 50 B,R,W c ,G,W w 51 B,R,W c ,W w ,G 52 B,R,W w ,G,W c 53 B,R,W w ,W c ,G 54 B,G,R,W c ,W w 55 B,G,R,W w ,W c 56 B,G,W c ,R,W w 57 B,G,W c ,W w ,R 58 B,G,W w ,R,W c 59 B,G,W w ,W c ,R 60 B,W c ,R,G,W w 61 B,W c ,R,W w ,G 62 B,W c ,G,R,W w 63 B,W c ,G,W w ,R 64 B,W c ,W w ,R,G 65 B,W c ,W w ,G,R 66 B,W w ,R,G,W c 67 B,W w ,R,W c ,G 68 B,W w ,G,R,W c 69 B,W w ,G,W c ,R 70 B,W w ,W c ,R,G 71 B,W w ,W c ,G,R 72 W c ,R,G,B,W w 73 W c ,R,G,W w ,B 74 W c ,R,B,G,W w 75 W c ,R,B,W w ,G 76 W c ,R,W w ,G,B 77 W c ,R,W w ,B,G 78 W c ,G,R,B,W w 79 W c ,G,R,W w ,B 80 W c ,G,B,R,W w 81 W c ,G,B,W w ,R 82 W c ,G,W w ,R,B 83 W c ,G,W w ,B,R 84 W c ,B,R,G,W w 85 W c ,B,R,W w ,G 86 W c ,B,G,R,W w 87 W c ,B,G,W w ,R 88 W c ,B,W w ,R,G 89 W c ,B,W w ,G,R 90 W c ,W w ,R,G,B 91 W c ,W w ,R,B,G 92 W c ,W w ,G,R,B 93 W c ,W w ,G,B,R 94 W c ,W w ,B,R,G 95 W c ,W w ,B,G,R 96 W w ,R,G,B,W c 97 W w ,R,G,W c ,B 98 W w ,R,B,G,W c 99 W w ,R,B,W c ,G 100 W w ,R,W c ,G,B 101 W w ,R,W c ,B,G 102 W w ,G,R,B,W c 103 W w ,G,R,W c ,B 104 W w ,G,B,R,W c 105 W w ,G,B,W c ,R 106 W w ,G,W c ,R,B 107 W w ,G,W c ,B,R 108 W w ,B,R,G,W c 109 W w ,B,R,W c ,G 110 W w ,B,G,R,W c 111 W w ,B,G,W c ,R 112 W w ,B,W c ,R,G 113 W w ,B,W c ,G,R 114 W w ,W c ,R,G,B 115 W w ,W c ,R,B,G 116 W w ,W c ,G,R,B 117 W w ,W c ,G,B,R 118 W w ,W c ,B,R,G 119 W w ,W c ,B,G,R Source: this spreadsheet","title":"SetOption37"},{"location":"Shutter-and-Steppers/","text":"","title":"Shutter and Steppers"},{"location":"Smart-Meter-Interface/","text":"Smart Meter Interface ~ This driver extracts selected values from Smart Meters over various protocols, filters and publishes them to MQTT as regular sensors. This feature is not included in precompiled binaries Based on Tasmota's scripting language . To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_SCRIPT #define USE_SCRIPT #endif #ifndef USE_SML_M #define USE_SML_M #endif #ifdef USE_RULES #undef USE_RULES #endif Additional features can be enabled by adding the following #define compiler directive parameters and then compiling the firmware. These parameters are explained further below in the article. Feature Description SML_MAX_VARS n (default 20) Maximum number of decode lines (html lines not counted). SML_BSIZ n (default 48) Maximum number of characters per line in serial input buffer. Complete chunk of serial data must fit into this size, so include any CR/LF if that applies. MAX_METERS n (default 5) Maximum number of meters. Decrease this to 1 for example if you have a meter with many lines and lots of characters per descriptor line. TMSBSIZ n (default 256) Maximum number of characters in serial IRQ buffer (should always be larger than SML_BSIZ and even larger on high baud rates). SML_DUMP_SIZE n (default 128) Maximum number of characters per line in dump mode. Only use if you have long strings comin in and they truncate. USE_ESP32_SW_SERIAL enables additional software serial channels for ESP32, (receive only), define pin with '-' sign to assign to software serial USE_SML_SPECOPT enables special decoder entry to specify direction bit for some SML meters USE_SML_SCRIPT_CMD If present, this enables some special SML script cmds and allows access to sml vars in other parts of the script. Is needed by some of the examples below. SML_REPLACE_VARS If present, this allows replacement of any text in descriptor by script text variables. Useful if several occurrences of a text occupies a lot of space and you get short of script buffer. Readability may get worse so only makes sense on large descriptors. Note: to use % symbol un measurement units, you need to escape it like %% . General description ~ To use this interface, connect the meter to available GPIO pins. These GPIOs must be set as None in Tasmota. If the interface detects that a script driven meter descriptor GPIO conflicts with a Tasmota GPIO setting, the interface will generate a duplicate GPIO defined error in the log and the meter descriptor will be ignored. Note When changing GPIO configurations, especially in conjunction with other Tasmota drivers, a restart may be required. Note On an ESP32, due to a different implementation, serial ports may not be used in conjunction with other Tasmota serial devices. Note when using bidirectional serial IO (receive and transmit), hardware serial is recommended. The Smart Meter Interface provides a means to connect many kinds of meters to Tasmota. The following types of meter protocols are supported: Protocol Description OBIS ASCII telegrams emitted from many smart meters, including P1 Smart Meters OBIS Binary SML telegrams emitted from many smart meters MODBus Binary telegrams used by many power meters and industrial devices EBus Binary telegrams emitted by many heaters and heat pumps (e.g. Vaillant, Wolf) VBus Binary telegrams emitted by many solar thermal systems boilers (e.g. Resol, Viessmann) RAW Binary decodes all kinds of binary data eg EMS heater bus Counter interface uses Tasmota counter storage (for e.g. REED contacts either in polling or IRQ mode) There are many different meters that use the same protocol. There are multitudes of variants and use cases. This interface provides a means of specifying these definitions through meter descriptors . This method uses the scripting language editor to define the descriptors. In this way, only one firmware binary version is required and a modification can be made easily on the fly . A meter can also be defined by using compilation time #define pragmas (deprecated). This requires recompiling the firmware to make modifications. Note Additional hardware may be required to read certain measuring devices. For example: RS485toTTL adapter for Modbus, IR transistor for electricity meters. Sometimes an additional IR diode and resistors. Descriptor Syntax ~ This section must be present, even if it's empty. If compiled with SML_REPLACE_VARS , here is the place where text variables can be defined for the script: >D Declare >B (boot) section to inform the interface to read the meter descriptor(s): >B => sensor53 r (Optional) declare >S section with additional scripting commands: >S <n> Declare >M section with the number of connected meters (n = 1..5 ): >M <n> Note If no >M section is found in the script or if the scripting language is not compiled, the driver reverts to the default hardcoded #define definitions. If no meter script is defined, the default hardcoded descriptor interface (deprecated) uses RX GPIO3 for receiving data and thus may interfere with other Tasmota Definitions without warning. Note Software serial only supports 8N1 serial format. Must use hardware serial for e.g. 8E1! Meter Definition ~ +<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} Parameter Description +<M> Meter number. The number must be increased with each additional Meter (default 1 to 5). <rxGPIO> The GPIO pin number where meter data is received. <type> The type of meter: - o - OBIS ASCII type of coding - s - SML binary smart message coding - e - EBus binary coding - v - VBus binary coding - m - MODBus binary coding with serial mode 8N1 - M - MODBus binary coding with serial mode 8E1 - c - Counter type - r - Raw binary coding (any binary telegram) <flag> Options flag: - 0 - counter without pullup - 1 - counter with pullup - 16 - enable median filter for that meter. Can help with sporadic dropouts, reading errors (not available for counters). <parameter> Parameters according to meter type: - for o,s,e,v,m,M,r types: serial baud rate e.g. 9600 . - for c type: a positive value = counter poll interval or a negative value = debounce time (milliseconds) for irq driven counters. <jsonPrefix> Prefix for Web UI and MQTT JSON payload. Up to 7 characters. <txGPIO> The GPIO pin number where meter command is transmitted (optional). <txPeriod> Period to repeat the transmission of commands to the meter (optional). Number of 100ms increments (n * 100ms). <cmdTelegram> Comma separated hex coded byte blocks to send to meter device. For MODBus each comma separated block is a command to retrieve a certain register from the meter (optional: only required for measuring devices that have to be triggered with a certain character string). Note for other serial protocols you may specify the exact mode (only for hardware serial) by the following code after the type specifier: N =no parity E =even parity O =odd parity and number of stop-bits e.g for Modbus: mN1,mN2,mE1,mE2,mO1,mO2 Example +1,3,o,0,9600,OBIS1,1,2,2F3F210D0A +1,3,o,16,115200,NormalTariff,1 +1,3,s,16,9600,SML1 +1,12,c,1,-10,H20_Cnt +1,3,v,0,9600,Solar Example For MODBus: +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 Components of the character string: ...01040000,01040002,... 01 = Modbus slave device ID 04 = Instruction to read an Input Register (alternatively, 03 = Instruction to read an Holding Register) 0000 / 0002 = Register # (as Hexadecimal codification, without the prefix 0x . Example: 0x0079 -> 0079 ) the number of requested registers is fixed to 2, however with the char 'r' before the hex string the complete request string may be specified ...r010400000001,r010400020003,... Note: ID , Instruction to read the register value (Input vs Holding) and Register# may differ depending on the measuring device. Meter Metrics ~ Each meter typically provides multiple metrics (energy, voltage, power, current etc.) which it measures. An entry for each metric to be collected must be specified. Up to 20 entries may be defined (unless stated differently by SML_MAX_VARS as a larger number in user_config_override.h ). An entry defines how to decode the data and put it into variables. <M>,<decoder>@<scale><offs>,<label>,<UoM>,<var>,<precision> Parameter Description <M> The meter number to which this decoder belongs <decoder> Decoding specification : OBIS as ASCII; SML, EBus, VBus, MODBus, RAW as HEX ASCII etc. No space characters allowed in this section! OBIS : ASCII OBIS code terminated with ( character which indicates the start of the meter value Counter : ASCII code 1-0:1.8.0*255 for counter value, code 1-0:1.7.0*255 for pulse rate (e.g. for actual power value) SML : SML binary OBIS as hex terminated with 0xFF indicating start of SML encoded value EBus, MODBus, RAW - hex values of data blocks to compare: - xx = ignore value (1 byte) or xN = ignore N bytes - ss = extract a signed byte - uu = extract an unsigned byte - UUuu = extract an unsigned word (high order byte first) - uuUU = extract an unsigned word (low order byte first) - UUuuUUuu = extract an unsigned long word (high order byte first) - uuUUuuUU = extract an unsigned long word (low order byte first) - SSss = extract a signed word (high order byte first) - ssSS = extract a signed word (low order byte first) - SSssSSss = extract a signed long word (high order byte first) - ssSSssSS = extract a signed long word (low order byte first) - on long word values if a trailing s is added word order is reversed - ffffffff = extract a float value - IEEE754 decode - FFffFFff = extract a reverse float value - IEEE754 decode if using VBus - hex values of data blocks to compare: - AAffffaddrff0001ffff = VBus-specific hex header: AA -sync byte, addr -the reversed address of the device. To find his out first look up the known hex address of the device . E.g. Resol DeltaSol BS Plus is 0x4221 . Reverse it (without 0x ) and you will get 21 42 hex characters. Now turn on raw dump mode using command sensor53 d1 and look for rows starting with aa , containing your reversed address at position 4 and 5 and 00 01 hex characters at position 7 and 8. If found, the entire header will be 10 hex characters long including aa (20 ascii chars without space, e.g. for Resol DeltaSol BS Plus this will be AA100021421000010774 ). At position 9 you see the number of frames containing readable data. To turn off raw dump use sensor53 d0 . - v = VBus protocol indicator - oN = extract data from offset N (see offsets of your device in VBus protocol documentation ) - u or s = extract unsigned or signed data - w or b = extract word or byte End of decoding : @ indicates termination of the decoding procedure. - ( following the @ character in case of obis decoder indicates to fetch the 2. value in brackets, not the 1. value. (e.g. to get the second value from an obis like 0-1:24.2.3(210117125004W)(01524.450*m3) ) - decoding multiple values coming in brackets after each other is possible with (@(0:1 , (@(1:1 , (@(2:1 and so on (e.g. to get values from an obis like 0-0:98.1.0(210201000000W)(000000.000*kWh)(000000.000*kWh) ) - decoding a 0/1 bit is indicated by a @ character followed by bx: (x = 0..7 ) extracting the corresponding bit from a byte. (e.g.: 1,xxxx5017xxuu@b0:1,Solarpump,,Solarpump,0 ) - in case of MODBus, ix: designates the index (x = 0..n ) referring to the requested block in the transmit section of the meter definition <scale> scaling factor (divisor) or string definition This can be a fraction (e.g., 0.1 = result * 10), or a negative value. When decoding a string result (e.g. meter serial number), use # character for this parameter (Note: only one string can be decoded per meter!) . For OBIS, you need a ) termination character after the # character. <offs> optional offset must precede with + or - sign, note: offset is applied before scale! <label> web UI label (max. 23 characters) <UoM> unit of measurement (max. 7 characters) <var> MQTT label (max. 23 characters) <precision> number of decimal places. Add 16 to transmit the data immediately. Otherwise it is transmitted on TelePeriod only. Use ; character to comment lines in the script. Put # character at the end to terminate M section of the script. Example (OBIS/SML/MODBus): 1,1-0:1.8.1*255(@1,Total consumption,KWh,Total_in,4` 1,77070100010801ff@1000,W1,kWh,w1,4` 1,010304UUuuxxxxxxxx@i0:1,Spannung L1,V,Voltage_L1,0` 1,0:98.1.0(@(0:1,Havi adat, KWh,havi1,3` 1,0:98.1.0(@(1:1,Havi adat, KWh,havi2,3` 1,0:98.1.0(@(2:1,Havi adat, KWh,havi3,3` OBIS: 1,1-0:0.0.0*255(@#),Meter Nr,, Meter_number,0 Counter: 1,1-0:1.8.0*255(@1000,consumption,KWh,Total_in,3) precision of 3, scale for 1000 pulses/kWh 1,1-0:1.7.0*255(@0.01667, power,W,Power_actual,0) actual power from pulse rate (in pulses/min) of counter meter, scale for 1 pulse/Wh (1 pulse/min => 60W; 1/60(=0.01667) (pulses/min)/W) SML: 1,77078181c78203ff@#,Service ID,,Meter_id,0 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,4 precision of 4, transmitted only on TelePeriod 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,20 precision of 4, transmitted immediately (4 + 16 = 20) MODBus: +1,3,M,1,9600,SBC,1,2,01030023,01030028... 1,010304UUuuxxxxxxxx@i0:1,Voltage L1,V,Voltage_L1,0 the i0:1 refers to: 01030023 with a scaling factor ( :1 ) for 1 1,010304UUuuxxxxxxxx@i1:10,Current L1,V,Current_L1,2 the i1:10 refers to: 01030028 with a scaling factor ( :10 ) for 10 Tip Use: sensor53 dM to output the received data in the console. M = the number of the meter in the definition line. During the output of the data in the console, the data in the WEB UI are not updated. To return write: sensor53 d0 Tip You can monitor the serial activity at a GPIO with a connected LED. This function is useful for debugging purposes and also to see data is coming in during normal operation. Usage: Enter the command sensor53 lx to activate this function (Lowercase L for LED ). x is the number of the GPIO where the LED is connected. For example you can use sensor53 l2 for the onboard LED on a Wemos D1-mini or sensor53 l13 on a Sonoff Basic. sensor53 l255 turns the function off. This is the default value. With sensor53 mx you can choose which serial meter ( x ) will be monitored. Set sensor53 m0 will monitor all serial meters. This is the default value. To start the monitoring at boot-time, simply add the necessary entries in the boot-section ( >B ) of the script: Example >B =>sensor53 r =>sensor53 l13 Special Commands ~ With = character at the beginning of a line you can do some special decoding. With * character fields can be hidden or skipped. Command Description M,=m Perform arithmetic ( +,-,*,/ ) on the measured data. Use # before a number to designate a constant value e.g. 1,=m 3+4+5/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 to sum results of decoder entries 3,4,5 and divide by 3 (average) M,=d Calculate difference between metric values decoded at time intervals (up to 10 =d lines possible) e.g. 1,=d 3 10 calculate 10 second interval difference of decoder entry 3 M,=h Insert text on the web interface (html text up to 30 chars). These lines do not count as decoder entry. e.g. 1,=h<hr/> to insert a separator line on the web UI * character To hide fields from result output or disable output completely. Compiling with USE_SML_SCRIPT_CMD required. - as single character in <label> of the metrics line will hide that value from the web UI - as single character in <label> of the meter definition line will suppress the entire JSON output on MQTT M,=so1 special SML option for meters that use a bit in the status register to sign import or export like ED300L, AS2020 or DTZ541 e.g. 1,=so1,00010800,65,11,65,11,00100700 for DTZ541 1. obis code that holds the direction bit, 2. Flag identifier, 3. direction bit, 4. second Flag identifier (some meters use 2 different flags), 5. second bit, 6 obis code of value to be inverted on direction bit. needs #define USE_SML_SPECOPT remark: channel math only works on frequently (fast) updated channels and is not recommended with counters Example To get the value of one of the descriptor lines, use sml[X] . X = Line number. Starts with 1 . (compiling with USE_SML_SCRIPT_CMD required) >D v1=0 v2=0 >S ;Writes the value of Descriptorline 1 to v1 v1=sml[1] ;Writes the value of Descriptorline 2 to v2 v2=sml[2] Example To disable and enable publishing of MQTT data on TelePeriod, use smlj=0 and smlj=1 , respectively. For example to skip first MQTT publishing after boot (may contain erroneous data at after restart if meter is slow, see Sanxing SX6x1 ): >B ;disable publishing at MQTT teleperiod, on boot smlj=0 >S ;re-enable publishing at MQTT teleperiod, after 10 seconds of uptime if upsecs>10 then smlj=1 endif Example If you have large meter descriptors and want to extract multiple values from the same descriptor, you can save flash space using SML_REPLACE_VARS at compile time (see Resol Deltasol BS Plus ): >D ;define a text variable r=\"1,AA100021421000010774\" >M 1 ;in your meter definitions you can use your variable for the same descriptor +1,3,v,0,9600,Solar %r%vo12ut@#,time,,zeit,1 %r%vo0uw@10,S1 COL,\u00b0C,sens1,1 %r%vo2uw@10,S2 TST1,\u00b0C,sens2,1 %r%vo4uw@10,S3 TST2,\u00b0C,sens3,1 %r%vo6uw@10,S4 TR,\u00b0C,sens4,1 ;%r% inserts the text variable and saves script storage space (3 instead of 22 chars for each line) Attention With a few meters, it is necessary to request the meter to send data using a specific character string. This string has to be sent at a very low baud rate (300Baud). If you reply the meter with an acknowledge and ask the it for a new baud rate of 9600 baud, the baud rate of the SML driver has to be changed, too (see Landis + Gyr ZMR120AR ). To change the baud rate: sml( METERNUMBER 0 BAUDRATE ) For sending a specific character string: sml( METERNUMBER 1 STRING ) And it works like this: >D res=0 scnt=0 ;For this Example in the >F section >F ;count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1800ms later \\> Send ACK and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") ;2000ms later \\> Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) ;Restart sequence after 50x100ms case 50 ; 5000ms later \\> restart sequence scnt=0 ends >M 1 +1,3,o,0,9600, ,1 ;...etc. Note : This procedure is only necessary, if the meter explicitly asks for 300 baud. The most meters work directly with 9600 baud. Therefore it is easier to give this method a try (see Iskra MT 174 ): Meter#,GPIO# Input,TYPE,FLAG,Baudrate,JSONNAME,GPIO# Output,TX Period,Character string +1,3,o,0,9600,energy,1,4,2F3F210D0A Tip If you use a Wemos D1 Mini you could compile a 4M flash image with filesystem support so your script will survive upgrades and factory resets. To do this, create a new entry in platformio_tasmota_env.ini : [env:tasmota-4mb] board_build.ldscript = eagle.flash.4m2m.ld Add tasmota-4mb to platformio.ini 's build variants. Add the following to user_config_override.h : #undef MODULE #define MODULE WEMOS #define USE_UFILESYS #define GUI_TRASH_FILE Also recommended, if you use lots of vars and increased buffer sizes to free up the image from unused drivers. You should get some inspiration from the tasmota-lite image definition in tasmota_configurations.h . Tip You can dump to your PC the raw data coming in if you use the module's hardware serial ports (1 and 3) as GPIOs of the script, using Serial to TCP Bridge . Compile your firmware with USE_TCP_BRIDGE , disable the script and configure in module parameters TCP Tx and TCP Rx . After module reboot, start the server with command TCPStart 8888 . Connect to this port from your PC to see or dump the data, in Linux it's as easy as cat < /dev/tcp/IP.OF.YOUR.TASMOTA/8888 > rawdump.txt . To revert to SML you need to set back both GPIO ports to None , enable the script and restart. Commands ~ sensor53 r = resets the sml driver, must be applied in script >B section sensor53 cx num = sets counter x (1 or 2) to number (persistent change) sensor53 dm = sets dump mode for meter m (1...N), must be set to 0 for normal operation sensor53 l x = set an optional LED GPIO pin to indicate serial activity of a meter, set to 255 for disable sensor53 m x = sets the meter from which to show activity via the l cmd Smart Meter Descriptors ~ ABB B23 (MODBus) ~ Meter is basically the same as Janitza B23 with the same interface. It's just missing whole section of registers which are used in Janitza B23 example. Beware that A and B MODBus connectors are switched! View script >D >B ->sensor53 r >M 1 +1,3,m,0,9600,ABB,1,10,01035B00,01035B02,01035B04,01035B14,01035B16,01035B18,01035B1A,r010350080004,r010350000004,r010350040004 1,010304UUuuUUuu@i0:10,Voltage L1-N,V,Voltage_L1,1 1,010304UUuuUUuu@i1:10,Voltage L2-N,V,Voltage_L2,1 1,010304UUuuUUuu@i2:10,Voltage L3-N,V,Voltage_L3,1 1,010304SSssSSss@i3:100,Active power Total,W,Active_power_Total,2 1,010304SSssSSss@i4:100,Active power L1-N,W,Active_power_L1,2 1,010304SSssSSss@i5:100,Active power L2-N,W,Active_power_L2,2 1,010304SSssSSss@i6:100,Active power L3-N,W,Active_power_L3,2 1,010308xxxxxxxxSSssSSss@i7:100,Real energy,kWh,Real_energy,2 1,010308xxxxxxxxUUuuUUuu@i8:100,Real energy consumed,kWh,Real_energy_consumed,2 1,010308xxxxxxxxUUuuUUuu@i9:100,Real energy delivered,kWh,Real_energy_delivered,2 # Using the IR Port on left side of the device. IR doesn't support MODBUS only M-Bus and EQ-Bus protocol. Configure the IR output at the device menu. This example is using 9600 baud and address 10h (16 decimal). The meter is using equal parity 1 stop bit 9600E1 The upper diode is TX the lower RX. My device is sending always 2 telegrams. I tried to add additional values by sending SND_UD telegram. I only receive the e5 response showing that the request was accepted. No change in response. The last telegram will end on a \"0F xx 16\" instead of a \"1F xx 16\", which will show that additional telegrams are available. If you can receive more telegrams, add alternating 107b108b16 - 105b106b16. One for each telegram. This example will only work with address 10! the second last byte is a check sum. For this REQ_UD2 it is the sum of the 2 bytes before (Address and VIF). View script >M 1 +1,3,rE1,0,9600,ABB,1,10,1040105016,107b108b16,105b106b16[,107b108b16[,105b106b16]] 1,081072bcd8@1,Meter ID,,ID,0 ; meter ID (BCD-8) 1,0E8400bcd8@100,E Imp total,kWh,Imp,2 ; Total imported energy 0.01 kWh 1,04A900ssSSssSSs@100,P total,W,P_tot,2 ; Total Power 0.01 W 1,04A9FF8100ssSSssSSs@100,P L1,W,P_L1,2 ; L1 Power 0.01 W 1,04A9FF8200ssSSssSSs@100,P L2,W,P_L2,2 ; L2 Power 0.01 W 1,04A9FF8300ssSSssSSs@100,P L3,W,P_L3,2 ; L3 Power 0.01 W 1,04FDC8FF8100uuUUuuUUs@10,U L1,V,U_L1,1 ; Voltage L1 0.1 V 1,04FDC8FF8200uuUUuuUUs@10,U L2,V,U_L2,1 ; Voltage L2 0.1 V 1,04FDC8FF8300uuUUuuUUs@10,U L3,V,U_L3,1 ; Voltage L3 0.1 V 1,0AFFD900bcd4@100,*,Hz,F,2 ; Frequency 1,0E84FF8100bcd8@100,E Imp L1,kWh,Imp-L1,2 ; L1 imported energy 0.01 kWh 1,0E84FF8200bcd8@100,E Imp L2,kWh,Imp-L2,2 ; L2 imported energy 0.01 kWh 1,0E84FF8300bcd8@100,E Imp L3,kWh,Imp-L3,2 ; L3 imported energy 0.01 kWh # Apator APOX+ (SML) ~ Energy provider supplied a PIN code to enable output of additional data. View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,SML 1,77070100010801ff@1000,Verbrauch_Tarif_1,kWh,Total_Tarif1,3 1,77070100010802ff@1000,Verbrauch_Tarif_2,kWh,Total_Tarif2,3 1,77070100010800ff@1000,Verbrauch_Summe,kWh,Total_Summe,3 1,77070100100700ff@1,Current consumption,W,Power_curr,3 1,=h ---- 1,770701001f0700ff@1,Current L1,A,Curr_p1,3 1,77070100330700ff@1,Current L2,A,Curr_p2,3 1,77070100470700ff@1,Current L3,A,Curr_p3,3 1,=h ---- 1,77070100200700ff@1,Voltage L1,V,Volt_p1,3 1,77070100340700ff@1,Voltage L2,V,Volt_p2,3 1,77070100480700ff@1,Voltage L3,V,Volt_p3,3 # Carlo Gavazzi EM340 (MODBUS RTU) ~ View script >D >B ->sensor53 r ;->sensor53 d1 >M 1 +1,13,m,0,115200,MODBUS,12,2,01030000,01030002,01030004,0103000C,0103000E,01030010,01030012,01030014,01030016,01030018,0103001A,0103001C,0103001E,01030020,01030022,01030034,01030038,0103002e,0103002f,01030030,0103004e 1,010304SSssSSsss@i0:10,Voltage L1,V,Voltage_L1,1 1,010304SSssSSsss@i1:10,Voltage L2,V,Voltage_L2,1 1,010304SSssSSsss@i2:10,Voltage L3,V,Voltage_L3,1 1,010304SSssSSsss@i3:1000,Current L1,A,Current_L1,3 1,010304SSssSSsss@i4:1000,Current L2,A,Current_L2,3 1,010304SSssSSsss@i5:1000,Current L3,A,Current_L3,3 1,010304SSssSSsss@i6:10,Power L1,W,Power_L1,1 1,010304SSssSSsss@i7:10,Power L2,W,Power_L2,1 1,010304SSssSSsss@i8:10,Power L3,W,Power_L3,1 1,010304SSssSSsss@i9:10,Power VA L1,VA,Power_va_L1,1 1,010304SSssSSsss@i10:10,Power VA L2,VA,Power_va_L2,1 1,010304SSssSSsss@i11:10,Power VA L3,VA,Power_va_L3,1 1,010304SSssSSsss@i12:10,Power var L1,var,Power_var_L1,1 1,010304SSssSSsss@i13:10,Power var L2,var,Power_var_L2,1 1,010304SSssSSsss@i14:10,Power var L3,var,Power_var_L3,1 1,010304SSssSSsss@i15:10,Energy Tot,kWh,Energy_Tot,1 1,010304SSssSSsss@i16:10,Energy Demand,W,Energy_Demand,1 1,010304SSss@i17:1000,PF L1,PF,PF_L1,1 1,010304SSss@i18:1000,PF L2,PF,PF_L2,1 1,010304SSss@i19:1000,PF L3,PF,PF_L3,1 1,010304SSssSSsss@i20:10,Energy Tot Export,kWh,Energy_Tot_Export,1 # COMBO Meter (Water, Gas, SML) ~ View script >D >B ->sensor53 r >M 3 +1,1,c,0,10,H20 +2,4,c,0,50,GAS +3,3,s,0,9600,SML 1,1-0:1.8.0*255(@10000,Water reading,cbm,Count,4 2,=h================== 2,1-0:1.8.0*255(@100,Gas reading,cbm,Count,3 3,77070100010800ff@1000,Total consumption,KWh,Total_in,3 3,=h================== 3,77070100100700ff@1,Current consumption,W,Power_curr,2 3,=h ---- 3,=m 10+11+12 @100,Currents L1+L2+L3,A,Curr_summ,2 3,=m 13+14+15/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 3,=h================== 3,77070100240700ff@1,Consumption P1,W,Power_p1,2 3,77070100380700ff@1,Consumption P2,W,Power_p2,2 3,770701004c0700ff@1,Consumption P3,W,Power_p3,2 3,=h ---- 3,770701001f0700ff@100,Current L1,A,Curr_p1,2 3,77070100330700ff@100,Current L2,A,Curr_p2,2 3,77070100470700ff@100,Current L3,A,Curr_p3,2 3,=h ---- 3,77070100200700ff@100,Voltage L1,V,Volt_p1,2 3,77070100340700ff@100,Voltage L2,V,Volt_p2,2 3,77070100480700ff@100,Voltage L3,V,Volt_p3,2 3,=h================== 3,77070100000009ff@#,Service ID,,Meter_id,0 3,=h # DDM18SD (MODBus) ~ This script, based on tasmota scripting language, is to read data on a unsupported DDM18SD power meter. It has a 8E1 parity and the slave ID address is n 5. On a Nodemcu or Wemos D1 board, put wires between GPIO3 and GPIO1 to the RX and TX pinout of a RS485 to TTL board, but leave empty (none) the GPIO Tasmota software settings. A & B connected to the meter pinout. View script >B ->sensor53 r >M 1 +1,3,M,0,9600,DDM,1,2,05040000,05040008,05040012,0504001A,05040036,0504002A,05040100,05040400 1,050404ffffffff@i0:1,Tensione,V,DDM_Voltage,2 1,050404ffffffff@i1:1,Corrente,A,DDM_Current,2 1,050404ffffffff@i2:1,Consumo Ist.,W,DDM_Power,2 1,050404ffffffff@i3:1,Reactive power,Var,DDM_React_Power,2 1,050404ffffffff@i4:1,Frequenza,Hz,DDM_Frequency,2 1,050404ffffffff@i5:1,Power factor,,DDM_PF,2 1,050404ffffffff@i6:1,Consumi tot.,Kwh,DDM_Tot_Power,2 1,050404ffffffff@i7:1,Tot. react. power,Kvarh,DDM_Reac_Power,2 # Digimeto GS303 (SML) ~ View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,GS303 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,3 1,77070100100700ff@1,Current Consumption,W,Power_cur,0 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,3 1,7707010060320101@#,Service ID,,Meter_id,0 # EasyMeter Q3A / Apator APOX+ (SML) ~ A 2-Tariff Meter which for Example SWM (Stadtwerke M\u00fcnchen) oder DGY (Discovergy) uses. Unfortunately this Version sends only whole kWh (precision 0) without PIN. With PIN behaviour changes and high resolution is available as seen below (e.g. precision 7 for consumption/kWh, precision 2 for power/W, precision 1 for voltage/V). Apator APOX+ behaves same as the EasyMeter while pin locked, just precision 0 without additional data. After calling the energy provider they send a letter with the unlock pin. View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,SML 1,77070100010801ff@1000,Verbrauch_Tarif_1,kWh,Verbrauch_T1,7 1,77070100010802ff@1000,Verbrauch_Tarif_2,kWh,Verbrauch_T2,7 1,77070100010800ff@1000,Verbrauch_Summe,kWh,Verbrauch_Summe,7 1,77070100020800ff@1000,Einspeisung_Summe,kWh,Einspeisung_Summe,7 1,=h-- 1,77070100240700ff@1,Leistung_L1,W,Watt_L1,2 1,77070100380700ff@1,Leistung_L2,W,Watt_L2,2 1,770701004c0700ff@1,Leistung_L3,W,Watt_L3,2 1,77070100100700ff@1,Leistung_Summe,W,Watt_Summe,2 1,=h-- 1,77070100200700ff@1,Spannung_L1,V,Volt_L1,1 1,77070100340700ff@1,Spannung_L2,V,Volt_L2,1 1,77070100480700ff@1,Spannung_L3,V,Volt_L3,1 # EasyMeter Q3B (SML) ~ Two separate 2-Tariff meters (e.g. from Fairenergie Reutlingen) are readout by the same Tasmota device. The first one is for general purpose and is connected to GPIO14 . The JSON prefix is set to Power . The second one is for the heat pump and connected to GPIO13 . The JSON prefix is set to Pump . For both meters, tariff 1 & 2 are rounded kWh (precision 0), actual consumption in W has a higher precision (1). View script >D >B =>sensor53 r >M 2 +1,14,s,0,9600,Power 1,77070100010801ff@1000,Tarif 1,kWh,Power_T1,0 1,77070100010802ff@1000,Tarif 2,kWh,Power_T2,0 1,77070100010800ff@1000,Summe,kWh,Power_Sum,0 1,77070100010700ff@1000,Verbrauch,W,Power_Use_Sum,1 +2,13,s,0,9600,Pump 2,77070100010801ff@1000,Tarif 1,kWh,HP_T1,0 2,77070100010802ff@1000,Tarif 2,kWh,HP_T2,0 2,77070100010800ff@1000,Summe,kWh,HP_Sum,0 2,77070100010700ff@1000,Verbrauch,W,HP_Use_Sum,1 # EasyMeter Q3D, Q3DA1024 (OBIS) ~ The Q3D is a three-phase model energy meter, which was sold in a number of different configurations. This is a legacy device, however still available new in some shops. The most popular model seems to be the two-direction model for solar power metering. The D0 port is read-only with a fixed time interval of two seconds. The communication settings are unusual: 7 data bits, even parity, one stop bit, 9600 baud (9600 7E1). Because the 7E1 serial mode is not supported by Tasmota software serial, the hardware serial port must be used, i.e. GPIO 3. This will /not/ work using GPIO 0 or 2. Also, the source code has to be patched from 8N1 to 7E1 mode for the hardware serial in file src/TasmotaSerial.cpp, please see the patch further down below. Since Tasmota 9.5.0 the serial mode can be changed in the console by typing SerialConfig 7E1 without having to patch TasmotaSerial. Example reading of the two-direction model using GPIO 3 - P_in power reading will be negative in case of inverse power flow: >D >B =>sensor53 r >M 1 +1,12,o,0,9600,SML,1 1,1-0:1.7.255*255(@1,P_in,W,P_in,18 1,1-0:21.7.255*255(@1,L1,W,L1,18 1,1-0:41.7.255*255(@1,L2,W,L2,18 1,1-0:61.7.255*255(@1,L3,W,L3,18 1,1-0:1.8.0*255(@1,E_in,kWh,E_in,19 1,1-0:2.8.0*255(@1,E_out,kWh,E_out,19 1,1-0:0.0.0*255(@1,Netzbetreiber-ID,,NetID,0 1,0-0:96.1.255*255(@#),Seriennummer,,serial,0 # Alternative script running on a Wemos D1 mini on hardware serial pin 3 for the Q3DB1024 two direction >D >B =>sensor53 r >M 1 +1,3,o,0,9600,Haupt,1 1,1-0:1.7.0*255(@1,P_in,W,P_in,18 1,1-0:1.8.0*255(@1,E_in,kWh,E_in,19 1,1-0:2.8.0*255(@1,E_out,kWh,E_out,19 1,1-0:21.7.0*255(@1,L1,W,L1,18 1,1-0:41.7.0*255(@1,L2,W,L2,18 1,1-0:61.7.0*255(@1,L3,W,L3,18 1,1-0:0.0.0*255(@1,Netzbetreiber-ID,,NetID,0 1,0-0:96.1.255*255(@#),Seriennummer,,serial,0 # Apply following patch to src/TasmotaSerial.cpp --- a / lib / default / TasmotaSerial -3.2.0 / src / TasmotaSerial . cpp +++ b / lib / default / TasmotaSerial -3.2.0 / src / TasmotaSerial . cpp @@ -117 , 7 + 117 , 7 @@ bool TasmotaSerial :: begin ( long speed , int stop_bits ) { if ( 2 == m_stop_bits ) { Serial . begin ( speed , SERIAL_8N2 ); } else { - Serial . begin ( speed , SERIAL_8N1 ); + Serial . begin ( speed , SERIAL_7E1 ); } if ( m_hardswap ) { Serial . swap (); eBZ DD3 (OBIS) ~ The eBZ DD3 by eBZ GmbH is a three-phase model energy meter, which is sold in a number of different configurations. The D0 port is read-only with a fixed time interval of one second. There are two communication interfaces: * The INFO interface on the front, with a metal backplate. Pushes a reduces OBIS ASCI datagram every second. * The MSB interface on the top, no metal backplate. Pushes a full OBIS ASCI datagram every second. There are two types available using different communication settings: * OD-type: 7 data bits, even parity, one stop bit, 9600 baud (9600 7E1) * SM-type: 8 data bits, no parity, one stop bit, 9600 baud (9600 8N1) Tested with a eBZ DD3 2R06 ODZ1 (two-direction model for e. g. solar power metering). Because the 7E1 serial mode is not supported by Tasmota software serial, the hardware serial port must be used, i.e. GPIO 3. This will /not/ work using GPIO 0 or 2. Also, the source code has to be patched from 8N1 to 7E1 mode for the hardware serial in file src/TasmotaSerial.cpp, please see the patch further down below. Since Tasmota 9.5.0 the serial mode can be changed in the console by typing SerialConfig 7E1 without having to patch TasmotaSerial. Example reading of the two-direction model using GPIO 3: \"TelePeriod 30\" sets telemetry period to 30 seconds (remove if not needed/wanted) Values for ?6.7.0 (power) are transmit immediately (precision + 16) power readings will be negative in case of inverse power flow View script >D >B TelePeriod 30 =>sensor53 r >M 1 ; Device: eBZ DD3 2R06 ODZ1 ; protocol is D0 OBIS ASCII ; 9600@7E1 for OP-type devices, 9600@8N1 for SM-type devices +1,3,o,0,9600,SM,1 ; Z\u00e4hlerstand zu +A, tariflos, ; Z\u00e4hlerst\u00e4nde Aufl\u00f6sung 10 \u00b5W*h (6 Vorkomma- und 8 Nachkommastellen) 1,1-0:1.8.0*255(@0.001,Energie Bezung,Wh,1_8_0,8 ; Z\u00e4hlerstand zu +A, Tarif 1 1,1-0:1.8.1*255(@0.001,Energie Bezung T1,Wh,1_8_1,8 ; Z\u00e4hlerstand zu +A, Tarif 2 1,1-0:1.8.2*255(@0.001,Energie Bezung T2,Wh,1_8_2,8 ; Z\u00e4hlerstand zu -A, tariflos 1,1-0:2.8.0*255(@0.001,Energie Export,Wh,2_8_0,8 ; Summe der Momentan-Leistungen in allen Phasen, Aufl\u00f6sung 0,01W (5 Vorkomma- und 2 Nachkommastellen) 1,1-0:16.7.0*255(@1,Leistung,W,16_7_0,18 ; Momentane Leistung in Phase Lx, Aufl\u00f6sung 0,01W (5 Vorkomma- und 2 Nachkommastellen) 1,1-0:36.7.0*255(@1,Leistung L1,W,36_7_0,18 1,1-0:56.7.0*255(@1,Leistung L2,W,56_7_0,18 1,1-0:76.7.0*255(@1,Leistung L3,W,76_7_0,18 ; Spannung in Phase Lx, Aufl\u00f6sung 0,1V (nur \u00fcber MSB) 1,1-0:32.7.0*255(@1,Spannung L1,V,32_7_0,1 1,1-0:52.7.0*255(@1,Spannung L2,V,52_7_0,1 1,1-0:72.7.0*255(@1,Spannung L3,V,72_7_0,1 ; Statuswort, 4 Byte Information \u00fcber den Betriebszustand, HEX string ; tasmota can decode one string per device only! ;1,1-0:96.5.0*255(@#),Status1,,96_5_0,0 ;1,1-0:96.8.0*255(@#),Status2,,96_8_0,0 ; Ger\u00e4te-Identifikation, Nach DIN 43863-5 1,1-0:96.1.0*255(@#),Identifikation,,96_1_0,0 ;1,1-0:0.0.0*255(@#),Identifikation,,0_0_0,0 # Apply following patch to src/TasmotaSerial.cpp --- a/lib/default/TasmotaSerial-3.2.0/src/TasmotaSerial.cpp +++ b/lib/default/TasmotaSerial-3.2.0/src/TasmotaSerial.cpp @@ -117,7 +117,7 @@ bool TasmotaSerial::begin(long speed, int stop_bits) { if (2 == m_stop_bits) { Serial.begin(speed, SERIAL_8N2); } else { - Serial.begin(speed, SERIAL_8N1); + Serial.begin(speed, SERIAL_7E1); } if (m_hardswap) { Serial.swap(); For the SM-type meter DD3 2R06 DTA SMZ1 the following script worked without having to apply the above patch, because it uses 8N1 for communication >D >B ;TelePeriod 30 =>sensor53 r >M 1 ; Device: eBZ DD3 2R06 DTA SMZ1 ; protocol is D0 SML HEX ; 9600@7E1 for OP-type devices, 9600@8N1 for SM-type devices +1,3,s,0,9600,SML,1 ; Z\u00e4hlerstand zu +A, tariflos, ; Z\u00e4hlerst\u00e4nde Aufl\u00f6sung 10 \u00b5W*h (6 Vorkomma- und 8 Nachkommastellen) 1,77070100010800FF@100000000,Energie Bezug,kWh,1_8_0,8 ; Z\u00e4hlerstand zu +A, Tarif 1 1,77070100010801FF@100000000,Energie Bezug T1,kWh,1_8_1,8 ; Z\u00e4hlerstand zu +A, Tarif 2 1,77070100010802FF@100000000,Energie Bezug T2,kWh,1_8_2,8 ; Z\u00e4hlerstand zu -A, tariflos 1,77070100020800FF@100000000,Energie Export,kWh,2_8_0,8 ; Summe der Momentan-Leistungen in allen Phasen, Aufl\u00f6sung 0,01W (5 Vorkomma- und 2 Nachkommastellen) 1,77070100100700FF@1,Leistung,W,16_7_0,16 ; Momentane Leistung in Phase Lx, Aufl\u00f6sung 0,01W (5 Vorkomma- und 2 Nachkommastellen) 1,77070100240700FF@1,Leistung L1,W,36_7_0,16 1,77070100380700FF@1,Leistung L2,W,56_7_0,16 1,770701004C0700FF@1,Leistung L3,W,76_7_0,16 ; Spannung in Phase Lx, Aufl\u00f6sung 0,1V (nur \u00fcber MSB) ;1,77070100200700FF@1,Spannung L1,V,32_70,1 ;1,77070100340700FF@1,Spannung L2,V,52_7_0,1 ;1,77070100480700FF@1,Spannung L3,V,72_7_0,1 ; Statuswort, 4 Byte Information \u00fcber den Betriebszustand, HEX string ; tasmota can decode one string per device only! ;1,1-0:96.5.0*255@#),Status1,,96_5_0,0 ;1,1-0:96.8.0*255@#),Status2,,96_8_0,0 ; Ger\u00e4te-Identifikation, Nach DIN 43863-5 1,77070100000009FF@#),Identifikation,,96_1_0,0 ;1,77070100000000FF@#),Identifikation,,0_0_0,0 # EasyMeter Q1D (ASCII OBIS) ~ This script is for the EasyMeter Q1DB1004 variant of the Q1D series. This variant is a one-phase one-way electricity counter with a backstop mechanism. Therefore the script reads only two values: the energy counter value and the power value. The power value is positive when you are drawing power from the public grid, and negative when you are feeding power to the public grid. Due to the backstop mechanism, the energy counter value will not decrease when you feed power to the public grid. The meter's manufacturer's datasheet neatly explains the serial message format used, so you can easily adapt the code below to your EasyMeter Q1D, e.g. if you have a two-way counter variant like the EasyMeter Q1DA1026. View script >D >B =>sensor53 r >M 1 +1,3,o,0,9600,SML 1,1-0:1.8.0*255(@1,EC_CounterVal,kWh,EC_CounterVal,4 1,1-0:61.7.255*255(@1,EC_PowerVal,W,EC_PowerVal,0 # According to the manufacturer's datasheet, the serial parameters are 9600 baud and 7E1. For Tasmota versions that are built with a TasmotaSerial.cpp of version 3.5.0 (and probably all higher versions, too), no modification of the TasmotaSerial.cpp source code (as suggested in other entries of this documentation) is necessary to set the serial parameters to 7E1: By configuring the meter type as OBIS (\"o\") in line 5 of the above code, you implicitly tell Tasmota to set the serial parameters to 7E1 (probably the same applies to all other meters in this documentation where a modification of TasmotaSerial.cpp has previously been recommended). EFR SGM-C4-4A920L (OBIS) ~ By default, the wattmeter only sends the actual power. To be able to read all the other values, you need to enter the PIN. The PIN must be requested to the electricity provider. After entering the PIN, all the values will be available and you also have the option to disable the need of the PIN. View script >D >B ->sensor53 r >M 1 +1,3,s,16,9600,SML 1,77070100010800ff@1000,Comsumption,kWh,HT,4 1,77070100020800ff@1000,Supply,kWh,SP,4 1,77070100100700ff@1,Actual Power,W,AP,0 1,77070100200700ff@1,Voltage P1,V,V_P1,1 1,77070100340700ff@1,Voltage P2,V,V_P2,1 1,77070100480700ff@1,Voltage P3,V,V_P3,1 1,770701001f0700ff@1,Current P1,A,A_P1,2 1,77070100330700ff@1,Current P2,A,A_P2,2 1,77070100470700ff@1,Current P3,A,A_P3,2 1,77070100510704ff@1,Phaseangle I-L1/U-L1,deg,phase_angle_p1,1 1,7707010051070fff@1,Phaseangle I-L27I-L2,deg,phase_angle_p2,1 1,7707010051071aff@1,Phaseangle I-L3/I-L3,deg,phase_angle_p3,1 1,770701000e0700ff@1,Frequency,Hz,HZ,1 # Overview of the codes Elster / Honeywell AS1440 (OBIS) ~ Based on Landis script with changed timings in the >F section, as AS1440 seems to be slower in responding. View script >D scnt=0 res=0 >B =>sensor53 r >F ; count 100ms scnt+=1 switch scnt case 3 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1700ms later \\> Ack and ask for switching to 9600 baud case 20 res=sml(1 1 \"063035300D0A\") ;300ms later \\> Switching sml driver to 9600 baud case 23 res=sml(1 0 9600) ;Restart sequence after 55x100ms case 55 ; 5500ms later \\> restart sequence scnt=0 ends >M 1 +1,3,o,0,9600,AS1440,1 1,1-1:1.8.1(@1,Total_In,KWh,Total_In,3 1,1-1:2.8.1(@1,Total_Out,KWh,Total_Out,3 # Elster / Honeywell AS2020 (SML) ~ View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,,1 1,77070100600100ff@#,Server-ID,,Wert,0 1,77070100010800ff@1000,Total Consumed,kWh,total_consumed_kwh,1 1,77070100020800ff@1000,Total Delivered,kWh,total_delivered_kwh,1 1,77070100100700ff@0.1,Current Consumption,W,current_consumption,0 # EMH ED300L (SML) ~ View script >D >B ->sensor53 r >M 2 +1,13,s,0,9600,Haus +2,12,s,0,9600,Heizung 1,770701000F0700FF@1,Aktuell,W,Power_curr,0 1,77070100010800FF@1000,Z\u00e4hlerstand Verb.,kWh,Tariflos,2 1,77070100020800FF@1000,Z\u00e4hlerstand Einsp.,kWh,Tariflos,2 2,=h================== 2,770701000F0700FF@1,Aktuell,W,Power_curr,0 2,77070100010800FF@1000,Z\u00e4hlerstand Verb.,kWh,Tariflos,2 2,77070100020800FF@1000,Z\u00e4hlerstand Einsp.,kWh,Tariflos,2 # EMH ED300S (SML) ~ View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,Main 1,77070100100700ff@1,Power,W,power,0 1,77070100010800FF@1000,Counter,kWh,counter,3 # EMH eHZ Generation K (SML) ~ View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600, 1,77070100010800ff@1000,Gesamtverbrauch,KWh,Total_in,2 1,77070100020800ff@1000,Gesamteinspeisung,KWh,Total_out,2 1,77070100100700ff@1,Verbrauch,W,Power_curr,0 # EMH mMe4.0 (SML) ~ View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,Main,1,10 1,77070100010800FF@1000,Total Consumed,kWh,counter_pos,3 1,77070100020800FF@1000,Total Feed,kWh,counter_neg,3 1,77070100100700FF@1,Power,W,power,0 # eZB MD3 (SML) ~ View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,Smartmeter 1,77070100010800ff@100000000,Total consumption,KWh,Total_in,3 1,77070100020800ff@100000000,Total generation,KWh,Total_out,3 1,77070100100700ff@1,Power L1+L2+L3,W,P_L1_L2_L3,18 1,77070100240700ff@1,Power L1,W,P_L1,18 1,77070100380700ff@1,Power L2,W,P_L2,18 1,770701004C0700ff@1,Power L3,W,P_L3,18 # Growatt MAX4200 (MODBus) ~ Growatt solar inverter. this example also shows how to send cmds to modbus View script >D 22 cstr=\"\" gl=0 tmp=0 >B =>sensor53 r >S if chg[gl]>0 { ; change limit tmp=int(gl/42) cstr=\"r0106000300\"+hn(tmp) sml(1 3 cstr) } >M 1 +1,18,m,0,9600,GRW,19,5,01040026,01040028,01040005,01040009,01030003 1,010404UUuu@i0:10,Netzspannung,V,mainsv,1 1,010404xxxxUUuu@i0:10,Einspeisestrom,A,mainsc,1 1,010404UUuuUUuu@i1:10,Einspeiseleistung,W,mainsw,1 1,010404UUuuUUuu@i2:10,string 1 unten,W,s1w,1 1,010404UUuuUUuu@i3:10,string 2 oben,W,s2w,1 1,010304UUuu@i4:1,limit,%,limit,0 # >W <hr> nm(1000 3600 10 gl \"Growatt limit (W) \" 80 0) Hager EHZ161 (OBIS) ~ View script >D >B ->sensor53 r >M 1 +1,3,o,0,9600,OBIS 1,1-0:1.8.1\\*255(@1,Total consumption,KWh,Total_in,4 1,1-0:2.8.1\\*255(@1,Total Feed,KWh,Total_out,4 1,=d 2 10 @1,Current consumption,W,Power_curr,0 1,1-0:0.0.0\\*255(@#),Meter Nr,, Meter_number,0 # Hager EHZ363, Apator Norax 3D (SML) ~ View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,SML 1,77070100010800ff@1000,Total consumption,KWh,Total_in,4 1,77070100020800ff@1000,Total Feed,KWh,Total_out,4 1,77070100100700ff@1,Current consumption,W,Power_curr,0 1,77070100200700ff@1,Voltage L1,V,Volt_p1,1 1,77070100340700ff@1,Voltage L2,V,Volt_p2,1 1,77070100480700ff@1,Voltage L3,V,Volt_p3,1 1,770701001f0700ff@1,Amperage L1,A,Amperage_p1,1 1,77070100330700ff@1,Amperage L2,A,Amperage_p2,1 1,77070100470700ff@1,Amperage L3,A,Amperage_p3,1 1,77070100510704ff@1,Phaseangle I-L1/U-L1,deg,phase_angle_p1,1 1,7707010051070fff@1,Phaseangle I-L27I-L2,deg,phase_angle_p2,1 1,7707010051071aff@1,Phaseangle I-L3/I-L3,deg,phase_angle_p3,1 1,770701000e0700ff@1,Frequency,Hz,frequency,0 # SML with daily values >D pin=0 pout=0 pi_d=0 po_d=0 hr=0 ; permanent midnight values p:pi_m=0 p:po_m=0 >B ->sensor53 r >T ; get total consumption and total feed pin=SML#Total_in pout=SML#Total_out >S ; at midnight, save meter total values hr=hours if chg[hr]>0 and hr==0 then pi_m=pin po_m=pout svars endif ; on teleperiod calculate current daily values from midnight if upsecs%tper==0 then pi_d=pin-pi_m po_d=pout-po_m endif ; show these values on WEB UI >W Tagesverbrauch: {m} %pi_d% kWh Tageseinspeisung: {m} %po_d% kWh ; transmit these values with MQTT >J ,\"daily_consumption\":%pi_d%,\"daily_feed\":%po_d% ; meter definition >M 1 +1,3,s,0,9600,SML 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,4 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,4 1,77070100100700ff@1,Current Consumption,W,Power_curr,0 1,77070100000009ff@#,Meter Number,,Meter_number,0 # Hiking DDS238-2 ZN/S3 4x (MODBus) ~ This is an example for 4 MODBus devices on the same bus (at different addresses). Wiring diagram View script >D >B ->sensor53 r >M 1 +1,3,m,1,9600,Hiking,1,10,0103000c,0103000e,0303000c,0303000e,0403000c,0403000e,0503000c,0503000e ;---> two groups of registrers for each device --> default 2 registers returned ---> 4 values per device 1,=h Contatore 1 1,010304UUuu@i0:10,C1_Voltage,V,C1Voltage,1 ;---> decoder for the first registry returned for the first group 1,010304xxxxUUuu@i0:1000,C1_Current,A,C1Current,3 ;---> decoder for the second registry returned for the first group 1,010304SSss@i1:1,C1_ActivePower,W,C1ActivePower,0 1,010304xxxxUUuu@i1:1,C1_ReactivePower,Var,C1ReactivePower,0 1,=h Contatore 3 1,030304UUuu@i2:10,C3_Voltage,V,C3Voltage,1 1,030304xxxxUUuu@i2:1000,C3_Current,A,C3Current,3 1,030304SSss@i3:1,C3_ActivePower,W,C3ActivePower,0 1,030304xxxxUUuu@i3:1,C3_ReactivePower,Var,C3ReactivePower,0 1,=h Contatore 4 1,040304UUuu@i4:10,C4_Voltage,V,C4Voltage,1 1,040304xxxxUUuu@i4:1000,C4_Current,A,C4Current,3 1,040304SSss@i5:1,C4_ActivePower,W,C4ActivePower,0 1,040304xxxxUUuu@i5:1,C4_ReactivePower,Var,C4ReactivePower,0 1,=h Contatore 5 1,050304UUuu@i6:10,C5_Voltage,V,C5Voltage,1 1,050304xxxxUUuu@i6:1000,C5_Current,A,C5Current,3 1,050304SSss@i7:1,C5_ActivePower,W,C5ActivePower,0 1,050304xxxxUUuu@i7:1,C5_ReactivePower,Var,C5ReactivePower,0 # Holley DTZ541 (SML) ~ This script reads pretty much all given informations. Make sure to enable info in the settings, otherwise you only get total / current consuption and total export. This script was used and tested on a WeMos D1 mini with an IR Head connected to the RX pin (3). View script >D >B ->sensor53 r >M 1 +1,3,s,16,9600,SML 1,77070100600100ff@#,Server ID,,server_id,0 1,77070100020800ff@1000,Export (Total),kWh,export_total_kwh,4 1,77070100010800ff@1000,Consumption (Total),kWh,total_kwh,4 1,77070100100700ff@1,Consumption (Current),W,curr_w,0 1,77070100200700ff@1,Voltage L1,V,volt_p1,1 1,77070100340700ff@1,Voltage L2,V,volt_p2,1 1,77070100480700ff@1,Voltage L3,V,volt_p3,1 1,770701001f0700ff@1,Amperage L1,A,amp_p1,1 1,77070100330700ff@1,Amperage L2,A,amp_p2,1 1,77070100470700ff@1,Amperage L3,A,amp_p3,1 1,77070100510701ff@1,Phase angle U-L2/U-L1,deg,phase_angle_l2_l1,1 1,77070100510702ff@1,Phase angle U-L3/U-L1,deg,phase_angle_l3_l1,1 1,77070100510704ff@1,Phase angle I-L1/U-L1,deg,phase_angle_p1,1 1,7707010051070fff@1,Phase angle I-L2/U-L2,deg,phase_angle_p2,1 1,7707010051071aff@1,Phase angle I-L3/U-L3,deg,phase_angle_p3,1 1,770701000e0700ff@1,Frequency,Hz,freq,0 # Iskra MT 174 (OBIS) ~ View script >D >B ->sensor53 r >M 1 +1,3,o,0,300,STROM,1,100,2F3F210D0A 1,1-0:1.8.1*255(@1,Total Consumed,KWh,Total_in,3 1,1-0:2.8.1*255(@1,Total Delivered,KWh,Total_out,3 1,1-0:0.0.0*255(@#),Meter Number,,Meter_number,0 # Iskra MT 175 (SML) ~ This meter needs a PIN to unlock the current power usage. You need to ask your provider. View script >D >B ->sensor53 r >M 1 +1,3,s,16,9600,MT175 1,77070100010800ff@1000,E_in,kWh,E_in,1 1,77070100020800ff@1000,E_out,kWh,E_out,1 1,77070100100700ff@1,P,W,P,18 1,77070100240700ff@1,L1,W,L1,18 1,77070100380700ff@1,L2,W,L2,18 1,770701004C0700ff@1,L3,W,L3,18 1,77070100000009ff@#,Server_ID,,Server_ID,0 # Iskra MT 681 (SML) ~ This is script for a two-direction meter (consumption and delivery) for the Isra MT 681, that is widely used in Germany. If you don't deliver energy, just delete the \"Total Delivered\" line. If the meter provides the consumption values for the 3 phases depends also on the configuration by your local energy provider. View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,MT681 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,3 1,77070100100700ff@1,Current Consumption,W,Power_cur,0 1,77070100240700ff@1,Current Consumption P1,W,Power_p1,0 1,77070100380700ff@1,Current Consumption P2,W,Power_p2,0 1,770701004c0700ff@1,Current Consumption P3,W,Power_p3,0 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,3 1,77070100000009ff@#,Service ID,,Meter_id,0| # Iskra eHZ-MT681-D4A51-K0p ~ 2012 version of the Iskra MT 681 with slightly other OBIS codes for the power values. View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,MT681 1,77070100010800ff@1000,Gesamtverbrauch,KWh,Total_in,3 1,770701000f0700ff@1,Leistung,W,Power_cur,0 1,77070100150700ff@1,Leistung P1,W,Power_p1,0 1,77070100290700ff@1,Leistung P2,W,Power_p2,0 1,770701003d0700ff@1,Leistung P3,W,Power_p3,0 1,77070100020800ff@1000,Gesamteinspeisung,KWh,Total_out,3 1,77070100000009ff@#,Service ID,,Meter_id,0| # Itron (SML V1.04) ~ The Itron electrical meter is a German end-user meter installed by EnBW. You can read values using an IR Sensor. The following script shows the meter number and the consuption and the generation of a Photovoltaik generator. View script >D >B =>sensor53 r >M 1 +1,12,s,0,9600,ELZ 1,77070100600100ff@#,Z\u00e4hlernummer,,Wert,0 1,77070100010800ff@1000,Verbrauch,kWh,ELZ_PV_1.8.0,1 1,77070100020800ff@1000,Erzeugung,kWh,ELZ_PV_2.8.0,1 # This script additionally reads the power in watts It has enhanced precision of 4 decimal places for the total consumption. Be sure to turn on the full precision at the meter using a flashlight (if you see inF=Off , hold for 5 seconds until you see inF=On ) >D >B =>sensor53 r ;Set teleperiod to 20sec tper=10 >M 1 +1,3,s,0,9600,Power 1,77070100600100ff@#,Z\u00e4hlernummer,,Meter_Number,0 1,77070100010800ff@1000,Verbrauch,kWh,Total_in,4 1,77070100100700ff@1,Leistung,W,Power_curr,0 1,77070100020800ff@1000,Erzeugung,kWh,Total_out,4 # Janitza B23 (MODBus) ~ View script >D >B ->sensor53 r >M 1 +1,3,m,0,9600,Janitza,1,1,01034A38,01034A3A,01034A3C,01034A4C,01034A4E,01034A50,01034A72,01034A7A,01034A82 1,010304ffffffff@i0:1,Voltage L1-N,V,Voltage_L1-N,2 1,010304ffffffff@i1:1,Voltage L2-N,V,Voltage_L2-N,2 1,010304ffffffff@i2:1,Voltage L3-N,V,Voltage_L3-N,2 1,010304ffffffff@i3:1,Real power L1-N,W,Real_power_L1-N,2 1,010304ffffffff@i4:1,Real power L2-N,W,Real_power_L2-N,2 1,010304ffffffff@i5:1,Real power L3-N,W,Real_power_L3-N,2 1,010304ffffffff@i6:1,Real energy L3,Wh,Real_energy_L3,2 1,010304ffffffff@i7:1,Real energy L3-consumed,Wh,Real_energy_L3_consumed,2 1,010304ffffffff@i8:1,Real energy L3-delivered,Wh,Real_energy_L3_delivered,2 # JANZ C3801 (MODBus) ~ This is an example for one of the many quite similar smart meters implemented in Portugal, by EDP Distribui\u00e7\u00e3o S.A. May be valid for many more models, as stated. You should additionally configure in your user_config_override.h #define SML_MAX_VARS 10 . View script >D >B =>sensor53 r >M 1 +1,14,m,1,9600,EB,5,50,0104006C,01040079,0104007A,0104007F,01040026,01040027,01040028,0104000B,01040084 1,=hVALORES T\u00c9CNICOS 1,010404UUuuxxxx@i0:10,Tens\u00e3o,V,Voltage_P1,17 1,010404xxxxUUuu@i0:10,Corrente,A,Current_P1,17 1,010408UUuuUUuuxxxxxxxxxxxx@i1:1,Pot\u00eancia ativa,W,Power_P1,16 1,010406xxxxxxxxUUuu@i2:1000,Fator de pot\u00eancia,pu,PFactor_P1,19 1,01040aUUuuxxxx@i3:10,Frequ\u00eancia,Hz,Frequency_P1,17 1,=h&#8205; 1,=hTOTALIZADORES DE ENERGIA 1,010408UUuuUUuuxxxxxxxxxxxx@i4:1000,Vazio (1),kWh,Energy_P1_R1,17 1,010408UUuuUUuuxxxxxxxxxxxx@i5:1000,Ponta (2),kWh,Energy_P1_R2,17 1,010408UUuuUUuuxxxxxxxxxxxx@i6:1000,Cheia (3),kWh,Energy_P1_R3,17 1,=h&#8205; 1,=hESTADOS 1,010406uuxxxxxxxx@i7:1,Tarifa,,Tariff_P1,16 1,010406uuxxxxxxxx@i8:1,DCP,,DCP_P1,16 # KAIFA MB310H4BDE ~ View script D B =>sensor53 r M 1 +1,3,s,0,9600,Haus 1,77070100010800ff@1000,Zaehlerstand In,KWh,Total_in,2 1,77070100020800ff@1000,Zaehlerstand Out,KWh,Total_out,2 1,77070100100700ff@1,Leistung-akt.,W,Power_curr,0 1,77070100600100ff@#,Server-ID,,Meter_Number,0 Landis + Gyr E220 (SML) ~ For read-out of \"current power\" the advanced data set has to be enabled in user menue View script >D >B =>sensor53 r ;Set teleperiod to 20sec tper=10 >M 1 +1,3,s,0,9600,Power 1,77070100600100ff@#,Server-ID,,Meter_Number,0 1,77070100010800ff@1000,Verbrauch,kWh,Total_in,4 1,77070100100700ff@1,Leistung-akt.,W,Power_curr,0 # Landis + Gyr E320 (SML) ~ For read-out of \"Current power\" the advanced data set has to be enabled in user menue View script >D >B =>sensor53 r >M 1 +1,3,s,20,9600,E320 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,3 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,3 1,77070100100700ff@1,Current power,W,Power_in,3 1,77070100600100ff@#,Server-ID,,Meter_Number,0 # Landis + Gyr ZMB120 T213CS (OBIS) ~ This meter may need a PIN to unlock the current power usage - ask your provider. View script >D >B =>sensor53 r >M 1 +1,3,o,0,300,STROM,1,10,2F3F210D0A,063030300D0A 1,0(@1,Z\u00e4hlernummer,,Meter_number,0 1,=h=================== 1,8.0(@1,Total T1 & T2,KWh,Total,2 1,8.1(@1,T1 aktuell,KWh,Total_T1,2 1,8.2(@1,T2 aktuell,KWh,Total_T2,2 1,=h=================== 1,8.1.1(@1,T1 letzte Saison,KWh,Total_T1-1,2 1,8.2.1(@1,T2 letzte Saison,KWh,Total_T2-1,2 1,8.1.2(@1,T1 vorletzte Saison,KWh,Total_T1-2,2 1,8.2.2(@1,T2 vorletzte Saison,KWh,Total_T2-2,2 # Landis + Gyr ZMR120AReS2R2sfCS (OBIS) ~ Example: Changing the baud rate during operation. View script >D ;Var Power consumption total HT+NT v1=0 ;HT Main electricity tariff consumption total v2=0 ;NT Night electricity tariff consumption total v3=0 ; Energie L1+L2+L3 v4=0 ;recent Energie L1 v5=0 ;recent Energie L2 v6=0 ;recent Energie L3 v7=0 ;Var minute min=0 ;Var hour hr=0 ;Var begin of the month 01.xx.20xx 0:00 Uhr md=0 ;Var begin of the year 01.01. 0:00 Uhr yr=0 ;Var for counter see >F=ms scnt=0 ;Var for baudrate changeing res=0 ;Permanent Var Meter1 0:00 p:sm=0 p:HT_sm=0 p:NT_sm=0 ;Var for daily =0 sd=0 HT_sd=0 NT_sd=0 ;Permanent Var for month begin p:sma=0 p:HT_sma=0 p:NT_sma=0 ;Var for monthly =0 smn=0 HT_smn=0 NT_smn=0 ;Permanent Var for year begin p:sya=0 p:HT_sya=0 p:NT_sya=0 ;Var for yearly =0 syn=0 HT_syn=0 NT_syn=0 ;Fill vars with content on teleperiod >T v1=#Total_in v2=#HT_Total_in v3=#NT_Total_in v4=#kW_L1+L2+L3 v5=#kw_L1 v6=#kw_L2 v7=#kw_L3 >B ;Restart driver ->sensor53 r ;Set teleperiod to 20sec tper=20 >F ; count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1800ms later \\> Ack and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") ;2000ms later \\> Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) ;Restart sequence after 50x100ms case 50 ; 5000ms later \\> restart sequence scnt=0 ends >S ;daily usage hr=hours if chg[hr]>0 and hr==0 and v1>0 then sm=v1 HT_sm=v2 NT_sm=v3 svars endif if upsecs%tper==0{ sd=v1-sm HT_sd=v2-HT_sm NT_sd=v3-NT_sm } ;Monthly usage md=day if chg[md]>0 and md==1 and v1>0 then sma=v1 HT_sma=v2 NT_sma=v3 svars endif if upsecs%tper==0{ smn=v1-sma HT_smn=v2-HT_sma NT_smn=v3-NT_sma } ;Yearly usage yr=year if chg[yr]>0 and v1>0 then sya=v1 HT_sya=v2 NT_sya=v3 svars endif if upsecs%tper==0{ syn=v1-sya HT_syn=v2-HT_sya NT_syn=v3-NT_sya ; Json payload \\> send on teleperiod >J ,\"Strom_Vb_Tag\":%3sd% ,\"HT_Strom_Vb_Tag\":%3HT_sd% ,\"NT_Strom_Vb_Tag\":%3NT_sd% ,\"Strom_Vb_M\":%1smn% ,\"HT_Strom_Vb_M\":%1HT_smn% ,\"NT_Strom_Vb_M\":%1NT_smn% ,\"Strom_Vb_Jahr\":%0syn% ,\"HT_Strom_Vb_Jahr\":%0HT_syn% ,\"NT_Strom_Vb_Jahr\":%0NT_syn% ,\"Strom_0:00 _Uhr\":%1sm% ,\"HT_Strom_0:00 _Uhr\":%1HT_sm% ,\"NT_Strom_0:00 _Uhr\":%1NT_sm% ,\"Strom_Ma\":%3sma% ,\"HT_Strom_Ma\":%3HT_sma% ,\"NT_Strom_Ma\":%3NT_sma% ,\"Strom_Ja\":%3sya% ,\"HT_Strom_Ja\":%3HT_sya% ,\"NT_Strom_Ja\":%3NT_sya% ;Webdisplay stuff >W 0:00 Uhr \u03a3 HT+NT: {m} %0sm% KWh HT: {m} %0HT_sm% KWh NT: {m} %0NT_sm% KWh Monatsanfang: {m} %1sma% KWh HT: {m} %1HT_sma% KWh NT: {m} %1NT_sma% KWh Jahresanfang: {m} %0sya% KWh HT: {m} %0HT_sya% KWh NT: {m} %0NT_sya% KWh ............................. Tagesverbrauch: {m} %1sd% KWh HT: {m} %1HT_sd% KWh NT: {m} %1NT_sd% KWh Monatsverbrauch: {m} %0smn% KWh HT: {m} %0HT_smn% KWh NT: {m} %0NT_smn% KWh - Jahresverbrauch: {m} %0syn% KWh HT: {m} %0HT_syn% KWh 0:00 Uhr \u03a3 HT+NT: {m} %0sm% KWh HT: {m} %0HT_sm% KWh NT: {m} %0NT_sm% KWh Monatsanfang: {m} %1sma% KWh HT: {m} %1HT_sma% KWh NT: {m} %1NT_sma% KWh Jahresanfang: {m} %0sya% KWh HT: {m} %0HT_sya% KWh NT: {m} %0NT_sya% KWh ............................. Tagesverbrauch: {m} %1sd% KWh HT: {m} %1HT_sd% KWh NT: {m} %1NT_sd% KWh Monatsverbrauch: {m} %0smn% KWh HT: {m} %0HT_smn% KWh NT: {m} %0NT_smn% KWh - Jahresverbrauch: {m} %0syn% KWh HT: {m} %0HT_syn% KWh NT: {m} %0NT_syn% KWhNT: {m} %0NT_syn% KWh >M 1 +1,3,o,0,9600,,1 1,0.0.1(@1,Z\u00e4hlernummer,,Meter_number,0 1,0.9.1(@#),Zeitstempel,Uhr,time-stamp,0 1,=h=================== 1,1.8.0(@1,HT+NT Z\u00e4hlerstand,KWh,Total_in,3 1,1.8.1(@1,HT,KWh,HT_Total_in,3 1,1.8.2(@1,NT,KWh,NT_Total_in,3 1,=h=================== 1,36.7.0(@1,Power_L1,kW,kW_L1,2 1,56.7.0(@1,Power_L2,kW,kW_L2,2 1,76.7.0(@1,Power_L3,kW,kW_L3,2 1,16.7.0(@1,\u03a3_L1+L2+L3,kW,kW_L1+L2+L3,2 1,=h=================== 1,31.7.0(@1,Strom_L1,A,I_L1,2 1,51.7.0(@1,Strom_L2,A,I_L2,2 1,71.7.0(@1,Strom_L3,A,I_L3,2 # Logarex LK13BE (OBIS) ~ View script >D >B =>sensor53 r >M 1 +1,3,o,0,9600,LK13BE,13,30,2F3F210D0A,063035310D0A 1,1-0:1.8.0*255(@1,Gesamtverbrauch,KWh,total,4 1,1-0:1.8.0*96(@1,Verbrauch 1 Tag,KWh,total_1d,4 1,1-0:1.8.0*97(@1,Verbrauch 7 Tage,KWh,total_7d,4 1,1-0:1.8.0*98(@1,Verbrauch 30 Tage,KWh,total_30d,4 1,1-0:1.8.0*99(@1,Verbrauch 365 Tage,KWh,total_365d,4 1,1-0:16.7.0*255(@1,Verbrauch aktuell,W,current,20 # Logarex LK13BE (SML) (e.g. LK13BE6067x9) ~ View script ``` D B ->sensor53 r M 1 +1,3,s,0,9600,LK13BE,1,10,2F3F210D0A,063035310D0A 1,77070100010800ff@1000,Gesamt kWh bezogen,kWh,Power_total_in,1 1,77070100020800ff@1000,Gesamt kWh geliefert,kWh,Power_total_out,1 1,77070100100700ff@1,Verbrauch aktuell,W,Power_curr,0 1,77070100240700ff@1,Power L1,W,Power_L1_curr,0 1,77070100380700ff@1,Power L2,W,Power_L2_curr,0 1,770701004C0700ff@1,Power L3,W,Power_L3_curr,0 1,77070100200700ff@1,Voltage L1,V,Volt_L1_curr,1 1,77070100340700ff@1,Voltage L2,V,Volt_L2_curr,1 1,77070100480700ff@1,Voltage L3,V,Volt_L3_curr,1 1,770701001f0700ff@1,Amperage L1,A,Amperage_L1_curr,2 1,77070100330700ff@1,Amperage L2,A,Amperage_L2_curr,2 1,77070100470700ff@1,Amperage L3,A,Amperage_L3_curr,2 1,770701000e0700ff@1,Frequency,Hz,HZ,2 1,77070100510704ff@1,Phaseangle I-L1/U-L1,deg,phase_angle_p1,1 1,7707010051070fff@1,Phaseangle I-L2/I-L2,deg,phase_angle_p2,1 1,7707010051071aff@1,Phaseangle I-L3/I-L3,deg,phase_angle_p3,1 1,77070100510701ff@1,Phase angle U-L2/U-L1,deg,phase_angle_l2_l1,1 1,77070100510702ff@1,Phase angle U-L3/U-L1,deg,phase_angle_l3_l1,1 # ``` Norax 3D+ (SML) ~ This script gives also the wattage per phase. Make sure to get the PIN from your grid operator! Tested on a WeMos D1 mini with an IR Head from https://agalakhov.github.io/ir-interface connected to the RX pin (3). The meter also outputs the phase angles, but i left them out since i do not need them. You can easily find additional values by activating the debug mode (\"sensor53 d1\" for the first meter, switch off after a few seconds with \"sensor53 d0\"). View script >D >B ->sensor53 r >M 1 +1,3,s,1,9600,SML 1,77070100010800ff@1000,Total consumption,KWh,Total_in,4 1,77070100020800ff@1000,Total Feed,KWh,Total_out,4 1,77070100100700ff@1,Current consumption,W,Power_curr,0 1,77070100200700ff@1,Voltage L1,V,Volt_p1,1 1,77070100340700ff@1,Voltage L2,V,Volt_p2,1 1,77070100480700ff@1,Voltage L3,V,Volt_p3,1 1,770701001f0700ff@1,Amperage L1,A,Amperage_p1,1 1,77070100330700ff@1,Amperage L2,A,Amperage_p2,1 1,77070100470700ff@1,Amperage L3,A,Amperage_p3,1 1,77070100240700ff@1,Current consumption L1,W,Power_curr_p1,0 1,77070100380700ff@1,Current consumption L2,W,Power_curr_p2,0 1,770701004c0700ff@1,Current consumption L3,W,Power_curr_p3,0 1,770701000e0700ff@1,Frequency,Hz,frequency,0 # Peacefair PZEM004TV30 (MODBUS) ~ PZEM004T V30 multiple meters on Modbus View script >D >B ->sensor53 r >M 1 +1,3,m,0,9600,ENERGY,1,1,02040000,02040001,02040003,02040005,02040007,02040008,03040000,03040001,03040003,03040005,03040007,03040008,05040000,05040001,05040003,05040005,05040007,05040008 1,=h<hr/>Sensor-1 1,020404UUuuxxxxxxxx@i0:10,Voltage,V,Sensor-1-V,2 1,020404UUuuUUuusxxxx@i1:1000,Current,A,Sensor-1-A,2 1,020404UUuuUUuusxxxx@i2:10,Power,W,Sensor-1-W,2 1,020404UUuuUUuusxxxx@i3:1000,Energy,kWh,Sensor-1-kWh,4 1,020404UUuuxxxxxxxx@i4:10,Frequency,Hz,Sensor-1-hz,2 1,020404UUuuxxxxxxxx@i5:100,Power Factor,PF,Sensor-1-PF,2 1,=h<hr/>Sensor-2 1,030404UUuuxxxxxxxx@i6:10,Voltage,V,Sensor-2-V,2 1,030404UUuuUUuusxxxx@i7:1000,Current,A,Sensor-2-A,2 1,030404UUuuUUuusxxxx@i8:10,Power,W,Sensor-2-W,2 1,030404UUuuUUuusxxxx@i9:1000,Energy,kWh,Sensor-2-kWh,4 1,030404UUuuxxxxxxxx@i10:10,Frequency,Hz,Sensor-2-hz,2 1,030404UUuuxxxxxxxx@i11:100,Power Factor,PF,Sensor-2-PF,2 1,=h<hr/>Sensor-5 1,050404UUuuxxxxxxxx@i12:10,Voltage,V,Sensor-05-V,2 1,050404UUuuUUuusxxxx@i13:1000,Current,A,Sensor-05-A,2 1,050404UUuuUUuusxxxx@i14:10,Power,W,Sensor-05-W,2 1,050404UUuuUUuusxxxx@i15:1000,Energy,kWh,Sensor-05-kWh,4 1,050404UUuuxxxxxxxx@i16:10,Frequency,Hz,Sensor-05-hz,2 1,050404UUuuxxxxxxxx@i17:100,Power Factor,PF,Sensor-05-PF,2 # Resol Deltasol BS Plus (VBus) ~ This is a controller for standard solar thermal systems equipped with VBus data interface. Outputs data every second at 9600 baud 8N1. To connect to this and read data from the bus a level shifting is needed as the voltage is around 8V. Although this is a symmetric connection supporting long wires for our purposes it's enough to measure its polarity with a voltmeter and adapt the level appropriately to 3.3V using the below circuit (many others exist but this is simple and works). Do not connect the GND pin of Wemos with the ground of Resol unit as that may damage the output port of it. The Wemos module needs its own power supply (double insulated recommended). The script (compile firmware with SML_REPLACE_VARS ) >D r=\"1,AA100021421000010774\" >B =>sensor53 r >M 1 +1,3,v,0,9600,Solar %r%vo12ut@#,time,,zeit,1 %r%vo0sw@10,S1 COL,\u00b0C,sens1,1 %r%vo2sw@10,S2 TST1,\u00b0C,sens2,1 %r%vo4sw@10,S3 TST2,\u00b0C,sens3,1 %r%vo6sw@10,S4 TR,\u00b0C,sens4,1 %r%vo10ub@b0:1,R1 PUMP,,relay1,0 %r%vo10ub@b1:1,R2 VALVE,,relay2,0 %r%vo8ub@1,Pump1 speed,%%,pump1,0 %r%vo9ub@1,Pump2 speed,%%,pump2,0 %r%vo20uw@1,p1,Wh,p1,0 %r%vo22uw@1,p1000,Wh,p2,0 %r%vo24uw@1,p1000000,Wh,p3,0 %r%vo15ub@b0:1,Col Max,,col1,0 %r%vo15ub@b1:1,Col Min,,col2,0 %r%vo15ub@b2:1,Col Frost,,col3,0 %r%vo15ub@b3:1,Col Opt,,col4,0 %r%vo15ub@b4:1,Col Rueck,,col5,0 %r%vo15ub@b5:1,Col WMZ,,col6,0 # Sanxing SX6x1 (SxxU1x) (Ascii OBIS) ~ Tested on SX631 (S34U18). Needs an RJ12 cable and a small adaptor circuit: (Note how power for the Wemos module is drawn directly from the meter. No external power supply needed) This meter sends bursts of data at 115200 baud every 10 seconds. Some data lines exceed 1038 characters. To adapt to these conditions, compile firmware with: #define SML_MAX_VARS 60 #define SML_BSIZ 1060 #define MAX_METERS 1 #define TMSBSIZ 2048 #define USE_SML_SCRIPT_CMD #define SML_REPLACE_VARS View script >D r=\"1,0-0:98.1.0(@(\" ;use a variable to store the decode string >B smlj=0 ;don't send teleperiod MQTT at boot, because we can have 0 values (meter didn't send data yet) ->sensor53 r >R smlj=0 ;don't send teleperiod MQTT at script restart, because we can have 0 values (meter didn't send data yet) >S if upsecs>22 then smlj=1 endif ;only send teleperiod MQTT if 22 seconds passed since boot (during this time meter most probably sent data) >M 1 +1,3,o,16,115200,Name,1 1,1-0:32.7.0(@1,L1 Voltage,V,volts_l1,1 1,1-0:52.7.0(@1,L2 Voltage,V,volts_l2,1 1,1-0:72.7.0(@1,L3 Voltage,V,volts_l3,1 1,1-0:14.7.0(@1,Frequency,Hz,freq,2 1,0-0:96.14.0(@1,Current tariff,,tariff,0 1,=h<hr/> 1,1-0:1.8.0(@1,Energy import,kWh,enrg_imp,3 1,1-0:2.8.0(@1,Energy export,kWh,enrg_exp,3 1,1-0:1.8.1(@1,Energy import T1,kWh,enrg_imp_t1,3 1,1-0:1.8.2(@1,Energy import T2,kWh,enrg_imp_t2,3 1,1-0:2.8.1(@1,Energy export T1,kWh,enrg_exp_t1,3 1,1-0:2.8.2(@1,Energy export T2,kWh,enrg_exp_t2,3 1,1-0:1.7.0(@1,Power import,kW,pwr_imp,3 1,1-0:2.7.0(@1,Power export,kW,pwr_exp,3 1,1-0:13.7.0(@1,Power factor,,factor,3 1,=h<hr/> 1,1-0:3.8.0(@1,Reactive nrg import,kvarh,nrg_reac_imp,3 1,1-0:4.8.0(@1,Reactive nrg export,kvarh,nrg_reac_exp,3 1,1-0:5.8.0(@1,Reactive energy QI,kvarh,nrg_reac_q1,3 1,1-0:6.8.0(@1,Reactive energy QII,kvarh,nrg_reac_q2,3 1,1-0:7.8.0(@1,Reactive energy QIII,kvarh,nrg_reac_q3,3 1,1-0:8.8.0(@1,Reactive energy QIV,kvarh,nrg_reac_q4,3 1,1-0:5.7.0(@1,Reactive power QI,kvar,pwr_reac_q1,3 1,1-0:6.7.0(@1,Reactive power QII,kvar,pwr_reac_q2,3 1,1-0:7.7.0(@1,Reactive power QIII,kvar,pwr_reac_q3,3 1,1-0:8.7.0(@1,Reactive power QIV,kvar,pwr_reac_q4,3 1,=h<hr/> 1,=hPrevious month stats: %r%1:1,Energy import,kWh,mo_enrg_imp,3 %r%2:1,Energy import T1,kWh,mo_enrg_impt1,3 %r%3:1,Energy import T2,kWh,mo_enrg_impt2,3 %r%4:1,Energy export,kWh,mo_enrg_exp,3 %r%5:1,Energy export T1,kWh,mo_enrg_expt1,3 %r%6:1,Energy export T2,kWh,mo_enrg_expt2,3 %r%7:1,Reactive nrg import,kvarh,mo_nrg_reac_imp,3 %r%8:1,Reactive nrg export,kvarh,mo_nrg_reac_exp,3 %r%9:1,Reactive energy QI,kvarh,mo_nrg_reac_q1,3 %r%10:1,Reactive energy QII,kvarh,mo_nrg_reac_q2,3 %r%11:1,Reactive energy QIII,kvarh,mo_nrg_reac_q3,3 %r%12:1,Reactive energy QIV,kvarh,mo_nrg_reac_q4,3 %r%13:1,Reactive energy SUM?,kvarh,mo_nrg_reac_sum,3 %r%14:1,Peak power import L1,kW,mo_pw_pk_in_l1,3 %r%15:1,Peak power import L2,kW,mo_pw_pk_in_l2,3 %r%16:1,Peak power import L3,kW,mo_pw_pk_in_l3,3 %r%17:1,Peak power export L1,kW,mo_pw_pk_ex_l1,3 %r%18:1,Peak power export L2,kW,mo_pw_pk_ex_l2,3 %r%19:1,Peak power export L3,kW,mo_pw_pk_ex_l3,3 # Sample data /1234567890123 0-0:1.0.0(202056789012W) 0-0:42.0.0(AUX1234567890123) 0-0:96.1.0(1234567890) 0-0:96.14.0(0001) 0-0:96.50.68(ON) 0-0:17.0.0(90.000*kW) 1-0:1.8.0(000258.072*kWh) 1-0:1.8.1(000103.782*kWh) 1-0:1.8.2(000154.290*kWh) 1-0:1.8.3(000000.000*kWh) 1-0:1.8.4(000000.000*kWh) 1-0:2.8.0(000048.367*kWh) 1-0:2.8.1(000032.813*kWh) 1-0:2.8.2(000015.554*kWh) 1-0:2.8.3(000000.000*kWh) 1-0:2.8.4(000000.000*kWh) 1-0:3.8.0(000003.513*kvarh) 1-0:4.8.0(000156.910*kvarh) 1-0:5.8.0(000003.498*kvarh) 1-0:6.8.0(000000.015*kvarh) 1-0:7.8.0(000027.718*kvarh) 1-0:8.8.0(000129.192*kvarh) 1-0:15.8.0(000306.440*kWh) 1-0:32.7.0(233.0*V) 1-0:52.7.0(230.6*V) 1-0:72.7.0(228.7*V) 1-0:31.7.0(002*A) 1-0:51.7.0(002*A) 1-0:71.7.0(001*A) 1-0:13.7.0(0.758) 1-0:33.7.0(0.615) 1-0:53.7.0(0.746) 1-0:73.7.0(0.937) 1-0:14.7.0(49.98*Hz) 1-0:1.7.0(00.000*kW) 1-0:2.7.0(00.854*kW) 1-0:5.7.0(00.000*kvar) 1-0:6.7.0(00.000*kvar) 1-0:7.7.0(00.735*kvar) 1-0:8.7.0(00.000*kvar) 0-0:98.1.0(210301000000W)(000249.070*kWh)(000100.816*kWh)(000148.254*kWh)(000047.903*kWh)(000032.349*kWh)(000015.554*kWh)(000003.513*kvarh)(000150.665*kvarh)(000003.498*kvarh)(000000.015*kvarh)(000027.119*kvarh)(000123.546*kvarh)(000296.974*kWh)(04.872*kW)(04.872*kW)(04.072*kW)(01.844*kW)(01.672*kW)(01.844*kW) 0-0:96.13.0(\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd) !DA6A SBC ALE3 (MODBus) ~ View script >DH >B ->sensor53 r >M 1 +1,3,M,1,9600,SBC,1,1,02030023,02030028,0203002d,02030025,0203002a,0203002f,02030032,02030027,0203002c,02030031,02030021,02030015,02030018 1,020304UUuu@i0:1,Spannung L1,V,Voltage_L1,0 1,020304UUuu@i1:1,Spannung L2,V,Voltage_L2,0 1,020304UUuu@i2:1,Spannung L3,V,Voltage_L3,0 1,020304xxxxUUuu@i0:10,Strom L1,A,Current_L1,2 1,020304xxxxUUuu@i1:10,Strom L2,A,Current_L2,2 1,020304xxxxUUuu@i2:10,Strom L3,A,Current_L3,2 1,=h= 1,020304UUuu@i3:100,Leistung L1,kW,Power_L1,3 1,020304UUuu@i4:100,Leistung L2,kW,Power_L2,3 1,020304UUuu@i5:100,Leistung L3,kW,Power_L3,3 1,020304UUuu@i6:100,Leistung Total,kW,Power_Total,3 1,020304xxxxSSss@i3:100,BlindLeistung L1,kVAr,ReaktivePower_L1,3 1,020304xxxxSSss@i4:100,BlindLeistung L2,kVAr,ReaktivePower_L2,3 1,020304xxxxSSss@i5:100,BlindLeistung L3,kVAr,ReaktivePower_L3,3 1,020304xxxxSSss@i6:100,BLeistung Total,kVAr,ReaktivePower_Total,3 1,=h= 1,020304UUuu@i7:100,CosPhi L1,,CosPhi_L1,2 1,020304UUuu@i8:100,CosPhi L2,,CosPhi_L2,2 1,020304UUuu@i9:100,CosPhi L3,,CosPhi_L3,2 1,=h= 1,020304UUuuUUuu@i10:100,T2 Wert,kWh,T2_Value,2 # SBC ALE3 2x (MODBus) ~ View script >D >B ->sensor53 r >M 1 +1,3,M,1,9600,Meter,1,1,01030023,01030028,0103002d,01030025,0103002a,0103002f,01030032,01030027,0103002c,01030031,0103001B,0103001d,03030023,03030028,0303002d,03030025,0303002a,0303002f,03030032,03030027,0303002c,03030031,0303001B,0303001d 1,=h Domestic Electricity: 1,010304UUuuUUuu@i10:100,1 Tariff 1 total,kWh,M1_T1_total,2 1,010304UUuuUUuu@i11:100,1 Tariff 1 partial,kWh,M1_T1_par,2 1,=h Readings: 1,010304UUuu@i0:1,1 Voltage L1,V,M1_Voltage_L1,0 1,010304UUuu@i1:1,1 Voltage L2,V,M1_Voltage_L2,0 1,010304UUuu@i2:1,1 Voltage L3,V,M1_Voltage_L3,0 1,010304xxxxUUuu@i0:10,1 Current L1,A,M1_Current_L1,2 1,010304xxxxUUuu@i1:10,1 Current L2,A,M1_Current_L2,2 1,010304xxxxUUuu@i2:10,1 Current L3,A,M1_Current_L3,2 1,010304UUuu@i3:100,1 Active Power L1,kW,M1_PRMS_L1,3 1,010304UUuu@i4:100,1 Active Power L2,kW,M1_PRMS_L2,3 1,010304UUuu@i5:100,1 Active Power L3,kW,M1_PRMS_L3,3 1,010304UUuu@i6:100,1 Active Power total,kW,M1_PRMS_total,3 1,010304xxxxSSss@i3:100,1 Reactive Power L1,kVAr,M1_QRMS_L1,3 1,010304xxxxSSss@i4:100,1 Reactive Power L2,kVAr,M1_QRMS_L2,3 1,010304xxxxSSss@i5:100,1 Reactive Power L3,kVAr,M1_QRMS_L3,3 1,010304xxxxSSss@i6:100,1 Reactive Power total,kVAr,M1_QRMS_total,3 1,010304UUuu@i7:100,1 CosPhi L1,,M1_CosPhi_L1,2 1,010304UUuu@i8:100,1 CosPhi L2,,M1_CosPhi_L2,2 1,010304UUuu@i9:100,1 CosPhi L3,,M1_CosPhi_L3,2 1,=h________________________________________________ ; meter 2 +12 offset 1,=h Heat Pump 1,030304UUuuUUuu@i22:100,2 Tariff 1 total,kWh,M2_T1_total,2 1,030304UUuuUUuu@i23:100,2 Tariff 1 partial,kWh,M2_T1_par,2 1,=h Readings: 1,030304UUuu@i12:1,2 Voltage L1,V,M2_Voltage_L1,0 1,030304UUuu@i13:1,2 Voltage L2,V,M2_Voltage_L2,0 1,030304UUuu@i14:1,2 Voltage L3,V,M2_Voltage_L3,0 1,030304xxxxUUuu@i12:10,2 Current L1,A,M2_Current_L1,2 1,030304xxxxUUuu@i13:10,2 Current L2,A,M2_Current_L2,2 1,030304xxxxUUuu@i14:10,2 Current L3,A,M2_Current_L3,2 1,030304UUuu@i15:100,2 Active Power L1,kW,M2_PRMS_L1,3 1,030304UUuu@i16:100,2 Active Power L2,kW,M2_PRMS_L2,3 1,030304UUuu@i17:100,2 Active Power L3,kW,M2_PRMS_L3,3 1,030304UUuu@i18:100,2 Active Power total,kW,M2_PRMS_total,3 1,030304xxxxSSss@i15:100,2 Reactive Power L1,kVAr,M2_QRMS_L1,3 1,030304xxxxSSss@i16:100,2 Reactive Power L2,kVAr,M2_QRMS_L2,3 1,030304xxxxSSss@i16:100,2 Reactive Power L3,kVAr,M2_QRMS_L3,3 1,030304xxxxSSss@i18:100,2 Reactive Power total,kVAr,M2_QRMS_total,3 1,030304UUuu@i19:100,2 CosPhi L1,,M2_CosPhi_L1,2 1,030304UUuu@i20:100,2 CosPhi L2,,M2_CosPhi_L2,2 1,030304UUuu@i21:100,2 CosPhi L3,,M2_CosPhi_L3,2 # SDM230 (MODBus) ~ View script >D ms=\"1,010404ffffffff@\" >B ->sensor53 r >M 1 +1,3,m,0,9600,PV,1,2,01040000,01040006,0104000C,01040012,01040018,0104001E,01040024,01040046,01040048,0104004A,0104004C,0104004E,01040054,01040056,01040058,0104005A,0104005C,0104005E,01040102,01040108,01040152,01040158,01040180,01040182 %ms%i0:1,Volt,V,Volt,2 %ms%i1:1,Strom P1,A,Strom,3 %ms%i2:1,*,W,Leistung,2 %ms%i3:1,Scheinleistung,VA,ScheinLeistung,2 %ms%i4:1,Blindleistung,VAr,Blindleistung,2 %ms%i5:1,P-Faktor,,P_Faktor,1 %ms%i6:1,cosPhi,\u00b0,cosPhi,2 %ms%i7:1,Frequenz,Hz, Frequenz,1 %ms%i8:1,Wirkleistung Import,kWh,Wirkleistung_Im1,3 %ms%i9:1,Wirkleistung Export,kWh,Wirkleistung_Ex,3 %ms%i10:1,Blindleistung Import,VkkVARh,Blindleistung_Im,3 %ms%i11:1,Blindleistung Export,VkkVARh,Blindleistung_Ex,3 %ms%i12:1,Gesamtleistungsbedarf,W,GesLeistBed,2 %ms%i13:1,GesamtLeistung Max,W,GesLeistMax,2 %ms%i14:1,Akt.Nachfrage,W,AktNachfrage,2 %ms%i15:1,R\u00fcckleistungs Bed,W,RueckLeistBed,2 %ms%i16:1,R\u00fcckleistungs Bed Max,W,RueckLeistBedMax,2 %ms%i17:1,Strom Nachfrage,A,StromNachfrage2,2 %ms%i19:1,Max Strombedarf,A,StromBedMax,2 %ms%i20:1,Wirkleistung Gesamt,kWh,Wirkleistung_total,2 %ms%i21:1,Blindleistung Gesamt,kVARh,Blindleistung_total,2 %ms%i22:1,Temp Gesamtleistung,kWh,TempGesamtLeist,2 # SDM530 (MODBus) ~ View script >D >B ->sensor53 r >M 1 +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 1,010404ffffffff@i0:1,Voltage P1,V,Voltage_P1,2 1,010404ffffffff@i1:1,Voltage P2,V,Voltage_P2,2 1,010404ffffffff@i2:1,Voltage P3,V,Voltage_P3,2 1,010404ffffffff@i3:1,Current P1,A,Current_P1,2 1,010404ffffffff@i4:1,Current P2,A,Current_P2,2 1,010404ffffffff@i5:1,Current P3,A,Current_P3,2 1,010404ffffffff@i6:1,Active Power P1,W,Power_P1,2 1,010404ffffffff@i7:1,Active Power P2,W,Power_P2,2 1,010404ffffffff@i8:1,Active Power P3,W,Power_P3,2 # Trovis 557x (MODBus) ~ These heating regulators have a lot of registers . View script >D >B ->sensor53 r >M 1 +1,3,m,0,19200,Trovis,1,2,rF7030009000E,rF703001C0004,F703006A 1,F7031CSSss@i0:10,Au\u00dfentemp.,\u00b0C,Temp_Outside,1 1,F7031CxxxxxxxxxxxxSSss@i0:10,Vorlauftemp.,\u00b0C,Temp_Flow,1 1,F7031CxxxxxxxxxxxxxxxxxxxxxxxxxxxxSSss@i0:10,R\u00fccklauftemp.,\u00b0C,Temp_Return,1 1,F7031CxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxSSss@i0:10,Speichertemp.,\u00b0C,Temp_Vessel,1 1,F70308UUuu@i1:1,MesswertImp-h,imp/h,Metric_ImpH,0 1,F70308xxxxUUuu@i1:100,Messwertm3-h,m\u00b3/h,Metric_M3H,2 1,F70308xxxxxxxxUUuu@i1:10,AA10-10V,V,Metric_AA10,1 1,F70308xxxxxxxxxxxxUUuu@i1:10,AA20-10V,V,Metric_AA20,1 1,F70304UUuu@i2:1,StellsignalRk1,%,CtrlSig_RK1,0 # WOLF CSZ 11/300 Heater (EBus) ~ View script >D >B ->sensor53 r >M 1 +1,3,e,0,2400,EBUS 1,xxxx0503xxxxxxxxxxxxxxxxss@1,Outside temperature,C,Outsidetemp,0 1,xxxx5014xxxxxxxxxxuu@1,Romm temperature,C,Roomtemp,0 1,xxxx0503xxxxxxxxxxxxxxuu@1,Warmwater,C,Warmwater,0 1,xxxx0503xxxxxxxxxxuu@1,Boiler,C,Boiler,0 1,03fe0503xxxxxxxxxxxxuu@1,Returns,C,Returns,0 1,03fe0503xxxxuu@1,Status,,Status,0 1,03fe0503xxxxxxuu@b3:1,Burner on,,Burner,0 1,xxxx5017xxxxxxuuuu@16,Solar collektor,C,Collector,1 1,xxxx5017xxxxxxxxxxuuuu@16,Solar storage,C,Solarstorage,1 1,xxxx5017xxuu@b0:1,Solar pump on,,Solarpump,0 #","title":"Smart Meter Interface"},{"location":"Smart-Meter-Interface/#smart-meter-interface","text":"This driver extracts selected values from Smart Meters over various protocols, filters and publishes them to MQTT as regular sensors. This feature is not included in precompiled binaries Based on Tasmota's scripting language . To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_SCRIPT #define USE_SCRIPT #endif #ifndef USE_SML_M #define USE_SML_M #endif #ifdef USE_RULES #undef USE_RULES #endif Additional features can be enabled by adding the following #define compiler directive parameters and then compiling the firmware. These parameters are explained further below in the article. Feature Description SML_MAX_VARS n (default 20) Maximum number of decode lines (html lines not counted). SML_BSIZ n (default 48) Maximum number of characters per line in serial input buffer. Complete chunk of serial data must fit into this size, so include any CR/LF if that applies. MAX_METERS n (default 5) Maximum number of meters. Decrease this to 1 for example if you have a meter with many lines and lots of characters per descriptor line. TMSBSIZ n (default 256) Maximum number of characters in serial IRQ buffer (should always be larger than SML_BSIZ and even larger on high baud rates). SML_DUMP_SIZE n (default 128) Maximum number of characters per line in dump mode. Only use if you have long strings comin in and they truncate. USE_ESP32_SW_SERIAL enables additional software serial channels for ESP32, (receive only), define pin with '-' sign to assign to software serial USE_SML_SPECOPT enables special decoder entry to specify direction bit for some SML meters USE_SML_SCRIPT_CMD If present, this enables some special SML script cmds and allows access to sml vars in other parts of the script. Is needed by some of the examples below. SML_REPLACE_VARS If present, this allows replacement of any text in descriptor by script text variables. Useful if several occurrences of a text occupies a lot of space and you get short of script buffer. Readability may get worse so only makes sense on large descriptors. Note: to use % symbol un measurement units, you need to escape it like %% .","title":"Smart Meter Interface"},{"location":"Smart-Meter-Interface/#general-description","text":"To use this interface, connect the meter to available GPIO pins. These GPIOs must be set as None in Tasmota. If the interface detects that a script driven meter descriptor GPIO conflicts with a Tasmota GPIO setting, the interface will generate a duplicate GPIO defined error in the log and the meter descriptor will be ignored. Note When changing GPIO configurations, especially in conjunction with other Tasmota drivers, a restart may be required. Note On an ESP32, due to a different implementation, serial ports may not be used in conjunction with other Tasmota serial devices. Note when using bidirectional serial IO (receive and transmit), hardware serial is recommended. The Smart Meter Interface provides a means to connect many kinds of meters to Tasmota. The following types of meter protocols are supported: Protocol Description OBIS ASCII telegrams emitted from many smart meters, including P1 Smart Meters OBIS Binary SML telegrams emitted from many smart meters MODBus Binary telegrams used by many power meters and industrial devices EBus Binary telegrams emitted by many heaters and heat pumps (e.g. Vaillant, Wolf) VBus Binary telegrams emitted by many solar thermal systems boilers (e.g. Resol, Viessmann) RAW Binary decodes all kinds of binary data eg EMS heater bus Counter interface uses Tasmota counter storage (for e.g. REED contacts either in polling or IRQ mode) There are many different meters that use the same protocol. There are multitudes of variants and use cases. This interface provides a means of specifying these definitions through meter descriptors . This method uses the scripting language editor to define the descriptors. In this way, only one firmware binary version is required and a modification can be made easily on the fly . A meter can also be defined by using compilation time #define pragmas (deprecated). This requires recompiling the firmware to make modifications. Note Additional hardware may be required to read certain measuring devices. For example: RS485toTTL adapter for Modbus, IR transistor for electricity meters. Sometimes an additional IR diode and resistors.","title":"General description"},{"location":"Smart-Meter-Interface/#descriptor-syntax","text":"This section must be present, even if it's empty. If compiled with SML_REPLACE_VARS , here is the place where text variables can be defined for the script: >D Declare >B (boot) section to inform the interface to read the meter descriptor(s): >B => sensor53 r (Optional) declare >S section with additional scripting commands: >S <n> Declare >M section with the number of connected meters (n = 1..5 ): >M <n> Note If no >M section is found in the script or if the scripting language is not compiled, the driver reverts to the default hardcoded #define definitions. If no meter script is defined, the default hardcoded descriptor interface (deprecated) uses RX GPIO3 for receiving data and thus may interfere with other Tasmota Definitions without warning. Note Software serial only supports 8N1 serial format. Must use hardware serial for e.g. 8E1!","title":"Descriptor Syntax"},{"location":"Smart-Meter-Interface/#meter-definition","text":"+<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} Parameter Description +<M> Meter number. The number must be increased with each additional Meter (default 1 to 5). <rxGPIO> The GPIO pin number where meter data is received. <type> The type of meter: - o - OBIS ASCII type of coding - s - SML binary smart message coding - e - EBus binary coding - v - VBus binary coding - m - MODBus binary coding with serial mode 8N1 - M - MODBus binary coding with serial mode 8E1 - c - Counter type - r - Raw binary coding (any binary telegram) <flag> Options flag: - 0 - counter without pullup - 1 - counter with pullup - 16 - enable median filter for that meter. Can help with sporadic dropouts, reading errors (not available for counters). <parameter> Parameters according to meter type: - for o,s,e,v,m,M,r types: serial baud rate e.g. 9600 . - for c type: a positive value = counter poll interval or a negative value = debounce time (milliseconds) for irq driven counters. <jsonPrefix> Prefix for Web UI and MQTT JSON payload. Up to 7 characters. <txGPIO> The GPIO pin number where meter command is transmitted (optional). <txPeriod> Period to repeat the transmission of commands to the meter (optional). Number of 100ms increments (n * 100ms). <cmdTelegram> Comma separated hex coded byte blocks to send to meter device. For MODBus each comma separated block is a command to retrieve a certain register from the meter (optional: only required for measuring devices that have to be triggered with a certain character string). Note for other serial protocols you may specify the exact mode (only for hardware serial) by the following code after the type specifier: N =no parity E =even parity O =odd parity and number of stop-bits e.g for Modbus: mN1,mN2,mE1,mE2,mO1,mO2 Example +1,3,o,0,9600,OBIS1,1,2,2F3F210D0A +1,3,o,16,115200,NormalTariff,1 +1,3,s,16,9600,SML1 +1,12,c,1,-10,H20_Cnt +1,3,v,0,9600,Solar Example For MODBus: +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 Components of the character string: ...01040000,01040002,... 01 = Modbus slave device ID 04 = Instruction to read an Input Register (alternatively, 03 = Instruction to read an Holding Register) 0000 / 0002 = Register # (as Hexadecimal codification, without the prefix 0x . Example: 0x0079 -> 0079 ) the number of requested registers is fixed to 2, however with the char 'r' before the hex string the complete request string may be specified ...r010400000001,r010400020003,... Note: ID , Instruction to read the register value (Input vs Holding) and Register# may differ depending on the measuring device.","title":"Meter Definition"},{"location":"Smart-Meter-Interface/#meter-metrics","text":"Each meter typically provides multiple metrics (energy, voltage, power, current etc.) which it measures. An entry for each metric to be collected must be specified. Up to 20 entries may be defined (unless stated differently by SML_MAX_VARS as a larger number in user_config_override.h ). An entry defines how to decode the data and put it into variables. <M>,<decoder>@<scale><offs>,<label>,<UoM>,<var>,<precision> Parameter Description <M> The meter number to which this decoder belongs <decoder> Decoding specification : OBIS as ASCII; SML, EBus, VBus, MODBus, RAW as HEX ASCII etc. No space characters allowed in this section! OBIS : ASCII OBIS code terminated with ( character which indicates the start of the meter value Counter : ASCII code 1-0:1.8.0*255 for counter value, code 1-0:1.7.0*255 for pulse rate (e.g. for actual power value) SML : SML binary OBIS as hex terminated with 0xFF indicating start of SML encoded value EBus, MODBus, RAW - hex values of data blocks to compare: - xx = ignore value (1 byte) or xN = ignore N bytes - ss = extract a signed byte - uu = extract an unsigned byte - UUuu = extract an unsigned word (high order byte first) - uuUU = extract an unsigned word (low order byte first) - UUuuUUuu = extract an unsigned long word (high order byte first) - uuUUuuUU = extract an unsigned long word (low order byte first) - SSss = extract a signed word (high order byte first) - ssSS = extract a signed word (low order byte first) - SSssSSss = extract a signed long word (high order byte first) - ssSSssSS = extract a signed long word (low order byte first) - on long word values if a trailing s is added word order is reversed - ffffffff = extract a float value - IEEE754 decode - FFffFFff = extract a reverse float value - IEEE754 decode if using VBus - hex values of data blocks to compare: - AAffffaddrff0001ffff = VBus-specific hex header: AA -sync byte, addr -the reversed address of the device. To find his out first look up the known hex address of the device . E.g. Resol DeltaSol BS Plus is 0x4221 . Reverse it (without 0x ) and you will get 21 42 hex characters. Now turn on raw dump mode using command sensor53 d1 and look for rows starting with aa , containing your reversed address at position 4 and 5 and 00 01 hex characters at position 7 and 8. If found, the entire header will be 10 hex characters long including aa (20 ascii chars without space, e.g. for Resol DeltaSol BS Plus this will be AA100021421000010774 ). At position 9 you see the number of frames containing readable data. To turn off raw dump use sensor53 d0 . - v = VBus protocol indicator - oN = extract data from offset N (see offsets of your device in VBus protocol documentation ) - u or s = extract unsigned or signed data - w or b = extract word or byte End of decoding : @ indicates termination of the decoding procedure. - ( following the @ character in case of obis decoder indicates to fetch the 2. value in brackets, not the 1. value. (e.g. to get the second value from an obis like 0-1:24.2.3(210117125004W)(01524.450*m3) ) - decoding multiple values coming in brackets after each other is possible with (@(0:1 , (@(1:1 , (@(2:1 and so on (e.g. to get values from an obis like 0-0:98.1.0(210201000000W)(000000.000*kWh)(000000.000*kWh) ) - decoding a 0/1 bit is indicated by a @ character followed by bx: (x = 0..7 ) extracting the corresponding bit from a byte. (e.g.: 1,xxxx5017xxuu@b0:1,Solarpump,,Solarpump,0 ) - in case of MODBus, ix: designates the index (x = 0..n ) referring to the requested block in the transmit section of the meter definition <scale> scaling factor (divisor) or string definition This can be a fraction (e.g., 0.1 = result * 10), or a negative value. When decoding a string result (e.g. meter serial number), use # character for this parameter (Note: only one string can be decoded per meter!) . For OBIS, you need a ) termination character after the # character. <offs> optional offset must precede with + or - sign, note: offset is applied before scale! <label> web UI label (max. 23 characters) <UoM> unit of measurement (max. 7 characters) <var> MQTT label (max. 23 characters) <precision> number of decimal places. Add 16 to transmit the data immediately. Otherwise it is transmitted on TelePeriod only. Use ; character to comment lines in the script. Put # character at the end to terminate M section of the script. Example (OBIS/SML/MODBus): 1,1-0:1.8.1*255(@1,Total consumption,KWh,Total_in,4` 1,77070100010801ff@1000,W1,kWh,w1,4` 1,010304UUuuxxxxxxxx@i0:1,Spannung L1,V,Voltage_L1,0` 1,0:98.1.0(@(0:1,Havi adat, KWh,havi1,3` 1,0:98.1.0(@(1:1,Havi adat, KWh,havi2,3` 1,0:98.1.0(@(2:1,Havi adat, KWh,havi3,3` OBIS: 1,1-0:0.0.0*255(@#),Meter Nr,, Meter_number,0 Counter: 1,1-0:1.8.0*255(@1000,consumption,KWh,Total_in,3) precision of 3, scale for 1000 pulses/kWh 1,1-0:1.7.0*255(@0.01667, power,W,Power_actual,0) actual power from pulse rate (in pulses/min) of counter meter, scale for 1 pulse/Wh (1 pulse/min => 60W; 1/60(=0.01667) (pulses/min)/W) SML: 1,77078181c78203ff@#,Service ID,,Meter_id,0 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,4 precision of 4, transmitted only on TelePeriod 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,20 precision of 4, transmitted immediately (4 + 16 = 20) MODBus: +1,3,M,1,9600,SBC,1,2,01030023,01030028... 1,010304UUuuxxxxxxxx@i0:1,Voltage L1,V,Voltage_L1,0 the i0:1 refers to: 01030023 with a scaling factor ( :1 ) for 1 1,010304UUuuxxxxxxxx@i1:10,Current L1,V,Current_L1,2 the i1:10 refers to: 01030028 with a scaling factor ( :10 ) for 10 Tip Use: sensor53 dM to output the received data in the console. M = the number of the meter in the definition line. During the output of the data in the console, the data in the WEB UI are not updated. To return write: sensor53 d0 Tip You can monitor the serial activity at a GPIO with a connected LED. This function is useful for debugging purposes and also to see data is coming in during normal operation. Usage: Enter the command sensor53 lx to activate this function (Lowercase L for LED ). x is the number of the GPIO where the LED is connected. For example you can use sensor53 l2 for the onboard LED on a Wemos D1-mini or sensor53 l13 on a Sonoff Basic. sensor53 l255 turns the function off. This is the default value. With sensor53 mx you can choose which serial meter ( x ) will be monitored. Set sensor53 m0 will monitor all serial meters. This is the default value. To start the monitoring at boot-time, simply add the necessary entries in the boot-section ( >B ) of the script: Example >B =>sensor53 r =>sensor53 l13","title":"Meter Metrics"},{"location":"Smart-Meter-Interface/#special-commands","text":"With = character at the beginning of a line you can do some special decoding. With * character fields can be hidden or skipped. Command Description M,=m Perform arithmetic ( +,-,*,/ ) on the measured data. Use # before a number to designate a constant value e.g. 1,=m 3+4+5/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 to sum results of decoder entries 3,4,5 and divide by 3 (average) M,=d Calculate difference between metric values decoded at time intervals (up to 10 =d lines possible) e.g. 1,=d 3 10 calculate 10 second interval difference of decoder entry 3 M,=h Insert text on the web interface (html text up to 30 chars). These lines do not count as decoder entry. e.g. 1,=h<hr/> to insert a separator line on the web UI * character To hide fields from result output or disable output completely. Compiling with USE_SML_SCRIPT_CMD required. - as single character in <label> of the metrics line will hide that value from the web UI - as single character in <label> of the meter definition line will suppress the entire JSON output on MQTT M,=so1 special SML option for meters that use a bit in the status register to sign import or export like ED300L, AS2020 or DTZ541 e.g. 1,=so1,00010800,65,11,65,11,00100700 for DTZ541 1. obis code that holds the direction bit, 2. Flag identifier, 3. direction bit, 4. second Flag identifier (some meters use 2 different flags), 5. second bit, 6 obis code of value to be inverted on direction bit. needs #define USE_SML_SPECOPT remark: channel math only works on frequently (fast) updated channels and is not recommended with counters Example To get the value of one of the descriptor lines, use sml[X] . X = Line number. Starts with 1 . (compiling with USE_SML_SCRIPT_CMD required) >D v1=0 v2=0 >S ;Writes the value of Descriptorline 1 to v1 v1=sml[1] ;Writes the value of Descriptorline 2 to v2 v2=sml[2] Example To disable and enable publishing of MQTT data on TelePeriod, use smlj=0 and smlj=1 , respectively. For example to skip first MQTT publishing after boot (may contain erroneous data at after restart if meter is slow, see Sanxing SX6x1 ): >B ;disable publishing at MQTT teleperiod, on boot smlj=0 >S ;re-enable publishing at MQTT teleperiod, after 10 seconds of uptime if upsecs>10 then smlj=1 endif Example If you have large meter descriptors and want to extract multiple values from the same descriptor, you can save flash space using SML_REPLACE_VARS at compile time (see Resol Deltasol BS Plus ): >D ;define a text variable r=\"1,AA100021421000010774\" >M 1 ;in your meter definitions you can use your variable for the same descriptor +1,3,v,0,9600,Solar %r%vo12ut@#,time,,zeit,1 %r%vo0uw@10,S1 COL,\u00b0C,sens1,1 %r%vo2uw@10,S2 TST1,\u00b0C,sens2,1 %r%vo4uw@10,S3 TST2,\u00b0C,sens3,1 %r%vo6uw@10,S4 TR,\u00b0C,sens4,1 ;%r% inserts the text variable and saves script storage space (3 instead of 22 chars for each line) Attention With a few meters, it is necessary to request the meter to send data using a specific character string. This string has to be sent at a very low baud rate (300Baud). If you reply the meter with an acknowledge and ask the it for a new baud rate of 9600 baud, the baud rate of the SML driver has to be changed, too (see Landis + Gyr ZMR120AR ). To change the baud rate: sml( METERNUMBER 0 BAUDRATE ) For sending a specific character string: sml( METERNUMBER 1 STRING ) And it works like this: >D res=0 scnt=0 ;For this Example in the >F section >F ;count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1800ms later \\> Send ACK and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") ;2000ms later \\> Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) ;Restart sequence after 50x100ms case 50 ; 5000ms later \\> restart sequence scnt=0 ends >M 1 +1,3,o,0,9600, ,1 ;...etc. Note : This procedure is only necessary, if the meter explicitly asks for 300 baud. The most meters work directly with 9600 baud. Therefore it is easier to give this method a try (see Iskra MT 174 ): Meter#,GPIO# Input,TYPE,FLAG,Baudrate,JSONNAME,GPIO# Output,TX Period,Character string +1,3,o,0,9600,energy,1,4,2F3F210D0A Tip If you use a Wemos D1 Mini you could compile a 4M flash image with filesystem support so your script will survive upgrades and factory resets. To do this, create a new entry in platformio_tasmota_env.ini : [env:tasmota-4mb] board_build.ldscript = eagle.flash.4m2m.ld Add tasmota-4mb to platformio.ini 's build variants. Add the following to user_config_override.h : #undef MODULE #define MODULE WEMOS #define USE_UFILESYS #define GUI_TRASH_FILE Also recommended, if you use lots of vars and increased buffer sizes to free up the image from unused drivers. You should get some inspiration from the tasmota-lite image definition in tasmota_configurations.h . Tip You can dump to your PC the raw data coming in if you use the module's hardware serial ports (1 and 3) as GPIOs of the script, using Serial to TCP Bridge . Compile your firmware with USE_TCP_BRIDGE , disable the script and configure in module parameters TCP Tx and TCP Rx . After module reboot, start the server with command TCPStart 8888 . Connect to this port from your PC to see or dump the data, in Linux it's as easy as cat < /dev/tcp/IP.OF.YOUR.TASMOTA/8888 > rawdump.txt . To revert to SML you need to set back both GPIO ports to None , enable the script and restart.","title":"Special Commands"},{"location":"Smart-Meter-Interface/#commands","text":"sensor53 r = resets the sml driver, must be applied in script >B section sensor53 cx num = sets counter x (1 or 2) to number (persistent change) sensor53 dm = sets dump mode for meter m (1...N), must be set to 0 for normal operation sensor53 l x = set an optional LED GPIO pin to indicate serial activity of a meter, set to 255 for disable sensor53 m x = sets the meter from which to show activity via the l cmd","title":"Commands"},{"location":"Smart-Meter-Interface/#smart-meter-descriptors","text":"","title":"Smart Meter Descriptors"},{"location":"Smart-Meter-Interface/#abb-b23-modbus","text":"Meter is basically the same as Janitza B23 with the same interface. It's just missing whole section of registers which are used in Janitza B23 example. Beware that A and B MODBus connectors are switched! View script >D >B ->sensor53 r >M 1 +1,3,m,0,9600,ABB,1,10,01035B00,01035B02,01035B04,01035B14,01035B16,01035B18,01035B1A,r010350080004,r010350000004,r010350040004 1,010304UUuuUUuu@i0:10,Voltage L1-N,V,Voltage_L1,1 1,010304UUuuUUuu@i1:10,Voltage L2-N,V,Voltage_L2,1 1,010304UUuuUUuu@i2:10,Voltage L3-N,V,Voltage_L3,1 1,010304SSssSSss@i3:100,Active power Total,W,Active_power_Total,2 1,010304SSssSSss@i4:100,Active power L1-N,W,Active_power_L1,2 1,010304SSssSSss@i5:100,Active power L2-N,W,Active_power_L2,2 1,010304SSssSSss@i6:100,Active power L3-N,W,Active_power_L3,2 1,010308xxxxxxxxSSssSSss@i7:100,Real energy,kWh,Real_energy,2 1,010308xxxxxxxxUUuuUUuu@i8:100,Real energy consumed,kWh,Real_energy_consumed,2 1,010308xxxxxxxxUUuuUUuu@i9:100,Real energy delivered,kWh,Real_energy_delivered,2 # Using the IR Port on left side of the device. IR doesn't support MODBUS only M-Bus and EQ-Bus protocol. Configure the IR output at the device menu. This example is using 9600 baud and address 10h (16 decimal). The meter is using equal parity 1 stop bit 9600E1 The upper diode is TX the lower RX. My device is sending always 2 telegrams. I tried to add additional values by sending SND_UD telegram. I only receive the e5 response showing that the request was accepted. No change in response. The last telegram will end on a \"0F xx 16\" instead of a \"1F xx 16\", which will show that additional telegrams are available. If you can receive more telegrams, add alternating 107b108b16 - 105b106b16. One for each telegram. This example will only work with address 10! the second last byte is a check sum. For this REQ_UD2 it is the sum of the 2 bytes before (Address and VIF). View script >M 1 +1,3,rE1,0,9600,ABB,1,10,1040105016,107b108b16,105b106b16[,107b108b16[,105b106b16]] 1,081072bcd8@1,Meter ID,,ID,0 ; meter ID (BCD-8) 1,0E8400bcd8@100,E Imp total,kWh,Imp,2 ; Total imported energy 0.01 kWh 1,04A900ssSSssSSs@100,P total,W,P_tot,2 ; Total Power 0.01 W 1,04A9FF8100ssSSssSSs@100,P L1,W,P_L1,2 ; L1 Power 0.01 W 1,04A9FF8200ssSSssSSs@100,P L2,W,P_L2,2 ; L2 Power 0.01 W 1,04A9FF8300ssSSssSSs@100,P L3,W,P_L3,2 ; L3 Power 0.01 W 1,04FDC8FF8100uuUUuuUUs@10,U L1,V,U_L1,1 ; Voltage L1 0.1 V 1,04FDC8FF8200uuUUuuUUs@10,U L2,V,U_L2,1 ; Voltage L2 0.1 V 1,04FDC8FF8300uuUUuuUUs@10,U L3,V,U_L3,1 ; Voltage L3 0.1 V 1,0AFFD900bcd4@100,*,Hz,F,2 ; Frequency 1,0E84FF8100bcd8@100,E Imp L1,kWh,Imp-L1,2 ; L1 imported energy 0.01 kWh 1,0E84FF8200bcd8@100,E Imp L2,kWh,Imp-L2,2 ; L2 imported energy 0.01 kWh 1,0E84FF8300bcd8@100,E Imp L3,kWh,Imp-L3,2 ; L3 imported energy 0.01 kWh #","title":"ABB B23 (MODBus)"},{"location":"Smart-Meter-Interface/#apator-apox-sml","text":"Energy provider supplied a PIN code to enable output of additional data. View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,SML 1,77070100010801ff@1000,Verbrauch_Tarif_1,kWh,Total_Tarif1,3 1,77070100010802ff@1000,Verbrauch_Tarif_2,kWh,Total_Tarif2,3 1,77070100010800ff@1000,Verbrauch_Summe,kWh,Total_Summe,3 1,77070100100700ff@1,Current consumption,W,Power_curr,3 1,=h ---- 1,770701001f0700ff@1,Current L1,A,Curr_p1,3 1,77070100330700ff@1,Current L2,A,Curr_p2,3 1,77070100470700ff@1,Current L3,A,Curr_p3,3 1,=h ---- 1,77070100200700ff@1,Voltage L1,V,Volt_p1,3 1,77070100340700ff@1,Voltage L2,V,Volt_p2,3 1,77070100480700ff@1,Voltage L3,V,Volt_p3,3 #","title":"Apator APOX+ (SML)"},{"location":"Smart-Meter-Interface/#carlo-gavazzi-em340-modbus-rtu","text":"View script >D >B ->sensor53 r ;->sensor53 d1 >M 1 +1,13,m,0,115200,MODBUS,12,2,01030000,01030002,01030004,0103000C,0103000E,01030010,01030012,01030014,01030016,01030018,0103001A,0103001C,0103001E,01030020,01030022,01030034,01030038,0103002e,0103002f,01030030,0103004e 1,010304SSssSSsss@i0:10,Voltage L1,V,Voltage_L1,1 1,010304SSssSSsss@i1:10,Voltage L2,V,Voltage_L2,1 1,010304SSssSSsss@i2:10,Voltage L3,V,Voltage_L3,1 1,010304SSssSSsss@i3:1000,Current L1,A,Current_L1,3 1,010304SSssSSsss@i4:1000,Current L2,A,Current_L2,3 1,010304SSssSSsss@i5:1000,Current L3,A,Current_L3,3 1,010304SSssSSsss@i6:10,Power L1,W,Power_L1,1 1,010304SSssSSsss@i7:10,Power L2,W,Power_L2,1 1,010304SSssSSsss@i8:10,Power L3,W,Power_L3,1 1,010304SSssSSsss@i9:10,Power VA L1,VA,Power_va_L1,1 1,010304SSssSSsss@i10:10,Power VA L2,VA,Power_va_L2,1 1,010304SSssSSsss@i11:10,Power VA L3,VA,Power_va_L3,1 1,010304SSssSSsss@i12:10,Power var L1,var,Power_var_L1,1 1,010304SSssSSsss@i13:10,Power var L2,var,Power_var_L2,1 1,010304SSssSSsss@i14:10,Power var L3,var,Power_var_L3,1 1,010304SSssSSsss@i15:10,Energy Tot,kWh,Energy_Tot,1 1,010304SSssSSsss@i16:10,Energy Demand,W,Energy_Demand,1 1,010304SSss@i17:1000,PF L1,PF,PF_L1,1 1,010304SSss@i18:1000,PF L2,PF,PF_L2,1 1,010304SSss@i19:1000,PF L3,PF,PF_L3,1 1,010304SSssSSsss@i20:10,Energy Tot Export,kWh,Energy_Tot_Export,1 #","title":"Carlo Gavazzi EM340 (MODBUS RTU)"},{"location":"Smart-Meter-Interface/#combo-meter-water-gas-sml","text":"View script >D >B ->sensor53 r >M 3 +1,1,c,0,10,H20 +2,4,c,0,50,GAS +3,3,s,0,9600,SML 1,1-0:1.8.0*255(@10000,Water reading,cbm,Count,4 2,=h================== 2,1-0:1.8.0*255(@100,Gas reading,cbm,Count,3 3,77070100010800ff@1000,Total consumption,KWh,Total_in,3 3,=h================== 3,77070100100700ff@1,Current consumption,W,Power_curr,2 3,=h ---- 3,=m 10+11+12 @100,Currents L1+L2+L3,A,Curr_summ,2 3,=m 13+14+15/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 3,=h================== 3,77070100240700ff@1,Consumption P1,W,Power_p1,2 3,77070100380700ff@1,Consumption P2,W,Power_p2,2 3,770701004c0700ff@1,Consumption P3,W,Power_p3,2 3,=h ---- 3,770701001f0700ff@100,Current L1,A,Curr_p1,2 3,77070100330700ff@100,Current L2,A,Curr_p2,2 3,77070100470700ff@100,Current L3,A,Curr_p3,2 3,=h ---- 3,77070100200700ff@100,Voltage L1,V,Volt_p1,2 3,77070100340700ff@100,Voltage L2,V,Volt_p2,2 3,77070100480700ff@100,Voltage L3,V,Volt_p3,2 3,=h================== 3,77070100000009ff@#,Service ID,,Meter_id,0 3,=h #","title":"COMBO Meter (Water, Gas, SML)"},{"location":"Smart-Meter-Interface/#ddm18sd-modbus","text":"This script, based on tasmota scripting language, is to read data on a unsupported DDM18SD power meter. It has a 8E1 parity and the slave ID address is n 5. On a Nodemcu or Wemos D1 board, put wires between GPIO3 and GPIO1 to the RX and TX pinout of a RS485 to TTL board, but leave empty (none) the GPIO Tasmota software settings. A & B connected to the meter pinout. View script >B ->sensor53 r >M 1 +1,3,M,0,9600,DDM,1,2,05040000,05040008,05040012,0504001A,05040036,0504002A,05040100,05040400 1,050404ffffffff@i0:1,Tensione,V,DDM_Voltage,2 1,050404ffffffff@i1:1,Corrente,A,DDM_Current,2 1,050404ffffffff@i2:1,Consumo Ist.,W,DDM_Power,2 1,050404ffffffff@i3:1,Reactive power,Var,DDM_React_Power,2 1,050404ffffffff@i4:1,Frequenza,Hz,DDM_Frequency,2 1,050404ffffffff@i5:1,Power factor,,DDM_PF,2 1,050404ffffffff@i6:1,Consumi tot.,Kwh,DDM_Tot_Power,2 1,050404ffffffff@i7:1,Tot. react. power,Kvarh,DDM_Reac_Power,2 #","title":"DDM18SD (MODBus)"},{"location":"Smart-Meter-Interface/#digimeto-gs303-sml","text":"View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,GS303 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,3 1,77070100100700ff@1,Current Consumption,W,Power_cur,0 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,3 1,7707010060320101@#,Service ID,,Meter_id,0 #","title":"Digimeto GS303 (SML)"},{"location":"Smart-Meter-Interface/#easymeter-q3a-apator-apox-sml","text":"A 2-Tariff Meter which for Example SWM (Stadtwerke M\u00fcnchen) oder DGY (Discovergy) uses. Unfortunately this Version sends only whole kWh (precision 0) without PIN. With PIN behaviour changes and high resolution is available as seen below (e.g. precision 7 for consumption/kWh, precision 2 for power/W, precision 1 for voltage/V). Apator APOX+ behaves same as the EasyMeter while pin locked, just precision 0 without additional data. After calling the energy provider they send a letter with the unlock pin. View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,SML 1,77070100010801ff@1000,Verbrauch_Tarif_1,kWh,Verbrauch_T1,7 1,77070100010802ff@1000,Verbrauch_Tarif_2,kWh,Verbrauch_T2,7 1,77070100010800ff@1000,Verbrauch_Summe,kWh,Verbrauch_Summe,7 1,77070100020800ff@1000,Einspeisung_Summe,kWh,Einspeisung_Summe,7 1,=h-- 1,77070100240700ff@1,Leistung_L1,W,Watt_L1,2 1,77070100380700ff@1,Leistung_L2,W,Watt_L2,2 1,770701004c0700ff@1,Leistung_L3,W,Watt_L3,2 1,77070100100700ff@1,Leistung_Summe,W,Watt_Summe,2 1,=h-- 1,77070100200700ff@1,Spannung_L1,V,Volt_L1,1 1,77070100340700ff@1,Spannung_L2,V,Volt_L2,1 1,77070100480700ff@1,Spannung_L3,V,Volt_L3,1 #","title":"EasyMeter Q3A / Apator APOX+ (SML)"},{"location":"Smart-Meter-Interface/#easymeter-q3b-sml","text":"Two separate 2-Tariff meters (e.g. from Fairenergie Reutlingen) are readout by the same Tasmota device. The first one is for general purpose and is connected to GPIO14 . The JSON prefix is set to Power . The second one is for the heat pump and connected to GPIO13 . The JSON prefix is set to Pump . For both meters, tariff 1 & 2 are rounded kWh (precision 0), actual consumption in W has a higher precision (1). View script >D >B =>sensor53 r >M 2 +1,14,s,0,9600,Power 1,77070100010801ff@1000,Tarif 1,kWh,Power_T1,0 1,77070100010802ff@1000,Tarif 2,kWh,Power_T2,0 1,77070100010800ff@1000,Summe,kWh,Power_Sum,0 1,77070100010700ff@1000,Verbrauch,W,Power_Use_Sum,1 +2,13,s,0,9600,Pump 2,77070100010801ff@1000,Tarif 1,kWh,HP_T1,0 2,77070100010802ff@1000,Tarif 2,kWh,HP_T2,0 2,77070100010800ff@1000,Summe,kWh,HP_Sum,0 2,77070100010700ff@1000,Verbrauch,W,HP_Use_Sum,1 #","title":"EasyMeter Q3B (SML)"},{"location":"Smart-Meter-Interface/#easymeter-q3d-q3da1024-obis","text":"The Q3D is a three-phase model energy meter, which was sold in a number of different configurations. This is a legacy device, however still available new in some shops. The most popular model seems to be the two-direction model for solar power metering. The D0 port is read-only with a fixed time interval of two seconds. The communication settings are unusual: 7 data bits, even parity, one stop bit, 9600 baud (9600 7E1). Because the 7E1 serial mode is not supported by Tasmota software serial, the hardware serial port must be used, i.e. GPIO 3. This will /not/ work using GPIO 0 or 2. Also, the source code has to be patched from 8N1 to 7E1 mode for the hardware serial in file src/TasmotaSerial.cpp, please see the patch further down below. Since Tasmota 9.5.0 the serial mode can be changed in the console by typing SerialConfig 7E1 without having to patch TasmotaSerial. Example reading of the two-direction model using GPIO 3 - P_in power reading will be negative in case of inverse power flow: >D >B =>sensor53 r >M 1 +1,12,o,0,9600,SML,1 1,1-0:1.7.255*255(@1,P_in,W,P_in,18 1,1-0:21.7.255*255(@1,L1,W,L1,18 1,1-0:41.7.255*255(@1,L2,W,L2,18 1,1-0:61.7.255*255(@1,L3,W,L3,18 1,1-0:1.8.0*255(@1,E_in,kWh,E_in,19 1,1-0:2.8.0*255(@1,E_out,kWh,E_out,19 1,1-0:0.0.0*255(@1,Netzbetreiber-ID,,NetID,0 1,0-0:96.1.255*255(@#),Seriennummer,,serial,0 # Alternative script running on a Wemos D1 mini on hardware serial pin 3 for the Q3DB1024 two direction >D >B =>sensor53 r >M 1 +1,3,o,0,9600,Haupt,1 1,1-0:1.7.0*255(@1,P_in,W,P_in,18 1,1-0:1.8.0*255(@1,E_in,kWh,E_in,19 1,1-0:2.8.0*255(@1,E_out,kWh,E_out,19 1,1-0:21.7.0*255(@1,L1,W,L1,18 1,1-0:41.7.0*255(@1,L2,W,L2,18 1,1-0:61.7.0*255(@1,L3,W,L3,18 1,1-0:0.0.0*255(@1,Netzbetreiber-ID,,NetID,0 1,0-0:96.1.255*255(@#),Seriennummer,,serial,0 # Apply following patch to src/TasmotaSerial.cpp --- a / lib / default / TasmotaSerial -3.2.0 / src / TasmotaSerial . cpp +++ b / lib / default / TasmotaSerial -3.2.0 / src / TasmotaSerial . cpp @@ -117 , 7 + 117 , 7 @@ bool TasmotaSerial :: begin ( long speed , int stop_bits ) { if ( 2 == m_stop_bits ) { Serial . begin ( speed , SERIAL_8N2 ); } else { - Serial . begin ( speed , SERIAL_8N1 ); + Serial . begin ( speed , SERIAL_7E1 ); } if ( m_hardswap ) { Serial . swap ();","title":"EasyMeter Q3D, Q3DA1024 (OBIS)"},{"location":"Smart-Meter-Interface/#ebz-dd3-obis","text":"The eBZ DD3 by eBZ GmbH is a three-phase model energy meter, which is sold in a number of different configurations. The D0 port is read-only with a fixed time interval of one second. There are two communication interfaces: * The INFO interface on the front, with a metal backplate. Pushes a reduces OBIS ASCI datagram every second. * The MSB interface on the top, no metal backplate. Pushes a full OBIS ASCI datagram every second. There are two types available using different communication settings: * OD-type: 7 data bits, even parity, one stop bit, 9600 baud (9600 7E1) * SM-type: 8 data bits, no parity, one stop bit, 9600 baud (9600 8N1) Tested with a eBZ DD3 2R06 ODZ1 (two-direction model for e. g. solar power metering). Because the 7E1 serial mode is not supported by Tasmota software serial, the hardware serial port must be used, i.e. GPIO 3. This will /not/ work using GPIO 0 or 2. Also, the source code has to be patched from 8N1 to 7E1 mode for the hardware serial in file src/TasmotaSerial.cpp, please see the patch further down below. Since Tasmota 9.5.0 the serial mode can be changed in the console by typing SerialConfig 7E1 without having to patch TasmotaSerial. Example reading of the two-direction model using GPIO 3: \"TelePeriod 30\" sets telemetry period to 30 seconds (remove if not needed/wanted) Values for ?6.7.0 (power) are transmit immediately (precision + 16) power readings will be negative in case of inverse power flow View script >D >B TelePeriod 30 =>sensor53 r >M 1 ; Device: eBZ DD3 2R06 ODZ1 ; protocol is D0 OBIS ASCII ; 9600@7E1 for OP-type devices, 9600@8N1 for SM-type devices +1,3,o,0,9600,SM,1 ; Z\u00e4hlerstand zu +A, tariflos, ; Z\u00e4hlerst\u00e4nde Aufl\u00f6sung 10 \u00b5W*h (6 Vorkomma- und 8 Nachkommastellen) 1,1-0:1.8.0*255(@0.001,Energie Bezung,Wh,1_8_0,8 ; Z\u00e4hlerstand zu +A, Tarif 1 1,1-0:1.8.1*255(@0.001,Energie Bezung T1,Wh,1_8_1,8 ; Z\u00e4hlerstand zu +A, Tarif 2 1,1-0:1.8.2*255(@0.001,Energie Bezung T2,Wh,1_8_2,8 ; Z\u00e4hlerstand zu -A, tariflos 1,1-0:2.8.0*255(@0.001,Energie Export,Wh,2_8_0,8 ; Summe der Momentan-Leistungen in allen Phasen, Aufl\u00f6sung 0,01W (5 Vorkomma- und 2 Nachkommastellen) 1,1-0:16.7.0*255(@1,Leistung,W,16_7_0,18 ; Momentane Leistung in Phase Lx, Aufl\u00f6sung 0,01W (5 Vorkomma- und 2 Nachkommastellen) 1,1-0:36.7.0*255(@1,Leistung L1,W,36_7_0,18 1,1-0:56.7.0*255(@1,Leistung L2,W,56_7_0,18 1,1-0:76.7.0*255(@1,Leistung L3,W,76_7_0,18 ; Spannung in Phase Lx, Aufl\u00f6sung 0,1V (nur \u00fcber MSB) 1,1-0:32.7.0*255(@1,Spannung L1,V,32_7_0,1 1,1-0:52.7.0*255(@1,Spannung L2,V,52_7_0,1 1,1-0:72.7.0*255(@1,Spannung L3,V,72_7_0,1 ; Statuswort, 4 Byte Information \u00fcber den Betriebszustand, HEX string ; tasmota can decode one string per device only! ;1,1-0:96.5.0*255(@#),Status1,,96_5_0,0 ;1,1-0:96.8.0*255(@#),Status2,,96_8_0,0 ; Ger\u00e4te-Identifikation, Nach DIN 43863-5 1,1-0:96.1.0*255(@#),Identifikation,,96_1_0,0 ;1,1-0:0.0.0*255(@#),Identifikation,,0_0_0,0 # Apply following patch to src/TasmotaSerial.cpp --- a/lib/default/TasmotaSerial-3.2.0/src/TasmotaSerial.cpp +++ b/lib/default/TasmotaSerial-3.2.0/src/TasmotaSerial.cpp @@ -117,7 +117,7 @@ bool TasmotaSerial::begin(long speed, int stop_bits) { if (2 == m_stop_bits) { Serial.begin(speed, SERIAL_8N2); } else { - Serial.begin(speed, SERIAL_8N1); + Serial.begin(speed, SERIAL_7E1); } if (m_hardswap) { Serial.swap(); For the SM-type meter DD3 2R06 DTA SMZ1 the following script worked without having to apply the above patch, because it uses 8N1 for communication >D >B ;TelePeriod 30 =>sensor53 r >M 1 ; Device: eBZ DD3 2R06 DTA SMZ1 ; protocol is D0 SML HEX ; 9600@7E1 for OP-type devices, 9600@8N1 for SM-type devices +1,3,s,0,9600,SML,1 ; Z\u00e4hlerstand zu +A, tariflos, ; Z\u00e4hlerst\u00e4nde Aufl\u00f6sung 10 \u00b5W*h (6 Vorkomma- und 8 Nachkommastellen) 1,77070100010800FF@100000000,Energie Bezug,kWh,1_8_0,8 ; Z\u00e4hlerstand zu +A, Tarif 1 1,77070100010801FF@100000000,Energie Bezug T1,kWh,1_8_1,8 ; Z\u00e4hlerstand zu +A, Tarif 2 1,77070100010802FF@100000000,Energie Bezug T2,kWh,1_8_2,8 ; Z\u00e4hlerstand zu -A, tariflos 1,77070100020800FF@100000000,Energie Export,kWh,2_8_0,8 ; Summe der Momentan-Leistungen in allen Phasen, Aufl\u00f6sung 0,01W (5 Vorkomma- und 2 Nachkommastellen) 1,77070100100700FF@1,Leistung,W,16_7_0,16 ; Momentane Leistung in Phase Lx, Aufl\u00f6sung 0,01W (5 Vorkomma- und 2 Nachkommastellen) 1,77070100240700FF@1,Leistung L1,W,36_7_0,16 1,77070100380700FF@1,Leistung L2,W,56_7_0,16 1,770701004C0700FF@1,Leistung L3,W,76_7_0,16 ; Spannung in Phase Lx, Aufl\u00f6sung 0,1V (nur \u00fcber MSB) ;1,77070100200700FF@1,Spannung L1,V,32_70,1 ;1,77070100340700FF@1,Spannung L2,V,52_7_0,1 ;1,77070100480700FF@1,Spannung L3,V,72_7_0,1 ; Statuswort, 4 Byte Information \u00fcber den Betriebszustand, HEX string ; tasmota can decode one string per device only! ;1,1-0:96.5.0*255@#),Status1,,96_5_0,0 ;1,1-0:96.8.0*255@#),Status2,,96_8_0,0 ; Ger\u00e4te-Identifikation, Nach DIN 43863-5 1,77070100000009FF@#),Identifikation,,96_1_0,0 ;1,77070100000000FF@#),Identifikation,,0_0_0,0 #","title":"eBZ DD3 (OBIS)"},{"location":"Smart-Meter-Interface/#easymeter-q1d-ascii-obis","text":"This script is for the EasyMeter Q1DB1004 variant of the Q1D series. This variant is a one-phase one-way electricity counter with a backstop mechanism. Therefore the script reads only two values: the energy counter value and the power value. The power value is positive when you are drawing power from the public grid, and negative when you are feeding power to the public grid. Due to the backstop mechanism, the energy counter value will not decrease when you feed power to the public grid. The meter's manufacturer's datasheet neatly explains the serial message format used, so you can easily adapt the code below to your EasyMeter Q1D, e.g. if you have a two-way counter variant like the EasyMeter Q1DA1026. View script >D >B =>sensor53 r >M 1 +1,3,o,0,9600,SML 1,1-0:1.8.0*255(@1,EC_CounterVal,kWh,EC_CounterVal,4 1,1-0:61.7.255*255(@1,EC_PowerVal,W,EC_PowerVal,0 # According to the manufacturer's datasheet, the serial parameters are 9600 baud and 7E1. For Tasmota versions that are built with a TasmotaSerial.cpp of version 3.5.0 (and probably all higher versions, too), no modification of the TasmotaSerial.cpp source code (as suggested in other entries of this documentation) is necessary to set the serial parameters to 7E1: By configuring the meter type as OBIS (\"o\") in line 5 of the above code, you implicitly tell Tasmota to set the serial parameters to 7E1 (probably the same applies to all other meters in this documentation where a modification of TasmotaSerial.cpp has previously been recommended).","title":"EasyMeter Q1D (ASCII OBIS)"},{"location":"Smart-Meter-Interface/#efr-sgm-c4-4a920l-obis","text":"By default, the wattmeter only sends the actual power. To be able to read all the other values, you need to enter the PIN. The PIN must be requested to the electricity provider. After entering the PIN, all the values will be available and you also have the option to disable the need of the PIN. View script >D >B ->sensor53 r >M 1 +1,3,s,16,9600,SML 1,77070100010800ff@1000,Comsumption,kWh,HT,4 1,77070100020800ff@1000,Supply,kWh,SP,4 1,77070100100700ff@1,Actual Power,W,AP,0 1,77070100200700ff@1,Voltage P1,V,V_P1,1 1,77070100340700ff@1,Voltage P2,V,V_P2,1 1,77070100480700ff@1,Voltage P3,V,V_P3,1 1,770701001f0700ff@1,Current P1,A,A_P1,2 1,77070100330700ff@1,Current P2,A,A_P2,2 1,77070100470700ff@1,Current P3,A,A_P3,2 1,77070100510704ff@1,Phaseangle I-L1/U-L1,deg,phase_angle_p1,1 1,7707010051070fff@1,Phaseangle I-L27I-L2,deg,phase_angle_p2,1 1,7707010051071aff@1,Phaseangle I-L3/I-L3,deg,phase_angle_p3,1 1,770701000e0700ff@1,Frequency,Hz,HZ,1 # Overview of the codes","title":"EFR SGM-C4-4A920L (OBIS)"},{"location":"Smart-Meter-Interface/#elster-honeywell-as1440-obis","text":"Based on Landis script with changed timings in the >F section, as AS1440 seems to be slower in responding. View script >D scnt=0 res=0 >B =>sensor53 r >F ; count 100ms scnt+=1 switch scnt case 3 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1700ms later \\> Ack and ask for switching to 9600 baud case 20 res=sml(1 1 \"063035300D0A\") ;300ms later \\> Switching sml driver to 9600 baud case 23 res=sml(1 0 9600) ;Restart sequence after 55x100ms case 55 ; 5500ms later \\> restart sequence scnt=0 ends >M 1 +1,3,o,0,9600,AS1440,1 1,1-1:1.8.1(@1,Total_In,KWh,Total_In,3 1,1-1:2.8.1(@1,Total_Out,KWh,Total_Out,3 #","title":"Elster / Honeywell AS1440 (OBIS)"},{"location":"Smart-Meter-Interface/#elster-honeywell-as2020-sml","text":"View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,,1 1,77070100600100ff@#,Server-ID,,Wert,0 1,77070100010800ff@1000,Total Consumed,kWh,total_consumed_kwh,1 1,77070100020800ff@1000,Total Delivered,kWh,total_delivered_kwh,1 1,77070100100700ff@0.1,Current Consumption,W,current_consumption,0 #","title":"Elster / Honeywell AS2020 (SML)"},{"location":"Smart-Meter-Interface/#emh-ed300l-sml","text":"View script >D >B ->sensor53 r >M 2 +1,13,s,0,9600,Haus +2,12,s,0,9600,Heizung 1,770701000F0700FF@1,Aktuell,W,Power_curr,0 1,77070100010800FF@1000,Z\u00e4hlerstand Verb.,kWh,Tariflos,2 1,77070100020800FF@1000,Z\u00e4hlerstand Einsp.,kWh,Tariflos,2 2,=h================== 2,770701000F0700FF@1,Aktuell,W,Power_curr,0 2,77070100010800FF@1000,Z\u00e4hlerstand Verb.,kWh,Tariflos,2 2,77070100020800FF@1000,Z\u00e4hlerstand Einsp.,kWh,Tariflos,2 #","title":"EMH ED300L (SML)"},{"location":"Smart-Meter-Interface/#emh-ed300s-sml","text":"View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,Main 1,77070100100700ff@1,Power,W,power,0 1,77070100010800FF@1000,Counter,kWh,counter,3 #","title":"EMH ED300S (SML)"},{"location":"Smart-Meter-Interface/#emh-ehz-generation-k-sml","text":"View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600, 1,77070100010800ff@1000,Gesamtverbrauch,KWh,Total_in,2 1,77070100020800ff@1000,Gesamteinspeisung,KWh,Total_out,2 1,77070100100700ff@1,Verbrauch,W,Power_curr,0 #","title":"EMH eHZ Generation K (SML)"},{"location":"Smart-Meter-Interface/#emh-mme40-sml","text":"View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,Main,1,10 1,77070100010800FF@1000,Total Consumed,kWh,counter_pos,3 1,77070100020800FF@1000,Total Feed,kWh,counter_neg,3 1,77070100100700FF@1,Power,W,power,0 #","title":"EMH mMe4.0 (SML)"},{"location":"Smart-Meter-Interface/#ezb-md3-sml","text":"View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,Smartmeter 1,77070100010800ff@100000000,Total consumption,KWh,Total_in,3 1,77070100020800ff@100000000,Total generation,KWh,Total_out,3 1,77070100100700ff@1,Power L1+L2+L3,W,P_L1_L2_L3,18 1,77070100240700ff@1,Power L1,W,P_L1,18 1,77070100380700ff@1,Power L2,W,P_L2,18 1,770701004C0700ff@1,Power L3,W,P_L3,18 #","title":"eZB MD3 (SML)"},{"location":"Smart-Meter-Interface/#growatt-max4200-modbus","text":"Growatt solar inverter. this example also shows how to send cmds to modbus View script >D 22 cstr=\"\" gl=0 tmp=0 >B =>sensor53 r >S if chg[gl]>0 { ; change limit tmp=int(gl/42) cstr=\"r0106000300\"+hn(tmp) sml(1 3 cstr) } >M 1 +1,18,m,0,9600,GRW,19,5,01040026,01040028,01040005,01040009,01030003 1,010404UUuu@i0:10,Netzspannung,V,mainsv,1 1,010404xxxxUUuu@i0:10,Einspeisestrom,A,mainsc,1 1,010404UUuuUUuu@i1:10,Einspeiseleistung,W,mainsw,1 1,010404UUuuUUuu@i2:10,string 1 unten,W,s1w,1 1,010404UUuuUUuu@i3:10,string 2 oben,W,s2w,1 1,010304UUuu@i4:1,limit,%,limit,0 # >W <hr> nm(1000 3600 10 gl \"Growatt limit (W) \" 80 0)","title":"Growatt MAX4200 (MODBus)"},{"location":"Smart-Meter-Interface/#hager-ehz161-obis","text":"View script >D >B ->sensor53 r >M 1 +1,3,o,0,9600,OBIS 1,1-0:1.8.1\\*255(@1,Total consumption,KWh,Total_in,4 1,1-0:2.8.1\\*255(@1,Total Feed,KWh,Total_out,4 1,=d 2 10 @1,Current consumption,W,Power_curr,0 1,1-0:0.0.0\\*255(@#),Meter Nr,, Meter_number,0 #","title":"Hager EHZ161 (OBIS)"},{"location":"Smart-Meter-Interface/#hager-ehz363-apator-norax-3d-sml","text":"View script >D >B ->sensor53 r >M 1 +1,3,s,0,9600,SML 1,77070100010800ff@1000,Total consumption,KWh,Total_in,4 1,77070100020800ff@1000,Total Feed,KWh,Total_out,4 1,77070100100700ff@1,Current consumption,W,Power_curr,0 1,77070100200700ff@1,Voltage L1,V,Volt_p1,1 1,77070100340700ff@1,Voltage L2,V,Volt_p2,1 1,77070100480700ff@1,Voltage L3,V,Volt_p3,1 1,770701001f0700ff@1,Amperage L1,A,Amperage_p1,1 1,77070100330700ff@1,Amperage L2,A,Amperage_p2,1 1,77070100470700ff@1,Amperage L3,A,Amperage_p3,1 1,77070100510704ff@1,Phaseangle I-L1/U-L1,deg,phase_angle_p1,1 1,7707010051070fff@1,Phaseangle I-L27I-L2,deg,phase_angle_p2,1 1,7707010051071aff@1,Phaseangle I-L3/I-L3,deg,phase_angle_p3,1 1,770701000e0700ff@1,Frequency,Hz,frequency,0 # SML with daily values >D pin=0 pout=0 pi_d=0 po_d=0 hr=0 ; permanent midnight values p:pi_m=0 p:po_m=0 >B ->sensor53 r >T ; get total consumption and total feed pin=SML#Total_in pout=SML#Total_out >S ; at midnight, save meter total values hr=hours if chg[hr]>0 and hr==0 then pi_m=pin po_m=pout svars endif ; on teleperiod calculate current daily values from midnight if upsecs%tper==0 then pi_d=pin-pi_m po_d=pout-po_m endif ; show these values on WEB UI >W Tagesverbrauch: {m} %pi_d% kWh Tageseinspeisung: {m} %po_d% kWh ; transmit these values with MQTT >J ,\"daily_consumption\":%pi_d%,\"daily_feed\":%po_d% ; meter definition >M 1 +1,3,s,0,9600,SML 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,4 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,4 1,77070100100700ff@1,Current Consumption,W,Power_curr,0 1,77070100000009ff@#,Meter Number,,Meter_number,0 #","title":"Hager EHZ363, Apator Norax 3D (SML)"},{"location":"Smart-Meter-Interface/#hiking-dds238-2-zns3-4x-modbus","text":"This is an example for 4 MODBus devices on the same bus (at different addresses). Wiring diagram View script >D >B ->sensor53 r >M 1 +1,3,m,1,9600,Hiking,1,10,0103000c,0103000e,0303000c,0303000e,0403000c,0403000e,0503000c,0503000e ;---> two groups of registrers for each device --> default 2 registers returned ---> 4 values per device 1,=h Contatore 1 1,010304UUuu@i0:10,C1_Voltage,V,C1Voltage,1 ;---> decoder for the first registry returned for the first group 1,010304xxxxUUuu@i0:1000,C1_Current,A,C1Current,3 ;---> decoder for the second registry returned for the first group 1,010304SSss@i1:1,C1_ActivePower,W,C1ActivePower,0 1,010304xxxxUUuu@i1:1,C1_ReactivePower,Var,C1ReactivePower,0 1,=h Contatore 3 1,030304UUuu@i2:10,C3_Voltage,V,C3Voltage,1 1,030304xxxxUUuu@i2:1000,C3_Current,A,C3Current,3 1,030304SSss@i3:1,C3_ActivePower,W,C3ActivePower,0 1,030304xxxxUUuu@i3:1,C3_ReactivePower,Var,C3ReactivePower,0 1,=h Contatore 4 1,040304UUuu@i4:10,C4_Voltage,V,C4Voltage,1 1,040304xxxxUUuu@i4:1000,C4_Current,A,C4Current,3 1,040304SSss@i5:1,C4_ActivePower,W,C4ActivePower,0 1,040304xxxxUUuu@i5:1,C4_ReactivePower,Var,C4ReactivePower,0 1,=h Contatore 5 1,050304UUuu@i6:10,C5_Voltage,V,C5Voltage,1 1,050304xxxxUUuu@i6:1000,C5_Current,A,C5Current,3 1,050304SSss@i7:1,C5_ActivePower,W,C5ActivePower,0 1,050304xxxxUUuu@i7:1,C5_ReactivePower,Var,C5ReactivePower,0 #","title":"Hiking DDS238-2 ZN/S3 4x (MODBus)"},{"location":"Smart-Meter-Interface/#holley-dtz541-sml","text":"This script reads pretty much all given informations. Make sure to enable info in the settings, otherwise you only get total / current consuption and total export. This script was used and tested on a WeMos D1 mini with an IR Head connected to the RX pin (3). View script >D >B ->sensor53 r >M 1 +1,3,s,16,9600,SML 1,77070100600100ff@#,Server ID,,server_id,0 1,77070100020800ff@1000,Export (Total),kWh,export_total_kwh,4 1,77070100010800ff@1000,Consumption (Total),kWh,total_kwh,4 1,77070100100700ff@1,Consumption (Current),W,curr_w,0 1,77070100200700ff@1,Voltage L1,V,volt_p1,1 1,77070100340700ff@1,Voltage L2,V,volt_p2,1 1,77070100480700ff@1,Voltage L3,V,volt_p3,1 1,770701001f0700ff@1,Amperage L1,A,amp_p1,1 1,77070100330700ff@1,Amperage L2,A,amp_p2,1 1,77070100470700ff@1,Amperage L3,A,amp_p3,1 1,77070100510701ff@1,Phase angle U-L2/U-L1,deg,phase_angle_l2_l1,1 1,77070100510702ff@1,Phase angle U-L3/U-L1,deg,phase_angle_l3_l1,1 1,77070100510704ff@1,Phase angle I-L1/U-L1,deg,phase_angle_p1,1 1,7707010051070fff@1,Phase angle I-L2/U-L2,deg,phase_angle_p2,1 1,7707010051071aff@1,Phase angle I-L3/U-L3,deg,phase_angle_p3,1 1,770701000e0700ff@1,Frequency,Hz,freq,0 #","title":"Holley DTZ541 (SML)"},{"location":"Smart-Meter-Interface/#iskra-mt-174-obis","text":"View script >D >B ->sensor53 r >M 1 +1,3,o,0,300,STROM,1,100,2F3F210D0A 1,1-0:1.8.1*255(@1,Total Consumed,KWh,Total_in,3 1,1-0:2.8.1*255(@1,Total Delivered,KWh,Total_out,3 1,1-0:0.0.0*255(@#),Meter Number,,Meter_number,0 #","title":"Iskra MT 174 (OBIS)"},{"location":"Smart-Meter-Interface/#iskra-mt-175-sml","text":"This meter needs a PIN to unlock the current power usage. You need to ask your provider. View script >D >B ->sensor53 r >M 1 +1,3,s,16,9600,MT175 1,77070100010800ff@1000,E_in,kWh,E_in,1 1,77070100020800ff@1000,E_out,kWh,E_out,1 1,77070100100700ff@1,P,W,P,18 1,77070100240700ff@1,L1,W,L1,18 1,77070100380700ff@1,L2,W,L2,18 1,770701004C0700ff@1,L3,W,L3,18 1,77070100000009ff@#,Server_ID,,Server_ID,0 #","title":"Iskra MT 175 (SML)"},{"location":"Smart-Meter-Interface/#iskra-mt-681-sml","text":"This is script for a two-direction meter (consumption and delivery) for the Isra MT 681, that is widely used in Germany. If you don't deliver energy, just delete the \"Total Delivered\" line. If the meter provides the consumption values for the 3 phases depends also on the configuration by your local energy provider. View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,MT681 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,3 1,77070100100700ff@1,Current Consumption,W,Power_cur,0 1,77070100240700ff@1,Current Consumption P1,W,Power_p1,0 1,77070100380700ff@1,Current Consumption P2,W,Power_p2,0 1,770701004c0700ff@1,Current Consumption P3,W,Power_p3,0 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,3 1,77070100000009ff@#,Service ID,,Meter_id,0| #","title":"Iskra MT 681 (SML)"},{"location":"Smart-Meter-Interface/#iskra-ehz-mt681-d4a51-k0p","text":"2012 version of the Iskra MT 681 with slightly other OBIS codes for the power values. View script >D >B =>sensor53 r >M 1 +1,3,s,0,9600,MT681 1,77070100010800ff@1000,Gesamtverbrauch,KWh,Total_in,3 1,770701000f0700ff@1,Leistung,W,Power_cur,0 1,77070100150700ff@1,Leistung P1,W,Power_p1,0 1,77070100290700ff@1,Leistung P2,W,Power_p2,0 1,770701003d0700ff@1,Leistung P3,W,Power_p3,0 1,77070100020800ff@1000,Gesamteinspeisung,KWh,Total_out,3 1,77070100000009ff@#,Service ID,,Meter_id,0| #","title":"Iskra eHZ-MT681-D4A51-K0p"},{"location":"Smart-Meter-Interface/#itron-sml-v104","text":"The Itron electrical meter is a German end-user meter installed by EnBW. You can read values using an IR Sensor. The following script shows the meter number and the consuption and the generation of a Photovoltaik generator. View script >D >B =>sensor53 r >M 1 +1,12,s,0,9600,ELZ 1,77070100600100ff@#,Z\u00e4hlernummer,,Wert,0 1,77070100010800ff@1000,Verbrauch,kWh,ELZ_PV_1.8.0,1 1,77070100020800ff@1000,Erzeugung,kWh,ELZ_PV_2.8.0,1 # This script additionally reads the power in watts It has enhanced precision of 4 decimal places for the total consumption. Be sure to turn on the full precision at the meter using a flashlight (if you see inF=Off , hold for 5 seconds until you see inF=On ) >D >B =>sensor53 r ;Set teleperiod to 20sec tper=10 >M 1 +1,3,s,0,9600,Power 1,77070100600100ff@#,Z\u00e4hlernummer,,Meter_Number,0 1,77070100010800ff@1000,Verbrauch,kWh,Total_in,4 1,77070100100700ff@1,Leistung,W,Power_curr,0 1,77070100020800ff@1000,Erzeugung,kWh,Total_out,4 #","title":"Itron (SML V1.04)"},{"location":"Smart-Meter-Interface/#janitza-b23-modbus","text":"View script >D >B ->sensor53 r >M 1 +1,3,m,0,9600,Janitza,1,1,01034A38,01034A3A,01034A3C,01034A4C,01034A4E,01034A50,01034A72,01034A7A,01034A82 1,010304ffffffff@i0:1,Voltage L1-N,V,Voltage_L1-N,2 1,010304ffffffff@i1:1,Voltage L2-N,V,Voltage_L2-N,2 1,010304ffffffff@i2:1,Voltage L3-N,V,Voltage_L3-N,2 1,010304ffffffff@i3:1,Real power L1-N,W,Real_power_L1-N,2 1,010304ffffffff@i4:1,Real power L2-N,W,Real_power_L2-N,2 1,010304ffffffff@i5:1,Real power L3-N,W,Real_power_L3-N,2 1,010304ffffffff@i6:1,Real energy L3,Wh,Real_energy_L3,2 1,010304ffffffff@i7:1,Real energy L3-consumed,Wh,Real_energy_L3_consumed,2 1,010304ffffffff@i8:1,Real energy L3-delivered,Wh,Real_energy_L3_delivered,2 #","title":"Janitza B23 (MODBus)"},{"location":"Smart-Meter-Interface/#janz-c3801-modbus","text":"This is an example for one of the many quite similar smart meters implemented in Portugal, by EDP Distribui\u00e7\u00e3o S.A. May be valid for many more models, as stated. You should additionally configure in your user_config_override.h #define SML_MAX_VARS 10 . View script >D >B =>sensor53 r >M 1 +1,14,m,1,9600,EB,5,50,0104006C,01040079,0104007A,0104007F,01040026,01040027,01040028,0104000B,01040084 1,=hVALORES T\u00c9CNICOS 1,010404UUuuxxxx@i0:10,Tens\u00e3o,V,Voltage_P1,17 1,010404xxxxUUuu@i0:10,Corrente,A,Current_P1,17 1,010408UUuuUUuuxxxxxxxxxxxx@i1:1,Pot\u00eancia ativa,W,Power_P1,16 1,010406xxxxxxxxUUuu@i2:1000,Fator de pot\u00eancia,pu,PFactor_P1,19 1,01040aUUuuxxxx@i3:10,Frequ\u00eancia,Hz,Frequency_P1,17 1,=h&#8205; 1,=hTOTALIZADORES DE ENERGIA 1,010408UUuuUUuuxxxxxxxxxxxx@i4:1000,Vazio (1),kWh,Energy_P1_R1,17 1,010408UUuuUUuuxxxxxxxxxxxx@i5:1000,Ponta (2),kWh,Energy_P1_R2,17 1,010408UUuuUUuuxxxxxxxxxxxx@i6:1000,Cheia (3),kWh,Energy_P1_R3,17 1,=h&#8205; 1,=hESTADOS 1,010406uuxxxxxxxx@i7:1,Tarifa,,Tariff_P1,16 1,010406uuxxxxxxxx@i8:1,DCP,,DCP_P1,16 #","title":"JANZ C3801 (MODBus)"},{"location":"Smart-Meter-Interface/#kaifa-mb310h4bde","text":"View script D B =>sensor53 r M 1 +1,3,s,0,9600,Haus 1,77070100010800ff@1000,Zaehlerstand In,KWh,Total_in,2 1,77070100020800ff@1000,Zaehlerstand Out,KWh,Total_out,2 1,77070100100700ff@1,Leistung-akt.,W,Power_curr,0 1,77070100600100ff@#,Server-ID,,Meter_Number,0","title":"KAIFA MB310H4BDE"},{"location":"Smart-Meter-Interface/#landis-gyr-e220-sml","text":"For read-out of \"current power\" the advanced data set has to be enabled in user menue View script >D >B =>sensor53 r ;Set teleperiod to 20sec tper=10 >M 1 +1,3,s,0,9600,Power 1,77070100600100ff@#,Server-ID,,Meter_Number,0 1,77070100010800ff@1000,Verbrauch,kWh,Total_in,4 1,77070100100700ff@1,Leistung-akt.,W,Power_curr,0 #","title":"Landis + Gyr E220 (SML)"},{"location":"Smart-Meter-Interface/#landis-gyr-e320-sml","text":"For read-out of \"Current power\" the advanced data set has to be enabled in user menue View script >D >B =>sensor53 r >M 1 +1,3,s,20,9600,E320 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,3 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,3 1,77070100100700ff@1,Current power,W,Power_in,3 1,77070100600100ff@#,Server-ID,,Meter_Number,0 #","title":"Landis + Gyr E320 (SML)"},{"location":"Smart-Meter-Interface/#landis-gyr-zmb120-t213cs-obis","text":"This meter may need a PIN to unlock the current power usage - ask your provider. View script >D >B =>sensor53 r >M 1 +1,3,o,0,300,STROM,1,10,2F3F210D0A,063030300D0A 1,0(@1,Z\u00e4hlernummer,,Meter_number,0 1,=h=================== 1,8.0(@1,Total T1 & T2,KWh,Total,2 1,8.1(@1,T1 aktuell,KWh,Total_T1,2 1,8.2(@1,T2 aktuell,KWh,Total_T2,2 1,=h=================== 1,8.1.1(@1,T1 letzte Saison,KWh,Total_T1-1,2 1,8.2.1(@1,T2 letzte Saison,KWh,Total_T2-1,2 1,8.1.2(@1,T1 vorletzte Saison,KWh,Total_T1-2,2 1,8.2.2(@1,T2 vorletzte Saison,KWh,Total_T2-2,2 #","title":"Landis + Gyr ZMB120 T213CS (OBIS)"},{"location":"Smart-Meter-Interface/#landis-gyr-zmr120ares2r2sfcs-obis","text":"Example: Changing the baud rate during operation. View script >D ;Var Power consumption total HT+NT v1=0 ;HT Main electricity tariff consumption total v2=0 ;NT Night electricity tariff consumption total v3=0 ; Energie L1+L2+L3 v4=0 ;recent Energie L1 v5=0 ;recent Energie L2 v6=0 ;recent Energie L3 v7=0 ;Var minute min=0 ;Var hour hr=0 ;Var begin of the month 01.xx.20xx 0:00 Uhr md=0 ;Var begin of the year 01.01. 0:00 Uhr yr=0 ;Var for counter see >F=ms scnt=0 ;Var for baudrate changeing res=0 ;Permanent Var Meter1 0:00 p:sm=0 p:HT_sm=0 p:NT_sm=0 ;Var for daily =0 sd=0 HT_sd=0 NT_sd=0 ;Permanent Var for month begin p:sma=0 p:HT_sma=0 p:NT_sma=0 ;Var for monthly =0 smn=0 HT_smn=0 NT_smn=0 ;Permanent Var for year begin p:sya=0 p:HT_sya=0 p:NT_sya=0 ;Var for yearly =0 syn=0 HT_syn=0 NT_syn=0 ;Fill vars with content on teleperiod >T v1=#Total_in v2=#HT_Total_in v3=#NT_Total_in v4=#kW_L1+L2+L3 v5=#kw_L1 v6=#kw_L2 v7=#kw_L3 >B ;Restart driver ->sensor53 r ;Set teleperiod to 20sec tper=20 >F ; count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1800ms later \\> Ack and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") ;2000ms later \\> Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) ;Restart sequence after 50x100ms case 50 ; 5000ms later \\> restart sequence scnt=0 ends >S ;daily usage hr=hours if chg[hr]>0 and hr==0 and v1>0 then sm=v1 HT_sm=v2 NT_sm=v3 svars endif if upsecs%tper==0{ sd=v1-sm HT_sd=v2-HT_sm NT_sd=v3-NT_sm } ;Monthly usage md=day if chg[md]>0 and md==1 and v1>0 then sma=v1 HT_sma=v2 NT_sma=v3 svars endif if upsecs%tper==0{ smn=v1-sma HT_smn=v2-HT_sma NT_smn=v3-NT_sma } ;Yearly usage yr=year if chg[yr]>0 and v1>0 then sya=v1 HT_sya=v2 NT_sya=v3 svars endif if upsecs%tper==0{ syn=v1-sya HT_syn=v2-HT_sya NT_syn=v3-NT_sya ; Json payload \\> send on teleperiod >J ,\"Strom_Vb_Tag\":%3sd% ,\"HT_Strom_Vb_Tag\":%3HT_sd% ,\"NT_Strom_Vb_Tag\":%3NT_sd% ,\"Strom_Vb_M\":%1smn% ,\"HT_Strom_Vb_M\":%1HT_smn% ,\"NT_Strom_Vb_M\":%1NT_smn% ,\"Strom_Vb_Jahr\":%0syn% ,\"HT_Strom_Vb_Jahr\":%0HT_syn% ,\"NT_Strom_Vb_Jahr\":%0NT_syn% ,\"Strom_0:00 _Uhr\":%1sm% ,\"HT_Strom_0:00 _Uhr\":%1HT_sm% ,\"NT_Strom_0:00 _Uhr\":%1NT_sm% ,\"Strom_Ma\":%3sma% ,\"HT_Strom_Ma\":%3HT_sma% ,\"NT_Strom_Ma\":%3NT_sma% ,\"Strom_Ja\":%3sya% ,\"HT_Strom_Ja\":%3HT_sya% ,\"NT_Strom_Ja\":%3NT_sya% ;Webdisplay stuff >W 0:00 Uhr \u03a3 HT+NT: {m} %0sm% KWh HT: {m} %0HT_sm% KWh NT: {m} %0NT_sm% KWh Monatsanfang: {m} %1sma% KWh HT: {m} %1HT_sma% KWh NT: {m} %1NT_sma% KWh Jahresanfang: {m} %0sya% KWh HT: {m} %0HT_sya% KWh NT: {m} %0NT_sya% KWh ............................. Tagesverbrauch: {m} %1sd% KWh HT: {m} %1HT_sd% KWh NT: {m} %1NT_sd% KWh Monatsverbrauch: {m} %0smn% KWh HT: {m} %0HT_smn% KWh NT: {m} %0NT_smn% KWh - Jahresverbrauch: {m} %0syn% KWh HT: {m} %0HT_syn% KWh 0:00 Uhr \u03a3 HT+NT: {m} %0sm% KWh HT: {m} %0HT_sm% KWh NT: {m} %0NT_sm% KWh Monatsanfang: {m} %1sma% KWh HT: {m} %1HT_sma% KWh NT: {m} %1NT_sma% KWh Jahresanfang: {m} %0sya% KWh HT: {m} %0HT_sya% KWh NT: {m} %0NT_sya% KWh ............................. Tagesverbrauch: {m} %1sd% KWh HT: {m} %1HT_sd% KWh NT: {m} %1NT_sd% KWh Monatsverbrauch: {m} %0smn% KWh HT: {m} %0HT_smn% KWh NT: {m} %0NT_smn% KWh - Jahresverbrauch: {m} %0syn% KWh HT: {m} %0HT_syn% KWh NT: {m} %0NT_syn% KWhNT: {m} %0NT_syn% KWh >M 1 +1,3,o,0,9600,,1 1,0.0.1(@1,Z\u00e4hlernummer,,Meter_number,0 1,0.9.1(@#),Zeitstempel,Uhr,time-stamp,0 1,=h=================== 1,1.8.0(@1,HT+NT Z\u00e4hlerstand,KWh,Total_in,3 1,1.8.1(@1,HT,KWh,HT_Total_in,3 1,1.8.2(@1,NT,KWh,NT_Total_in,3 1,=h=================== 1,36.7.0(@1,Power_L1,kW,kW_L1,2 1,56.7.0(@1,Power_L2,kW,kW_L2,2 1,76.7.0(@1,Power_L3,kW,kW_L3,2 1,16.7.0(@1,\u03a3_L1+L2+L3,kW,kW_L1+L2+L3,2 1,=h=================== 1,31.7.0(@1,Strom_L1,A,I_L1,2 1,51.7.0(@1,Strom_L2,A,I_L2,2 1,71.7.0(@1,Strom_L3,A,I_L3,2 #","title":"Landis + Gyr ZMR120AReS2R2sfCS (OBIS)"},{"location":"Smart-Meter-Interface/#logarex-lk13be-obis","text":"View script >D >B =>sensor53 r >M 1 +1,3,o,0,9600,LK13BE,13,30,2F3F210D0A,063035310D0A 1,1-0:1.8.0*255(@1,Gesamtverbrauch,KWh,total,4 1,1-0:1.8.0*96(@1,Verbrauch 1 Tag,KWh,total_1d,4 1,1-0:1.8.0*97(@1,Verbrauch 7 Tage,KWh,total_7d,4 1,1-0:1.8.0*98(@1,Verbrauch 30 Tage,KWh,total_30d,4 1,1-0:1.8.0*99(@1,Verbrauch 365 Tage,KWh,total_365d,4 1,1-0:16.7.0*255(@1,Verbrauch aktuell,W,current,20 #","title":"Logarex LK13BE (OBIS)"},{"location":"Smart-Meter-Interface/#logarex-lk13be-sml-eg-lk13be6067x9","text":"View script ``` D B ->sensor53 r M 1 +1,3,s,0,9600,LK13BE,1,10,2F3F210D0A,063035310D0A 1,77070100010800ff@1000,Gesamt kWh bezogen,kWh,Power_total_in,1 1,77070100020800ff@1000,Gesamt kWh geliefert,kWh,Power_total_out,1 1,77070100100700ff@1,Verbrauch aktuell,W,Power_curr,0 1,77070100240700ff@1,Power L1,W,Power_L1_curr,0 1,77070100380700ff@1,Power L2,W,Power_L2_curr,0 1,770701004C0700ff@1,Power L3,W,Power_L3_curr,0 1,77070100200700ff@1,Voltage L1,V,Volt_L1_curr,1 1,77070100340700ff@1,Voltage L2,V,Volt_L2_curr,1 1,77070100480700ff@1,Voltage L3,V,Volt_L3_curr,1 1,770701001f0700ff@1,Amperage L1,A,Amperage_L1_curr,2 1,77070100330700ff@1,Amperage L2,A,Amperage_L2_curr,2 1,77070100470700ff@1,Amperage L3,A,Amperage_L3_curr,2 1,770701000e0700ff@1,Frequency,Hz,HZ,2 1,77070100510704ff@1,Phaseangle I-L1/U-L1,deg,phase_angle_p1,1 1,7707010051070fff@1,Phaseangle I-L2/I-L2,deg,phase_angle_p2,1 1,7707010051071aff@1,Phaseangle I-L3/I-L3,deg,phase_angle_p3,1 1,77070100510701ff@1,Phase angle U-L2/U-L1,deg,phase_angle_l2_l1,1 1,77070100510702ff@1,Phase angle U-L3/U-L1,deg,phase_angle_l3_l1,1 # ```","title":"Logarex LK13BE (SML) (e.g. LK13BE6067x9)"},{"location":"Smart-Meter-Interface/#norax-3d-sml","text":"This script gives also the wattage per phase. Make sure to get the PIN from your grid operator! Tested on a WeMos D1 mini with an IR Head from https://agalakhov.github.io/ir-interface connected to the RX pin (3). The meter also outputs the phase angles, but i left them out since i do not need them. You can easily find additional values by activating the debug mode (\"sensor53 d1\" for the first meter, switch off after a few seconds with \"sensor53 d0\"). View script >D >B ->sensor53 r >M 1 +1,3,s,1,9600,SML 1,77070100010800ff@1000,Total consumption,KWh,Total_in,4 1,77070100020800ff@1000,Total Feed,KWh,Total_out,4 1,77070100100700ff@1,Current consumption,W,Power_curr,0 1,77070100200700ff@1,Voltage L1,V,Volt_p1,1 1,77070100340700ff@1,Voltage L2,V,Volt_p2,1 1,77070100480700ff@1,Voltage L3,V,Volt_p3,1 1,770701001f0700ff@1,Amperage L1,A,Amperage_p1,1 1,77070100330700ff@1,Amperage L2,A,Amperage_p2,1 1,77070100470700ff@1,Amperage L3,A,Amperage_p3,1 1,77070100240700ff@1,Current consumption L1,W,Power_curr_p1,0 1,77070100380700ff@1,Current consumption L2,W,Power_curr_p2,0 1,770701004c0700ff@1,Current consumption L3,W,Power_curr_p3,0 1,770701000e0700ff@1,Frequency,Hz,frequency,0 #","title":"Norax 3D+ (SML)"},{"location":"Smart-Meter-Interface/#peacefair-pzem004tv30-modbus","text":"PZEM004T V30 multiple meters on Modbus View script >D >B ->sensor53 r >M 1 +1,3,m,0,9600,ENERGY,1,1,02040000,02040001,02040003,02040005,02040007,02040008,03040000,03040001,03040003,03040005,03040007,03040008,05040000,05040001,05040003,05040005,05040007,05040008 1,=h<hr/>Sensor-1 1,020404UUuuxxxxxxxx@i0:10,Voltage,V,Sensor-1-V,2 1,020404UUuuUUuusxxxx@i1:1000,Current,A,Sensor-1-A,2 1,020404UUuuUUuusxxxx@i2:10,Power,W,Sensor-1-W,2 1,020404UUuuUUuusxxxx@i3:1000,Energy,kWh,Sensor-1-kWh,4 1,020404UUuuxxxxxxxx@i4:10,Frequency,Hz,Sensor-1-hz,2 1,020404UUuuxxxxxxxx@i5:100,Power Factor,PF,Sensor-1-PF,2 1,=h<hr/>Sensor-2 1,030404UUuuxxxxxxxx@i6:10,Voltage,V,Sensor-2-V,2 1,030404UUuuUUuusxxxx@i7:1000,Current,A,Sensor-2-A,2 1,030404UUuuUUuusxxxx@i8:10,Power,W,Sensor-2-W,2 1,030404UUuuUUuusxxxx@i9:1000,Energy,kWh,Sensor-2-kWh,4 1,030404UUuuxxxxxxxx@i10:10,Frequency,Hz,Sensor-2-hz,2 1,030404UUuuxxxxxxxx@i11:100,Power Factor,PF,Sensor-2-PF,2 1,=h<hr/>Sensor-5 1,050404UUuuxxxxxxxx@i12:10,Voltage,V,Sensor-05-V,2 1,050404UUuuUUuusxxxx@i13:1000,Current,A,Sensor-05-A,2 1,050404UUuuUUuusxxxx@i14:10,Power,W,Sensor-05-W,2 1,050404UUuuUUuusxxxx@i15:1000,Energy,kWh,Sensor-05-kWh,4 1,050404UUuuxxxxxxxx@i16:10,Frequency,Hz,Sensor-05-hz,2 1,050404UUuuxxxxxxxx@i17:100,Power Factor,PF,Sensor-05-PF,2 #","title":"Peacefair PZEM004TV30 (MODBUS)"},{"location":"Smart-Meter-Interface/#resol-deltasol-bs-plus-vbus","text":"This is a controller for standard solar thermal systems equipped with VBus data interface. Outputs data every second at 9600 baud 8N1. To connect to this and read data from the bus a level shifting is needed as the voltage is around 8V. Although this is a symmetric connection supporting long wires for our purposes it's enough to measure its polarity with a voltmeter and adapt the level appropriately to 3.3V using the below circuit (many others exist but this is simple and works). Do not connect the GND pin of Wemos with the ground of Resol unit as that may damage the output port of it. The Wemos module needs its own power supply (double insulated recommended). The script (compile firmware with SML_REPLACE_VARS ) >D r=\"1,AA100021421000010774\" >B =>sensor53 r >M 1 +1,3,v,0,9600,Solar %r%vo12ut@#,time,,zeit,1 %r%vo0sw@10,S1 COL,\u00b0C,sens1,1 %r%vo2sw@10,S2 TST1,\u00b0C,sens2,1 %r%vo4sw@10,S3 TST2,\u00b0C,sens3,1 %r%vo6sw@10,S4 TR,\u00b0C,sens4,1 %r%vo10ub@b0:1,R1 PUMP,,relay1,0 %r%vo10ub@b1:1,R2 VALVE,,relay2,0 %r%vo8ub@1,Pump1 speed,%%,pump1,0 %r%vo9ub@1,Pump2 speed,%%,pump2,0 %r%vo20uw@1,p1,Wh,p1,0 %r%vo22uw@1,p1000,Wh,p2,0 %r%vo24uw@1,p1000000,Wh,p3,0 %r%vo15ub@b0:1,Col Max,,col1,0 %r%vo15ub@b1:1,Col Min,,col2,0 %r%vo15ub@b2:1,Col Frost,,col3,0 %r%vo15ub@b3:1,Col Opt,,col4,0 %r%vo15ub@b4:1,Col Rueck,,col5,0 %r%vo15ub@b5:1,Col WMZ,,col6,0 #","title":"Resol Deltasol BS Plus (VBus)"},{"location":"Smart-Meter-Interface/#sanxing-sx6x1-sxxu1x-ascii-obis","text":"Tested on SX631 (S34U18). Needs an RJ12 cable and a small adaptor circuit: (Note how power for the Wemos module is drawn directly from the meter. No external power supply needed) This meter sends bursts of data at 115200 baud every 10 seconds. Some data lines exceed 1038 characters. To adapt to these conditions, compile firmware with: #define SML_MAX_VARS 60 #define SML_BSIZ 1060 #define MAX_METERS 1 #define TMSBSIZ 2048 #define USE_SML_SCRIPT_CMD #define SML_REPLACE_VARS View script >D r=\"1,0-0:98.1.0(@(\" ;use a variable to store the decode string >B smlj=0 ;don't send teleperiod MQTT at boot, because we can have 0 values (meter didn't send data yet) ->sensor53 r >R smlj=0 ;don't send teleperiod MQTT at script restart, because we can have 0 values (meter didn't send data yet) >S if upsecs>22 then smlj=1 endif ;only send teleperiod MQTT if 22 seconds passed since boot (during this time meter most probably sent data) >M 1 +1,3,o,16,115200,Name,1 1,1-0:32.7.0(@1,L1 Voltage,V,volts_l1,1 1,1-0:52.7.0(@1,L2 Voltage,V,volts_l2,1 1,1-0:72.7.0(@1,L3 Voltage,V,volts_l3,1 1,1-0:14.7.0(@1,Frequency,Hz,freq,2 1,0-0:96.14.0(@1,Current tariff,,tariff,0 1,=h<hr/> 1,1-0:1.8.0(@1,Energy import,kWh,enrg_imp,3 1,1-0:2.8.0(@1,Energy export,kWh,enrg_exp,3 1,1-0:1.8.1(@1,Energy import T1,kWh,enrg_imp_t1,3 1,1-0:1.8.2(@1,Energy import T2,kWh,enrg_imp_t2,3 1,1-0:2.8.1(@1,Energy export T1,kWh,enrg_exp_t1,3 1,1-0:2.8.2(@1,Energy export T2,kWh,enrg_exp_t2,3 1,1-0:1.7.0(@1,Power import,kW,pwr_imp,3 1,1-0:2.7.0(@1,Power export,kW,pwr_exp,3 1,1-0:13.7.0(@1,Power factor,,factor,3 1,=h<hr/> 1,1-0:3.8.0(@1,Reactive nrg import,kvarh,nrg_reac_imp,3 1,1-0:4.8.0(@1,Reactive nrg export,kvarh,nrg_reac_exp,3 1,1-0:5.8.0(@1,Reactive energy QI,kvarh,nrg_reac_q1,3 1,1-0:6.8.0(@1,Reactive energy QII,kvarh,nrg_reac_q2,3 1,1-0:7.8.0(@1,Reactive energy QIII,kvarh,nrg_reac_q3,3 1,1-0:8.8.0(@1,Reactive energy QIV,kvarh,nrg_reac_q4,3 1,1-0:5.7.0(@1,Reactive power QI,kvar,pwr_reac_q1,3 1,1-0:6.7.0(@1,Reactive power QII,kvar,pwr_reac_q2,3 1,1-0:7.7.0(@1,Reactive power QIII,kvar,pwr_reac_q3,3 1,1-0:8.7.0(@1,Reactive power QIV,kvar,pwr_reac_q4,3 1,=h<hr/> 1,=hPrevious month stats: %r%1:1,Energy import,kWh,mo_enrg_imp,3 %r%2:1,Energy import T1,kWh,mo_enrg_impt1,3 %r%3:1,Energy import T2,kWh,mo_enrg_impt2,3 %r%4:1,Energy export,kWh,mo_enrg_exp,3 %r%5:1,Energy export T1,kWh,mo_enrg_expt1,3 %r%6:1,Energy export T2,kWh,mo_enrg_expt2,3 %r%7:1,Reactive nrg import,kvarh,mo_nrg_reac_imp,3 %r%8:1,Reactive nrg export,kvarh,mo_nrg_reac_exp,3 %r%9:1,Reactive energy QI,kvarh,mo_nrg_reac_q1,3 %r%10:1,Reactive energy QII,kvarh,mo_nrg_reac_q2,3 %r%11:1,Reactive energy QIII,kvarh,mo_nrg_reac_q3,3 %r%12:1,Reactive energy QIV,kvarh,mo_nrg_reac_q4,3 %r%13:1,Reactive energy SUM?,kvarh,mo_nrg_reac_sum,3 %r%14:1,Peak power import L1,kW,mo_pw_pk_in_l1,3 %r%15:1,Peak power import L2,kW,mo_pw_pk_in_l2,3 %r%16:1,Peak power import L3,kW,mo_pw_pk_in_l3,3 %r%17:1,Peak power export L1,kW,mo_pw_pk_ex_l1,3 %r%18:1,Peak power export L2,kW,mo_pw_pk_ex_l2,3 %r%19:1,Peak power export L3,kW,mo_pw_pk_ex_l3,3 # Sample data /1234567890123 0-0:1.0.0(202056789012W) 0-0:42.0.0(AUX1234567890123) 0-0:96.1.0(1234567890) 0-0:96.14.0(0001) 0-0:96.50.68(ON) 0-0:17.0.0(90.000*kW) 1-0:1.8.0(000258.072*kWh) 1-0:1.8.1(000103.782*kWh) 1-0:1.8.2(000154.290*kWh) 1-0:1.8.3(000000.000*kWh) 1-0:1.8.4(000000.000*kWh) 1-0:2.8.0(000048.367*kWh) 1-0:2.8.1(000032.813*kWh) 1-0:2.8.2(000015.554*kWh) 1-0:2.8.3(000000.000*kWh) 1-0:2.8.4(000000.000*kWh) 1-0:3.8.0(000003.513*kvarh) 1-0:4.8.0(000156.910*kvarh) 1-0:5.8.0(000003.498*kvarh) 1-0:6.8.0(000000.015*kvarh) 1-0:7.8.0(000027.718*kvarh) 1-0:8.8.0(000129.192*kvarh) 1-0:15.8.0(000306.440*kWh) 1-0:32.7.0(233.0*V) 1-0:52.7.0(230.6*V) 1-0:72.7.0(228.7*V) 1-0:31.7.0(002*A) 1-0:51.7.0(002*A) 1-0:71.7.0(001*A) 1-0:13.7.0(0.758) 1-0:33.7.0(0.615) 1-0:53.7.0(0.746) 1-0:73.7.0(0.937) 1-0:14.7.0(49.98*Hz) 1-0:1.7.0(00.000*kW) 1-0:2.7.0(00.854*kW) 1-0:5.7.0(00.000*kvar) 1-0:6.7.0(00.000*kvar) 1-0:7.7.0(00.735*kvar) 1-0:8.7.0(00.000*kvar) 0-0:98.1.0(210301000000W)(000249.070*kWh)(000100.816*kWh)(000148.254*kWh)(000047.903*kWh)(000032.349*kWh)(000015.554*kWh)(000003.513*kvarh)(000150.665*kvarh)(000003.498*kvarh)(000000.015*kvarh)(000027.119*kvarh)(000123.546*kvarh)(000296.974*kWh)(04.872*kW)(04.872*kW)(04.072*kW)(01.844*kW)(01.672*kW)(01.844*kW) 0-0:96.13.0(\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd) !DA6A","title":"Sanxing SX6x1 (SxxU1x) (Ascii OBIS)"},{"location":"Smart-Meter-Interface/#sbc-ale3-modbus","text":"View script >DH >B ->sensor53 r >M 1 +1,3,M,1,9600,SBC,1,1,02030023,02030028,0203002d,02030025,0203002a,0203002f,02030032,02030027,0203002c,02030031,02030021,02030015,02030018 1,020304UUuu@i0:1,Spannung L1,V,Voltage_L1,0 1,020304UUuu@i1:1,Spannung L2,V,Voltage_L2,0 1,020304UUuu@i2:1,Spannung L3,V,Voltage_L3,0 1,020304xxxxUUuu@i0:10,Strom L1,A,Current_L1,2 1,020304xxxxUUuu@i1:10,Strom L2,A,Current_L2,2 1,020304xxxxUUuu@i2:10,Strom L3,A,Current_L3,2 1,=h= 1,020304UUuu@i3:100,Leistung L1,kW,Power_L1,3 1,020304UUuu@i4:100,Leistung L2,kW,Power_L2,3 1,020304UUuu@i5:100,Leistung L3,kW,Power_L3,3 1,020304UUuu@i6:100,Leistung Total,kW,Power_Total,3 1,020304xxxxSSss@i3:100,BlindLeistung L1,kVAr,ReaktivePower_L1,3 1,020304xxxxSSss@i4:100,BlindLeistung L2,kVAr,ReaktivePower_L2,3 1,020304xxxxSSss@i5:100,BlindLeistung L3,kVAr,ReaktivePower_L3,3 1,020304xxxxSSss@i6:100,BLeistung Total,kVAr,ReaktivePower_Total,3 1,=h= 1,020304UUuu@i7:100,CosPhi L1,,CosPhi_L1,2 1,020304UUuu@i8:100,CosPhi L2,,CosPhi_L2,2 1,020304UUuu@i9:100,CosPhi L3,,CosPhi_L3,2 1,=h= 1,020304UUuuUUuu@i10:100,T2 Wert,kWh,T2_Value,2 #","title":"SBC ALE3 (MODBus)"},{"location":"Smart-Meter-Interface/#sbc-ale3-2x-modbus","text":"View script >D >B ->sensor53 r >M 1 +1,3,M,1,9600,Meter,1,1,01030023,01030028,0103002d,01030025,0103002a,0103002f,01030032,01030027,0103002c,01030031,0103001B,0103001d,03030023,03030028,0303002d,03030025,0303002a,0303002f,03030032,03030027,0303002c,03030031,0303001B,0303001d 1,=h Domestic Electricity: 1,010304UUuuUUuu@i10:100,1 Tariff 1 total,kWh,M1_T1_total,2 1,010304UUuuUUuu@i11:100,1 Tariff 1 partial,kWh,M1_T1_par,2 1,=h Readings: 1,010304UUuu@i0:1,1 Voltage L1,V,M1_Voltage_L1,0 1,010304UUuu@i1:1,1 Voltage L2,V,M1_Voltage_L2,0 1,010304UUuu@i2:1,1 Voltage L3,V,M1_Voltage_L3,0 1,010304xxxxUUuu@i0:10,1 Current L1,A,M1_Current_L1,2 1,010304xxxxUUuu@i1:10,1 Current L2,A,M1_Current_L2,2 1,010304xxxxUUuu@i2:10,1 Current L3,A,M1_Current_L3,2 1,010304UUuu@i3:100,1 Active Power L1,kW,M1_PRMS_L1,3 1,010304UUuu@i4:100,1 Active Power L2,kW,M1_PRMS_L2,3 1,010304UUuu@i5:100,1 Active Power L3,kW,M1_PRMS_L3,3 1,010304UUuu@i6:100,1 Active Power total,kW,M1_PRMS_total,3 1,010304xxxxSSss@i3:100,1 Reactive Power L1,kVAr,M1_QRMS_L1,3 1,010304xxxxSSss@i4:100,1 Reactive Power L2,kVAr,M1_QRMS_L2,3 1,010304xxxxSSss@i5:100,1 Reactive Power L3,kVAr,M1_QRMS_L3,3 1,010304xxxxSSss@i6:100,1 Reactive Power total,kVAr,M1_QRMS_total,3 1,010304UUuu@i7:100,1 CosPhi L1,,M1_CosPhi_L1,2 1,010304UUuu@i8:100,1 CosPhi L2,,M1_CosPhi_L2,2 1,010304UUuu@i9:100,1 CosPhi L3,,M1_CosPhi_L3,2 1,=h________________________________________________ ; meter 2 +12 offset 1,=h Heat Pump 1,030304UUuuUUuu@i22:100,2 Tariff 1 total,kWh,M2_T1_total,2 1,030304UUuuUUuu@i23:100,2 Tariff 1 partial,kWh,M2_T1_par,2 1,=h Readings: 1,030304UUuu@i12:1,2 Voltage L1,V,M2_Voltage_L1,0 1,030304UUuu@i13:1,2 Voltage L2,V,M2_Voltage_L2,0 1,030304UUuu@i14:1,2 Voltage L3,V,M2_Voltage_L3,0 1,030304xxxxUUuu@i12:10,2 Current L1,A,M2_Current_L1,2 1,030304xxxxUUuu@i13:10,2 Current L2,A,M2_Current_L2,2 1,030304xxxxUUuu@i14:10,2 Current L3,A,M2_Current_L3,2 1,030304UUuu@i15:100,2 Active Power L1,kW,M2_PRMS_L1,3 1,030304UUuu@i16:100,2 Active Power L2,kW,M2_PRMS_L2,3 1,030304UUuu@i17:100,2 Active Power L3,kW,M2_PRMS_L3,3 1,030304UUuu@i18:100,2 Active Power total,kW,M2_PRMS_total,3 1,030304xxxxSSss@i15:100,2 Reactive Power L1,kVAr,M2_QRMS_L1,3 1,030304xxxxSSss@i16:100,2 Reactive Power L2,kVAr,M2_QRMS_L2,3 1,030304xxxxSSss@i16:100,2 Reactive Power L3,kVAr,M2_QRMS_L3,3 1,030304xxxxSSss@i18:100,2 Reactive Power total,kVAr,M2_QRMS_total,3 1,030304UUuu@i19:100,2 CosPhi L1,,M2_CosPhi_L1,2 1,030304UUuu@i20:100,2 CosPhi L2,,M2_CosPhi_L2,2 1,030304UUuu@i21:100,2 CosPhi L3,,M2_CosPhi_L3,2 #","title":"SBC ALE3 2x (MODBus)"},{"location":"Smart-Meter-Interface/#sdm230-modbus","text":"View script >D ms=\"1,010404ffffffff@\" >B ->sensor53 r >M 1 +1,3,m,0,9600,PV,1,2,01040000,01040006,0104000C,01040012,01040018,0104001E,01040024,01040046,01040048,0104004A,0104004C,0104004E,01040054,01040056,01040058,0104005A,0104005C,0104005E,01040102,01040108,01040152,01040158,01040180,01040182 %ms%i0:1,Volt,V,Volt,2 %ms%i1:1,Strom P1,A,Strom,3 %ms%i2:1,*,W,Leistung,2 %ms%i3:1,Scheinleistung,VA,ScheinLeistung,2 %ms%i4:1,Blindleistung,VAr,Blindleistung,2 %ms%i5:1,P-Faktor,,P_Faktor,1 %ms%i6:1,cosPhi,\u00b0,cosPhi,2 %ms%i7:1,Frequenz,Hz, Frequenz,1 %ms%i8:1,Wirkleistung Import,kWh,Wirkleistung_Im1,3 %ms%i9:1,Wirkleistung Export,kWh,Wirkleistung_Ex,3 %ms%i10:1,Blindleistung Import,VkkVARh,Blindleistung_Im,3 %ms%i11:1,Blindleistung Export,VkkVARh,Blindleistung_Ex,3 %ms%i12:1,Gesamtleistungsbedarf,W,GesLeistBed,2 %ms%i13:1,GesamtLeistung Max,W,GesLeistMax,2 %ms%i14:1,Akt.Nachfrage,W,AktNachfrage,2 %ms%i15:1,R\u00fcckleistungs Bed,W,RueckLeistBed,2 %ms%i16:1,R\u00fcckleistungs Bed Max,W,RueckLeistBedMax,2 %ms%i17:1,Strom Nachfrage,A,StromNachfrage2,2 %ms%i19:1,Max Strombedarf,A,StromBedMax,2 %ms%i20:1,Wirkleistung Gesamt,kWh,Wirkleistung_total,2 %ms%i21:1,Blindleistung Gesamt,kVARh,Blindleistung_total,2 %ms%i22:1,Temp Gesamtleistung,kWh,TempGesamtLeist,2 #","title":"SDM230 (MODBus)"},{"location":"Smart-Meter-Interface/#sdm530-modbus","text":"View script >D >B ->sensor53 r >M 1 +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 1,010404ffffffff@i0:1,Voltage P1,V,Voltage_P1,2 1,010404ffffffff@i1:1,Voltage P2,V,Voltage_P2,2 1,010404ffffffff@i2:1,Voltage P3,V,Voltage_P3,2 1,010404ffffffff@i3:1,Current P1,A,Current_P1,2 1,010404ffffffff@i4:1,Current P2,A,Current_P2,2 1,010404ffffffff@i5:1,Current P3,A,Current_P3,2 1,010404ffffffff@i6:1,Active Power P1,W,Power_P1,2 1,010404ffffffff@i7:1,Active Power P2,W,Power_P2,2 1,010404ffffffff@i8:1,Active Power P3,W,Power_P3,2 #","title":"SDM530 (MODBus)"},{"location":"Smart-Meter-Interface/#trovis-557x-modbus","text":"These heating regulators have a lot of registers . View script >D >B ->sensor53 r >M 1 +1,3,m,0,19200,Trovis,1,2,rF7030009000E,rF703001C0004,F703006A 1,F7031CSSss@i0:10,Au\u00dfentemp.,\u00b0C,Temp_Outside,1 1,F7031CxxxxxxxxxxxxSSss@i0:10,Vorlauftemp.,\u00b0C,Temp_Flow,1 1,F7031CxxxxxxxxxxxxxxxxxxxxxxxxxxxxSSss@i0:10,R\u00fccklauftemp.,\u00b0C,Temp_Return,1 1,F7031CxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxSSss@i0:10,Speichertemp.,\u00b0C,Temp_Vessel,1 1,F70308UUuu@i1:1,MesswertImp-h,imp/h,Metric_ImpH,0 1,F70308xxxxUUuu@i1:100,Messwertm3-h,m\u00b3/h,Metric_M3H,2 1,F70308xxxxxxxxUUuu@i1:10,AA10-10V,V,Metric_AA10,1 1,F70308xxxxxxxxxxxxUUuu@i1:10,AA20-10V,V,Metric_AA20,1 1,F70304UUuu@i2:1,StellsignalRk1,%,CtrlSig_RK1,0 #","title":"Trovis 557x (MODBus)"},{"location":"Smart-Meter-Interface/#wolf-csz-11300-heater-ebus","text":"View script >D >B ->sensor53 r >M 1 +1,3,e,0,2400,EBUS 1,xxxx0503xxxxxxxxxxxxxxxxss@1,Outside temperature,C,Outsidetemp,0 1,xxxx5014xxxxxxxxxxuu@1,Romm temperature,C,Roomtemp,0 1,xxxx0503xxxxxxxxxxxxxxuu@1,Warmwater,C,Warmwater,0 1,xxxx0503xxxxxxxxxxuu@1,Boiler,C,Boiler,0 1,03fe0503xxxxxxxxxxxxuu@1,Returns,C,Returns,0 1,03fe0503xxxxuu@1,Status,,Status,0 1,03fe0503xxxxxxuu@b3:1,Burner on,,Burner,0 1,xxxx5017xxxxxxuuuu@16,Solar collektor,C,Collector,1 1,xxxx5017xxxxxxxxxxuuuu@16,Solar storage,C,Solarstorage,1 1,xxxx5017xxuu@b0:1,Solar pump on,,Solarpump,0 #","title":"WOLF CSZ 11/300 Heater (EBus)"},{"location":"SolaX-X1/","text":"SolaX Power - Single phase string inverter X1 ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : ```arduino ifndef USE_SOLAX_X1 ~ define USE_SOLAX_X1 ~ // Change serial speed from the default value of 9600: #define SOLAXX1_SPEED 9600 // Solax X1 Modbus RS485 serial speed (default: 9600 baud) // If your inverter has two PV-inputs, you can activate the 2nd one: #define SOLAXX1_PV2 // Solax X1 using second PV endif ~ ``` General ~ This module reads runtime values from a Solax X1 device via RS485 Modbus interface and publishes them to MQTT. Wiring ~ To connect the inverter to the Tasmota-device, you have to use a breakout board to adapt the RS485 interface of the inverter to serial interface of the ESP. Breakout boards ~ There are many RS485-to-TTL modules, aka breakout boards, available. They may work or not. You should have attention on the operation voltage. The ESP-devices work with 3 volts. Because of that be carefull experimenting with 5 volts. In the best case nothing works. In the worst case it will destroy your ESP or breakout board. Here are two examples of tested breakout boards. Recommended is a board with a SP3485 chip, because it is designed for operating at 3 volts. SP3485 ~ The SP3485 breakout board is specially made to work with only 3 volts. It has a seperate RTS-pin and works with a voltage from 3 to 5 volts. HW-0519 ~ The HW-0519 breakout board does not need a seperate RTS-pin, because it automatically switches between sending and receiving. The recommended voltage is 5 volts, but it should also work with 3 volts. ESP \u2b0c breakout board ~ The RX-, TX- and RTS- (if needed) lines have to be connected to the ESP matching the module configuration . ESP SP3485 HW-0519 3.3V 3-5V VCC GND GND GND RX TX-O TXD TX RX-I RXD RTS RTS - Breakout board \u2b0c inverter ~ The RS485 interface is a 2-wire-connection. The wires are called A+ and B- . The big advantage of the interface is, beside of needing only two wires, that it can reach a length up to 1200 meters. The inverter has a RJ45-jack, where the interface is accessible. Please consult the manual of your inverter where it is located. Tip: You can use an ethernet cable and cut off one connector. The RS485 interface uses the blue wire pair. Breakout board RJ45 inverter Wire color (T568B) A (+) Pin 4 blue B (-) Pin 5 blue-white G / Ground Pin 7 brown-white Info In many cases two wires are enough to keep it working without errors. When your environment has electrical interferences or your cable is quiet long, you should use a third wire to establish a common signal reference. This wire has to be connected to the Ground pins. Configuration ~ You have to configure the module or the template. Select SolaxX1 Tx and SolaxX1 Rx for the RS485 communication. If you have a breakout board which needs the RTS line, you must also select SolaxX1 RTS . Operation ~ Result ~ When every thing works you will see the current data on the main page. They are also provided via MQTT. Tip To send a MQTT telemetry message immediately on every change of power, you can set a PowerDelta value. E.g. PowerDelta 101 for every change of at least 1 W. Inverter status ~ The inverter status field represents the value reported by the inverter, when the inverter is sending data. In the case when no data is received, it will be display off . As the converter is only working, when the sun is shining , you will see off normally at night or too low light. Tip When the inverter is working and off is displayed, so you have to check your hard- and software setup. Communcation protocol ~ The communication of this module is based on the description of the communication protocol version 1.7 .","title":"SolaX X1"},{"location":"SolaX-X1/#solax-power-single-phase-string-inverter-x1","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : ```arduino","title":"SolaX Power - Single phase string inverter X1"},{"location":"SolaX-X1/#ifndef-use_solax_x1","text":"","title":"ifndef USE_SOLAX_X1"},{"location":"SolaX-X1/#define-use_solax_x1","text":"// Change serial speed from the default value of 9600: #define SOLAXX1_SPEED 9600 // Solax X1 Modbus RS485 serial speed (default: 9600 baud) // If your inverter has two PV-inputs, you can activate the 2nd one: #define SOLAXX1_PV2 // Solax X1 using second PV","title":"define USE_SOLAX_X1"},{"location":"SolaX-X1/#endif","text":"```","title":"endif"},{"location":"SolaX-X1/#general","text":"This module reads runtime values from a Solax X1 device via RS485 Modbus interface and publishes them to MQTT.","title":"General"},{"location":"SolaX-X1/#wiring","text":"To connect the inverter to the Tasmota-device, you have to use a breakout board to adapt the RS485 interface of the inverter to serial interface of the ESP.","title":"Wiring"},{"location":"SolaX-X1/#breakout-boards","text":"There are many RS485-to-TTL modules, aka breakout boards, available. They may work or not. You should have attention on the operation voltage. The ESP-devices work with 3 volts. Because of that be carefull experimenting with 5 volts. In the best case nothing works. In the worst case it will destroy your ESP or breakout board. Here are two examples of tested breakout boards. Recommended is a board with a SP3485 chip, because it is designed for operating at 3 volts.","title":"Breakout boards"},{"location":"SolaX-X1/#esp-breakout-board","text":"The RX-, TX- and RTS- (if needed) lines have to be connected to the ESP matching the module configuration . ESP SP3485 HW-0519 3.3V 3-5V VCC GND GND GND RX TX-O TXD TX RX-I RXD RTS RTS -","title":"ESP \u2b0c breakout board"},{"location":"SolaX-X1/#breakout-board-inverter","text":"The RS485 interface is a 2-wire-connection. The wires are called A+ and B- . The big advantage of the interface is, beside of needing only two wires, that it can reach a length up to 1200 meters. The inverter has a RJ45-jack, where the interface is accessible. Please consult the manual of your inverter where it is located. Tip: You can use an ethernet cable and cut off one connector. The RS485 interface uses the blue wire pair. Breakout board RJ45 inverter Wire color (T568B) A (+) Pin 4 blue B (-) Pin 5 blue-white G / Ground Pin 7 brown-white Info In many cases two wires are enough to keep it working without errors. When your environment has electrical interferences or your cable is quiet long, you should use a third wire to establish a common signal reference. This wire has to be connected to the Ground pins.","title":"Breakout board \u2b0c inverter"},{"location":"SolaX-X1/#configuration","text":"You have to configure the module or the template. Select SolaxX1 Tx and SolaxX1 Rx for the RS485 communication. If you have a breakout board which needs the RTS line, you must also select SolaxX1 RTS .","title":"Configuration"},{"location":"SolaX-X1/#operation","text":"","title":"Operation"},{"location":"SolaX-X1/#result","text":"When every thing works you will see the current data on the main page. They are also provided via MQTT. Tip To send a MQTT telemetry message immediately on every change of power, you can set a PowerDelta value. E.g. PowerDelta 101 for every change of at least 1 W.","title":"Result"},{"location":"SolaX-X1/#inverter-status","text":"The inverter status field represents the value reported by the inverter, when the inverter is sending data. In the case when no data is received, it will be display off . As the converter is only working, when the sun is shining , you will see off normally at night or too low light. Tip When the inverter is working and off is displayed, so you have to check your hard- and software setup.","title":"Inverter status"},{"location":"SolaX-X1/#communcation-protocol","text":"The communication of this module is based on the description of the communication protocol version 1.7 .","title":"Communcation protocol"},{"location":"Sonoff-DIY/","text":"Some new Sonoff devices support the new Itead DIY architecture which allows OTA firmware upload. With Sonoff DIY , a user has more control over the hardware features of the device and also allows for upgrading the firmware without additional hardware. The following procedure upgrades Sonoff eWelink firmware to Tasmota. There are many reports this procedure has changed with newer versions of Sonoff DIY Tasmota does not provide any kind of support for flashing using this method. Please contact Sonoff Support for help. IMPORTANT: There are some reports suggesting that the Windows version of Sonoff DIY Tool contains a trojan. It is not clear if it actually contains the malicious code or these are just false positives due to the way Python code was converted to native executables. Nevertheless, proceed with care. Compatible devices ~ Currently the following devices officially support Sonoff DIY: - Sonoff Basic R3 - Sonoff RF R3 - Sonoff Mini As Sonoff DIY is enabled by connecting GPIO16 to GND it may well be possible that other Sonoff devices running eWelink will support it. Note The OTA process Sonoff provides through the Sonoff DIY procedure does not create a backup of the Itead firmware on the device. If you use this OTA method to flash Tasmota on the Sonoff device, you will not be able to revert to the original factory firmware. Flash procedure ~ Guide originally from @Brunas Pair the device with the eWeLink app and update firmware. The wifi network you connect to during this step will need to be reachable in order to enter DIY mode. Follow instructions how to enter DIY mode from Sonoff . This is the excerpt from it: Long press the button for 5 seconds to enter pairing mode, then press another 5 seconds to ender Compatible Pairing Mode (AP). The LED indicator should blink continuously. From mobile phone or PC WiFi setting, an Access Point of the device named ITEAD-XXXXXXXX will be found, connect it with default password 12345678 Open the browser and access http://10.10.7.1/ Next, Fill in WiFi SSID and password. Once successfully connected, the device is in DIY mode. Note: I needed to manually change IP address to 10.10.7.2, 255.0.0.0 with gateway 10.10.7.1 in adapter TCP/IPv4 settings to access that IP address. Use Fing or any similar local network scanning app on your smartphone or PC to find IP address of your Sonoff Mini device. MAC Vendor most likely is Espressif and the device has 8081 port open. Check that diy mode is working properly. With curl: curl -XPOST --header \"Content-Type: application/json\" --data-raw '{\"deviceid\": \"\", \"data\": {}}' http:// $SONOFF_IP :8081/zeroconf/info Or with the Rester browser extension: Install **Rester** extension in Chrome or Firefox or any other preferred tool to perform REST API operations. To test your device DIY mode create new request in **Rester**: 1. Method: **POST** 2. URL: http:// < *IP of your device*>:8081/zeroconf/info 3. Body: `{\"data\": {}}` 4. You might need to add Header **Content-Type** with value **application/json** 5. Press **SEND** If all is OK, status code 200 should be returned with bunch of data: { \"seq\" : 1 , \"error\" : 0 , \"data\" : { \"switch\" : \"off\" , \"startup\" : \"off\" , \"pulse\" : \"off\" , \"pulseWidth\" : 2000 , \"ssid\" : \"YourWiFi\" , \"otaUnlock\" : false , \"fwVersion\" : \"3.6.0\" , \"deviceid\" : \"YourDeviceId\" , \"bssid\" : \"YourBSSId\" , \"signalStrength\" : -52 } } If that doesn't return 200 , try going back to 5s+5s reset above. 4. If all above works, let's unlock OTA: With curl: curl -XPOST --header \"Content-Type: application/json\" --data-raw '{\"deviceid\": \"\", \"data\": {}}' http:// $SONOFF_IP :8081/zeroconf/ota_unlock Or with the Rester browser extension: 1. Method: **POST** 2. URL: http:// < *IP of your device*>:8081/zeroconf/ota_unlock 3. Body: `{\"data\": {}}` 4. You might need to add Header **Content-Type** with value **application/json** 5. Press **SEND** 6. You should get status code *200* Optionally for curiousity you could retry info query to check if otaUnlock value now is true 5. Download the appropriate binary from http://ota.tasmota.com/tasmota/release and flash it. NOTE: The maximum firmware size is 508kb, which precludes the standard release binary. Absolutely do not use tasmota-minimal at this stage, this would brick your device. There are a number of reported issues with the stock firmware's OTA behavior, so it may be easier to use an existing server that works around these issues. For example: curl -XPOST --data \"{\\\"deviceid\\\":\\\"\\\",\\\"data\\\":{\\\"downloadUrl\\\": \\\"http://sonoff-ota.aelius.com/tasmota-latest-lite.bin\\\", \\\"sha256sum\\\": \\\" $HASH \\\"} }\" http:// $SONOFF_IP :8081/zeroconf/ota_flash You're now ready to configure tasmota . Video tutorials ~ Andreas Spiess DrZzs Paul Hibbert More info: ~ Michel Deslierres","title":"Sonoff DIY"},{"location":"Sonoff-DIY/#compatible-devices","text":"Currently the following devices officially support Sonoff DIY: - Sonoff Basic R3 - Sonoff RF R3 - Sonoff Mini As Sonoff DIY is enabled by connecting GPIO16 to GND it may well be possible that other Sonoff devices running eWelink will support it. Note The OTA process Sonoff provides through the Sonoff DIY procedure does not create a backup of the Itead firmware on the device. If you use this OTA method to flash Tasmota on the Sonoff device, you will not be able to revert to the original factory firmware.","title":"Compatible devices"},{"location":"Sonoff-DIY/#flash-procedure","text":"Guide originally from @Brunas Pair the device with the eWeLink app and update firmware. The wifi network you connect to during this step will need to be reachable in order to enter DIY mode. Follow instructions how to enter DIY mode from Sonoff . This is the excerpt from it: Long press the button for 5 seconds to enter pairing mode, then press another 5 seconds to ender Compatible Pairing Mode (AP). The LED indicator should blink continuously. From mobile phone or PC WiFi setting, an Access Point of the device named ITEAD-XXXXXXXX will be found, connect it with default password 12345678 Open the browser and access http://10.10.7.1/ Next, Fill in WiFi SSID and password. Once successfully connected, the device is in DIY mode. Note: I needed to manually change IP address to 10.10.7.2, 255.0.0.0 with gateway 10.10.7.1 in adapter TCP/IPv4 settings to access that IP address. Use Fing or any similar local network scanning app on your smartphone or PC to find IP address of your Sonoff Mini device. MAC Vendor most likely is Espressif and the device has 8081 port open. Check that diy mode is working properly. With curl: curl -XPOST --header \"Content-Type: application/json\" --data-raw '{\"deviceid\": \"\", \"data\": {}}' http:// $SONOFF_IP :8081/zeroconf/info Or with the Rester browser extension: Install **Rester** extension in Chrome or Firefox or any other preferred tool to perform REST API operations. To test your device DIY mode create new request in **Rester**: 1. Method: **POST** 2. URL: http:// < *IP of your device*>:8081/zeroconf/info 3. Body: `{\"data\": {}}` 4. You might need to add Header **Content-Type** with value **application/json** 5. Press **SEND** If all is OK, status code 200 should be returned with bunch of data: { \"seq\" : 1 , \"error\" : 0 , \"data\" : { \"switch\" : \"off\" , \"startup\" : \"off\" , \"pulse\" : \"off\" , \"pulseWidth\" : 2000 , \"ssid\" : \"YourWiFi\" , \"otaUnlock\" : false , \"fwVersion\" : \"3.6.0\" , \"deviceid\" : \"YourDeviceId\" , \"bssid\" : \"YourBSSId\" , \"signalStrength\" : -52 } } If that doesn't return 200 , try going back to 5s+5s reset above. 4. If all above works, let's unlock OTA: With curl: curl -XPOST --header \"Content-Type: application/json\" --data-raw '{\"deviceid\": \"\", \"data\": {}}' http:// $SONOFF_IP :8081/zeroconf/ota_unlock Or with the Rester browser extension: 1. Method: **POST** 2. URL: http:// < *IP of your device*>:8081/zeroconf/ota_unlock 3. Body: `{\"data\": {}}` 4. You might need to add Header **Content-Type** with value **application/json** 5. Press **SEND** 6. You should get status code *200* Optionally for curiousity you could retry info query to check if otaUnlock value now is true 5. Download the appropriate binary from http://ota.tasmota.com/tasmota/release and flash it. NOTE: The maximum firmware size is 508kb, which precludes the standard release binary. Absolutely do not use tasmota-minimal at this stage, this would brick your device. There are a number of reported issues with the stock firmware's OTA behavior, so it may be easier to use an existing server that works around these issues. For example: curl -XPOST --data \"{\\\"deviceid\\\":\\\"\\\",\\\"data\\\":{\\\"downloadUrl\\\": \\\"http://sonoff-ota.aelius.com/tasmota-latest-lite.bin\\\", \\\"sha256sum\\\": \\\" $HASH \\\"} }\" http:// $SONOFF_IP :8081/zeroconf/ota_flash You're now ready to configure tasmota .","title":"Flash procedure"},{"location":"Sonoff-DIY/#video-tutorials","text":"Andreas Spiess DrZzs Paul Hibbert","title":"Video tutorials"},{"location":"Sonoff-DIY/#more-info","text":"Michel Deslierres","title":"More info:"},{"location":"Sonoff-SPM/","text":"Sonoff SPM ~ This feature is included only in tasmota32 binaries Do not use this device as safety fuse! Info For ARM firmware upgrades it's advised to make a full backup of the SPM-Main ESP 4M flash firmware before flashing Tasmota. The Sonoff Smart Stackable Power Meter uses a SPM-Main unit with ESP32 providing Wi-Fi and ethernet connections. A serial interface and a SPI interface connects to an ARM MCU which in turn provides a RS-485 bus to up to 32 SPM-4Relay modules. The SPM-4Relay module contains an ARM MCU too providing independent power management for four bi-stable relays rated for 20A at 240V for a total of 4400W. Note As of this writing Tasmota v11.1.0.3 supports ARM firmware versions 1.0.0 and 1.2.0. The firmware monitors the attached SPM-4Relay modules and stores energy usage history for up to 180 days on an optional SD-Card accessible by the ARM MCU only. The ARM firmware provides numerous un-documented functions allowing the ESP32 to send and receive information. Background information ~ More information about the SPM can be obtained here: Sonoff tech product documentation SPM HTTP API Sonoff DIY mode API Tasmota ~ Tasmota, installed on the ESP32, can connect to the SPM-Main ARM MCU using the serial interface and provides the following functionality: Support for up to 8 SPM-4Relays limited by current register usage Power control of all 32 relays using standard features Energy usage using standard features Overload detection using ARM firmware GUI display of rotating relays or a user selected 4Relay module Fix firmware max 180 days energy usage by storing daily Energy Total in Tasmota's filesystem Mapping physical relays to scanned relays Limitations ~ The following notes currently apply: Tasmota is unable to upgrade the ARM firmware. In case an upgrade is wanted install the backed-up sonoff firmware and perform the upgrade using the eWeLink app. Once upgraded make another backup before restoring Tasmota for future ARM firmware upgrades. Configuration ~ In addition to installing the tasmota32.bin image some configuration might be needed. Relay mapping ~ After a restart the ARM firmware starts to scan for available 4Relay modules. Every module has a unique id which is send to Tasmota in random order. For a user to pinpoint a physical set of four relays it is therefor needed to \"map\" the scanned modules once. Tasmota stores the id's in a mapping table build using the command SspmMap <scanned module number>,<scanned module number>,.. where the first entry will map to physical relays 1 to 4, the second entry will map to physical relays 5 to 8 etc. The scanned module information needed is displayed on the console during restart or on request by executing command SspmScan with a weblog 2 setting. Note Scanning takes over 20 seconds so be patient Look for the below information during a restart for a two 4Relay module system: 00:00:00.123 Project tasmota - Sspm2 Version 11.0.0.1(tasmota)-2_0_2_2(2022-02-18T12:09:05) 00:00:05.191 CFG: SPM loaded from file 00:00:08.305 SPM: Main version 1.0.0 found 13:54:05.392 SPM: 4Relay 1 (mapped to 2) type 130 version 1.0.0 found with id 8B343237393734134B353637 13:54:05.401 SPM: 4Relay 2 (mapped to 1) type 130 version 1.0.0 found with id 6B7E3237393734134B353637 In this case the two modules are mapped using command SspmMap 2,1 . As Tasmota does store the ids of the 4Relay modules a future hussle of the received modules will keep the physical mapping correct. Commands List ~ The following SPM specific commands are supported. Command Parameters SspmDisplay Change GUI display between rotating display of all scanned relays, of all scanned relays that are powered on or select a group of four relays using a tab 0 = Display all relays 1 = Display powered on relays 2 = Provide user selectable tabs to display four relays within a 4Relay module SspmEnergyTotal<x> (P)reset total energy in kWh without today's energy for relay <x> 0 = preset with total of history 0.01..262143.99 = set value in kWh SspmEnergyYesterday<x> (P)reset energy yesterday in kWh for relay <x> 0.01..262143.99 = set value in kWh SspmHistory<x> Show daily energy for relay <x> of up to 180 days SspmIAmHere<x> Blink SPM-4Relay module error light containing relay <x> SspmLog<x> Show relay <x> power state change and cause SspmMap Map scanned SPM-4Relay modules to physical location. Use unique numbers for all fields 0 = rescan modbus for SPM-4Relay modules and reset mapping to default. This takes at least 20 seconds 3,4,1,2 = map scanned module 1 to physical module 3 containing relays 9 to 12, module 2 to 4 with relays 13 to 16, module 3 to 1 with relays 1 to 4 and module 4 to 2 with relays 5 to 8 SspmOverload<x> Set overload detection criteria for relay <x> 0 = reset and disable overload detection to scanned module criteria <delay>,<min_power>,<max_power>,<min_voltage>,<max_voltage>,<max_current> = set any or all overload detection criteria 0,0.10,4400.00,0.10,240.00,20.00 = enable overload detection with default values 9,0,22.1 = enable max_power over 22.1W detection after 9 seconds 0,0,0,0,235.2 = enable immediate max_voltage over 235.2V detection SspmScan Rescan modbus for SPM-4Relay modules. This takes at least 20 seconds","title":"Sonoff SPM"},{"location":"Sonoff-SPM/#sonoff-spm","text":"This feature is included only in tasmota32 binaries Do not use this device as safety fuse! Info For ARM firmware upgrades it's advised to make a full backup of the SPM-Main ESP 4M flash firmware before flashing Tasmota. The Sonoff Smart Stackable Power Meter uses a SPM-Main unit with ESP32 providing Wi-Fi and ethernet connections. A serial interface and a SPI interface connects to an ARM MCU which in turn provides a RS-485 bus to up to 32 SPM-4Relay modules. The SPM-4Relay module contains an ARM MCU too providing independent power management for four bi-stable relays rated for 20A at 240V for a total of 4400W. Note As of this writing Tasmota v11.1.0.3 supports ARM firmware versions 1.0.0 and 1.2.0. The firmware monitors the attached SPM-4Relay modules and stores energy usage history for up to 180 days on an optional SD-Card accessible by the ARM MCU only. The ARM firmware provides numerous un-documented functions allowing the ESP32 to send and receive information.","title":"Sonoff SPM"},{"location":"Sonoff-SPM/#background-information","text":"More information about the SPM can be obtained here: Sonoff tech product documentation SPM HTTP API Sonoff DIY mode API","title":"Background information"},{"location":"Sonoff-SPM/#tasmota","text":"Tasmota, installed on the ESP32, can connect to the SPM-Main ARM MCU using the serial interface and provides the following functionality: Support for up to 8 SPM-4Relays limited by current register usage Power control of all 32 relays using standard features Energy usage using standard features Overload detection using ARM firmware GUI display of rotating relays or a user selected 4Relay module Fix firmware max 180 days energy usage by storing daily Energy Total in Tasmota's filesystem Mapping physical relays to scanned relays","title":"Tasmota"},{"location":"Sonoff-SPM/#limitations","text":"The following notes currently apply: Tasmota is unable to upgrade the ARM firmware. In case an upgrade is wanted install the backed-up sonoff firmware and perform the upgrade using the eWeLink app. Once upgraded make another backup before restoring Tasmota for future ARM firmware upgrades.","title":"Limitations"},{"location":"Sonoff-SPM/#configuration","text":"In addition to installing the tasmota32.bin image some configuration might be needed.","title":"Configuration"},{"location":"Sonoff-SPM/#relay-mapping","text":"After a restart the ARM firmware starts to scan for available 4Relay modules. Every module has a unique id which is send to Tasmota in random order. For a user to pinpoint a physical set of four relays it is therefor needed to \"map\" the scanned modules once. Tasmota stores the id's in a mapping table build using the command SspmMap <scanned module number>,<scanned module number>,.. where the first entry will map to physical relays 1 to 4, the second entry will map to physical relays 5 to 8 etc. The scanned module information needed is displayed on the console during restart or on request by executing command SspmScan with a weblog 2 setting. Note Scanning takes over 20 seconds so be patient Look for the below information during a restart for a two 4Relay module system: 00:00:00.123 Project tasmota - Sspm2 Version 11.0.0.1(tasmota)-2_0_2_2(2022-02-18T12:09:05) 00:00:05.191 CFG: SPM loaded from file 00:00:08.305 SPM: Main version 1.0.0 found 13:54:05.392 SPM: 4Relay 1 (mapped to 2) type 130 version 1.0.0 found with id 8B343237393734134B353637 13:54:05.401 SPM: 4Relay 2 (mapped to 1) type 130 version 1.0.0 found with id 6B7E3237393734134B353637 In this case the two modules are mapped using command SspmMap 2,1 . As Tasmota does store the ids of the 4Relay modules a future hussle of the received modules will keep the physical mapping correct.","title":"Relay mapping"},{"location":"Sonoff-SPM/#commands-list","text":"The following SPM specific commands are supported. Command Parameters SspmDisplay Change GUI display between rotating display of all scanned relays, of all scanned relays that are powered on or select a group of four relays using a tab 0 = Display all relays 1 = Display powered on relays 2 = Provide user selectable tabs to display four relays within a 4Relay module SspmEnergyTotal<x> (P)reset total energy in kWh without today's energy for relay <x> 0 = preset with total of history 0.01..262143.99 = set value in kWh SspmEnergyYesterday<x> (P)reset energy yesterday in kWh for relay <x> 0.01..262143.99 = set value in kWh SspmHistory<x> Show daily energy for relay <x> of up to 180 days SspmIAmHere<x> Blink SPM-4Relay module error light containing relay <x> SspmLog<x> Show relay <x> power state change and cause SspmMap Map scanned SPM-4Relay modules to physical location. Use unique numbers for all fields 0 = rescan modbus for SPM-4Relay modules and reset mapping to default. This takes at least 20 seconds 3,4,1,2 = map scanned module 1 to physical module 3 containing relays 9 to 12, module 2 to 4 with relays 13 to 16, module 3 to 1 with relays 1 to 4 and module 4 to 2 with relays 5 to 8 SspmOverload<x> Set overload detection criteria for relay <x> 0 = reset and disable overload detection to scanned module criteria <delay>,<min_power>,<max_power>,<min_voltage>,<max_voltage>,<max_current> = set any or all overload detection criteria 0,0.10,4400.00,0.10,240.00,20.00 = enable overload detection with default values 9,0,22.1 = enable max_power over 22.1W detection after 9 seconds 0,0,0,0,235.2 = enable immediate max_voltage over 235.2V detection SspmScan Rescan modbus for SPM-4Relay modules. This takes at least 20 seconds","title":"Commands List"},{"location":"Status-LED/","text":"","title":"Status LED"},{"location":"Subscribe-%26-Unsubscribe/","text":"","title":"Subscribe & Unsubscribe"},{"location":"Supported-Modules/","text":"Supported Modules ~ Sonoff 4CH Sonoff 4CH Pro Sonoff 4CH DIY Sonoff B1 / B1 R2 Sonoff Basic R1/R2/R3 Sonoff Dual Sonoff Dual R2 Sonoff iFan02 Sonoff iFan03 Sonoff Mini Sonoff Pow Sonoff Pow R2 Sonoff PSA Sonoff RF Sonoff RF R3 Sonoff RF Bridge 433 Sonoff S20 Smart Socket Sonoff S26 Smart Socket Sonoff S31 Sonoff SC Sonoff Slampher Sonoff SV Sonoff T1 Sonoff Touch Sonoff TH Arilux LC02 Armtronix Dimmers Blitzwolf BW-SHP2 Blitzwolf BW-SHP4 Blitzwolf BW-SHP6 Digoo DG-SP202 Geekcreit 2CH Gosund SP1 H801 LED Controller HuaFan Smart Socket Luminea LED Controller MagicHome LED Controller (ESP-12S/ESP-2M.md) MagicHome LED Controller (ESP8285.md) Mi Desk Lamp PS-16-DZ Dimmer OBI Socket OBI Socket 2 OBI Socket IP44 (Black.md) Shelly 1 Shelly 1PM Shelly 2 Shelly 2.5 SK03 Outdoor Smart Plug Teckin SP10 Smart Socket Teckin SP22 YTF IR Bridge WT003-EU 4 AC + 4 USB Outlet Tuya Power Strip EU Wemos D1 R1 & R2 Wemos D1 Mini Other Devices","title":"Supported Modules"},{"location":"Supported-Modules/#supported-modules","text":"Sonoff 4CH Sonoff 4CH Pro Sonoff 4CH DIY Sonoff B1 / B1 R2 Sonoff Basic R1/R2/R3 Sonoff Dual Sonoff Dual R2 Sonoff iFan02 Sonoff iFan03 Sonoff Mini Sonoff Pow Sonoff Pow R2 Sonoff PSA Sonoff RF Sonoff RF R3 Sonoff RF Bridge 433 Sonoff S20 Smart Socket Sonoff S26 Smart Socket Sonoff S31 Sonoff SC Sonoff Slampher Sonoff SV Sonoff T1 Sonoff Touch Sonoff TH Arilux LC02 Armtronix Dimmers Blitzwolf BW-SHP2 Blitzwolf BW-SHP4 Blitzwolf BW-SHP6 Digoo DG-SP202 Geekcreit 2CH Gosund SP1 H801 LED Controller HuaFan Smart Socket Luminea LED Controller MagicHome LED Controller (ESP-12S/ESP-2M.md) MagicHome LED Controller (ESP8285.md) Mi Desk Lamp PS-16-DZ Dimmer OBI Socket OBI Socket 2 OBI Socket IP44 (Black.md) Shelly 1 Shelly 1PM Shelly 2 Shelly 2.5 SK03 Outdoor Smart Plug Teckin SP10 Smart Socket Teckin SP22 YTF IR Bridge WT003-EU 4 AC + 4 USB Outlet Tuya Power Strip EU Wemos D1 R1 & R2 Wemos D1 Mini Other Devices","title":"Supported Modules"},{"location":"Supported-Peripherals/","text":"Supported Peripherals ~ Name Description Connection 74x595 74x595 Shift Registers gpio A4988 Stepper Motor Controller ADC Analog input over A0 pin analog ADS111x A/D Converter I 2 C AHT1x Asair AHT10/AHT15 Temperature and Humidity Sensor I 2 C AHT2x Asair AHT20/AHT21/AHT25/AM2301B Temperature and Humidity Sensor I 2 C AM2301 / DHT21 AM2302 / DHT22 AM2321 Temperature and Humidity Sensor gpio AM2301B Temperature and Humidity Sensor Use same driver as AHT2X I 2 C AM2320 Temperature and Humidity Sensor gpio AS608 AS608 Optical and R503 Capacitive Fingerprint Sensor serial AS3935 Franklin Lightning Sensor serial APDS-9960 Ambient Light, RGB Color and Proximity Sensor with Gesture Detection I 2 C AZ 7798 CO 2 Meter Datalogger BH1750 Luminosity Sensor BMP280 BMP085 BMP180) Pressure Sensor BME280 Temperature, Humidity and Pressure Sensor I 2 C BME680 BME688 Temperature, Humidity, Pressure and Gas Sensor I 2 C Buzzer Audio Signalling Device gpio CC2530 TI CC2530 Zigbee Adapter serial CCS811 Gas and Air Quality Sensor I 2 C Chirp! Soil Moisture Sensor Moisture Sensor I 2 C DFR0299 DFRobot DFPlayer Mini MP3 Player serial DHT11 Temperature and Humidity Sensor gpio DHT12 Temperature and Humidity Sensor gpio DY-SV17F DY-SV17F MP3 Player serial DYP-ME007 Ultrasonic distance Sensor serial DS18x20 Temperature Sensor 1-Wire DS1624 DS1621 Temperature Sensor 1-Wire DS3231 Real-Time-Clock I 2 C DS3502 Digital potentiometer I 2 C EZO EZO series of chemical Sensors I 2 C F&F LE-01MR F&F LE-01MR Single Phase Modbus Energy meter GPS-NTP-server GPS-NTP-server serial GGreg20_V3 Ionizing Radiation Detector gpio (ESP32 only) HDC1080 Texas Instruments HDC1080 Humidity and Temperature Sensor I 2 C HDC2010 Texas Instruments HDC2010 Humidity and Temperature Sensor I 2 C HM-10 BLE Bluetooth gateway serial HM-17 HM-16 Bluetooth iBeacon reader serial HP303B Barometric Pressure Shield I 2 C HYTxx Temperature and Humidity Sensor I 2 C HR-E Water Meter Encoder interface serial HRG-15 Hydreon RG-15 Rain Gauge Sensor serial HRXL MaxBotix HRXL line of Sonar Ranging Sensors gpio HC-SR04 HC-SR04P JSN-SR04T) Ultrasonic Sensor gpio HM330x SeedStudio Grove HM3301 Particulate Matter Sensor I 2 C Honeywell HIH Temperature and Humidity Sensor I 2 C Honeywell HPMA115xx Particulate Matter Sensor serial HTU21 Temperature and Humidity Sensor I 2 C HX711 Load Cell Sensor gpio HRG15 Solid State Rain Sensor serial I2S Audio I2S Audio DAC and microphone I2s iAQ-Core Indoor Air Quality Sensor I 2 C iEM3000 Schenider Electric modbus energy meter serial INA219 ISL28022 High-Side DC Current and Voltage Sensor I 2 C INA226 High-Side or Low-side DC Current and Voltage Sensor I 2 C IR Remote IR transmitter and receiver K30, K70, S8 SenseAir CO 2 Sensors serial LM75AD Temperature Sensor I 2 C LMT01 Temperature Sensor gpio MAX31855 MAX6675 Thermocouple Sensor SPI MAX31865 RTD Temperature Sensor Amplifier SPI MAX44009 Ambient Light Sensor I 2 C MCP23008 MCP23017 I/O Expander I 2 C MCP2515 CAN bus controller SPI MCP9808 Temperature Sensor I 2 C MFRC522 NFC Tag Reader SPI MGC3130 3D Tracking and Gesture Controller MH-Z19B CO 2 Sensor MLX90614 MLX9061X Infrared Thermometer I 2 C MLX90640 MLX90640 Far Infrared Thermal Sensor Array I 2 C MPR121 Proximity Capacitive Touch Sensor Controller (I 2 C) MPU6050 3-Axis Gyroscope and 3-Axis Accelerometer Sensor (I 2 C) MQ MQ Sensors (MQ-02, MQ-03, MQ-04, MQ-05, MQ-06, MQ-07, MQ-08, MQ-09, MQ-131, MQ-135) analog MS01 Moisture sensor from Sonoff 1wire NeoPool Sugar Valley NeoPool Controller serial NRF24L01 NRF24L01 as BLE-bridge for Mijia BT Sensors SPI OpenTherm OpenTherm adapter serial P1 Smart Meter Energy Meter serial PAJ7620 Gesture & Proximity Detection Sensor PIR Passive Infrared Sensor gpio PCA9685 16-channel, 12-bit PWM LED controller I 2 C PCF8574(A) 8-port IO Expander I 2 C PMS3003 PMS5003 PMS7003 Particle Concentration Sensor serial PN532 NFC/RFID controller PZEM-004 PZEM-016 Energy Monitor serial RCWL-0516 Microwave Radar Presence detection RDM6300 125Khz RFID Module RF Transceiver IR receiver and/or transmitter RX-4M50RR30SF RX-AM8SF RF Sensor receiver gpio SCD30 CO 2 Sensor I 2 C SCD40 SCD41 CO 2 Sensor I 2 C Eastron SDM72 Modbus Energy Meter serial Eastron SDM120 Modbus Energy Meter serial Eastron SDM220 Modbus Energy Meter serial Eastron SDM230 Modbus Energy Meter serial Eastron SDM630 Modbus Energy Meter serial YF-DN50 Flow rate meter gpio SDS011 SDS021 Laser Dust Sensor SGP30 Gas and Air Quality Sensor I 2 C SHT1x Temperature and Humidity Sensor I 2 C SHT30 Humidity & Temperature Sensor I 2 C SHT4x Temperature and Humidity Sensor I 2 C SI114x UV Index, IR and Visible Light Sensor I 2 C Si7021 Humidity and Temperature Sensor I 2 C SK6812 Addressable LEDs Smart Meter Interface Smart Meter Interface serial, gpio SolaX X1 SolaX Power X1 inverter serial SPS30 Particulate Matter PM) T6703 T6713 Telaire T6700 Series CO 2 sensor I 2 C T\u00e9l\u00e9info French energy measuring system serial TFMini TFmini, TFmini Plus, TFmini Plus (Indoor Version), TFmini-S LiDAR module serial TM1638 8 Switch, LED and 7 Segment Unit Sensor gpio TSL2561 Luminosity Sensor I 2 C TSL2591 Luminosity Sensor I 2 C TX20 TX23 WS2300 La Crosse TX2x / Technoline WS2300-15 Anemometer gpio VEML6070 UV Sensor I 2 C VEML6075 UVA/UVB/UVINDEX Sensor I 2 C VEML7700 Ambient light intensity Sensor I 2 C VL53L0x Time of flight Sensor I 2 C VL53L1x Time of flight Sensor I 2 C ** VINDRIKTNING IKEA VINDRIKTNING Particle Concentration Sensor serial WindMeter Analog cup anemometer WS2812B Wemos Shield with Addressable LED WS2812B WS2813B Addressable LEDs **Xadow Grove) Mutichannel Gas Sensor** gas Sensor (I 2 C Google Sheet list of supported peripherals Sensor API Documentation Expanding Specific Devices ~ LEGO nightstand switch using Sonoff SV Add a physical button to Sonoff Basic Remote button for Sonoff Expand Sonoff S20 with a jack plug Expand Sonoff 4CH with a jack plug Modify KaKu to WKaKu Power Socket GPIO Locations for some devices","title":"Peripherals"},{"location":"Supported-Peripherals/#supported-peripherals","text":"Name Description Connection 74x595 74x595 Shift Registers gpio A4988 Stepper Motor Controller ADC Analog input over A0 pin analog ADS111x A/D Converter I 2 C AHT1x Asair AHT10/AHT15 Temperature and Humidity Sensor I 2 C AHT2x Asair AHT20/AHT21/AHT25/AM2301B Temperature and Humidity Sensor I 2 C AM2301 / DHT21 AM2302 / DHT22 AM2321 Temperature and Humidity Sensor gpio AM2301B Temperature and Humidity Sensor Use same driver as AHT2X I 2 C AM2320 Temperature and Humidity Sensor gpio AS608 AS608 Optical and R503 Capacitive Fingerprint Sensor serial AS3935 Franklin Lightning Sensor serial APDS-9960 Ambient Light, RGB Color and Proximity Sensor with Gesture Detection I 2 C AZ 7798 CO 2 Meter Datalogger BH1750 Luminosity Sensor BMP280 BMP085 BMP180) Pressure Sensor BME280 Temperature, Humidity and Pressure Sensor I 2 C BME680 BME688 Temperature, Humidity, Pressure and Gas Sensor I 2 C Buzzer Audio Signalling Device gpio CC2530 TI CC2530 Zigbee Adapter serial CCS811 Gas and Air Quality Sensor I 2 C Chirp! Soil Moisture Sensor Moisture Sensor I 2 C DFR0299 DFRobot DFPlayer Mini MP3 Player serial DHT11 Temperature and Humidity Sensor gpio DHT12 Temperature and Humidity Sensor gpio DY-SV17F DY-SV17F MP3 Player serial DYP-ME007 Ultrasonic distance Sensor serial DS18x20 Temperature Sensor 1-Wire DS1624 DS1621 Temperature Sensor 1-Wire DS3231 Real-Time-Clock I 2 C DS3502 Digital potentiometer I 2 C EZO EZO series of chemical Sensors I 2 C F&F LE-01MR F&F LE-01MR Single Phase Modbus Energy meter GPS-NTP-server GPS-NTP-server serial GGreg20_V3 Ionizing Radiation Detector gpio (ESP32 only) HDC1080 Texas Instruments HDC1080 Humidity and Temperature Sensor I 2 C HDC2010 Texas Instruments HDC2010 Humidity and Temperature Sensor I 2 C HM-10 BLE Bluetooth gateway serial HM-17 HM-16 Bluetooth iBeacon reader serial HP303B Barometric Pressure Shield I 2 C HYTxx Temperature and Humidity Sensor I 2 C HR-E Water Meter Encoder interface serial HRG-15 Hydreon RG-15 Rain Gauge Sensor serial HRXL MaxBotix HRXL line of Sonar Ranging Sensors gpio HC-SR04 HC-SR04P JSN-SR04T) Ultrasonic Sensor gpio HM330x SeedStudio Grove HM3301 Particulate Matter Sensor I 2 C Honeywell HIH Temperature and Humidity Sensor I 2 C Honeywell HPMA115xx Particulate Matter Sensor serial HTU21 Temperature and Humidity Sensor I 2 C HX711 Load Cell Sensor gpio HRG15 Solid State Rain Sensor serial I2S Audio I2S Audio DAC and microphone I2s iAQ-Core Indoor Air Quality Sensor I 2 C iEM3000 Schenider Electric modbus energy meter serial INA219 ISL28022 High-Side DC Current and Voltage Sensor I 2 C INA226 High-Side or Low-side DC Current and Voltage Sensor I 2 C IR Remote IR transmitter and receiver K30, K70, S8 SenseAir CO 2 Sensors serial LM75AD Temperature Sensor I 2 C LMT01 Temperature Sensor gpio MAX31855 MAX6675 Thermocouple Sensor SPI MAX31865 RTD Temperature Sensor Amplifier SPI MAX44009 Ambient Light Sensor I 2 C MCP23008 MCP23017 I/O Expander I 2 C MCP2515 CAN bus controller SPI MCP9808 Temperature Sensor I 2 C MFRC522 NFC Tag Reader SPI MGC3130 3D Tracking and Gesture Controller MH-Z19B CO 2 Sensor MLX90614 MLX9061X Infrared Thermometer I 2 C MLX90640 MLX90640 Far Infrared Thermal Sensor Array I 2 C MPR121 Proximity Capacitive Touch Sensor Controller (I 2 C) MPU6050 3-Axis Gyroscope and 3-Axis Accelerometer Sensor (I 2 C) MQ MQ Sensors (MQ-02, MQ-03, MQ-04, MQ-05, MQ-06, MQ-07, MQ-08, MQ-09, MQ-131, MQ-135) analog MS01 Moisture sensor from Sonoff 1wire NeoPool Sugar Valley NeoPool Controller serial NRF24L01 NRF24L01 as BLE-bridge for Mijia BT Sensors SPI OpenTherm OpenTherm adapter serial P1 Smart Meter Energy Meter serial PAJ7620 Gesture & Proximity Detection Sensor PIR Passive Infrared Sensor gpio PCA9685 16-channel, 12-bit PWM LED controller I 2 C PCF8574(A) 8-port IO Expander I 2 C PMS3003 PMS5003 PMS7003 Particle Concentration Sensor serial PN532 NFC/RFID controller PZEM-004 PZEM-016 Energy Monitor serial RCWL-0516 Microwave Radar Presence detection RDM6300 125Khz RFID Module RF Transceiver IR receiver and/or transmitter RX-4M50RR30SF RX-AM8SF RF Sensor receiver gpio SCD30 CO 2 Sensor I 2 C SCD40 SCD41 CO 2 Sensor I 2 C Eastron SDM72 Modbus Energy Meter serial Eastron SDM120 Modbus Energy Meter serial Eastron SDM220 Modbus Energy Meter serial Eastron SDM230 Modbus Energy Meter serial Eastron SDM630 Modbus Energy Meter serial YF-DN50 Flow rate meter gpio SDS011 SDS021 Laser Dust Sensor SGP30 Gas and Air Quality Sensor I 2 C SHT1x Temperature and Humidity Sensor I 2 C SHT30 Humidity & Temperature Sensor I 2 C SHT4x Temperature and Humidity Sensor I 2 C SI114x UV Index, IR and Visible Light Sensor I 2 C Si7021 Humidity and Temperature Sensor I 2 C SK6812 Addressable LEDs Smart Meter Interface Smart Meter Interface serial, gpio SolaX X1 SolaX Power X1 inverter serial SPS30 Particulate Matter PM) T6703 T6713 Telaire T6700 Series CO 2 sensor I 2 C T\u00e9l\u00e9info French energy measuring system serial TFMini TFmini, TFmini Plus, TFmini Plus (Indoor Version), TFmini-S LiDAR module serial TM1638 8 Switch, LED and 7 Segment Unit Sensor gpio TSL2561 Luminosity Sensor I 2 C TSL2591 Luminosity Sensor I 2 C TX20 TX23 WS2300 La Crosse TX2x / Technoline WS2300-15 Anemometer gpio VEML6070 UV Sensor I 2 C VEML6075 UVA/UVB/UVINDEX Sensor I 2 C VEML7700 Ambient light intensity Sensor I 2 C VL53L0x Time of flight Sensor I 2 C VL53L1x Time of flight Sensor I 2 C ** VINDRIKTNING IKEA VINDRIKTNING Particle Concentration Sensor serial WindMeter Analog cup anemometer WS2812B Wemos Shield with Addressable LED WS2812B WS2813B Addressable LEDs **Xadow Grove) Mutichannel Gas Sensor** gas Sensor (I 2 C Google Sheet list of supported peripherals Sensor API Documentation","title":"Supported Peripherals"},{"location":"Supported-Peripherals/#expanding-specific-devices","text":"LEGO nightstand switch using Sonoff SV Add a physical button to Sonoff Basic Remote button for Sonoff Expand Sonoff S20 with a jack plug Expand Sonoff 4CH with a jack plug Modify KaKu to WKaKu Power Socket GPIO Locations for some devices","title":"Expanding Specific Devices"},{"location":"TLS/","text":"TLS Secured MQTT ~ This feature is included only in tasmota32 binaries Starting with version 10.0.0.4, TLS now support dual mode, depending of the value of SetOption132 : SetOption132 0 (default): the server's identity is checked against pre-defined Certificate Authorities. There is no further configuration needed. Tasmota includes the following CAs: LetsEncrypt R3 certificate , RSA 2048 bits SHA 256, valid until 20250915 Amazon Root CA , RSA 2048 bits SHA 256, valid until 20380117, used by AWS IoT SetOption132 1 : Fingerprint validation. This method works for any server certificate, including self-signed certificates. The server's public key is hashed into a fingerprint and compared to a pre-recorded value. This method is more universal but requires an additional configuration (see below) There is no performance difference between both modes. Fingerprint Validation ~ The fingerprint is now calculated on the server's Public Key and no longer on its Certificate. The good news is that Public Keys tend to change far less often than certificates, i.e. LetsEncrypt triggers a certificate renewal every 3 months, the Public Key fingerprint will not change after a certificate renewal. The bad news is that there is no openssl command to retrieve the server's Public Key fingerprint. The original Fingerprint V1 algorithm had a security potential vulnerability, it has been replaced by a new more robust method v2. To avoid breaking compatibility, Tasmota will automatically detect when a fingerprint v1 is present and will convert it automatically to V2. Important : the following tool to calculate it from your certificate is now deprecated. The fingerprint will work once and will be replaced with the new fingerprint. So to simplify your task, we have added two more options: 1/ auto-learning of the fingerprint, 2/ disabling of the fingerprint validation altogether. Option 1: Fingerprint auto-learn ~ If set, Tasmota will automatically learn the fingerprint during the first connection and will set the Fingerprint settings to the target fingerprint. To do so, use one of the following commands: #define MQTT_FINGERPRINT1 \"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\" or #define MQTT_FINGERPRINT2 \"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\" Option 2: Disable Fingerprint ~ You can completely disable server fingerprint validation, which means that Tasmota will not check the server's identity. This also means that your traffic can possibly be intercepted and read/changed, so this option should only be used on trusted networks, i.e. with an MQTT on your local network. YOU HAVE BEEN WARNED! To do so, set one of the Fingerprints to all 0xFF: #define MQTT_FINGERPRINT1 \"FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF\" Tasmota also provide an option to authenticate clients using an x509 certificate and a public key for authentication, instead of username/password. For details on how to set up your local instance of Mosquitto, check the article Self-signed-Mosquitto . Compiling TLS for ESP8266 ~ To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS // Use TLS for MQTT connection (+34.5k code, +7.0k mem and +4.8k additional during connection handshake) #define MQTT_TLS_ENABLED true // [SetOption103] Enable TLS mode (requires TLS version) // #define USE_MQTT_TLS_CA_CERT // Force full CA validation instead of fingerprints, slower, but simpler to use. (+2.2k code, +1.9k mem during connection handshake) // This includes the LetsEncrypt CA in tasmota_ca.ino for verifying server certificates // #define USE_MQTT_TLS_FORCE_EC_CIPHER // Force Elliptic Curve cipher (higher security) required by some servers (automatically enabled with USE_MQTT_AWS_IOT) (+11.4k code, +0.4k mem) #endif Change port to 8883 ~ #define MQTT_PORT 8883 // [MqttPort] MQTT port (10123 on CloudMQTT) Ensure that for the environment you have selected, lib/lib_ssl is included on platformio_tasmota_env.ini : ~ lib_extra_dirs = lib/lib_ssl TLS offers increased security between your connected devices and your MQTT server, providing server authentication and encryption. Please refer to the general discussion in Securing-your-IoT-from-hacking Starting version 6.5.0.15, there are major changes to TLS to make it lighter in memory and easier to use. It has now reduced flash and memory requirements that makes it compatible with Web and Hue Emulation. If you are upgrading from a previous TLS activated version, there are breaking changes in the way Fingerprints are calculated At the Tasmota configuration, you need to enable to use the TLS Version. This is done by enable #define USE_MQTT_TLS in user_config_override.h and If you are using LetsEncrypt to generate your server certificates, you should activate #define USE_MQTT_TLS_CA_CERT . Tasmota will transparently check the server's certificate with LetsEncrypt CA. If you are generating self-signed certificates or prefer fingerprints, read below. Limitations ~ On ESP8266, starting with 6.5.0.15, AxTLS has been replaced with BearSSL . This uses less memory, typically 6.0k constantly, and an additional 6.8k during TLS connection. On ESP32, BearSSL provides a much lighter footprint than MbedTLS (~45kB instead of ~150kB) and continues to be used by Tasmota. Main limitations are: Your SSL/TLS server must support TLS 1.2 and the ECDHE_RSA_WITH_AES_128_GCM_SHA2566 cipher - which is the case with the default Mosquitto configuration The server certificate must have an RSA private key (max 2048 bits) and the certificate must be signed with RSA and SHA256 hash. This is the case with default LetsEncrypt certificates. ESP32 supports by default RSA private keys up to 4096 bits, ESP8266 must be compiled with option -DUSE_4K_RSA to support 4096 private keys. Your SSL/TLS should support TLS 1.2 MFLN to limit buffer to 1024 bytes. If MFLN is not supported, it will still work well, as long as the server does not send any message above 1024 bytes. On ESP32 buffers are raised to 2048 bytes. Implementation Notes ~ Arduino Core switched from AxTLS to BearSSL in 2.4.2, allowing further optimization of the TLS library footprint. BearSSL is designed for compactness, both in code size and memory requirements. Furthermore it is modular and allows for inclusion of only the code necessary for the subset of crypto-algorithms you want to support. All numbers below are for ESP8266 Thanks to BearSSL's compactness and aggressive optimization, the minimal TLS configuration requires just 34.5k of Flash and 6.7k of Memory . The full-blown AWS IoT version with full certificate validation requires 48.3k of Flash and 9.4k of Memory. Here are the tips and tricks used to reduce Flash and Memory: MFLN (Maximum Fragment Length Negotiation): TLS normally uses 16k buffers for send and receive. 32k looks very small on a server, but immensely huge for ESP8266. TLS 1.2 introduced MFLN, which allows the TLS Client to reduce both buffers down to 512 bytes. MFLN is not widely supported yet, but it is by recent OpenSSL versions and by AWS IoT. This is a huge improvement in memory footprint. If your server does not support MFLN, it will still work as long as the messages sent by the server do not exceed the buffer length. In Tasmota the buffer length is 1024 bytes for send buffer and 1024 bytes for receive buffer. Going below creates message fragmentation and much longer TLS connection times (above 3s). If your server does not support MFLN, you'll see a message to that effect in the logs. Max Certificate size : BearSSL normally supports server certificates of up to RSA 4096 bits and EC 521 bits. These certificates are very uncommon currently. To save extra memory, the included BearSSL library is trimmed down to maximum RSA 2048 bit certificate and EC 256 bit certificate. This should not have any impact for you. Tasmota will crash if the server serves a 4096 bit RSA certificate. The crash will likely be in br_rsa_i15_pkcs1_vrfy . Enable USE_4K_RSA to avoid this behaviour. EC private key : AWS IoT requires the client to authenticate with its own Private Key and Certificate. By default AWS IoT will generate an RSA 2048 bit private key. In Tasmota, we moved to an EC (Elliptic Curve) Private Key of 256 bits. EC keys are much smaller, and handshake is significantly faster. Note: the key being 256 bits does not mean it's less secure than RSA 2048, it's actually the opposite. Single Cipher : to reduce code size, we only support a single TLS cipher and embed only the code strictly necessary. When using TLS (e.g. LetsEncrypt on Mosquitto) the supported cipher is RSA_WITH_AES_128_GCM_SHA256 which is a very commonly supported cipher. For AWS IoT, the only supported cipher is ECDHE_RSA_WITH_AES_128_GCM_SHA256 which is one of the recommended ciphers. Additionally, ECDHE offers Perfect Forward Secrecy which means extra security. Adaptive Thunk Stack : BearSSL does not allocate memory on its own. It's either the caller's responsibility or memory is taken on the Stack. Stack usage can go above 5k, more than the ESP8266 stack. Arduino created a Thunk Stack , a secondary stack of 5.6k, allocated on Heap, and activated when a TLS connection is active. Actually the stack is mostly used during TLS handshake, and much less memory is required during TLS message processing. Tasmota only allocates the Thunk Stack during TLS handshake and switches back to the normal Stack afterwards. See below for details of actual memory usage. Keys and CA in PROGMEM : BearSSL was adapted from original source code to push most on the tables and static data into PROGMEM: https://github.com/earlephilhower/bearssl-esp8266. Additional work now allows us to put the Client Private Key, Certificate and CA in PROGMEM too, saving at least 3k of Memory. Memory Usage ~ TLS on Tasmota has been aggressively optimized to use as little memory (heap) as possible. It was also optimized to limit code size. Memory consumption (nominal): BearSSL lib: 1424 bytes (or 1024 bytes with LetsEncrypt or regular TLS) BearSSL ClientContext: 3440 bytes Buffers (1024 bytes in + 1024 bytes out + overhead): 2528 bytes Total = 7.4k (or 7.0k with LetsEncrypt or regular TLS) Note: if you use USE_WEBSERVER , your impact is lowered by 2k since the Web log buffer is reduced from 4k to 2k. Overall, when activating USE_WEBSERVER , you just see a memory impact of 5.4k. Memory needed during connection (TLS handshake - fingerprint validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 1152 bytes Total for connection = 6.5k (or 4.8k with LetsEncrypt or regular TLS) Memory needed during connection (TLS handshake - full CA validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 3072 bytes Total for connection = 8.4k (or 6.7k with LetsEncrypt or regular TLS) Connection Time ~ ESP8266 is quite slow compared to modern processors when it comes to SSL handshakes. Here are observed performance times when connecting to an SSL/TLS server, depending on CPU frequency (80MHz or 160MHz): AWS IoT Connection, with EC Private Key, simple fingerprint validation: 0.7s at 160MHz 1.3s at 80 MHz AWS IoT Connection, with EC Private Key, full CA validation (easier to configure than fingerprints): 1.0s at 160MHz 1.8s at 80 MHz LetsEncrypt based server (Mosquitto for ex), simple fingerprint validation: 0.3s at 160MHz 0.4s at 80MHz LetsEncrypt based server (Mosquitto for ex), with full CA validation (easier to configure than fingerprint): 0.4s at 160MHz 0.7s at 80MHz TLS Troubleshooting ~ Here are most common TLS errors: Error code Description -1004 Missing CA -1003 Missing EC private key -1002 Cannot connect to TCP port -1001 Cannot resolve IP address -1000 Out of memory error 1 Bad fingerprint 2 BR_ERR_BAD_STATE 3 BR_ERR_UNSUPPORTED_VERSION 4 BR_ERR_BAD_VERSION 5 BR_ERR_BAD_LENGTH 6 BR_ERR_TOO_LARGE 7 BR_ERR_BAD_MAC 8 BR_ERR_NO_RANDOM 9 BR_ERR_UNKNOWN_TYPE 10 BR_ERR_UNEXPECTED 12 BR_ERR_BAD_CCS 13 BR_ERR_BAD_ALERT 14 BR_ERR_BAD_HANDSHAKE 15 BR_ERR_OVERSIZED_ID 16 BR_ERR_BAD_CIPHER_SUITE 17 BR_ERR_BAD_COMPRESSION 18 BR_ERR_BAD_FRAGLEN 19 BR_ERR_BAD_SECRENEG 20 BR_ERR_EXTRA_EXTENSION 21 BR_ERR_BAD_SNI 22 BR_ERR_BAD_HELLO_DONE 23 BR_ERR_LIMIT_EXCEEDED: the server's public key is too large. Tasmota TLS is limited to 2048 RSA keys 24 BR_ERR_BAD_FINISHED 25 BR_ERR_RESUME_MISMATCH 26 BR_ERR_INVALID_ALGORITHM 27 BR_ERR_BAD_SIGNATURE 28 BR_ERR_WRONG_KEY_USAGE 29 BR_ERR_NO_CLIENT_AUTH 31 BR_ERR_IO 54 BR_ERR_X509_EXPIRED X.509 status: certificate is expired or not yet valid. 56 BR_ERR_X509_BAD_SERVER_NAME X.509 status: expected server name was not found in the chain. 62 X509 not trusted, the server certificate is not signed by the CA (AWS IoT or LetsEncrypt) 266 SSL3_ALERT_UNEXPECTED_MESSAGE 276 TLS1_ALERT_BAD_RECORD_MAC 277 TLS1_ALERT_DECRYPTION_FAILED 278 TLS1_ALERT_RECORD_OVERFLOW 286 SSL3_ALERT_DECOMPRESSION_FAIL 296 SSL3_ALERT_HANDSHAKE_FAILURE 298 TLS1_ALERT_BAD_CERTIFICATE: Missing or bad client private key 299 TLS1_ALERT_UNSUPPORTED_CERT 300 TLS1_ALERT_CERTIFICATE_REVOKED 301 TLS1_ALERT_CERTIFICATE_EXPIRED 302 TLS1_ALERT_CERTIFICATE_UNKNOWN 303 SSL3_ALERT_ILLEGAL_PARAMETER 304 TLS1_ALERT_UNKNOWN_CA 305 TLS1_ALERT_ACCESS_DENIED 306 TLS1_ALERT_DECODE_ERROR 307 TLS1_ALERT_DECRYPT_ERROR 316 TLS1_ALERT_EXPORT_RESTRICTION 326 TLS1_ALERT_PROTOCOL_VERSION 327 TLS1_ALERT_INSUFFIENT_SECURITY 336 TLS1_ALERT_INTERNAL_ERROR 346 TLS1_ALERT_USER_CANCELED 356 TLS1_ALERT_NO_RENEGOTIATION 366 TLS1_ALERT_UNSUPPORTED_EXT Additional BR_ERR* error codes","title":"TLS Secured MQTT"},{"location":"TLS/#tls-secured-mqtt","text":"This feature is included only in tasmota32 binaries Starting with version 10.0.0.4, TLS now support dual mode, depending of the value of SetOption132 : SetOption132 0 (default): the server's identity is checked against pre-defined Certificate Authorities. There is no further configuration needed. Tasmota includes the following CAs: LetsEncrypt R3 certificate , RSA 2048 bits SHA 256, valid until 20250915 Amazon Root CA , RSA 2048 bits SHA 256, valid until 20380117, used by AWS IoT SetOption132 1 : Fingerprint validation. This method works for any server certificate, including self-signed certificates. The server's public key is hashed into a fingerprint and compared to a pre-recorded value. This method is more universal but requires an additional configuration (see below) There is no performance difference between both modes.","title":"TLS Secured MQTT"},{"location":"TLS/#fingerprint-validation","text":"The fingerprint is now calculated on the server's Public Key and no longer on its Certificate. The good news is that Public Keys tend to change far less often than certificates, i.e. LetsEncrypt triggers a certificate renewal every 3 months, the Public Key fingerprint will not change after a certificate renewal. The bad news is that there is no openssl command to retrieve the server's Public Key fingerprint. The original Fingerprint V1 algorithm had a security potential vulnerability, it has been replaced by a new more robust method v2. To avoid breaking compatibility, Tasmota will automatically detect when a fingerprint v1 is present and will convert it automatically to V2. Important : the following tool to calculate it from your certificate is now deprecated. The fingerprint will work once and will be replaced with the new fingerprint. So to simplify your task, we have added two more options: 1/ auto-learning of the fingerprint, 2/ disabling of the fingerprint validation altogether.","title":"Fingerprint Validation"},{"location":"TLS/#compiling-tls-for-esp8266","text":"To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS // Use TLS for MQTT connection (+34.5k code, +7.0k mem and +4.8k additional during connection handshake) #define MQTT_TLS_ENABLED true // [SetOption103] Enable TLS mode (requires TLS version) // #define USE_MQTT_TLS_CA_CERT // Force full CA validation instead of fingerprints, slower, but simpler to use. (+2.2k code, +1.9k mem during connection handshake) // This includes the LetsEncrypt CA in tasmota_ca.ino for verifying server certificates // #define USE_MQTT_TLS_FORCE_EC_CIPHER // Force Elliptic Curve cipher (higher security) required by some servers (automatically enabled with USE_MQTT_AWS_IOT) (+11.4k code, +0.4k mem) #endif","title":"Compiling TLS for ESP8266"},{"location":"TLS/#limitations","text":"On ESP8266, starting with 6.5.0.15, AxTLS has been replaced with BearSSL . This uses less memory, typically 6.0k constantly, and an additional 6.8k during TLS connection. On ESP32, BearSSL provides a much lighter footprint than MbedTLS (~45kB instead of ~150kB) and continues to be used by Tasmota. Main limitations are: Your SSL/TLS server must support TLS 1.2 and the ECDHE_RSA_WITH_AES_128_GCM_SHA2566 cipher - which is the case with the default Mosquitto configuration The server certificate must have an RSA private key (max 2048 bits) and the certificate must be signed with RSA and SHA256 hash. This is the case with default LetsEncrypt certificates. ESP32 supports by default RSA private keys up to 4096 bits, ESP8266 must be compiled with option -DUSE_4K_RSA to support 4096 private keys. Your SSL/TLS should support TLS 1.2 MFLN to limit buffer to 1024 bytes. If MFLN is not supported, it will still work well, as long as the server does not send any message above 1024 bytes. On ESP32 buffers are raised to 2048 bytes.","title":"Limitations"},{"location":"TLS/#implementation-notes","text":"Arduino Core switched from AxTLS to BearSSL in 2.4.2, allowing further optimization of the TLS library footprint. BearSSL is designed for compactness, both in code size and memory requirements. Furthermore it is modular and allows for inclusion of only the code necessary for the subset of crypto-algorithms you want to support. All numbers below are for ESP8266 Thanks to BearSSL's compactness and aggressive optimization, the minimal TLS configuration requires just 34.5k of Flash and 6.7k of Memory . The full-blown AWS IoT version with full certificate validation requires 48.3k of Flash and 9.4k of Memory. Here are the tips and tricks used to reduce Flash and Memory: MFLN (Maximum Fragment Length Negotiation): TLS normally uses 16k buffers for send and receive. 32k looks very small on a server, but immensely huge for ESP8266. TLS 1.2 introduced MFLN, which allows the TLS Client to reduce both buffers down to 512 bytes. MFLN is not widely supported yet, but it is by recent OpenSSL versions and by AWS IoT. This is a huge improvement in memory footprint. If your server does not support MFLN, it will still work as long as the messages sent by the server do not exceed the buffer length. In Tasmota the buffer length is 1024 bytes for send buffer and 1024 bytes for receive buffer. Going below creates message fragmentation and much longer TLS connection times (above 3s). If your server does not support MFLN, you'll see a message to that effect in the logs. Max Certificate size : BearSSL normally supports server certificates of up to RSA 4096 bits and EC 521 bits. These certificates are very uncommon currently. To save extra memory, the included BearSSL library is trimmed down to maximum RSA 2048 bit certificate and EC 256 bit certificate. This should not have any impact for you. Tasmota will crash if the server serves a 4096 bit RSA certificate. The crash will likely be in br_rsa_i15_pkcs1_vrfy . Enable USE_4K_RSA to avoid this behaviour. EC private key : AWS IoT requires the client to authenticate with its own Private Key and Certificate. By default AWS IoT will generate an RSA 2048 bit private key. In Tasmota, we moved to an EC (Elliptic Curve) Private Key of 256 bits. EC keys are much smaller, and handshake is significantly faster. Note: the key being 256 bits does not mean it's less secure than RSA 2048, it's actually the opposite. Single Cipher : to reduce code size, we only support a single TLS cipher and embed only the code strictly necessary. When using TLS (e.g. LetsEncrypt on Mosquitto) the supported cipher is RSA_WITH_AES_128_GCM_SHA256 which is a very commonly supported cipher. For AWS IoT, the only supported cipher is ECDHE_RSA_WITH_AES_128_GCM_SHA256 which is one of the recommended ciphers. Additionally, ECDHE offers Perfect Forward Secrecy which means extra security. Adaptive Thunk Stack : BearSSL does not allocate memory on its own. It's either the caller's responsibility or memory is taken on the Stack. Stack usage can go above 5k, more than the ESP8266 stack. Arduino created a Thunk Stack , a secondary stack of 5.6k, allocated on Heap, and activated when a TLS connection is active. Actually the stack is mostly used during TLS handshake, and much less memory is required during TLS message processing. Tasmota only allocates the Thunk Stack during TLS handshake and switches back to the normal Stack afterwards. See below for details of actual memory usage. Keys and CA in PROGMEM : BearSSL was adapted from original source code to push most on the tables and static data into PROGMEM: https://github.com/earlephilhower/bearssl-esp8266. Additional work now allows us to put the Client Private Key, Certificate and CA in PROGMEM too, saving at least 3k of Memory.","title":"Implementation Notes"},{"location":"TLS/#memory-usage","text":"TLS on Tasmota has been aggressively optimized to use as little memory (heap) as possible. It was also optimized to limit code size. Memory consumption (nominal): BearSSL lib: 1424 bytes (or 1024 bytes with LetsEncrypt or regular TLS) BearSSL ClientContext: 3440 bytes Buffers (1024 bytes in + 1024 bytes out + overhead): 2528 bytes Total = 7.4k (or 7.0k with LetsEncrypt or regular TLS) Note: if you use USE_WEBSERVER , your impact is lowered by 2k since the Web log buffer is reduced from 4k to 2k. Overall, when activating USE_WEBSERVER , you just see a memory impact of 5.4k. Memory needed during connection (TLS handshake - fingerprint validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 1152 bytes Total for connection = 6.5k (or 4.8k with LetsEncrypt or regular TLS) Memory needed during connection (TLS handshake - full CA validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 3072 bytes Total for connection = 8.4k (or 6.7k with LetsEncrypt or regular TLS)","title":"Memory Usage"},{"location":"TLS/#connection-time","text":"ESP8266 is quite slow compared to modern processors when it comes to SSL handshakes. Here are observed performance times when connecting to an SSL/TLS server, depending on CPU frequency (80MHz or 160MHz): AWS IoT Connection, with EC Private Key, simple fingerprint validation: 0.7s at 160MHz 1.3s at 80 MHz AWS IoT Connection, with EC Private Key, full CA validation (easier to configure than fingerprints): 1.0s at 160MHz 1.8s at 80 MHz LetsEncrypt based server (Mosquitto for ex), simple fingerprint validation: 0.3s at 160MHz 0.4s at 80MHz LetsEncrypt based server (Mosquitto for ex), with full CA validation (easier to configure than fingerprint): 0.4s at 160MHz 0.7s at 80MHz","title":"Connection Time"},{"location":"TLS/#tls-troubleshooting","text":"Here are most common TLS errors: Error code Description -1004 Missing CA -1003 Missing EC private key -1002 Cannot connect to TCP port -1001 Cannot resolve IP address -1000 Out of memory error 1 Bad fingerprint 2 BR_ERR_BAD_STATE 3 BR_ERR_UNSUPPORTED_VERSION 4 BR_ERR_BAD_VERSION 5 BR_ERR_BAD_LENGTH 6 BR_ERR_TOO_LARGE 7 BR_ERR_BAD_MAC 8 BR_ERR_NO_RANDOM 9 BR_ERR_UNKNOWN_TYPE 10 BR_ERR_UNEXPECTED 12 BR_ERR_BAD_CCS 13 BR_ERR_BAD_ALERT 14 BR_ERR_BAD_HANDSHAKE 15 BR_ERR_OVERSIZED_ID 16 BR_ERR_BAD_CIPHER_SUITE 17 BR_ERR_BAD_COMPRESSION 18 BR_ERR_BAD_FRAGLEN 19 BR_ERR_BAD_SECRENEG 20 BR_ERR_EXTRA_EXTENSION 21 BR_ERR_BAD_SNI 22 BR_ERR_BAD_HELLO_DONE 23 BR_ERR_LIMIT_EXCEEDED: the server's public key is too large. Tasmota TLS is limited to 2048 RSA keys 24 BR_ERR_BAD_FINISHED 25 BR_ERR_RESUME_MISMATCH 26 BR_ERR_INVALID_ALGORITHM 27 BR_ERR_BAD_SIGNATURE 28 BR_ERR_WRONG_KEY_USAGE 29 BR_ERR_NO_CLIENT_AUTH 31 BR_ERR_IO 54 BR_ERR_X509_EXPIRED X.509 status: certificate is expired or not yet valid. 56 BR_ERR_X509_BAD_SERVER_NAME X.509 status: expected server name was not found in the chain. 62 X509 not trusted, the server certificate is not signed by the CA (AWS IoT or LetsEncrypt) 266 SSL3_ALERT_UNEXPECTED_MESSAGE 276 TLS1_ALERT_BAD_RECORD_MAC 277 TLS1_ALERT_DECRYPTION_FAILED 278 TLS1_ALERT_RECORD_OVERFLOW 286 SSL3_ALERT_DECOMPRESSION_FAIL 296 SSL3_ALERT_HANDSHAKE_FAILURE 298 TLS1_ALERT_BAD_CERTIFICATE: Missing or bad client private key 299 TLS1_ALERT_UNSUPPORTED_CERT 300 TLS1_ALERT_CERTIFICATE_REVOKED 301 TLS1_ALERT_CERTIFICATE_EXPIRED 302 TLS1_ALERT_CERTIFICATE_UNKNOWN 303 SSL3_ALERT_ILLEGAL_PARAMETER 304 TLS1_ALERT_UNKNOWN_CA 305 TLS1_ALERT_ACCESS_DENIED 306 TLS1_ALERT_DECODE_ERROR 307 TLS1_ALERT_DECRYPT_ERROR 316 TLS1_ALERT_EXPORT_RESTRICTION 326 TLS1_ALERT_PROTOCOL_VERSION 327 TLS1_ALERT_INSUFFIENT_SECURITY 336 TLS1_ALERT_INTERNAL_ERROR 346 TLS1_ALERT_USER_CANCELED 356 TLS1_ALERT_NO_RENEGOTIATION 366 TLS1_ALERT_UNSUPPORTED_EXT Additional BR_ERR* error codes","title":"TLS Troubleshooting"},{"location":"TM163x/","text":"TM1637, TM1638 and MAX7219 Seven-Segment Display ~ This feature is included only in tasmota*-display.bin precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DISPLAY #define USE_DISPLAY #endif #ifndef USE_DISPLAY_TM1637 #define USE_DISPLAY_TM1637 #endif In case you want MAX7219 also add: #ifndef USE_DISPLAY_MAX7219 #define USE_DISPLAY_MAX7219 #endif TM1637 TM1638 MAX7219 The TM1637 , TM1638 and MAX7219 display modules are small (~ 10mm high digits) 7-segment, LED-based display units with 4/6 digits (TM1637), 8 digits and 8 digits (TM1638 and MAX7219) respectively. They use a two-wire (TM1637) or three-wire (TM1638 and MAX7219) I2C-like (but not exactly) protocol for communication with MCUs like the ESP8266 / ESP32 / Arduino etc., These modules are a great way to add a simple numeric display to any MCU project. Features ~ The Tasmota support for these modules can -- display Numbers and Floats with control over position and leading zeros . display basic Text , for example, sending the text 22.5^ will display: display Raw segments. display Level , like a bar graph display Scrolling text display a Clock in 12 hr and 24 hr format set Brightness (8 levels) and Clear the display. Info This driver does not support the buttons and LEDs on the TM1638 Configuration ~ Wiring ~ The TM1637 module needs to be connected to two GPIO pins and a 3.3V-5V power supply. TM1637 ESP based module CLK GPIOx DIO GPIOy VCC 3.3V (e.g., ESP-01 ) or 5V (e.g., Wemos D1 Mini ) GND GND The TM1638 module needs to be connected to three GPIO pins and a 5V power supply. TM1638 ESP based module CLK GPIOx DIO GPIOy STB GPIOz VCC 5V GND GND The MAX7219 module needs to be connected to three GPIO pins and a 5V power supply. MAX7219 ESP based module CLK GPIOx DIN GPIOy CS GPIOz VCC 5V GND GND Tasmota Settings ~ In Tasmota 's Configuration -> Configure Module page, assign: For TM1637 GPIOx to TM1637 CLK GPIOy to TM1637 DIO For TM1638 GPIOx to TM1638 CLK GPIOy to TM1638 DIO GPIOz to TM1638 STB For MAX7219 GPIOx to MAX7219 CLK GPIOy to MAX7219 DIN GPIOz to MAX7219 CS For example, if x=0 and y=2, z=4 then the module configuration would look like the following: TM1637 TM1638 MAX7219 Initial Setup ~ The power toggle button in webUI turns the display on or off. However, if there are additional relays defined, resulting in multiple power toggle buttons in WebUI, display power will create and map to the last button. Thus, it is necessary to ensure that relays are numbered from 1, otherwise a conflict will occur with the display power. DisplayModel ~ Once the GPIO configuration is saved and the ESP8266 / ESP32 module restarts, set the Display Model to 15 using the command: DisplayModel 15 DisplayWidth ~ If you have a TM1637 with 6 digits, set the number of digits using the command: DisplayWidth 6 DisplayType ~ The 6-digit TM1637 has 2 known variants with different hardware wiring for the digit ordering. You can switch between these two variants with the following commands: DisplayType 0 - Use this for the Type 0 variant, with wiring similar to the TM1637 4-digit modules DisplayType 1 - Use this for the Type 1 variant, with a different wiring that causes the text 123456 to appear as 321654 After the ESP8266/ESP32 module restarts again, the display module is ready to accept commands. DisplayModes ~ DisplayModes 0..3 are supported. The firmware default is DisplayMode 1 . To use the Seven-Segment specific Display- commands described below, set the DisplayMode to 0 with: DisplayMode 0 DisplayDimmer ~ The brightness of the display can be set using the DisplayDimmer command. DisplayDimmer 0..100 maps the brightness value to 8 steps from 0..7 For a minimum brightness, make sure this value is at least about 13 7-Segment specific Commands ~ The Display- commands listed below can be used from the Tasmota web-console, MQTT , and from Tasmota Rules Commands and Usage ~ Console/MQTT Commands Description values DisplayClear Clears the display DisplayNumber Clears and then displays number without decimal. command e.g., \"DisplayNumber 1234\". Control position , leading zeros , and length . position can be 0 (left-most) to NUM_DIGITS-1 (right-most), leading zeros can be 1 or 0 (default), length can be 1 to NUM_DIGITS (4 or 6). Command example: DisplayNumber 12, 1, 1, 3 This will display: num [, position [, leading_zeros [, length ]]] DisplayNumberNC Display integer number as above, but without clearing first. e.g., \"DisplayNumberNC 1234\". Usage is same as above. same as above DisplayFloat Clears and then displays float (with decimal point) command e.g., \"DisplayFloat 12.34\". Control position , precision , and length . position can be 0 (left-most) to NUM_DIGITS-1 (right-most), precision can be 0 to NUM_DIGITS (default), length can be 1 to NUM_DIGITS (4 or 6). Command example: DisplayFloat 2.48, 1, 1, 2 This will display: num [, position [, precision [, length ]]] DisplayFloatNC Displays float (with decimal point) as above, but without clearing first. command e.g., \"DisplayFloatNC 12.34\" same as above DisplayRaw Takes up to NUM_DIGITS comma-separated integers (0-255) and displays raw segments. Each number represents a 7-segment digit. Each 8-bit number represents individual segments of a digit. Segment a=1, b=2, c=4, d=8, e=16, f=32, g=64 and h (decimal point)=128. To turn on all segments, the number would be 1+2+4+8+16+32+64+128 = 255 For example, the command DisplayRaw 0, 2, 255, 255 would display: position , length , num1 [, num2 [, num3 [, num4 [, ...up to NUM_DIGITS numbers]]...] DisplayText Clears and then displays basic text. Command e.g., DisplayText a.b12 Control length and position of the displayed text. length can be 1 to NUM_DIGITS , position can be 0 (left-most) to NUM_DIGITS-1 (right-most) A caret( ^ ) symbol in the text input is displayed as the degrees( \u00b0 ) symbol. This is useful for displaying Temperature (or angle)! For example, the command DisplayText 22.5^ will display: text [, position [, length ]] DisplayTextNC Displays text without first clearing the display. Usage is same as above. same as above DisplayScrollText Displays scrolling text, up to 50 characters. If num_iterations is not specified, it scrolls indefinitely, until another Display- command is issued. Optionally, specifying num_iterations causes the scrolling to stop after the specified number of iterations. Command examples: DisplayScrollText tasmota is awesome -- causes indefinite scrolling DisplayScrollText tasmota is awesome, 5 -- causes scrolling to stop after 5 iterations text [, num_iterations ] DisplayScrollDelay Sets the speed of text scroll. Smaller delay = faster scrolling. 0 to 15 DisplayLevel Display a horizontal bar graph. Command e.g., DisplayLevel 50 will display: 0 to 100 DisplayClock Displays a clock. DisplayClock 1 displays a clock in 12-hour format. DisplayClock 2 displays a clock in 24-hour format. DisplayClock 0 turns off the clock and clears the display 1 or 2 or 0 Usage in Rules ~ All the above commands can be used in Tasmota Rules , as usual. For example, a simple digital thermometer can be implemented by connecting a DHT22 Temperature-Humidity Sensor and a TM1637 to a Wemos D1 Mini , and writing a Rule like the following: Rule1 ON Tele - AM2301 # Temperature DO DisplayText % value %^ ENDON Another example, using a MAX7219 and a SHT3X temp/humidity sensor, with value comparison so displaytext only fires when the value changes. The first four digits display the temperature and the second four digits display the humidity. The DisplayTextNC command is used to leave unused digits illuminated, so both numbers can be independently updated. Rule1 on sht3x#Temperature!=%var1% do backlog displaytextnc %value%^;var1 %value% endon on sht3x#Humidity!=%var2% do backlog displaytextnc %value%h,4;var2 %value% endon on system#init do power 1 endon TM1637 Images ~ The TM1637 4-digit module (front and back) TM1637 4-digit module with Wemos D1 Mini","title":"TM1637, TM1638 and MAX7219 Seven-Segment Display"},{"location":"TM163x/#tm1637-tm1638-and-max7219-seven-segment-display","text":"This feature is included only in tasmota*-display.bin precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_DISPLAY #define USE_DISPLAY #endif #ifndef USE_DISPLAY_TM1637 #define USE_DISPLAY_TM1637 #endif In case you want MAX7219 also add: #ifndef USE_DISPLAY_MAX7219 #define USE_DISPLAY_MAX7219 #endif TM1637 TM1638 MAX7219 The TM1637 , TM1638 and MAX7219 display modules are small (~ 10mm high digits) 7-segment, LED-based display units with 4/6 digits (TM1637), 8 digits and 8 digits (TM1638 and MAX7219) respectively. They use a two-wire (TM1637) or three-wire (TM1638 and MAX7219) I2C-like (but not exactly) protocol for communication with MCUs like the ESP8266 / ESP32 / Arduino etc., These modules are a great way to add a simple numeric display to any MCU project.","title":"TM1637, TM1638 and MAX7219 Seven-Segment Display"},{"location":"TM163x/#features","text":"The Tasmota support for these modules can -- display Numbers and Floats with control over position and leading zeros . display basic Text , for example, sending the text 22.5^ will display: display Raw segments. display Level , like a bar graph display Scrolling text display a Clock in 12 hr and 24 hr format set Brightness (8 levels) and Clear the display. Info This driver does not support the buttons and LEDs on the TM1638","title":"Features"},{"location":"TM163x/#configuration","text":"","title":"Configuration"},{"location":"TM163x/#wiring","text":"The TM1637 module needs to be connected to two GPIO pins and a 3.3V-5V power supply. TM1637 ESP based module CLK GPIOx DIO GPIOy VCC 3.3V (e.g., ESP-01 ) or 5V (e.g., Wemos D1 Mini ) GND GND The TM1638 module needs to be connected to three GPIO pins and a 5V power supply. TM1638 ESP based module CLK GPIOx DIO GPIOy STB GPIOz VCC 5V GND GND The MAX7219 module needs to be connected to three GPIO pins and a 5V power supply. MAX7219 ESP based module CLK GPIOx DIN GPIOy CS GPIOz VCC 5V GND GND","title":"Wiring"},{"location":"TM163x/#tasmota-settings","text":"In Tasmota 's Configuration -> Configure Module page, assign: For TM1637 GPIOx to TM1637 CLK GPIOy to TM1637 DIO For TM1638 GPIOx to TM1638 CLK GPIOy to TM1638 DIO GPIOz to TM1638 STB For MAX7219 GPIOx to MAX7219 CLK GPIOy to MAX7219 DIN GPIOz to MAX7219 CS For example, if x=0 and y=2, z=4 then the module configuration would look like the following: TM1637 TM1638 MAX7219","title":"Tasmota Settings"},{"location":"TM163x/#initial-setup","text":"The power toggle button in webUI turns the display on or off. However, if there are additional relays defined, resulting in multiple power toggle buttons in WebUI, display power will create and map to the last button. Thus, it is necessary to ensure that relays are numbered from 1, otherwise a conflict will occur with the display power.","title":"Initial Setup"},{"location":"TM163x/#displaymodel","text":"Once the GPIO configuration is saved and the ESP8266 / ESP32 module restarts, set the Display Model to 15 using the command: DisplayModel 15","title":"DisplayModel"},{"location":"TM163x/#displaywidth","text":"If you have a TM1637 with 6 digits, set the number of digits using the command: DisplayWidth 6","title":"DisplayWidth"},{"location":"TM163x/#displaytype","text":"The 6-digit TM1637 has 2 known variants with different hardware wiring for the digit ordering. You can switch between these two variants with the following commands: DisplayType 0 - Use this for the Type 0 variant, with wiring similar to the TM1637 4-digit modules DisplayType 1 - Use this for the Type 1 variant, with a different wiring that causes the text 123456 to appear as 321654 After the ESP8266/ESP32 module restarts again, the display module is ready to accept commands.","title":"DisplayType"},{"location":"TM163x/#displaymodes","text":"DisplayModes 0..3 are supported. The firmware default is DisplayMode 1 . To use the Seven-Segment specific Display- commands described below, set the DisplayMode to 0 with: DisplayMode 0","title":"DisplayModes"},{"location":"TM163x/#displaydimmer","text":"The brightness of the display can be set using the DisplayDimmer command. DisplayDimmer 0..100 maps the brightness value to 8 steps from 0..7 For a minimum brightness, make sure this value is at least about 13","title":"DisplayDimmer"},{"location":"TM163x/#7-segment-specific-commands","text":"The Display- commands listed below can be used from the Tasmota web-console, MQTT , and from Tasmota Rules","title":"7-Segment specific Commands"},{"location":"TM163x/#commands-and-usage","text":"Console/MQTT Commands Description values DisplayClear Clears the display DisplayNumber Clears and then displays number without decimal. command e.g., \"DisplayNumber 1234\". Control position , leading zeros , and length . position can be 0 (left-most) to NUM_DIGITS-1 (right-most), leading zeros can be 1 or 0 (default), length can be 1 to NUM_DIGITS (4 or 6). Command example: DisplayNumber 12, 1, 1, 3 This will display: num [, position [, leading_zeros [, length ]]] DisplayNumberNC Display integer number as above, but without clearing first. e.g., \"DisplayNumberNC 1234\". Usage is same as above. same as above DisplayFloat Clears and then displays float (with decimal point) command e.g., \"DisplayFloat 12.34\". Control position , precision , and length . position can be 0 (left-most) to NUM_DIGITS-1 (right-most), precision can be 0 to NUM_DIGITS (default), length can be 1 to NUM_DIGITS (4 or 6). Command example: DisplayFloat 2.48, 1, 1, 2 This will display: num [, position [, precision [, length ]]] DisplayFloatNC Displays float (with decimal point) as above, but without clearing first. command e.g., \"DisplayFloatNC 12.34\" same as above DisplayRaw Takes up to NUM_DIGITS comma-separated integers (0-255) and displays raw segments. Each number represents a 7-segment digit. Each 8-bit number represents individual segments of a digit. Segment a=1, b=2, c=4, d=8, e=16, f=32, g=64 and h (decimal point)=128. To turn on all segments, the number would be 1+2+4+8+16+32+64+128 = 255 For example, the command DisplayRaw 0, 2, 255, 255 would display: position , length , num1 [, num2 [, num3 [, num4 [, ...up to NUM_DIGITS numbers]]...] DisplayText Clears and then displays basic text. Command e.g., DisplayText a.b12 Control length and position of the displayed text. length can be 1 to NUM_DIGITS , position can be 0 (left-most) to NUM_DIGITS-1 (right-most) A caret( ^ ) symbol in the text input is displayed as the degrees( \u00b0 ) symbol. This is useful for displaying Temperature (or angle)! For example, the command DisplayText 22.5^ will display: text [, position [, length ]] DisplayTextNC Displays text without first clearing the display. Usage is same as above. same as above DisplayScrollText Displays scrolling text, up to 50 characters. If num_iterations is not specified, it scrolls indefinitely, until another Display- command is issued. Optionally, specifying num_iterations causes the scrolling to stop after the specified number of iterations. Command examples: DisplayScrollText tasmota is awesome -- causes indefinite scrolling DisplayScrollText tasmota is awesome, 5 -- causes scrolling to stop after 5 iterations text [, num_iterations ] DisplayScrollDelay Sets the speed of text scroll. Smaller delay = faster scrolling. 0 to 15 DisplayLevel Display a horizontal bar graph. Command e.g., DisplayLevel 50 will display: 0 to 100 DisplayClock Displays a clock. DisplayClock 1 displays a clock in 12-hour format. DisplayClock 2 displays a clock in 24-hour format. DisplayClock 0 turns off the clock and clears the display 1 or 2 or 0","title":"Commands and Usage"},{"location":"TM163x/#usage-in-rules","text":"All the above commands can be used in Tasmota Rules , as usual. For example, a simple digital thermometer can be implemented by connecting a DHT22 Temperature-Humidity Sensor and a TM1637 to a Wemos D1 Mini , and writing a Rule like the following: Rule1 ON Tele - AM2301 # Temperature DO DisplayText % value %^ ENDON Another example, using a MAX7219 and a SHT3X temp/humidity sensor, with value comparison so displaytext only fires when the value changes. The first four digits display the temperature and the second four digits display the humidity. The DisplayTextNC command is used to leave unused digits illuminated, so both numbers can be independently updated. Rule1 on sht3x#Temperature!=%var1% do backlog displaytextnc %value%^;var1 %value% endon on sht3x#Humidity!=%var2% do backlog displaytextnc %value%h,4;var2 %value% endon on system#init do power 1 endon","title":"Usage in Rules"},{"location":"TM163x/#tm1637-images","text":"The TM1637 4-digit module (front and back) TM1637 4-digit module with Wemos D1 Mini","title":"TM1637 Images"},{"location":"TSL2561/","text":"TSL2561 light sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_TSL2561 #define USE_TSL2561 // [I2cDriver16] Enable TSL2561 sensor (I2C address 0x29, 0x39 or 0x49) using library Joba_Tsl2561 (+2k3 code) #endif The TSL2561 luminosity sensor is an advanced digital light I 2 C sensor, ideal for use in a wide range of light situations. Configuration ~ Wiring ~ TSL2561 ESP GND GND VCC 3.3V SCL GPIOy SDA GPIOx INT not used Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect TSL2561 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON response: { \"Time\" : \"2019-11-03T21:04:05\" , \"TSL2561\" :{ \"Illuminance\" : 21.180 }} Breakout Boards ~","title":"TSL2561 light sensor"},{"location":"TSL2561/#tsl2561-light-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_TSL2561 #define USE_TSL2561 // [I2cDriver16] Enable TSL2561 sensor (I2C address 0x29, 0x39 or 0x49) using library Joba_Tsl2561 (+2k3 code) #endif The TSL2561 luminosity sensor is an advanced digital light I 2 C sensor, ideal for use in a wide range of light situations.","title":"TSL2561 light sensor"},{"location":"TSL2561/#configuration","text":"","title":"Configuration"},{"location":"TSL2561/#wiring","text":"TSL2561 ESP GND GND VCC 3.3V SCL GPIOy SDA GPIOx INT not used","title":"Wiring"},{"location":"TSL2561/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL After a reboot the driver will detect TSL2561 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON response: { \"Time\" : \"2019-11-03T21:04:05\" , \"TSL2561\" :{ \"Illuminance\" : 21.180 }}","title":"Tasmota Settings"},{"location":"TSL2561/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"TX2x/","text":"TX20/TX23/WS2300-15 anemometer ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : For TX20 sensor #ifndef USE_TX20_WIND_SENSOR #define USE_TX20_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif For TX23 sensor #ifndef USE_TX23_WIND_SENSOR #define USE_TX23_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif For WS2300-15 sensor #ifndef USE_WS2300_WIND_SENSOR #define USE_WS2300_WIND_SENSOR // Add support for Technoline WS2300-15 anemometer #endif This setting compiles Tasmota with sensor statistical values (needs the higher value size of code), which are useful for the wind sensor, since the measured values naturally change very quickly. The values generated in addition to the wind speed and wind direction are: Wind speed min/max Wind speed average (\u2205) Wind direction average (\u2205) Wind direction range (\u2220) and min/max The average (\u2205) values are continuously calculated values. The range (\u2220) and min/max values are held for the time TelePeriod and reset after MQTT SENSOR message has been output. If you do not want the statistical calculation having speed and direction value only, use #ifndef USE_TX2X_WIND_SENSOR_NOSTATISTICS #define USE_TX2X_WIND_SENSOR_NOSTATISTICS #endif in your user_config_override.h . This will save approx. 1k8 bytes of code. The TX20 (retired) and TX23 sensor supplies the two measured values wind speed and wind direction. The TX23 sensor is still available under various brand names such as \"La Crosse\", \"Technoline\". Unfortunately, the TX20 (at least in Europe) is almost impossible to get. However, the two sensors differ only in the protocol used, but deliver the same measured values. Configuration ~ Wiring ~ TX20 / WS2300-15 ~ Pin Color Description ESP 1 Brown/Black TxD GPIOx 2 Red 3.3V 3.3V 3 Green DTR GND 4 Yellow GND GND TX23 ~ Pin Color Description ESP 1 Brown/Black TxD GPIOx 2 Red 3.3V 3.3V 3 Green - - 4 Yellow GND GND Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to TX2x (104) The TX2 pin needs a pull-up resistor. The internal pull-up is activated for this so you can use any useful GPIO except GPIO15 and GPIO16 (GPIO15 is always pulled low, GPIO16 has a built-in pull-down resistor). To be on the save side you can add an additional external 10k pull-up to TX2x GPIOx. After a reboot the driver will detect TX20/TX23/WS2300 automatically and display the wind data: Sensor sends a tele/%topic%/SENSOR JSON response: { \"Time\" : \"2020-03-03T00:00:00+00:00\" , \"TX23\" : { \"Speed\" : { \"Act\" : 14.8 , \"Avg\" : 8.5 , \"Min\" : 12.2 , \"Max\" : 14.8 }, \"Dir\" : { \"Card\" : \"WSW\" , \"Deg\" : 247.5 , \"Avg\" : 266.1 , \"AvgCard\" : \"W\" , \"Min\" : 247.5 , \"Max\" : 247.5 , \"Range\" : 0 } }, \"SpeedUnit\" : \"km/h\" } Commands ~ The wind speed unit is set to km/h as default. You can change the unit using the command SpeedUnit <x> where <x> = 1\u20266 : - 1 = m/s (meter per second) - 2 = km/h (kilometer per hour) - 3 = kn (knots) - 4 = mph (miles per hour) - 5 = ft/s (foot per second) - 6 = yd/s (yard per second) The changed unit will appear in the webUI and via MQTT SENSOR messages.","title":"TX20/TX23/WS2300-15 anemometer"},{"location":"TX2x/#tx20tx23ws2300-15-anemometer","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : For TX20 sensor #ifndef USE_TX20_WIND_SENSOR #define USE_TX20_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif For TX23 sensor #ifndef USE_TX23_WIND_SENSOR #define USE_TX23_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif For WS2300-15 sensor #ifndef USE_WS2300_WIND_SENSOR #define USE_WS2300_WIND_SENSOR // Add support for Technoline WS2300-15 anemometer #endif This setting compiles Tasmota with sensor statistical values (needs the higher value size of code), which are useful for the wind sensor, since the measured values naturally change very quickly. The values generated in addition to the wind speed and wind direction are: Wind speed min/max Wind speed average (\u2205) Wind direction average (\u2205) Wind direction range (\u2220) and min/max The average (\u2205) values are continuously calculated values. The range (\u2220) and min/max values are held for the time TelePeriod and reset after MQTT SENSOR message has been output. If you do not want the statistical calculation having speed and direction value only, use #ifndef USE_TX2X_WIND_SENSOR_NOSTATISTICS #define USE_TX2X_WIND_SENSOR_NOSTATISTICS #endif in your user_config_override.h . This will save approx. 1k8 bytes of code. The TX20 (retired) and TX23 sensor supplies the two measured values wind speed and wind direction. The TX23 sensor is still available under various brand names such as \"La Crosse\", \"Technoline\". Unfortunately, the TX20 (at least in Europe) is almost impossible to get. However, the two sensors differ only in the protocol used, but deliver the same measured values.","title":"TX20/TX23/WS2300-15 anemometer"},{"location":"TX2x/#configuration","text":"","title":"Configuration"},{"location":"TX2x/#wiring","text":"","title":"Wiring"},{"location":"TX2x/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to TX2x (104) The TX2 pin needs a pull-up resistor. The internal pull-up is activated for this so you can use any useful GPIO except GPIO15 and GPIO16 (GPIO15 is always pulled low, GPIO16 has a built-in pull-down resistor). To be on the save side you can add an additional external 10k pull-up to TX2x GPIOx. After a reboot the driver will detect TX20/TX23/WS2300 automatically and display the wind data: Sensor sends a tele/%topic%/SENSOR JSON response: { \"Time\" : \"2020-03-03T00:00:00+00:00\" , \"TX23\" : { \"Speed\" : { \"Act\" : 14.8 , \"Avg\" : 8.5 , \"Min\" : 12.2 , \"Max\" : 14.8 }, \"Dir\" : { \"Card\" : \"WSW\" , \"Deg\" : 247.5 , \"Avg\" : 266.1 , \"AvgCard\" : \"W\" , \"Min\" : 247.5 , \"Max\" : 247.5 , \"Range\" : 0 } }, \"SpeedUnit\" : \"km/h\" }","title":"Tasmota Settings"},{"location":"TX2x/#commands","text":"The wind speed unit is set to km/h as default. You can change the unit using the command SpeedUnit <x> where <x> = 1\u20266 : - 1 = m/s (meter per second) - 2 = km/h (kilometer per hour) - 3 = kn (knots) - 4 = mph (miles per hour) - 5 = ft/s (foot per second) - 6 = yd/s (yard per second) The changed unit will appear in the webUI and via MQTT SENSOR messages.","title":"Commands"},{"location":"TasUI/","text":"Warning Development of TasUI has stopped!!! TasUI is a zero-install device management interface web application for all your Tasmota devices. It will discover your deployed devices and allow you to set up and configure every device from a single dashboard. This initial version includes multiple views (Control, Health, Firmware, Wi-Fi, & MQTT) to allow you to quickly assess the state of your devices. There is also a detailed view (e.g., SetOptions, Status, etc.) available. TasUI provides a syntax-aware command interface for every Tasmota command by category (e.g., Configuration, Timers, Sensors, Lights, etc.) as well as the \"familiar\" Console interface to enter commands directly. This is a beta version (i.e., we expect you to find some unexpected features). As these issues are fixed, it will not require you to reinstall any software to get these fixes. This also applies to new features as they are added to the app. Join us on Discord ! Docker ~ For those who prefer to have everything installed locally, a Docker image for linux amd64 , arm32v7 , arm64v8 and i386 is available for download . docker pull iotreboot/tasui:latest docker run -p [PORT]:80 iotreboot/tasui:latest Home Assistant ~ The add-on can be installed on amd64 , arm32v7 , arm64v8 and i386 builds. Simply add the TasUI repository on your addons list: https://github.com/iotreboot/TasUI No configuration is required.","title":"TasUI"},{"location":"TasUI/#docker","text":"For those who prefer to have everything installed locally, a Docker image for linux amd64 , arm32v7 , arm64v8 and i386 is available for download . docker pull iotreboot/tasui:latest docker run -p [PORT]:80 iotreboot/tasui:latest","title":"Docker"},{"location":"TasUI/#home-assistant","text":"The add-on can be installed on amd64 , arm32v7 , arm64v8 and i386 builds. Simply add the TasUI repository on your addons list: https://github.com/iotreboot/TasUI No configuration is required.","title":"Home Assistant"},{"location":"TasmoAdmin/","text":"TasmoAdmin is an administrative Website for Devices flashed with Tasmota . You can find it here: TasmoAdmin GitHub . It supports running on Windows, Linux and as Docker container. Features ~ Login protected Multi Update Process Select devices to update Automatic Modus downloads latest firmware bin from Tasmota GitHub Show device information Mobile Responsive (Bootstrap4) Config devices SelfUpdate function for TasmoAdmin (disabled for Docker) NightMode (Enable/Disable/Auto) in settings AutoScan to find Tasmota Devices Support for multiple sensors chat (beta) Installation ~ Docker ~ TasmoAdmin is available as a Docker image on GitHub packages . This is a Linux Alpine based image with Nginx and PHP7 installed. It supports multiple architectures, amd64 (i.e. Synology DSM), arm (i.e. Raspberry PI3) and arm64 (i.e. Pine64). Check out the Guide for TasmoAdmin on Docker for setup instructions. This is the recommended way to get up and running. Windows ~ A ready to use TasmoAdmin-XAMP-Portable-*.zip is available on the release page and is based on XAMPP. Download the XAMPP Zip package from the releases page Extract the Zip (recommend to put the xamp folder on C:\\ Run once the xamp\\setup_xampp.bat Start xampp-control.exe Start Apache in the opened ControlCenter Get your local IP Address Now you can type in your browser http://YOURLOCALIP and TasmoAdmin shows up. Linux ~ Running TasmoAdmin on a Linux/Unix hosts requires the following: * A Webserver * apache2 recommended * php7 recommended (works with php5 too) * php-curl php-zip Modules installed You need to install a web server with php-zip and php-curl modules installed. Also mod_rewrite must be enabled. I suggest to look in the Guide for Ubuntu Server 16.04 and try to adjust it to your server OS. Example Images ~ Login Page ~ Start Page ~ Devices Page ~ Devices Add/Edit Page ~ Config General Page ~ Config Network Page ~ Update Devices Page ~ Settings Page ~ Mobile ~","title":"TasmoAdmin"},{"location":"TasmoAdmin/#features","text":"Login protected Multi Update Process Select devices to update Automatic Modus downloads latest firmware bin from Tasmota GitHub Show device information Mobile Responsive (Bootstrap4) Config devices SelfUpdate function for TasmoAdmin (disabled for Docker) NightMode (Enable/Disable/Auto) in settings AutoScan to find Tasmota Devices Support for multiple sensors chat (beta)","title":"Features"},{"location":"TasmoAdmin/#installation","text":"","title":"Installation"},{"location":"TasmoAdmin/#docker","text":"TasmoAdmin is available as a Docker image on GitHub packages . This is a Linux Alpine based image with Nginx and PHP7 installed. It supports multiple architectures, amd64 (i.e. Synology DSM), arm (i.e. Raspberry PI3) and arm64 (i.e. Pine64). Check out the Guide for TasmoAdmin on Docker for setup instructions. This is the recommended way to get up and running.","title":"Docker"},{"location":"TasmoAdmin/#windows","text":"A ready to use TasmoAdmin-XAMP-Portable-*.zip is available on the release page and is based on XAMPP. Download the XAMPP Zip package from the releases page Extract the Zip (recommend to put the xamp folder on C:\\ Run once the xamp\\setup_xampp.bat Start xampp-control.exe Start Apache in the opened ControlCenter Get your local IP Address Now you can type in your browser http://YOURLOCALIP and TasmoAdmin shows up.","title":"Windows"},{"location":"TasmoAdmin/#linux","text":"Running TasmoAdmin on a Linux/Unix hosts requires the following: * A Webserver * apache2 recommended * php7 recommended (works with php5 too) * php-curl php-zip Modules installed You need to install a web server with php-zip and php-curl modules installed. Also mod_rewrite must be enabled. I suggest to look in the Guide for Ubuntu Server 16.04 and try to adjust it to your server OS.","title":"Linux"},{"location":"TasmoAdmin/#example-images","text":"","title":"Example Images"},{"location":"Tasmota-Application/","text":"Tasmota Application Files ~ Easily import any configuration or script using the .tapp file extension Any file with .tapp (Tasmota Application) extension will be considered as an uncompressed ZIP, and if it contains a sub-file autoexec.be it will be executed. In parallel tasmota.wd (working dir) contains the archive tapp prefix to easily load other assets from the same archive. Example heating.tapp contains: autoexec.be and html.json . The sub-file html.json can be opened with f = open(tasmota.wd + \"html.json\", \"r\") Berry allow imports from files inside a Tasmota App (.tapp file). Also enabled sys module. Here is the code you should add in your autoexec.be inside tapp file: import sys var wd = tasmota . wd if size ( wd ) sys . path () . push ( wd ) end # [...] you can import files from within the archive if size ( wd ) sys . path () . pop () end TAPP's ~ LCD/OLED Anti Screen Burn ~ copy Antiburn.tapp to file system Either issue Tasmota command Antiburn or programmatically using lv.antiburn() in Berry The LVGL screen will change from black to red to green to blue to white each second for 30 seconds. The anti-burn cleaning can be cancelled by touching the screen or it will complete after 30 seconds. Once complete the previous screen will be reloaded. Partition Management ~ Partition Wizard Partition Manager Display Calibration ~ Tasmota Application useful for Touch Screen calibration (resistive touchscreens only). This application guides you through simple steps and generates automatically the required settings in display.ini (the ':M' line). First download DisplayCalibrate.tapp application and upload it in the file system, and restart. Make sure you are in orientation DisplayRotate 0 In the console, type the command DisplayCalibrate You will see the following screens. Click on all 4 crosses near corners. Note: measures are taken every 50 ms and are averaged, and requires at least 3 measures (150ms). If everything went well, you will see the following screen. After reboot, your touchscreen is ready and calibrate. If the geometry is wrong, you will see the following screen and no change is done to display.ini","title":"Tasmota Application Files"},{"location":"Tasmota-Application/#tasmota-application-files","text":"Easily import any configuration or script using the .tapp file extension Any file with .tapp (Tasmota Application) extension will be considered as an uncompressed ZIP, and if it contains a sub-file autoexec.be it will be executed. In parallel tasmota.wd (working dir) contains the archive tapp prefix to easily load other assets from the same archive. Example heating.tapp contains: autoexec.be and html.json . The sub-file html.json can be opened with f = open(tasmota.wd + \"html.json\", \"r\") Berry allow imports from files inside a Tasmota App (.tapp file). Also enabled sys module. Here is the code you should add in your autoexec.be inside tapp file: import sys var wd = tasmota . wd if size ( wd ) sys . path () . push ( wd ) end # [...] you can import files from within the archive if size ( wd ) sys . path () . pop () end","title":"Tasmota Application Files"},{"location":"Tasmota-Application/#tapps","text":"","title":"TAPP's"},{"location":"Tasmota-Application/#lcdoled-anti-screen-burn","text":"copy Antiburn.tapp to file system Either issue Tasmota command Antiburn or programmatically using lv.antiburn() in Berry The LVGL screen will change from black to red to green to blue to white each second for 30 seconds. The anti-burn cleaning can be cancelled by touching the screen or it will complete after 30 seconds. Once complete the previous screen will be reloaded.","title":"LCD/OLED Anti Screen Burn"},{"location":"Tasmota-Application/#partition-management","text":"Partition Wizard Partition Manager","title":"Partition Management"},{"location":"Tasmota-Application/#display-calibration","text":"Tasmota Application useful for Touch Screen calibration (resistive touchscreens only). This application guides you through simple steps and generates automatically the required settings in display.ini (the ':M' line). First download DisplayCalibrate.tapp application and upload it in the file system, and restart. Make sure you are in orientation DisplayRotate 0 In the console, type the command DisplayCalibrate You will see the following screens. Click on all 4 crosses near corners. Note: measures are taken every 50 ms and are averaged, and requires at least 3 measures (150ms). If everything went well, you will see the following screen. After reboot, your touchscreen is ready and calibrate. If the geometry is wrong, you will see the following screen and no change is done to display.ini","title":"Display Calibration"},{"location":"Tasmota-Device-Locator/","text":"Tasmota Device Locator ~ Locate Tasmota Devices on your network when you only know the subnet of the device. The search is done with JavaScript in a browser and no software installation is required. Only newer devices with HTTP Cross-Origin Resource Sharing (CORS) support will be found. CORS is disabled in Tasmota by default. Use the CORS command to change this setting. Usage ~ Enter any IP address in the subnet and it will search for devices on the entire subnet. For example, specify 192.168.0.0 to locate all devices in the range 192.168.0.0 to 192.168.0.255. If the devices are password protected also enter the password. The password will be tried on all devices. If they have different passwords, multiple searches must be performed. Run the live version ~ The live version can be found here Local Deployment ~ If you want to run your own server, the Tasmota Device Locator can be served by any static http server (not https). - Checkout the branch gh-pages. - Copy the files to the root of the web server Development ~ Sources can be found on github, Tasmota Device Locator .","title":"Tasmota Device Locator"},{"location":"Tasmota-Device-Locator/#tasmota-device-locator","text":"Locate Tasmota Devices on your network when you only know the subnet of the device. The search is done with JavaScript in a browser and no software installation is required. Only newer devices with HTTP Cross-Origin Resource Sharing (CORS) support will be found. CORS is disabled in Tasmota by default. Use the CORS command to change this setting.","title":"Tasmota Device Locator"},{"location":"Tasmota-Device-Locator/#usage","text":"Enter any IP address in the subnet and it will search for devices on the entire subnet. For example, specify 192.168.0.0 to locate all devices in the range 192.168.0.0 to 192.168.0.255. If the devices are password protected also enter the password. The password will be tried on all devices. If they have different passwords, multiple searches must be performed.","title":"Usage"},{"location":"Tasmota-Device-Locator/#run-the-live-version","text":"The live version can be found here","title":"Run the live version"},{"location":"Tasmota-Device-Locator/#local-deployment","text":"If you want to run your own server, the Tasmota Device Locator can be served by any static http server (not https). - Checkout the branch gh-pages. - Copy the files to the root of the web server","title":"Local Deployment"},{"location":"Tasmota-Device-Locator/#development","text":"Sources can be found on github, Tasmota Device Locator .","title":"Development"},{"location":"Tasmota-Device-Manager/","text":"Tasmota Device Manager or TDM is a GUI application written in Python for discovery and monitoring of Tasmota flashed devices. Features ~ clean, readable interface autodetection of devices following the default topic template for Tasmota (%prefix%/%topic%/) and for HomeAssistant Auto Discovery protocol (%topic%/%prefix%/) module and GPIO configuration rules editor devices with different syntax can be added manually clean retained MQTT topic messages toggleable active querying of telemetry passive monitoring of state and telemetry (currently supported sensors are listed in \"status8.json\") relay control via context menu on device list (all ON/OFF, or individual) MQTT console with payload preview (dbl-click an entry to display), sorting and filtering selectable detail columns in device list BSSID aliasing for larger deployments Installation ~ Python 3.6+ is required. Clone the repo or download zip and extract, install prerequisites and run tdm.py using Python binary. Prerequisites ~ PyQt5: pip install PyQt5 paho-mqtt: pip install paho-mqtt","title":"Tasmota Device Manager"},{"location":"Tasmota-Device-Manager/#features","text":"clean, readable interface autodetection of devices following the default topic template for Tasmota (%prefix%/%topic%/) and for HomeAssistant Auto Discovery protocol (%topic%/%prefix%/) module and GPIO configuration rules editor devices with different syntax can be added manually clean retained MQTT topic messages toggleable active querying of telemetry passive monitoring of state and telemetry (currently supported sensors are listed in \"status8.json\") relay control via context menu on device list (all ON/OFF, or individual) MQTT console with payload preview (dbl-click an entry to display), sorting and filtering selectable detail columns in device list BSSID aliasing for larger deployments","title":"Features"},{"location":"Tasmota-Device-Manager/#installation","text":"Python 3.6+ is required. Clone the repo or download zip and extract, install prerequisites and run tdm.py using Python binary.","title":"Installation"},{"location":"Tasmota-Device-Manager/#prerequisites","text":"PyQt5: pip install PyQt5 paho-mqtt: pip install paho-mqtt","title":"Prerequisites"},{"location":"Tasmota-IR/","text":"The default Tasmota firmware variants include support for IR send/receive for a limited set of protocols (see IR Remote ). Tasmota uses the IRremoteESP8266 library that supports numerous protocols. Each protocol consumes some memory, especially air conditioner protocols (up to 81k of flash size). Also, every protocol included increases the time to decode the IR signal. There are two additional Tasmota firmware variants that provide almost all IRremoteESP8266 protocols. This requires disabling some other features to keep code size manageable. tasmota-ir is pre-packaged for IR bridge devices such as Automate Things IRBR , Eachen or YTF . Choose tasmota-ir if you are using an IR blaster. tasmota-ircustom is used if you want to customize your features (additional sensors, language, etc.). See compile your own firmware . You can flash the binary or upgrade your existing one. To test that you have the correct firmware on your device issue the following command in the web UI Console: IRhvac {\"Vendor\":\"xx\"} The output should be a list of the supported protocols/vendors. For example: RESULT = {\"IRHVAC\":\"Wrong Vendor (COOLIX|DAIKIN|KELVINATOR|MITSUBISHI_AC|GREE|ARGO|TROTEC|TOSHIBA_AC|FUJITSU_AC|MIDEA|HAIER_AC|HITACHI_AC|HAIER_AC_YRW02|WHIRLPOOL_AC|SAMSUNG_AC|ELECTRA_AC|PANASONIC_AC|DAIKIN2|VESTEL_AC|TECO|TCL112AC|MITSUBISHI_HEAVY_88|MITSUBISHI_HEAVY_152|DAIKIN216|SHARP_AC|GOODWEATHER|DAIKIN160|NEOCLIMA|DAIKIN176|DAIKIN128|AMCOR)\"} Sending IR Commands ~ Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . Neither GPIO01 nor GPIO03 can be used. Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload Sending IRHVAC Commands ~ Command Parameters IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E|ARDB1 Panasonic_AC : LKE|NKE|DKE|JKE|CKP|RKR Whirlpool_AC : DG11J13A|DG11J104|DG11J1-04|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds \"StateMode\" : SendOnly (default) StoreOnly SendStore Controling ACs with toggle fields ~ Some ACs such as Airwell, Whirlpool and others use a differential IR protocol for some properites. If \"power\" is a toggle property, then value of '1' in the protocol will mean \"turn off\" if the AC is currently \"on\" and it will mean \"turn on\" if the AC is currently \"off\". This could also be the case for other properties such as \"light\", \"swing\", etc. Since Tasmota and IRRemote8266 send and receive absolute states (i.e. the HVAC JSON object has a field called 'Power' not 'PowerToggle'), some functionaly was added to keep track of the predicted state of the AC. This way, if the predicted state is in-sync with the actual state, the device can transmit a correct IR packet to transition the AC from the previous state to the desired state. This logic is controlled by the StateMode HVAC property. If your AC IR protocol sends absolute values you can ignore this property. If your AC has a differential protocol Tasmota will be able to control the AC assuming the Tasmota IR device has at most one differential AC in IR range. If you would like to also control your AC with the physical remote your Tamsota IR device will need to have an IR receiver so that it can sync with the actual state. If at some point the state in Tasmota and the actual state get out of sync, you can specify StateMode=StoreOnly to update Tasmota with the actual state. This will update state but not send an IR command. Normally when receiving an IR command via the IR reciever the command will be processed and the state will be updated. As a result it is not needed to store state when sending as it will cause duplication and the toggle will happen twice. The most common operation mode, and default, therefore is StateMode=SendOnly . If your Tasmota device does not have an IR receiver you can still control a differential AC with it by specifying StateMode=SendStore but you will not be able to use a physical remote without loosing sync between the actual and predicted states. Receiving IR Commands ~ If you have an IR receiver, a message will be logged each time an IR message is seen. IR driver will try to decode the message against all supported protocols. If unrecognized, the \"Protocol\":\"UNKNOWN\" will be shown. In this case, the \"Data\" field contains a hash of the received message. The hash can't be used to send the a message, but the same hash will be produced by the same message. An inexpensive IR sensor such as a TSOP1838 can be connected to a device running Tasmota. Configure a free device GPIO as 'IRrecv (51)'. When Tasmota receives an IR message, the data portion of the payload has the same format as the IRsend parameter. {\"IrReceived\":{\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>}} This JSON payload data can be used in a rule such as: ON IrReceived#Data=<value> DO <command> ENDON If the data is received on an unknown protocol use SetOption58 1 . See here . Examples: Pioneer Vol+ MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0}} Pioneer Vol- tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD02FA55AD02F\",\"DataLSB\":\"0xA55A0BF4A55A0BF4\",\"Repeat\":0}} Toshiba (NEC): Channel 1 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD807F\",\"DataLSB\":\"0x40BF01FE\",\"Repeat\":0}} Toshiba (NEC): Channel 2 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD40BF\",\"DataLSB\":\"0x40BF02FD\",\"Repeat\":0}} Toshiba (NEC): Channel 3 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FDC03F\",\"DataLSB\":\"0x40BF03FC\",\"Repeat\":0}} As you can see above, \"DataLSB\" are easier to decode than \"Data\" . The third byte contains the command, and the fourth byte is the third with all bits reversed. Example of HVAC message: MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"MITSUBISHI_HEAVY_152\",\"Bits\":152,\"Data\":\"0xAD513CE51A08F705FA02FDC03F08F700FF807F\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"MITSUBISHI_HEAVY_152\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}} MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"COOLIX\",\"Bits\":24,\"Data\":\"0xB25F78\",\"DataLSB\":\"0x4DFA1E\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"COOLIX\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"on\",\"Filter\":\"off\",\"Clean\":\"on\",\"Beep\":\"off\",\"Sleep\":-1}}} RSL: RESULT = {\"Time\":\"2019-09-09T21:52:35\",\"IrReceived\":{\"Protocol\":\"PANASONIC_AC\",\"Bits\":216,\"Data\":\"0x0220E004000000060220E00400032C805F06000EE0000081000089\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"PANASONIC_AC\",\"Model\":2,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"auto\",\"SwingH\":\"middle\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}}","title":"IR Communication"},{"location":"Tasmota-IR/#sending-ir-commands","text":"Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . Neither GPIO01 nor GPIO03 can be used. Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also SetOption29 - Set IR received data format SetOption38 - Set IR received protocol sensitivity SetOption58 - IR Raw data in JSON payload","title":"Sending IR Commands"},{"location":"Tasmota-IR/#sending-irhvac-commands","text":"Command Parameters IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E|ARDB1 Panasonic_AC : LKE|NKE|DKE|JKE|CKP|RKR Whirlpool_AC : DG11J13A|DG11J104|DG11J1-04|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds \"StateMode\" : SendOnly (default) StoreOnly SendStore","title":"Sending IRHVAC Commands"},{"location":"Tasmota-IR/#controling-acs-with-toggle-fields","text":"Some ACs such as Airwell, Whirlpool and others use a differential IR protocol for some properites. If \"power\" is a toggle property, then value of '1' in the protocol will mean \"turn off\" if the AC is currently \"on\" and it will mean \"turn on\" if the AC is currently \"off\". This could also be the case for other properties such as \"light\", \"swing\", etc. Since Tasmota and IRRemote8266 send and receive absolute states (i.e. the HVAC JSON object has a field called 'Power' not 'PowerToggle'), some functionaly was added to keep track of the predicted state of the AC. This way, if the predicted state is in-sync with the actual state, the device can transmit a correct IR packet to transition the AC from the previous state to the desired state. This logic is controlled by the StateMode HVAC property. If your AC IR protocol sends absolute values you can ignore this property. If your AC has a differential protocol Tasmota will be able to control the AC assuming the Tasmota IR device has at most one differential AC in IR range. If you would like to also control your AC with the physical remote your Tamsota IR device will need to have an IR receiver so that it can sync with the actual state. If at some point the state in Tasmota and the actual state get out of sync, you can specify StateMode=StoreOnly to update Tasmota with the actual state. This will update state but not send an IR command. Normally when receiving an IR command via the IR reciever the command will be processed and the state will be updated. As a result it is not needed to store state when sending as it will cause duplication and the toggle will happen twice. The most common operation mode, and default, therefore is StateMode=SendOnly . If your Tasmota device does not have an IR receiver you can still control a differential AC with it by specifying StateMode=SendStore but you will not be able to use a physical remote without loosing sync between the actual and predicted states.","title":"Controling ACs with toggle fields"},{"location":"Tasmota-IR/#receiving-ir-commands","text":"If you have an IR receiver, a message will be logged each time an IR message is seen. IR driver will try to decode the message against all supported protocols. If unrecognized, the \"Protocol\":\"UNKNOWN\" will be shown. In this case, the \"Data\" field contains a hash of the received message. The hash can't be used to send the a message, but the same hash will be produced by the same message. An inexpensive IR sensor such as a TSOP1838 can be connected to a device running Tasmota. Configure a free device GPIO as 'IRrecv (51)'. When Tasmota receives an IR message, the data portion of the payload has the same format as the IRsend parameter. {\"IrReceived\":{\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>}} This JSON payload data can be used in a rule such as: ON IrReceived#Data=<value> DO <command> ENDON If the data is received on an unknown protocol use SetOption58 1 . See here . Examples: Pioneer Vol+ MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0}} Pioneer Vol- tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD02FA55AD02F\",\"DataLSB\":\"0xA55A0BF4A55A0BF4\",\"Repeat\":0}} Toshiba (NEC): Channel 1 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD807F\",\"DataLSB\":\"0x40BF01FE\",\"Repeat\":0}} Toshiba (NEC): Channel 2 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD40BF\",\"DataLSB\":\"0x40BF02FD\",\"Repeat\":0}} Toshiba (NEC): Channel 3 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FDC03F\",\"DataLSB\":\"0x40BF03FC\",\"Repeat\":0}} As you can see above, \"DataLSB\" are easier to decode than \"Data\" . The third byte contains the command, and the fourth byte is the third with all bits reversed. Example of HVAC message: MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"MITSUBISHI_HEAVY_152\",\"Bits\":152,\"Data\":\"0xAD513CE51A08F705FA02FDC03F08F700FF807F\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"MITSUBISHI_HEAVY_152\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}} MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"COOLIX\",\"Bits\":24,\"Data\":\"0xB25F78\",\"DataLSB\":\"0x4DFA1E\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"COOLIX\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"on\",\"Filter\":\"off\",\"Clean\":\"on\",\"Beep\":\"off\",\"Sleep\":-1}}} RSL: RESULT = {\"Time\":\"2019-09-09T21:52:35\",\"IrReceived\":{\"Protocol\":\"PANASONIC_AC\",\"Bits\":216,\"Data\":\"0x0220E004000000060220E00400032C805F06000EE0000081000089\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"PANASONIC_AC\",\"Model\":2,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"auto\",\"SwingH\":\"middle\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}}","title":"Receiving IR Commands"},{"location":"TasmotaClient/","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_TASMOTA_CLIENT #define USE_TASMOTA_CLIENT // Enable the driver #endif #ifndef USE_TASMOTA_CLIENT_FLASH_SPEED #define USE_TASMOTA_CLIENT_FLASH_SPEED 57600 // Configure the baud rate of the bootloader #endif #ifndef USE_TASMOTA_CLIENT_SERIAL_SPEED 57600 #define USE_TASMOTA_CLIENT_SERIAL_SPEED 57600 // Configure the baud rate at which the client microcontroller will be interfacing to Tasmota #endif It is possible to amend your existing Arduino Uno / Mini / Nano project to interface with a Tasmota powered ESP8266/ESP8285 generic development boards such as the Wemos D1 or NodeMCU branded hardware boards. The creation of a client driver interface implemented since Tasmota 7.0.0.2 enables this possibility. Please note that the USE_TASMOTA_CLIENT_FLASH_SPEED will depend on the variant of Arduino Uno/Mini/Nano board you are using - The general observation is that the 3.3V devices usually run at 57600 whereas the 5V devices usually run on 115200 but this is provided for guidance only as it has been found that some boards will not necessarily adhere to this. The main driving factor behind the baud rate is the crystal oscillator on the board which is usually 8Mhz for 3.3V variants and 16Mhz for 5V variants - hence 57600 being 1/2 of 115200. It should also be noted that this option is only really applicable if you're actually using an Arduino UNO/Mini/Nano as a client device and you want to be able to update the firmware on the Arduino OTA via the Tasmota Web UI. If you are using another type of microcontroller, obviously the OTA update functionality will not work (for now, until support is added for other microcontrollers). But if you are able to program the device manually there is no reason why you cannot use any microcontroller or development board as a client to your Tasmota powered ESP8266/8285 hardware. Once you have compiled your own variant with the correct settings and flashed the self-compiled binary to your Tasmota device it is time to make the necessary configuration within Tasmota. Configuring Tasmota to use the TasmotaClient functionality ~ The communication interface between Tasmota and your client micro-controller will be over serial communication. To make this possible you will need to configure two of the GPIO pins to Client TX and Client RX respectively. In addition to this you also need to define the GPIO which will be used to pull the reset pin of your client microcontroller down to GND or up to 3.3V, so either Client RST for normal reset behaviour (active low) or Client RSTi for inverted reset behaviour (active high) As mentioned above it is possible to connect any microcontroller of your choice but for the purpose of this article, only the implementation of an Arduino Pro Mini (3.3V) will be covered. Getting things wired up ~ With Tasmota GPIO configuration provided above you may now proceed to make the necessary electrical connections between the ESP8266/ESP8285 and your client device, for example: ESP Arduino Pro Mini (3.3V) VCC VCC GND GND D2 (GPIO4) RX (0) D1 (GPIO5) TX (1) D4 (GPIO2) Reset (RST) So to visualize the above: Please verify your specific board's pin naming as they are not always exactly the same depending on where they came from! Compiling a test sketch for the client ~ The TasmotaClient driver requires your client to operate within specific parameters allowed by the driver itself so head over to the TasmotaClient Library and install the library in your local Arduino development environment. Once installed you should be able to access the examples from the menu system: Make sure you have the correct board and speed selected: Now that everything is set, it's time to export the compiled binary by selecting it from the Arduino menu: Once completed head over to the known folder you chose in previous steps and locate the .hex file which should be in the same folder as where your sketch was originally saved to. You will most likely see a file listing like this: You are interested in Blink.ino.eightanaloginputs.hex and can ignore the one which has bootloader as part of the file name since the Arduino Pro Mini already has the bootloader flashed. Take note of the location and name of this file as you will need it in the next step to upload the compiled file to your client device. Uploading a new hex file to your client device ~ If you are using an Arduino Pro Mini as is the case in this example you would have created a .hex file in the previous step. This file can be flashed directly to the Arduino Pro Mini via the Tasmota Web UI. Navigate to the Firmware Upgrade page where you would normally upload a new binary file to upgrade Tasmota. The same method is used to upload a HEX file to the client device. Tasmota will automatically decide where it will flash the upload based on whether you're uploading a .bin file or a .hex file. Tasmota will prompt you for the firmware file you wish to upload - You need to navigate to the previously known location folder you chose in earlier steps and select the .hex file previously identified: After selecting the hex file you may proceed to click the Start Upgrade button: The hex file will upload to Tasmota and Tasmota will flash the new client firmware onto the Arduino Pro Mini and present you with the following web page: After the device completes a restart you should now have an Arduino Pro Mini running as a client where the blink is controlled from Tasmota's internal one-second callback.","title":"Arduino MCU"},{"location":"TasmotaClient/#configuring-tasmota-to-use-the-tasmotaclient-functionality","text":"The communication interface between Tasmota and your client micro-controller will be over serial communication. To make this possible you will need to configure two of the GPIO pins to Client TX and Client RX respectively. In addition to this you also need to define the GPIO which will be used to pull the reset pin of your client microcontroller down to GND or up to 3.3V, so either Client RST for normal reset behaviour (active low) or Client RSTi for inverted reset behaviour (active high) As mentioned above it is possible to connect any microcontroller of your choice but for the purpose of this article, only the implementation of an Arduino Pro Mini (3.3V) will be covered.","title":"Configuring Tasmota to use the TasmotaClient functionality"},{"location":"TasmotaClient/#getting-things-wired-up","text":"With Tasmota GPIO configuration provided above you may now proceed to make the necessary electrical connections between the ESP8266/ESP8285 and your client device, for example: ESP Arduino Pro Mini (3.3V) VCC VCC GND GND D2 (GPIO4) RX (0) D1 (GPIO5) TX (1) D4 (GPIO2) Reset (RST) So to visualize the above: Please verify your specific board's pin naming as they are not always exactly the same depending on where they came from!","title":"Getting things wired up"},{"location":"TasmotaClient/#compiling-a-test-sketch-for-the-client","text":"The TasmotaClient driver requires your client to operate within specific parameters allowed by the driver itself so head over to the TasmotaClient Library and install the library in your local Arduino development environment. Once installed you should be able to access the examples from the menu system: Make sure you have the correct board and speed selected: Now that everything is set, it's time to export the compiled binary by selecting it from the Arduino menu: Once completed head over to the known folder you chose in previous steps and locate the .hex file which should be in the same folder as where your sketch was originally saved to. You will most likely see a file listing like this: You are interested in Blink.ino.eightanaloginputs.hex and can ignore the one which has bootloader as part of the file name since the Arduino Pro Mini already has the bootloader flashed. Take note of the location and name of this file as you will need it in the next step to upload the compiled file to your client device.","title":"Compiling a test sketch for the client"},{"location":"TasmotaClient/#uploading-a-new-hex-file-to-your-client-device","text":"If you are using an Arduino Pro Mini as is the case in this example you would have created a .hex file in the previous step. This file can be flashed directly to the Arduino Pro Mini via the Tasmota Web UI. Navigate to the Firmware Upgrade page where you would normally upload a new binary file to upgrade Tasmota. The same method is used to upload a HEX file to the client device. Tasmota will automatically decide where it will flash the upload based on whether you're uploading a .bin file or a .hex file. Tasmota will prompt you for the firmware file you wish to upload - You need to navigate to the previously known location folder you chose in earlier steps and select the .hex file previously identified: After selecting the hex file you may proceed to click the Start Upgrade button: The hex file will upload to Tasmota and Tasmota will flash the new client firmware onto the Arduino Pro Mini and present you with the following web page: After the device completes a restart you should now have an Arduino Pro Mini running as a client where the blink is controlled from Tasmota's internal one-second callback.","title":"Uploading a new hex file to your client device"},{"location":"Teleinfo/","text":"This feature is not included in precompiled binaries. See below how to build you own Tasmota with Teleinfo enabled. Overview ~ Teleinfo is an Tasmota ENERGY driver for energy meters installed by French national electricity grid manager Enedis in all households. Teleinfo driver works with either legacy meters or the new Linky meters. It is based on Charles Hallard's LibTeleinfo. Teleinfo driver features: Support for Legacy mode (mode Historique at 1200 baud) or Standard mode (9600 baud) Extract fields to feed Tasmota standard ENERGY module allowing Tasmota to report standard SENSOR.ENERGY messages and all related features (PowerDelta, margins, ...) Publish raw Teleinfo frame to MQTT for processing by the backend Support in french is available on Charles Hallard forums . Compiling with support for Teleinfo ~ As the feature is not included by default, you must compile your build . To enable Teleinfo, add the following line in your user_config_override.h and compile tasmota or tasmota32 . #define USE_TELEINFO But as I'm testing lot of boards, my preference goes to add my custom boards section into the file platformio_tasmota_cenv.ini For example on ESP8266 board with teleinfo and I2C display to display Energy data [env:tasmota-tic-display] extends = env:tasmota platform_packages = ${common.platform_packages} build_unflags = ${common.build_unflags} build_flags = ${common.build_flags} -DUSE_TELEINFO -DUSE_DISPLAY Configure GPIOs for Teleinfo ~ Serial reception ~ Once you have flashed Tasmota with the support for Teleinfo, you need to configure the proper GPIO to receive the Teleinfo serial data with \"TInfo RX\" On ESP8266, suitable pins are Standard UART0 RX pin on GPIO3 Alternate UART0 RX pin on GPIO13 (D7) On ESP32, most of the pins can be used since uart can be mapped on almost all pins. On Denky boards it's connected to GPIO33 and on new DenkyD4 it's on GPIO8. Optional enable pin ~ An optional Enable GPIO can be configured as \"TInfo EN\". Any GPIO output can be used for that purpose. Enable pin is for low power future use and avoid to have any consumption when there is nothing to do. For example schematic on custom Denky board (ESP32) is as follow Resistors values R3 and R4 need to be changed to work with standard and historique . New official values for R3 is 220ohm and R4 is 3.3Kohm. As you can see GPIO33 is used for RX and GPIO4 for Enable (need set to 1 to be able to receive data) Setup in this case is Enable pin on GPIO4 RX pin on GPIO33 Another example on ESP8266 could be D5/GPIO14: After selecting the GPIOs, click on \"SAVE\" and Tasmota will reboot. Configuring Teleinfo ~ You can customize Teleinfo with the command EnergyConfig <command> <parameter> . The list of supported commands and parameters are: Command Parameters Without any command and parameter, displays the current active configuration. Historique Set Teleinfo in legacy ( historique ) mode at 1200 baud. Standard Set Teleinfo in standard mode at 9600 baud. NoRaw Disable sending of raw frame (see below). Full Enable sending of all frames in raw mode. Changed Enable sending raw frames only when data has changed. Skip n Skips n frames before sending raw frame. Limit Limit raw frames to values subject fo fast change (Power, Current, ...) Changing mode from historique to standard and vice-versa will restart tamota. Check current configuration ~ First thing is to see how teleinfo is configured, for this you need to use EnergyConfig command from console 17:24:56.758 CMD: EnergyConfig 17:24:56.766 TIC: Settings Mode:historique, RX:GPIO23, EN:None, Raw:noraw, Skip:0, Limit:0 17:24:56.783 MQT: emoncms/ch2i/factory/denky_D6C0C0/stat/RESULT = {\"EnergyConfig\":\"Done\"} In this case we can see we are in historique mode, RX data is coming on GPIO32 (it's an ESP32) and Enable Pin is not used. No MQTT raw frame will be sent (noraw) on teleinfo frame reception, so keeping default config of telemetry. Energy from Teleinfo ~ If correct mode and GPIO configuration are set, you'll be able to see on main tasmota screen something like that It's happening only as soon as tasmota was able to read one valid frame from Teleinfo. Data received from teleinfo is used by tasmota in real time to display information but also to calculate daily energy consumption. Of course as Teleinfo is returning lot of data (such as kWh indexes) all interesting information is displayed on the Web interface. Since we know (because it's on teleinfo frame) the current contract we can display bargraph of charge (in %). This can help to see when main house smartmeter will shut down due to over consumption (for example) Default data ~ If configuration is left by default (and if you have configured MQTT of course) you will receive a frame each time telemtry happens (menu configuration -> configure logging -> telemetry period ) which is by default every 5 minutes. You can check on console, the frame received is sent every 5 minutes under SENSOR topic as a JSON string. This frame as all default tasmota fields and also a object ENERGY related to tasmota Energy module. 17:28:45.907 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"Time\":\"2021-10-26T17:28:45\",\"ENERGY\":{\"TotalStartTime\":\"2021-10-25T15:22:04\",\"Total\":9098.245,\"Yesterday\":6822.685,\"Today\":2275.560,\"Period\": 9,\"Power\":170,\"Current\":1.000,\"Load\":6},\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275560,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0},\"ESP32\":{\"Temperature\":36.1},\"TempUnit\":\"C\"} 17:33:45.906 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"Time\":\"2021-10-26T17:33:45\",\"ENERGY\":{\"TotalStartTime\":\"2021-10-25T15:22:04\",\"Total\":9098.255,\"Yesterday\":6822.685,\"Today\":2275.570,\"Period\":10,\"Power\":190,\"Current\":1.000,\"Load\":6},\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275570,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":190,\"HHPHC\":\"A\",\"MOTDETAT\":0},\"ESP32\":{\"Temperature\":36.1},\"TempUnit\":\"C\"} 17:38:45.905 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"Time\":\"2021-10-26T17:38:45\",\"ENERGY\":{\"TotalStartTime\":\"2021-10-25T15:22:04\",\"Total\":9098.265,\"Yesterday\":6822.685,\"Today\":2275.579,\"Period\": 9,\"Power\":170,\"Current\":1.000,\"Load\":6},\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275579,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0},\"ESP32\":{\"Temperature\":36.7},\"TempUnit\":\"C\"} But in our case we have also a TIC object which contains all the frame received on teleinfo frame (last reveived value), for example in the frame above the TIC object is the following. { \"TIC\" :{ \"ADCO\" : \"021528603314\" , \"OPTARIF\" : \"HC..\" , \"ISOUSC\" : 15 , \"HCHC\" : 920750 , \"HCHP\" : 2275579 , \"PTEC\" : \"HP..\" , \"IINST\" : 1 , \"IMAX\" : 2 , \"PAPP\" : 170 , \"HHPHC\" : \"A\" , \"MOTDETAT\" : 0 } } Sending data to other ~ Teleinfo is a very powerfull tool to monitor house energy consumption that many of you may need to send theese date to backend for other treatment. For example receiving power value every 5 minutes may be an issue to real time monitoring house consuption, this is why we introduced option to send data in real time. Best would be sending full received frame to MQTT for example, let's do that. Raw Frame going outside (MQTT) ~ To enable real time raw teleinfo frame to be sent to MQTT you need to use EnergyConfig Full command from console 17:57:04.579 TIC: Raw to 'full' 17:57:04.594 MQT: emoncms/ch2i/factory/denky_D6C0C0/stat/RESULT = {\"EnergyConfig\":\"Done\"} 17:57:05.038 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275613,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":180,\"HHPHC\":\"A\",\"MOTDETAT\":0}} 17:57:06.693 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275613,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":180,\"HHPHC\":\"A\",\"MOTDETAT\":0}} 17:57:08.183 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275614,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0}} 17:57:09.684 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275614,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":200,\"HHPHC\":\"A\",\"MOTDETAT\":0}} Then each frame received is sent immediatly thru MQTT Skip frames ~ Depending on what you want to do on backend side it may be too much data and flood your database so we intrduced Skip flag. For example we may need only one frame up to 10 to be send on backend (so free up some network traffic). To limit teleinfo frame to one each 10 frames, you need to use EnergyConfig Skip 10 command from console 18:04:43.210 CMD: EnergyConfig Skip 10 18:04:43.214 TIC: Raw each 11 frame(s) 18:04:43.226 MQT: emoncms/ch2i/factory/denky_D6C0C0/stat/RESULT = {\"EnergyConfig\":\"Done\"} 18:05:00.438 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275628,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0}} 18:05:17.438 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275629,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0}} As you can see we now send one full frame every approx 17s, choose your limit depending on frame lenght (of course) and serial speed. In historique mode a frame takes about 1.2s to be received. This works only if Raw mode has been selected with EnergyConfig Full . Relevant data ~ We can also going further, in previous mode, even if we limited the number of frames sent, a complete frame with all data was send. And this is not optimized because some fields in the frame may vary only once or twice a day PTEC or even never ADCO , ISOUSC , ... So we indroduced the Changed mode where only data changed from one frame to another is sent. To enable this mode, you need to use EnergyConfig Changed command from console 18:28:57.610 CMD: EnergyConfig Changed 18:28:57.615 TIC: Raw to 'changed' 18:28:57.627 MQT: emoncms/ch2i/factory/denky_D6C0C0/stat/RESULT = {\"EnergyConfig\":\"Done\"} 18:29:00.425 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"PAPP\":160}} 18:29:17.745 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"PAPP\":190}} 18:29:34.689 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"PAPP\":170}} As you can see we now only data changed is sent. This works only if Raw mode has been selected with EnergyConfig Full and Skip mode should be disabled EnergyConfig Skip 0 for this to works properly. Don't worry about other fields, they will be send on each telemetry data as usual. Tasmota Rules examples ~ Raw Frame going outside (HTTP) ~ TBD, example to post HTTP data every 5 minutes Driving RGB Led depening on power ~ TBD, example to manage Led from Green (no charge) to Red (full charge) Tasmota Berry script examples ~ TBD, any idea is welcome Display info on display ~ TBD, any idea is welcome Raw frames examples ~ You can find various raw frames for standard and historique mode and different contracts on Teleinfo replay tool here Hardware information ~ Basic Schematics ~ Classic connectivity of teleinfo can be done with following schematic, works with historique and standard mode. DIY or ready made Shields ~ WeMos ~ Wemos Mini D1 (ESP8266) and MH-ET Live ESP32 Mini Kit You can get more information about this shield on github repository Raspberry Pi (Bare PCB) ~ You can also use or buy tiny Raspberry Pi shield to connect Teleinfo output signal to Tasmota device RX Pin Documentation and reference of this shield are available on tindie References ~ You can find a lot of information, such as schematics and wiring diagrams, on Charles' blog","title":"Teleinfo"},{"location":"Teleinfo/#overview","text":"Teleinfo is an Tasmota ENERGY driver for energy meters installed by French national electricity grid manager Enedis in all households. Teleinfo driver works with either legacy meters or the new Linky meters. It is based on Charles Hallard's LibTeleinfo. Teleinfo driver features: Support for Legacy mode (mode Historique at 1200 baud) or Standard mode (9600 baud) Extract fields to feed Tasmota standard ENERGY module allowing Tasmota to report standard SENSOR.ENERGY messages and all related features (PowerDelta, margins, ...) Publish raw Teleinfo frame to MQTT for processing by the backend Support in french is available on Charles Hallard forums .","title":"Overview"},{"location":"Teleinfo/#compiling-with-support-for-teleinfo","text":"As the feature is not included by default, you must compile your build . To enable Teleinfo, add the following line in your user_config_override.h and compile tasmota or tasmota32 . #define USE_TELEINFO But as I'm testing lot of boards, my preference goes to add my custom boards section into the file platformio_tasmota_cenv.ini For example on ESP8266 board with teleinfo and I2C display to display Energy data [env:tasmota-tic-display] extends = env:tasmota platform_packages = ${common.platform_packages} build_unflags = ${common.build_unflags} build_flags = ${common.build_flags} -DUSE_TELEINFO -DUSE_DISPLAY","title":"Compiling with support for Teleinfo"},{"location":"Teleinfo/#configure-gpios-for-teleinfo","text":"","title":"Configure GPIOs for Teleinfo"},{"location":"Teleinfo/#serial-reception","text":"Once you have flashed Tasmota with the support for Teleinfo, you need to configure the proper GPIO to receive the Teleinfo serial data with \"TInfo RX\" On ESP8266, suitable pins are Standard UART0 RX pin on GPIO3 Alternate UART0 RX pin on GPIO13 (D7) On ESP32, most of the pins can be used since uart can be mapped on almost all pins. On Denky boards it's connected to GPIO33 and on new DenkyD4 it's on GPIO8.","title":"Serial reception"},{"location":"Teleinfo/#optional-enable-pin","text":"An optional Enable GPIO can be configured as \"TInfo EN\". Any GPIO output can be used for that purpose. Enable pin is for low power future use and avoid to have any consumption when there is nothing to do. For example schematic on custom Denky board (ESP32) is as follow Resistors values R3 and R4 need to be changed to work with standard and historique . New official values for R3 is 220ohm and R4 is 3.3Kohm. As you can see GPIO33 is used for RX and GPIO4 for Enable (need set to 1 to be able to receive data) Setup in this case is Enable pin on GPIO4 RX pin on GPIO33 Another example on ESP8266 could be D5/GPIO14: After selecting the GPIOs, click on \"SAVE\" and Tasmota will reboot.","title":"Optional enable pin"},{"location":"Teleinfo/#configuring-teleinfo","text":"You can customize Teleinfo with the command EnergyConfig <command> <parameter> . The list of supported commands and parameters are: Command Parameters Without any command and parameter, displays the current active configuration. Historique Set Teleinfo in legacy ( historique ) mode at 1200 baud. Standard Set Teleinfo in standard mode at 9600 baud. NoRaw Disable sending of raw frame (see below). Full Enable sending of all frames in raw mode. Changed Enable sending raw frames only when data has changed. Skip n Skips n frames before sending raw frame. Limit Limit raw frames to values subject fo fast change (Power, Current, ...) Changing mode from historique to standard and vice-versa will restart tamota.","title":"Configuring Teleinfo"},{"location":"Teleinfo/#check-current-configuration","text":"First thing is to see how teleinfo is configured, for this you need to use EnergyConfig command from console 17:24:56.758 CMD: EnergyConfig 17:24:56.766 TIC: Settings Mode:historique, RX:GPIO23, EN:None, Raw:noraw, Skip:0, Limit:0 17:24:56.783 MQT: emoncms/ch2i/factory/denky_D6C0C0/stat/RESULT = {\"EnergyConfig\":\"Done\"} In this case we can see we are in historique mode, RX data is coming on GPIO32 (it's an ESP32) and Enable Pin is not used. No MQTT raw frame will be sent (noraw) on teleinfo frame reception, so keeping default config of telemetry.","title":"Check current configuration"},{"location":"Teleinfo/#energy-from-teleinfo","text":"If correct mode and GPIO configuration are set, you'll be able to see on main tasmota screen something like that It's happening only as soon as tasmota was able to read one valid frame from Teleinfo. Data received from teleinfo is used by tasmota in real time to display information but also to calculate daily energy consumption. Of course as Teleinfo is returning lot of data (such as kWh indexes) all interesting information is displayed on the Web interface. Since we know (because it's on teleinfo frame) the current contract we can display bargraph of charge (in %). This can help to see when main house smartmeter will shut down due to over consumption (for example)","title":"Energy from Teleinfo"},{"location":"Teleinfo/#default-data","text":"If configuration is left by default (and if you have configured MQTT of course) you will receive a frame each time telemtry happens (menu configuration -> configure logging -> telemetry period ) which is by default every 5 minutes. You can check on console, the frame received is sent every 5 minutes under SENSOR topic as a JSON string. This frame as all default tasmota fields and also a object ENERGY related to tasmota Energy module. 17:28:45.907 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"Time\":\"2021-10-26T17:28:45\",\"ENERGY\":{\"TotalStartTime\":\"2021-10-25T15:22:04\",\"Total\":9098.245,\"Yesterday\":6822.685,\"Today\":2275.560,\"Period\": 9,\"Power\":170,\"Current\":1.000,\"Load\":6},\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275560,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0},\"ESP32\":{\"Temperature\":36.1},\"TempUnit\":\"C\"} 17:33:45.906 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"Time\":\"2021-10-26T17:33:45\",\"ENERGY\":{\"TotalStartTime\":\"2021-10-25T15:22:04\",\"Total\":9098.255,\"Yesterday\":6822.685,\"Today\":2275.570,\"Period\":10,\"Power\":190,\"Current\":1.000,\"Load\":6},\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275570,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":190,\"HHPHC\":\"A\",\"MOTDETAT\":0},\"ESP32\":{\"Temperature\":36.1},\"TempUnit\":\"C\"} 17:38:45.905 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"Time\":\"2021-10-26T17:38:45\",\"ENERGY\":{\"TotalStartTime\":\"2021-10-25T15:22:04\",\"Total\":9098.265,\"Yesterday\":6822.685,\"Today\":2275.579,\"Period\": 9,\"Power\":170,\"Current\":1.000,\"Load\":6},\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275579,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0},\"ESP32\":{\"Temperature\":36.7},\"TempUnit\":\"C\"} But in our case we have also a TIC object which contains all the frame received on teleinfo frame (last reveived value), for example in the frame above the TIC object is the following. { \"TIC\" :{ \"ADCO\" : \"021528603314\" , \"OPTARIF\" : \"HC..\" , \"ISOUSC\" : 15 , \"HCHC\" : 920750 , \"HCHP\" : 2275579 , \"PTEC\" : \"HP..\" , \"IINST\" : 1 , \"IMAX\" : 2 , \"PAPP\" : 170 , \"HHPHC\" : \"A\" , \"MOTDETAT\" : 0 } }","title":"Default data"},{"location":"Teleinfo/#sending-data-to-other","text":"Teleinfo is a very powerfull tool to monitor house energy consumption that many of you may need to send theese date to backend for other treatment. For example receiving power value every 5 minutes may be an issue to real time monitoring house consuption, this is why we introduced option to send data in real time. Best would be sending full received frame to MQTT for example, let's do that.","title":"Sending data to other"},{"location":"Teleinfo/#raw-frame-going-outside-mqtt","text":"To enable real time raw teleinfo frame to be sent to MQTT you need to use EnergyConfig Full command from console 17:57:04.579 TIC: Raw to 'full' 17:57:04.594 MQT: emoncms/ch2i/factory/denky_D6C0C0/stat/RESULT = {\"EnergyConfig\":\"Done\"} 17:57:05.038 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275613,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":180,\"HHPHC\":\"A\",\"MOTDETAT\":0}} 17:57:06.693 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275613,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":180,\"HHPHC\":\"A\",\"MOTDETAT\":0}} 17:57:08.183 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275614,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0}} 17:57:09.684 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275614,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":200,\"HHPHC\":\"A\",\"MOTDETAT\":0}} Then each frame received is sent immediatly thru MQTT","title":"Raw Frame going outside (MQTT)"},{"location":"Teleinfo/#skip-frames","text":"Depending on what you want to do on backend side it may be too much data and flood your database so we intrduced Skip flag. For example we may need only one frame up to 10 to be send on backend (so free up some network traffic). To limit teleinfo frame to one each 10 frames, you need to use EnergyConfig Skip 10 command from console 18:04:43.210 CMD: EnergyConfig Skip 10 18:04:43.214 TIC: Raw each 11 frame(s) 18:04:43.226 MQT: emoncms/ch2i/factory/denky_D6C0C0/stat/RESULT = {\"EnergyConfig\":\"Done\"} 18:05:00.438 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275628,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0}} 18:05:17.438 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"ADCO\":\"021528603314\",\"OPTARIF\":\"HC..\",\"ISOUSC\":15,\"HCHC\":920750,\"HCHP\":2275629,\"PTEC\":\"HP..\",\"IINST\":1,\"IMAX\":2,\"PAPP\":170,\"HHPHC\":\"A\",\"MOTDETAT\":0}} As you can see we now send one full frame every approx 17s, choose your limit depending on frame lenght (of course) and serial speed. In historique mode a frame takes about 1.2s to be received. This works only if Raw mode has been selected with EnergyConfig Full .","title":"Skip frames"},{"location":"Teleinfo/#relevant-data","text":"We can also going further, in previous mode, even if we limited the number of frames sent, a complete frame with all data was send. And this is not optimized because some fields in the frame may vary only once or twice a day PTEC or even never ADCO , ISOUSC , ... So we indroduced the Changed mode where only data changed from one frame to another is sent. To enable this mode, you need to use EnergyConfig Changed command from console 18:28:57.610 CMD: EnergyConfig Changed 18:28:57.615 TIC: Raw to 'changed' 18:28:57.627 MQT: emoncms/ch2i/factory/denky_D6C0C0/stat/RESULT = {\"EnergyConfig\":\"Done\"} 18:29:00.425 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"PAPP\":160}} 18:29:17.745 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"PAPP\":190}} 18:29:34.689 MQT: emoncms/ch2i/factory/denky_D6C0C0/tele/SENSOR = {\"TIC\":{\"PAPP\":170}} As you can see we now only data changed is sent. This works only if Raw mode has been selected with EnergyConfig Full and Skip mode should be disabled EnergyConfig Skip 0 for this to works properly. Don't worry about other fields, they will be send on each telemetry data as usual.","title":"Relevant data"},{"location":"Teleinfo/#tasmota-rules-examples","text":"","title":"Tasmota Rules examples"},{"location":"Teleinfo/#raw-frame-going-outside-http","text":"TBD, example to post HTTP data every 5 minutes","title":"Raw Frame going outside (HTTP)"},{"location":"Teleinfo/#driving-rgb-led-depening-on-power","text":"TBD, example to manage Led from Green (no charge) to Red (full charge)","title":"Driving RGB Led depening on power"},{"location":"Teleinfo/#tasmota-berry-script-examples","text":"TBD, any idea is welcome","title":"Tasmota Berry script examples"},{"location":"Teleinfo/#display-info-on-display","text":"TBD, any idea is welcome","title":"Display info on display"},{"location":"Teleinfo/#raw-frames-examples","text":"You can find various raw frames for standard and historique mode and different contracts on Teleinfo replay tool here","title":"Raw frames examples"},{"location":"Teleinfo/#hardware-information","text":"","title":"Hardware information"},{"location":"Teleinfo/#basic-schematics","text":"Classic connectivity of teleinfo can be done with following schematic, works with historique and standard mode.","title":"Basic Schematics"},{"location":"Teleinfo/#diy-or-ready-made-shields","text":"","title":"DIY or ready made Shields"},{"location":"Teleinfo/#references","text":"You can find a lot of information, such as schematics and wiring diagrams, on Charles' blog","title":"References"},{"location":"Templates/","text":"Template is a definition of a device and how its GPIOs are assigned. Templates provide an easy way for you to create, modify and share configurations for various devices that have features supported in Tasmota. Bug Tasmota 9.1 completely redesigned template layout to allow for future expansion. Read more about the GPIO Conversion . To provide easy processing by Tasmota a template is written as a JSON string and looks like this: { \"NAME\" : \"Example Template\" , \"GPIO\" :[ 416 , 0 , 418 , 0 , 417 , 2720 , 0 , 0 , 2624 , 32 , 2656 , 224 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 } Tip Tasmota Supported Devices Repository has a complete list of supported devices. We encourage everyone who creates a template for a new unknown device to submit it using Add New Template form . How to Use ~ Go to Configuration - Configure Template ... ... and you'll end up looking at this screen. Time to create your template. Creating Your Template ~ Change the template name (also defines the name for the module). Select a module to BASE your template on . If you're not sure, Module 18 is the best choice. In this example the device is based on Blitzwolf SHP (45) module. Configure the components assigned to the GPIOs to match your device. If you do not know what pins your device uses, read about the new device configuration procedure to determine the correct pin assignments. Any unused GPIO that has cannot have a peripheral connected should be set to None (0). In our example the device has no exposed GPIO's so the unused ones are set to 0 compared to the original BlitzWolf module. GPIOs that can have peripherals connected to (exposed GPIOs) should be set to User (1). This allows future configuration through the Configure Module dialog without the need to create a new template. Example Sonoff TH has a jack connected to GPIO4 that allows a user to plug in a sensor. Assigning GPIO4 as User allows a Template to have correct GPIOs for this device even if nothing is plugged in. But, when a user decides to connect a sensor using the jack, GPIO4 can be set to the type of sensor through the Configure Module page. Click on Save and you'll see this message Finally, the device will reboot with the new template name Exporting Your Template ~ Now that you've set up your previously unsupported device in Tasmota it is time to share the knowledge: Check that Module 0 is selected in the Configuration - Configure Module menu. Open up Console and issue command Template which will output a string with the configuration of your currently active template. Our example gives the following: MQT : s tat / tas mo ta /RESULT = { \"NAME\" : \"Merged\" , \"GPIO\" :[ 416 , 0 , 418 , 0 , 417 , 2720 , 0 , 0 , 2624 , 32 , 2656 , 224 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 } Copy the string {\"NAME\":\"Merged\",\"GPIO\":[416,0,418,0,417,2720,0,0,2624,32,2656,224,0,0],\"FLAG\":0,\"BASE\":45} and share it on the Tasmota Supported Devices Repository . Importing Templates ~ Go to Configuration - Configure Other When there: Paste the template string into the Template field Make sure you check Activate Click on Save . The device will reboot with a name reflecting your template name and Module 0 selected which has your new template stored. If your device was previously configured you will have to manually change to Module 0 in * Configuration -> Configure Module * . Commands ~ A user provided template can be stored in Tasmota using the Template command. It has the following parameters. Parameter Description Show current Template 0 Create template from active module 1..71 Create template from a supported module { ... } Store template written in a JSON string 255 Merge configured template and current module Template {\"NAME\":\"Example Template\",\"GPIO\":[416,0,418,0,417,2720,0,0,2624,32,2656,224,0,0],\"FLAG\":0,\"BASE\":45} stores a complete template based on the Generic module Template {\"NAME\":\"AnotherModuleName\"} updates the name of a stored template Template {\"FLAG\":0} changes FLAG value Template {\"BASE\":18} updates the base of a stored template to Generic Template {\"CMND\":\"LedTable 1\"} adds LedTable 1 command to the stored template After setting a template in command line it is necessary to issue Module 0 command if the device doesn't reboot on its own. Merge Template with Module ~ You can set up your device in module * Configuration -> Configure Module * and use command Template 255 to merge the settings of the Module with current template into a new Template named \"Merged\". Anatomy of a Template ~ Let's look again at our example template: {\"NAME\":\"Example Template\",\"GPIO\":[416,0,418,0,417,2720,0,0,2624,32,2656,224,0,0],\"FLAG\":0,\"BASE\":45} The four properties with UPPERCASE property names have the following functionality: Property name Property value description NAME Up to 60 characters for the Module name GPIO Numbers from 0 to 65535 representing GPIO0 to GPIO5, GPIO09, GPIO10 and GPIO12 to GPIO16 and GPIO17 for A0 pin for ESP8266. ESP32 has more configurable GPIO's FLAG * Deprecated Replaced with GPIO17. 8 bit mask flag register. BASE Module number of a hard-coded device to be used when device specific functionality is needed CMND (Optional) Commands executed after activating the template GPIO ~ GPIO order ~ GPIO# |00| 01|02| 03|04| 05| 09| 10| 12| 13| 14| 15| 16| 17 CODE [416,0,418,0,417,2720,0,0,2624,32,2656,224,0,0] GPIO functionality ~ The GPIO functionality numbers are the same as shown by command GPIOs . In addition code 1 is added to select a GPIO as user configurable via the GUI Configure Module menu. Example In our example the GPIO 12 data element is 32 which corresponds to the Button1 component, according to the components table . If you change that template element to 160 it would then be assigned as a Switch1 component instead. Components ~ See Components for a complete list or use command Gpios 255 in console. FLAG ~ Before Tasmota 9.1 used to configure the ADC type. In new templates this should be set to 0 and the analog pin should be configured on GPIO17 FLAG Feature description 0 No features 1 Analog value 2 Temperature 3 Light 4 Button 5 Buttoni 15 User configured (same as User ) BASE ~ BASE is the starting module setup for the custom template. Some modules include special programming. If your device is similar to an existing built-in module it is best to use that as a starting point. When you're not sure which BASE module is suitable for your device use the Generic (18) module. A list of hard-coded devices can be found in Modules . Example In the RGB Smart Plug template we used the BlitzWolf SHP (45) module as BASE since the power monitoring circuitry is identical but GPIO00 and GPIO02 were changed and an unused GPIO04 was added to enable the RGB LED function. Using that specific module we took advantage of that module's calibrated power monitoring special programming which the Generic (18) module does not use. CMND ~ CMND is an optional field in the template JSON string. It is used to embed commands for configuring the device instead of needing to type them in console. Multiple commands are separated with | . \"CMND\":\"<any template related command>|<any template related command>|...\" Commands will only be executed if the template is enabled (device module is set to 0), either before the template is loaded, when the activate box in the UI is selected or if the module 0 command is included in the CMND string itself. Disable LED gamma correction and remap RGB channels { \"NAME\" : \"Example\" , \"GPIO\" :[ 416 , 0 , 418 , 0 , 417 , 2720 , 0 , 0 , 2624 , 32 , 2656 , 224 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 , \"CMND\" : \"LedTable 1|ChannelRemap 36\" } Total size of the template string should not exceed 500 chars.","title":"Templates"},{"location":"Templates/#how-to-use","text":"Go to Configuration - Configure Template ... ... and you'll end up looking at this screen. Time to create your template.","title":"How to Use"},{"location":"Templates/#creating-your-template","text":"Change the template name (also defines the name for the module). Select a module to BASE your template on . If you're not sure, Module 18 is the best choice. In this example the device is based on Blitzwolf SHP (45) module. Configure the components assigned to the GPIOs to match your device. If you do not know what pins your device uses, read about the new device configuration procedure to determine the correct pin assignments. Any unused GPIO that has cannot have a peripheral connected should be set to None (0). In our example the device has no exposed GPIO's so the unused ones are set to 0 compared to the original BlitzWolf module. GPIOs that can have peripherals connected to (exposed GPIOs) should be set to User (1). This allows future configuration through the Configure Module dialog without the need to create a new template. Example Sonoff TH has a jack connected to GPIO4 that allows a user to plug in a sensor. Assigning GPIO4 as User allows a Template to have correct GPIOs for this device even if nothing is plugged in. But, when a user decides to connect a sensor using the jack, GPIO4 can be set to the type of sensor through the Configure Module page. Click on Save and you'll see this message Finally, the device will reboot with the new template name","title":"Creating Your Template"},{"location":"Templates/#exporting-your-template","text":"Now that you've set up your previously unsupported device in Tasmota it is time to share the knowledge: Check that Module 0 is selected in the Configuration - Configure Module menu. Open up Console and issue command Template which will output a string with the configuration of your currently active template. Our example gives the following: MQT : s tat / tas mo ta /RESULT = { \"NAME\" : \"Merged\" , \"GPIO\" :[ 416 , 0 , 418 , 0 , 417 , 2720 , 0 , 0 , 2624 , 32 , 2656 , 224 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 } Copy the string {\"NAME\":\"Merged\",\"GPIO\":[416,0,418,0,417,2720,0,0,2624,32,2656,224,0,0],\"FLAG\":0,\"BASE\":45} and share it on the Tasmota Supported Devices Repository .","title":"Exporting Your Template"},{"location":"Templates/#importing-templates","text":"Go to Configuration - Configure Other When there: Paste the template string into the Template field Make sure you check Activate Click on Save . The device will reboot with a name reflecting your template name and Module 0 selected which has your new template stored. If your device was previously configured you will have to manually change to Module 0 in * Configuration -> Configure Module * .","title":"Importing Templates"},{"location":"Templates/#commands","text":"A user provided template can be stored in Tasmota using the Template command. It has the following parameters. Parameter Description Show current Template 0 Create template from active module 1..71 Create template from a supported module { ... } Store template written in a JSON string 255 Merge configured template and current module Template {\"NAME\":\"Example Template\",\"GPIO\":[416,0,418,0,417,2720,0,0,2624,32,2656,224,0,0],\"FLAG\":0,\"BASE\":45} stores a complete template based on the Generic module Template {\"NAME\":\"AnotherModuleName\"} updates the name of a stored template Template {\"FLAG\":0} changes FLAG value Template {\"BASE\":18} updates the base of a stored template to Generic Template {\"CMND\":\"LedTable 1\"} adds LedTable 1 command to the stored template After setting a template in command line it is necessary to issue Module 0 command if the device doesn't reboot on its own.","title":"Commands"},{"location":"Templates/#anatomy-of-a-template","text":"Let's look again at our example template: {\"NAME\":\"Example Template\",\"GPIO\":[416,0,418,0,417,2720,0,0,2624,32,2656,224,0,0],\"FLAG\":0,\"BASE\":45} The four properties with UPPERCASE property names have the following functionality: Property name Property value description NAME Up to 60 characters for the Module name GPIO Numbers from 0 to 65535 representing GPIO0 to GPIO5, GPIO09, GPIO10 and GPIO12 to GPIO16 and GPIO17 for A0 pin for ESP8266. ESP32 has more configurable GPIO's FLAG * Deprecated Replaced with GPIO17. 8 bit mask flag register. BASE Module number of a hard-coded device to be used when device specific functionality is needed CMND (Optional) Commands executed after activating the template","title":"Anatomy of a Template"},{"location":"Templates/#gpio","text":"","title":"GPIO"},{"location":"Templates/#flag","text":"Before Tasmota 9.1 used to configure the ADC type. In new templates this should be set to 0 and the analog pin should be configured on GPIO17 FLAG Feature description 0 No features 1 Analog value 2 Temperature 3 Light 4 Button 5 Buttoni 15 User configured (same as User )","title":"FLAG"},{"location":"Templates/#base","text":"BASE is the starting module setup for the custom template. Some modules include special programming. If your device is similar to an existing built-in module it is best to use that as a starting point. When you're not sure which BASE module is suitable for your device use the Generic (18) module. A list of hard-coded devices can be found in Modules . Example In the RGB Smart Plug template we used the BlitzWolf SHP (45) module as BASE since the power monitoring circuitry is identical but GPIO00 and GPIO02 were changed and an unused GPIO04 was added to enable the RGB LED function. Using that specific module we took advantage of that module's calibrated power monitoring special programming which the Generic (18) module does not use.","title":"BASE"},{"location":"Templates/#cmnd","text":"CMND is an optional field in the template JSON string. It is used to embed commands for configuring the device instead of needing to type them in console. Multiple commands are separated with | . \"CMND\":\"<any template related command>|<any template related command>|...\" Commands will only be executed if the template is enabled (device module is set to 0), either before the template is loaded, when the activate box in the UI is selected or if the module 0 command is included in the CMND string itself. Disable LED gamma correction and remap RGB channels { \"NAME\" : \"Example\" , \"GPIO\" :[ 416 , 0 , 418 , 0 , 417 , 2720 , 0 , 0 , 2624 , 32 , 2656 , 224 , 0 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 , \"CMND\" : \"LedTable 1|ChannelRemap 36\" } Total size of the template string should not exceed 500 chars.","title":"CMND"},{"location":"Thermal-considerations/","text":"Even though LEDs consume far less energy than incandescent bulbs, these devices contain more complex circuitries and sometimes they still produce more heat than they can handle. The produced heat is proportional to the LED intensities, and if it builds up faster than how it dissipates from the chassis, then the temperature will rise. The circuitries usually (but not necessarily ) contain some last-resort countermeasure that shuts down the device when it is critically overheated, but it shouldn't be relied upon. When testing the device for the first time, especially at higher light intensities, monitor its temperature for some time , like for at least half an hour, and if it rises rapidly, then please consider: Reducing the overall brightness Using only one of the light sources (i.e. either the color LEDs, or the high-power white ones) For such a test use an electrically safe lamp in which you can access the bulb, and which you can easily disconnect from the mains anytime. For measuring the temperature the best tool is an IR thermometer: aim it at the heatsink part of the chassis from a direction perpendicular to it, from such a distance that its cone of sensitivity is fully on the chassis. If you choose to test the temperature by hand, then be prepared that it may be hot , so approach it slowly, and if you already feel its heat, then don't touch it . During this check please also consider that a bulb standing on your desk in a test socket has considerably better cooling than one in a closed armature right below your ceiling, so try to 'model' the operating conditions in which you plan to use the device. If you have found a solution that keeps the temperature stable, don't forget to configure a limit in your home automation system so you (or anyone else) won't accidentally set the device to overheating when it'll be already installed. Some of the devices' original firmwares do contain such software throttling, but as the thermal behaviour differs from one model to another, there is no generic way to apply the right amount of throttling that would be both required and enough for everyone, so \"your mileage may vary\". Technical background ~ Light bulb circuitries consist of 3 main stages: A small power supply unit that converts the 230V or 110V mains to approx. 20V for the LEDs and 3.3V for the controller. This is a small switching-mode power supply, but usually of a parsimonius design, so it's usually barely adequate for the average power requirement, and sometimes not enough for the maximum . The main problem is not the transformer, but the voltage regulators: they produce heat proportionally to the current that's drawn through them, and they aren't connected to the heatsink , so all their heat goes just into the air within the bulb. The controller module, usually a SoC that contains the CPU, memory, flash and wifi. It is a logic circuit, its heat production is negligible compared to the other stages. The LED circuitry, meaning the LEDs themselves and their driver chips, usually on a separate board. They produce a lot of heat, but they are always connected to the chassis via either thermal grease or thermally conductive glue. So the problems are: - Voltage regulators produce heat proportional to light intensity - Their thermal coupling to the chassis is terrible: via a huge air gap - The chassis is not an effective heatsink (for aesthetic reasons it can't be) - The overall system is designed for the average conditions and not for the maximum. Thus our goal is to limit the power consumption to such a level that the heat produced can be dissipated by the chassis heatsink, and the way to achieve this is throttling down the light intensity and/or limiting the switched-on time. Measured values ~ SYF05 (Fcmila/Sunyesmart) ~ At start: 23\u00b0C After 10 minutes: 40\u00b0C (warm) After 20 minutes: 48\u00b0C (hot) After 30 minutes: 53\u00b0C (barely touchable) After 40 minutes: 55\u00b0C At this point the thermal protection has shut the device down, and the local temperatures were: - Chassis: 55\u00b0C - RGB LED driver chip: 73\u00b0C - White LED driver chip: 76\u00b0C - Controller module: 76\u00b0C - Transformer: 85\u00b0C - Area around the voltage regulator: 91\u00b0C Sonoff B1 ~ At start: 26\u00b0C After 10 minutes: 33\u00b0C After 20 minutes: 40\u00b0C After 30 minutes: 44\u00b0C After 40 minutes: 47\u00b0C After 50 minutes: 48\u00b0C After 1 hour: 50\u00b0C The bulb was operational at this point, but I considered this temperature too high for sustained use.","title":"Thermal considerations"},{"location":"Thermal-considerations/#technical-background","text":"Light bulb circuitries consist of 3 main stages: A small power supply unit that converts the 230V or 110V mains to approx. 20V for the LEDs and 3.3V for the controller. This is a small switching-mode power supply, but usually of a parsimonius design, so it's usually barely adequate for the average power requirement, and sometimes not enough for the maximum . The main problem is not the transformer, but the voltage regulators: they produce heat proportionally to the current that's drawn through them, and they aren't connected to the heatsink , so all their heat goes just into the air within the bulb. The controller module, usually a SoC that contains the CPU, memory, flash and wifi. It is a logic circuit, its heat production is negligible compared to the other stages. The LED circuitry, meaning the LEDs themselves and their driver chips, usually on a separate board. They produce a lot of heat, but they are always connected to the chassis via either thermal grease or thermally conductive glue. So the problems are: - Voltage regulators produce heat proportional to light intensity - Their thermal coupling to the chassis is terrible: via a huge air gap - The chassis is not an effective heatsink (for aesthetic reasons it can't be) - The overall system is designed for the average conditions and not for the maximum. Thus our goal is to limit the power consumption to such a level that the heat produced can be dissipated by the chassis heatsink, and the way to achieve this is throttling down the light intensity and/or limiting the switched-on time.","title":"Technical background"},{"location":"Thermal-considerations/#measured-values","text":"","title":"Measured values"},{"location":"Thermal-considerations/#syf05-fcmilasunyesmart","text":"At start: 23\u00b0C After 10 minutes: 40\u00b0C (warm) After 20 minutes: 48\u00b0C (hot) After 30 minutes: 53\u00b0C (barely touchable) After 40 minutes: 55\u00b0C At this point the thermal protection has shut the device down, and the local temperatures were: - Chassis: 55\u00b0C - RGB LED driver chip: 73\u00b0C - White LED driver chip: 76\u00b0C - Controller module: 76\u00b0C - Transformer: 85\u00b0C - Area around the voltage regulator: 91\u00b0C","title":"SYF05 (Fcmila/Sunyesmart)"},{"location":"Thermal-considerations/#sonoff-b1","text":"At start: 26\u00b0C After 10 minutes: 33\u00b0C After 20 minutes: 40\u00b0C After 30 minutes: 44\u00b0C After 40 minutes: 47\u00b0C After 50 minutes: 48\u00b0C After 1 hour: 50\u00b0C The bulb was operational at this point, but I considered this temperature too high for sustained use.","title":"Sonoff B1"},{"location":"Thermostat/","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_THERMOSTAT // Add support for Thermostat #define THERMOSTAT_CONTROLLER_OUTPUTS 1 // Number of outputs to be controlled independently #define THERMOSTAT_SENSOR_NAME \"DS18B20\" // Name of the local sensor to be used #define THERMOSTAT_SENSOR_NUMBER 1 // Number of local sensors to be used #define THERMOSTAT_RELAY_NUMBER 1 // Default output relay number for the first controller (+i for following ones) #define THERMOSTAT_SWITCH_NUMBER 1 // Default input switch number for the first controller (+i for following ones) #define THERMOSTAT_TIME_ALLOW_RAMPUP 300 // Default time after last target update to allow ramp-up controller phase in minutes #define THERMOSTAT_TIME_RAMPUP_MAX 960 // Default time maximum ramp-up controller duration in minutes #define THERMOSTAT_TIME_RAMPUP_CYCLE 30 // Default time ramp-up cycle in minutes #define THERMOSTAT_TIME_SENS_LOST 30 // Maximum time w/o sensor update to set it as lost in minutes #define THERMOSTAT_TEMP_SENS_NUMBER 1 // Default temperature sensor number #define THERMOSTAT_TIME_MANUAL_TO_AUTO 60 // Default time without input switch active to change from manual to automatic in minutes #define THERMOSTAT_TIME_RESET 12000 // Default reset time of the PI controller in seconds #define THERMOSTAT_TIME_PI_CYCLE 30 // Default cycle time for the thermostat controller in minutes #define THERMOSTAT_TIME_MAX_ACTION 20 // Default maximum thermostat time per cycle in minutes #define THERMOSTAT_TIME_MIN_ACTION 4 // Default minimum thermostat time per cycle in minutes #define THERMOSTAT_TIME_MIN_TURNOFF_ACTION 3 // Default minimum turnoff time in minutes, below it the thermostat will be held on #define THERMOSTAT_PROP_BAND 4 // Default proportional band of the PI controller in degrees celsius #define THERMOSTAT_TEMP_RESET_ANTI_WINDUP 8 // Default range where reset antiwindup is disabled, in tenths of degrees celsius #define THERMOSTAT_TEMP_HYSTERESIS 1 // Default range hysteresis for temperature PI controller, in tenths of degrees celsius #define THERMOSTAT_TEMP_FROST_PROTECT 40 // Default minimum temperature for frost protection, in tenths of degrees celsius #define THERMOSTAT_TEMP_RAMPUP_DELTA_IN 4 // Default minimum delta temperature to target to get into rampup mode, in tenths of degrees celsius #define THERMOSTAT_TEMP_RAMPUP_DELTA_OUT 2 // Default minimum delta temperature to target to get out of the rampup mode, in tenths of degrees celsius #define THERMOSTAT_TEMP_PI_RAMPUP_ACC_E 200 // Default accumulated error when switching from ramp-up controller to PI in hundreths of degrees celsius #define THERMOSTAT_TIME_OUTPUT_DELAY 180 // Default output delay between state change and real actuation event (f.i. valve open/closed) #define THERMOSTAT_TEMP_INIT 180 // Default init target temperature for the thermostat controller #define THERMOSTAT_TIME_MAX_OUTPUT_INCONSIST 3 // Default maximum time where the input and the outpus shall differ (for diagnostic) in minutes #define THERMOSTAT_TIME_MAX_AUTOTUNE 21600 // Maximum time for the PI autotune function to complete in seconds #define THERMOSTAT_DUTYCYCLE_AUTOTUNE 35 // Default duty cycle (in % over PI cycle time) for the step response of the autotune PI function #define THERMOSTAT_PEAKNUMBER_AUTOTUNE 8 // Default number of peak temperatures (max or min) to be used for the autotune PI function #define THERMOSTAT_TEMP_BAND_NO_PEAK_DET 1 // Default temperature band in thenths of degrees celsius within no peak will be detected #define THERMOSTAT_TIME_STD_DEV_PEAK_DET_OK 10 // Default standard deviation in minutes of the oscillation periods within the peak detection is successful Control over heating and cooling as a true HVAC unit Thermostat driver allows a Tasmota device, provided it receives the temperature input via MQTT or a locally connected sensor, to follow control heating/cooling strategies to reach the desired setpoint. The thermostat offers similar functions as feature rich commercial ones as the models found below: Typical setup: Heating floor system ~ A typical setup for heating room systems can be found in the picture below. A conventional room thermostat is connected to a heating floor valve actuator, both running at AC voltage (f.e. 220V). The thermostat is connected to neutral as well as to the phase, the actuator to the same neutral connection of the thermostat and to its actuation signal. The actuation signal will switch between the neutral voltage (actuation Off) and the phase voltage (actuation On). The conventional room thermostats offer nowadays either 2 point control with hysteresis or a more advanced PI (Proportional-Integral) control. The result of the PI control is typically transformed into a PWM signal with a pre-defined period and a variable duty cycle. Use of tasmota switch to bypass an existing wall thermostat ~ A tasmota switch can be installed in a way that it bypasses the existing wall thermostat. The advantage of this setup is that the thermostat driver offers the possibility to follow the output of the existing wall thermostat or acting autonomously. This setup allows a seamless integration with existing wall thermostats and gives the user the freedom to still use them. Below you can find an example of a Shelly switch bypassing a wall thermostat: Configuration for standalone application or bypass of existing wall thermostat ~ The driver by default does not consider the input switch states even if available and its therefore suitable for standalone use. If the application requires to follow the command of the input once active (see bypass setup explained in previous section). This bypass function is specially useful to allow the user to use the device bypassed, in case of a wall thermostat, to allow this thermostat to be used if desired. To enable this bypass function, the following command is to be sent to the tasmota device: cmnd/Tasmota_Name/INPUTSWITCHUSE 1 Note Some devices (such as the Sonoff 4CH Pro R2) even if having input buttons to manually switch the state of the output, report always its inputs in active state no matter if the button is pressed or not. For these devices the parameter above needs to be set to 0, otherwise the thermostat driver will activate the output continuously and stay permanently in manual mode. Once active, the thermostat, in case of its input being active, will switch to manual mode and set as output the same state of its input. The thermostat will switch back from manual to automatic mode after a defined time where the input is inactive. The following parameter can be set to modify the time window in minutes to switch back to automatic in case the input is inactive: cmnd/Tasmota_Name/TIMEMANUALTOAUTOSET 60 The default value for the time window to switch from manual to automatic is 60 minutes. Temperature input / setpoint ~ Local temperature sensor ~ The tasmota driver can receive the temperature either via the related MQTT command or via a local temperature sensor (see example of a DS18B20 temperature sensor and a shelly temperature sensor addon below). The default temperature input is MQTT. The following command can be used to select the local sensor as default input: cmnd/Tasmota_Name/SENSORINPUTSET 1 Note The default local temperature sensor is a DS18B20. In case a different Tasmota supported sensor is used, the following define in my_user_config.h is to be changed (or redefined in user_config_override.h ) and a user specific tasmota software needs to be compiled: #define THERMOSTAT_SENSOR_NAME \"DS18B20\" // Name of the local sensor to be used MQTT temperature value and setpoint ~ The following commands can be used to provide the driver with the temperature value of the room and the desired setpoint: cmnd/Tasmota_Name/TEMPTARGETSET 22.5 cmnd/Tasmota_Name/TEMPMEASUREDSET 21.8 Examples for room temperature of 21.8\u00b0C and temperature setpoint of 22.5\u00b0C There are several ways to send the MQTT room temperature. For the development and testing of this driver, a Raspberry Pi with Domoticz and a Z-Wave stick has been used to gather all room temperatures from Z-Wave sensors and send them to the respective Tasmota room thermostats. Customization of the controller for best results ~ The thermostat controller includes a default parameter set that targets a typical floor heating application for mid-sized rooms (< 20m2) with one heating circuit. The controller is however highly configurable via MQTT. The following sections will guide the user to adapt the main parameters to improve the performance of the thermostat controller via customization. Enable the thermostat driver ~ The thermostat driver is by default disabled. To enable it the following command can be used: cmnd/Tasmota_Name/THERMOSTATMODESET 1 Set the controller in degrees Celsius or Fahrenheit ~ The default temperature format is degrees Celsius. The format can be easily switched to degrees Fahrenheit via MQTT command, see below: cmnd/Tasmota_Name/TEMPFORMATSET 1 Set the control strategy ~ The control strategy by default is a Hybrid one. The hybrid control strategy mixes a so called \"Ramp-Up\" strategy (invention during the development of this driver, initially as a LUA script and ported to Tasmota later) and a PI one. The \"Ramp-Up\" strategy is typically used to reach as fast as possible the setpoint for big deltas between desired temperature and setpoint, the PI on the other hand for most part of the normal thermostat operation. The control strategy can be however modified, if the Hybrid one is not desired, the PI or \"Ramp-Up\" mode, can be forced. For that purpose the following command can be used: cmnd/Tasmota_Name/CONTROLLERMODESET 1 The value 1 forces the PI operation and the value 2 the \"Ramp-Up\" one. PI controller main parameters ~ Cycle time ~ Depending on the heating system, the cycle time (PMW period) can be adapted. Very slow systems (high time constants) such as heating floor systems might need higher values (default value is 30 minutes), faster systems might need smaller cycle times. Below the command to adapt the cycle time can be found: cmnd/Tasmota_Name/TIMEPICYCLESET 30 Proportional Band ~ Depending on the dimensioning of your heating system, the proportional band of the controller might be increased (if it takes too long to reach setpoint) or reduced (very high overshoot). The default proportional gain is 4, which means that the duty cycle due to the proportional part of the PI controller will be 100% for temperature deltas between setpoint and room temperature equal or bigger than 4\u00b0C. Below the command to adapt the proportional band can be found: cmnd/Tasmota_Name/PROPBANDSET 1 Note With the command above, the PI controller will output a proportional time equivalent to 100% of the duty cycle for delta temperatures between setpoint and room temp. above 1\u00b0C (f.e. for big rooms with weak dimensioned heating circuit). Reset Time ~ The reset time is the time the PI controller takes to overcome steady-state errors. The default value for the reset time is 1800 seconds. This value can be for instance increased in case a stronger integral reaction of the controller is desired. Below the command to adapt the proportional band can be found: cmnd/Tasmota_Name/TIMERESETSET 1800 Temperature for the anti-windup reset ~ To avoid the accumulated error and therefore integral component of the PI controller to grow too much and produce a high overshoot, a temperature delta can be defined within the integrator will work. Outside this range the accumulated error and integral part will be set to 0. The default value for the integrator to work is 0.8\u00b0C. Below the command to adapt the anti-windup temperature can be found: cmnd/Tasmota_Name/TEMPANTIWINDUPRESETSET 0.8 Temperature hysteresis ~ A temperature hysteresis can be set to avoid any PI controller actions within a certain value around the setpoint. The default value for the hysteresis is 0.1\u00b0C. In well configured controller this value should be as low as possible to avoid unwanted temperature oscillations which reduce efficiency and therefore increase costs. Below the command to adapt the anti-windup temperature can be found: cmnd/Tasmota_Name/TEMPHYSTSET 0.1 Maximum action of the controller ~ The maximum On time (Duty Cycle) in minutes within a cycle can be set by this parameter. The default value is 20 minutes. This represents for the default cycle time of 30 minutes 2 thirds of the complete cycle. In case the controller takes too long to reach the setpoint, this value can be increased to values closer to the cycle time. Below the command to adapt the maximum action time can be found: cmnd/Tasmota_Name/TIMEMAXACTIONSET 20 Minimum action of the controller ~ The minimum On time (Duty Cycle) in minutes within a cycle can be set by this parameter. The default value is 4 minutes. Below the command to adapt the minimum action time can be found: cmnd/Tasmota_Name/TIMEMINACTIONSET 4 It is very important to adapt this value to your heating system to obtain accurate temperature control If the value is very low, in case of floor heating systems for instance, the heating actuators might not have enough time to open the valves and the temperature will drop (depending on the actuator open/close time could take from 1 to 3 minutes) if it is too high, there will be unwanted oscillations around the setpoint. One way to configure this value in heating mode is to manually tune it in worst case conditions (highest typically desired room temperature and lower winter temperature outside) checking that the proportional action generated by the controller is sufficient to raise slightly the temperature. If the temperature still goes down after the pulse plus delay time of the system and rises just once the accumulated error triggers integral actions then the value set is too low. Ramp-Up controller main parameters ~ Temperature delta to get into \"Ramp-Up\" mode ~ When the controller is configured in Hybrid mode (default), the control strategy will be a mix-up between \"Ramp-Up\" (for big deltas between room temperature and setpoint) and PI (around the setpoint). The following parameter can be set to define at above which delta temperature between measured and setpoint the \"Ramp-Up\" controller shall be active: cmnd/Tasmota_Name/TEMPRUPDELTINSET 30 The default value is 0.4\u00b0C. Time passed after latest setpoint change to get into \"Ramp-Up\" mode ~ When the controller is configured in Hybrid mode (default), the activation of the \"Ramp-Up\" mode will not just depend on the defined temperature delta between measured and setpoint, but as well on the time in minutes passed since the last setpoint change occurred. This strategy matches the purpose of the \"Ramp-Up\" controller, which was developed to reach the desired temperature as fast as possible in very specific scenarios, f.e. after a night keeping the room temperature low. In hybrid mode, the controller active most part of the time should be the PI one. The following parameter can be used to define the time to allow switching to \"Ramp-Up\" in minutes. cmnd/Tasmota_Name/TIMEALLOWRAMPUPSET 300 The default value is 300 minutes. Cycle time ~ Depending on the heating system, the cycle time (PMW period) can be adapted. Very slow systems (high time constants) such as heating floor systems might need higher values (default value is 30 minutes), faster systems might need smaller cycle times. Below the command to adapt the cycle time can be found: cmnd/Tasmota_Name/TIMERAMPUPCYCLESET 30 Maximum Ramp-Up time ~ The maximum time the ramp-up phase of the controller shall be active can be configured. The default value is 960 minutes. Below the command to adapt this time can be found: cmnd/Tasmota_Name/TIMERAMPUPMAXSET 960 Thermostat persistent storage for configuration ~ The thermostat driver stores all configured parameters over MQTT exclusively in RAM, it does not use flash due to the amount of the parameters. This means that at every restart the default parameters will be set again. To avoid this behavior rules can be set-up to reconfigure desired parameters at every restart. See below an example: ON Power1#boot DO Backlog sensorinputset 1;controllermodeset 2;thermostatmodeset 1;temptargetset %mem1% ENDON ON mqtt#connected DO Publish2 stat/TestTopic/targetTempValue {\"Temp\":%mem1%} ENDON ON mem1#state DO Backlog temptargetset %value%;Publish2 stat/TestTopic/targetTempValue {\"Temp\":%mem1%} ENDON Advanced features ~ Multi-controller ~ The tasmota driver can be compiled to be used in devices with more than one output, allowing independent controllers for each one of the outputs. This feature has been successfully tested with a Sonoff 4CH PRO R2. To increase the number of controller outputs, modify the value of the thermostat controller outputs in my_user_config.h or redefine it in user_config_override.h and compile a customized tasmota software. #define THERMOSTAT_CONTROLLER_OUTPUTS 1 // Number of outputs to be controlled independently Alternative outputs: PWM duty cycle ~ The driver provides the possibility to read the duty cycle in % (0-100) of the actuated relay. Below the command to read the duty cycle can be found: cmnd/Tasmota_Name/CTRDUTYCYCLEREAD The physical switch of the output can as well be disabled via command. Below the command to disable it can be found: cmnd/Tasmota_Name/ENABLEOUTPUTSET 0 Future improvements ~ Cooling ~ The controller offers the possibility to switch from heating to cooling. Due to lack of cooling setup at the time of the development of the driver, this feature has however not been properly tested. Testers for cooling are therefore welcomed. The following MQTT command can be used to switch from heating (default) to cooling: cmnd/Tasmota_Name/CLIMATEMODESET 1 Self learning process of the \"Ramp-Up\" controller to reduce overshoot ~ The \"Ramp-Up\" controller evaluates the time constant of the system and predicts when to switch off the actuator to reach the desired temperature as fast as possible. This controller offers the best speed to reach the Setpoint. This controller will be improved by a learning process to evaluate how accurate the target value has been reached and therefore minimize gradually the overshoot. This feature will improve the behavior of the current controller which depending on the application and thermal capacity of the system might produce some overshoot. By default the controller set is the Hybrid one, enabling \"Ramp-Up\" for big temperature deltas between Setpoint and measured temperature and PI for smaller ones. If you are not satisfied with the performance of this controller in your system, you can disable it by MQTT and force the use of the PI controller exclusively (see Controller configuration section above). PI Autotune ~ A PI autotune feature following the Zigler-Nichols closed loop algorithm has been implemented. This feature is untested and will be further developed soon. To enable it for testing purposes add the following define in user_config_override.h and compile a customized tasmota software. #define USE_PI_AUTOTUNING // (Ziegler-Nichols closed loop method)","title":"Thermostat"},{"location":"Thermostat/#typical-setup-heating-floor-system","text":"A typical setup for heating room systems can be found in the picture below. A conventional room thermostat is connected to a heating floor valve actuator, both running at AC voltage (f.e. 220V). The thermostat is connected to neutral as well as to the phase, the actuator to the same neutral connection of the thermostat and to its actuation signal. The actuation signal will switch between the neutral voltage (actuation Off) and the phase voltage (actuation On). The conventional room thermostats offer nowadays either 2 point control with hysteresis or a more advanced PI (Proportional-Integral) control. The result of the PI control is typically transformed into a PWM signal with a pre-defined period and a variable duty cycle.","title":"Typical setup: Heating floor system"},{"location":"Thermostat/#use-of-tasmota-switch-to-bypass-an-existing-wall-thermostat","text":"A tasmota switch can be installed in a way that it bypasses the existing wall thermostat. The advantage of this setup is that the thermostat driver offers the possibility to follow the output of the existing wall thermostat or acting autonomously. This setup allows a seamless integration with existing wall thermostats and gives the user the freedom to still use them. Below you can find an example of a Shelly switch bypassing a wall thermostat:","title":"Use of tasmota switch to bypass an existing wall thermostat"},{"location":"Thermostat/#configuration-for-standalone-application-or-bypass-of-existing-wall-thermostat","text":"The driver by default does not consider the input switch states even if available and its therefore suitable for standalone use. If the application requires to follow the command of the input once active (see bypass setup explained in previous section). This bypass function is specially useful to allow the user to use the device bypassed, in case of a wall thermostat, to allow this thermostat to be used if desired. To enable this bypass function, the following command is to be sent to the tasmota device: cmnd/Tasmota_Name/INPUTSWITCHUSE 1 Note Some devices (such as the Sonoff 4CH Pro R2) even if having input buttons to manually switch the state of the output, report always its inputs in active state no matter if the button is pressed or not. For these devices the parameter above needs to be set to 0, otherwise the thermostat driver will activate the output continuously and stay permanently in manual mode. Once active, the thermostat, in case of its input being active, will switch to manual mode and set as output the same state of its input. The thermostat will switch back from manual to automatic mode after a defined time where the input is inactive. The following parameter can be set to modify the time window in minutes to switch back to automatic in case the input is inactive: cmnd/Tasmota_Name/TIMEMANUALTOAUTOSET 60 The default value for the time window to switch from manual to automatic is 60 minutes.","title":"Configuration for standalone application or bypass of existing wall thermostat"},{"location":"Thermostat/#temperature-input-setpoint","text":"","title":"Temperature input / setpoint"},{"location":"Thermostat/#local-temperature-sensor","text":"The tasmota driver can receive the temperature either via the related MQTT command or via a local temperature sensor (see example of a DS18B20 temperature sensor and a shelly temperature sensor addon below). The default temperature input is MQTT. The following command can be used to select the local sensor as default input: cmnd/Tasmota_Name/SENSORINPUTSET 1 Note The default local temperature sensor is a DS18B20. In case a different Tasmota supported sensor is used, the following define in my_user_config.h is to be changed (or redefined in user_config_override.h ) and a user specific tasmota software needs to be compiled: #define THERMOSTAT_SENSOR_NAME \"DS18B20\" // Name of the local sensor to be used","title":"Local temperature sensor"},{"location":"Thermostat/#mqtt-temperature-value-and-setpoint","text":"The following commands can be used to provide the driver with the temperature value of the room and the desired setpoint: cmnd/Tasmota_Name/TEMPTARGETSET 22.5 cmnd/Tasmota_Name/TEMPMEASUREDSET 21.8 Examples for room temperature of 21.8\u00b0C and temperature setpoint of 22.5\u00b0C There are several ways to send the MQTT room temperature. For the development and testing of this driver, a Raspberry Pi with Domoticz and a Z-Wave stick has been used to gather all room temperatures from Z-Wave sensors and send them to the respective Tasmota room thermostats.","title":"MQTT temperature value and setpoint"},{"location":"Thermostat/#customization-of-the-controller-for-best-results","text":"The thermostat controller includes a default parameter set that targets a typical floor heating application for mid-sized rooms (< 20m2) with one heating circuit. The controller is however highly configurable via MQTT. The following sections will guide the user to adapt the main parameters to improve the performance of the thermostat controller via customization.","title":"Customization of the controller for best results"},{"location":"Thermostat/#enable-the-thermostat-driver","text":"The thermostat driver is by default disabled. To enable it the following command can be used: cmnd/Tasmota_Name/THERMOSTATMODESET 1","title":"Enable the thermostat driver"},{"location":"Thermostat/#set-the-controller-in-degrees-celsius-or-fahrenheit","text":"The default temperature format is degrees Celsius. The format can be easily switched to degrees Fahrenheit via MQTT command, see below: cmnd/Tasmota_Name/TEMPFORMATSET 1","title":"Set the controller in degrees Celsius or Fahrenheit"},{"location":"Thermostat/#set-the-control-strategy","text":"The control strategy by default is a Hybrid one. The hybrid control strategy mixes a so called \"Ramp-Up\" strategy (invention during the development of this driver, initially as a LUA script and ported to Tasmota later) and a PI one. The \"Ramp-Up\" strategy is typically used to reach as fast as possible the setpoint for big deltas between desired temperature and setpoint, the PI on the other hand for most part of the normal thermostat operation. The control strategy can be however modified, if the Hybrid one is not desired, the PI or \"Ramp-Up\" mode, can be forced. For that purpose the following command can be used: cmnd/Tasmota_Name/CONTROLLERMODESET 1 The value 1 forces the PI operation and the value 2 the \"Ramp-Up\" one.","title":"Set the control strategy"},{"location":"Thermostat/#pi-controller-main-parameters","text":"","title":"PI controller main parameters"},{"location":"Thermostat/#ramp-up-controller-main-parameters","text":"","title":"Ramp-Up controller main parameters"},{"location":"Thermostat/#thermostat-persistent-storage-for-configuration","text":"The thermostat driver stores all configured parameters over MQTT exclusively in RAM, it does not use flash due to the amount of the parameters. This means that at every restart the default parameters will be set again. To avoid this behavior rules can be set-up to reconfigure desired parameters at every restart. See below an example: ON Power1#boot DO Backlog sensorinputset 1;controllermodeset 2;thermostatmodeset 1;temptargetset %mem1% ENDON ON mqtt#connected DO Publish2 stat/TestTopic/targetTempValue {\"Temp\":%mem1%} ENDON ON mem1#state DO Backlog temptargetset %value%;Publish2 stat/TestTopic/targetTempValue {\"Temp\":%mem1%} ENDON","title":"Thermostat persistent storage for configuration"},{"location":"Thermostat/#advanced-features","text":"","title":"Advanced features"},{"location":"Thermostat/#multi-controller","text":"The tasmota driver can be compiled to be used in devices with more than one output, allowing independent controllers for each one of the outputs. This feature has been successfully tested with a Sonoff 4CH PRO R2. To increase the number of controller outputs, modify the value of the thermostat controller outputs in my_user_config.h or redefine it in user_config_override.h and compile a customized tasmota software. #define THERMOSTAT_CONTROLLER_OUTPUTS 1 // Number of outputs to be controlled independently","title":"Multi-controller"},{"location":"Thermostat/#alternative-outputs-pwm-duty-cycle","text":"The driver provides the possibility to read the duty cycle in % (0-100) of the actuated relay. Below the command to read the duty cycle can be found: cmnd/Tasmota_Name/CTRDUTYCYCLEREAD The physical switch of the output can as well be disabled via command. Below the command to disable it can be found: cmnd/Tasmota_Name/ENABLEOUTPUTSET 0","title":"Alternative outputs: PWM duty cycle"},{"location":"Thermostat/#future-improvements","text":"","title":"Future improvements"},{"location":"Thermostat/#cooling","text":"The controller offers the possibility to switch from heating to cooling. Due to lack of cooling setup at the time of the development of the driver, this feature has however not been properly tested. Testers for cooling are therefore welcomed. The following MQTT command can be used to switch from heating (default) to cooling: cmnd/Tasmota_Name/CLIMATEMODESET 1","title":"Cooling"},{"location":"Thermostat/#self-learning-process-of-the-ramp-up-controller-to-reduce-overshoot","text":"The \"Ramp-Up\" controller evaluates the time constant of the system and predicts when to switch off the actuator to reach the desired temperature as fast as possible. This controller offers the best speed to reach the Setpoint. This controller will be improved by a learning process to evaluate how accurate the target value has been reached and therefore minimize gradually the overshoot. This feature will improve the behavior of the current controller which depending on the application and thermal capacity of the system might produce some overshoot. By default the controller set is the Hybrid one, enabling \"Ramp-Up\" for big temperature deltas between Setpoint and measured temperature and PI for smaller ones. If you are not satisfied with the performance of this controller in your system, you can disable it by MQTT and force the use of the PI controller exclusively (see Controller configuration section above).","title":"Self learning process of the \"Ramp-Up\" controller to reduce overshoot"},{"location":"Thermostat/#pi-autotune","text":"A PI autotune feature following the Zigler-Nichols closed loop algorithm has been implemented. This feature is untested and will be further developed soon. To enable it for testing purposes add the following define in user_config_override.h and compile a customized tasmota software. #define USE_PI_AUTOTUNING // (Ziegler-Nichols closed loop method)","title":"PI Autotune"},{"location":"Time-Proportioned-Output-support/","text":"This extension adds a Time Proportioned Digital Output feature into the Tasmota software. The relay output on a Sonoff device provides (obviously) just on/off control. Often it is desirable to be able to get a value between off and on, for example 25% power. The conventional way to achieve this with devices such as electrical heaters or hot water radiators is to switch the device on for a period and then off for a period. This extension allows a required power value between 0 and 1 to be specified via MQTT and the code will automatically cycle the relay on/off to achieve this power. The s/w is configured with a Cycle Time that specifies the period. So for example if a power value of 0.25 is specified with a cycle time of 12 minutes then the relay will be on for 3 minutes and off for 9 minutes every 12 minute period. The s/w includes a safety mechanism where the maximum time expected between MQTT power updates is specified. If this time is exceeded with no value being received then the power will revert to a specified fallback value. Instructions for setting it up and using it are in xdrv_48_timeprop.ino . The feature adds about 1.2k to the compiled code. Currently all configuration parameters must be setup at build time. If anyone wanted to add these to the MQTT and/or web interfaces a PR would be gratefully received.","title":"Time Proportioned Output support"},{"location":"Timers/","text":"Timers allow you to automate your device based on time triggers To control a device locally 16 timers are programmable. They can be configured with the Timer<x> command followed by a JSON payload with optional parameters. For example: Timer 1 will ENABLE output of POWER1 at exactly 2:23 every Tue/Wed and Sat Timer1 { \"Enable\" : 1 , \"Time\" : \"02:23\" , \"Window\" : 0 , \"Days\" : \"--TW--S\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Timer 4 will TOGGLE output of POWER2 within a 30 minute window centered around 16:23 each Sunday, Monday, Thursday and Friday and will disable (disarm) after executing. Timer4 { \"Enable\" : 1 , \"Time\" : \"16:23\" , \"Window\" : 15 , \"Days\" : \"SM00TF0\" , \"Repeat\" : 0 , \"Output\" : 2 , \"Action\" : 2 } When Mode 1 or Mode 2 is used, Latitude and Longitude become available. In that case the Time value is always used as an offset so make sure to set it to 00:00 if no offset is wanted. Timer1 { \"Enable\" : 1 , \"Mode\" : 2 , \"Time\" : \"-2:23\" , \"Window\" : 0 , \"Days\" : \"11TW11S\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Commands ~ Command Parameters Latitude <value> = set latitude Longitude <value> = set longitude Timers Timers control 0 = disable all timers\u2003 \u00bb v6.2.0 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x>\u2003 \u00bb v6.2.0 1..16 = copy Timer<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table below JSON Payload Anatomy ~ JSON Name JSON Value Enable 0 = disarm or disable timer 1 = arm or enable timer Mode 0 = use clock time 1 = Use local sunrise time using Longitude , Latitude and Time offset 2 = use local sunset time using Longitude , Latitude and Time offset Time hh:mm = set time in hours 0 .. 23 and minutes 0 .. 59 -hh:mm = set time in offset hours -11 .. 12 and minutes 0 .. 59 (used with Mode 1 and Mode 2 ) Window 0..15 = add or subtract a random number of minutes to Time Days SMTWTFS = set day of weeks mask where 0 or - = OFF and any different character = ON Repeat 0 = allow timer only once 1 = repeat timer execution Output 1..16 = select an output to be used if no rule is enabled Action 0 = turn output OFF 1 = turn output ON 2 = TOGGLE output 3 = RULE/BLINK If the Tasmota Rules feature has been activated by compiling the code (activated by default in all pre-compiled Tasmota binaries), a rule with Clock#Timer=<timer> will be triggered if written and turned on by the user. If Rules are not compiled, BLINK output using BlinkCount parameters.","title":"Timers"},{"location":"Timers/#commands","text":"Command Parameters Latitude <value> = set latitude Longitude <value> = set longitude Timers Timers control 0 = disable all timers\u2003 \u00bb v6.2.0 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x>\u2003 \u00bb v6.2.0 1..16 = copy Timer<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table below","title":"Commands"},{"location":"Timers/#json-payload-anatomy","text":"JSON Name JSON Value Enable 0 = disarm or disable timer 1 = arm or enable timer Mode 0 = use clock time 1 = Use local sunrise time using Longitude , Latitude and Time offset 2 = use local sunset time using Longitude , Latitude and Time offset Time hh:mm = set time in hours 0 .. 23 and minutes 0 .. 59 -hh:mm = set time in offset hours -11 .. 12 and minutes 0 .. 59 (used with Mode 1 and Mode 2 ) Window 0..15 = add or subtract a random number of minutes to Time Days SMTWTFS = set day of weeks mask where 0 or - = OFF and any different character = ON Repeat 0 = allow timer only once 1 = repeat timer execution Output 1..16 = select an output to be used if no rule is enabled Action 0 = turn output OFF 1 = turn output ON 2 = TOGGLE output 3 = RULE/BLINK If the Tasmota Rules feature has been activated by compiling the code (activated by default in all pre-compiled Tasmota binaries), a rule with Clock#Timer=<timer> will be triggered if written and turned on by the user. If Rules are not compiled, BLINK output using BlinkCount parameters.","title":"JSON Payload Anatomy"},{"location":"Tips/","text":"","title":"Tips"},{"location":"TouchPin/","text":"Capacitive Touch GPIO ~ The ESP32 has 10 capacitive touch GPIOs. It is possible to use a maximum number of 4 as a touch button. Note Only special pins are usable and not all of these 10 pins are exposed on every dev-board. More info in this article After wiring a cable or electrode to a supported pin you have to configure it in Configure Module as \"button_tc\". It is helpful to understand, what is going on under the hood: The continuous pin reading gives a unitless value, that will decrease when the pin (or connected cable) is touched. The touch pin driver will report a button touch when the pin reading falls below a threshold value for a certain amount of read cycles. The latter is important to filter out spikes. The default values are very conservative in order to rule out unwanted actions. In most cases it will be desirable to do a calibration. Commands: ~ Command Description TouchCal x x=button 1 .. 4. This plots the sensor values to the console, to get information regarding the setting of the 2 following commands 0 will turn off calibration 255 will turn on calibration for all buttons TouchThres x x=button 1 .. 4. This plots the sensor values to the console, to get information regarding the setting of the 2 following commands TouchNum x sets number of ignored measurements below the threshold, because there will likely be spikes. The default value of 3 is very conservative and 1 should be fine most of the time. A higher value is safer in a noisy environment, but for obvious reasons you will have to touch the pin (or cable ...) longer to trigger the button press. While the calibration process is running, the raw data values will be printed in the console in the format: PLOT: g, v, h, g - number of the graph (= number of the button) v - raw value of the corresponding touch pin h - number of continous hits below current threshold, useful to see the number and length of \"spikes\", should be 0 without touching The new values for a personal configuration can be stored in RULE: Example rule1 on System#Init do TouchNum 1 endon Tasmota Serial Plotter ~ This little tool should be helpful to get a feel for the touch values. It is located in the /tools folder of the Tasmota repository and needs the installation of \"mathplotlib\" and \"pyserial\" in the active python environment. It is confirmed to work under Windows 10 and macOS Catalina. Example: ./serial-plotter.py --port /dev/XXX --baud 115200 You can send commands to Tasmota via SEND-box. For the touch button driver: TouchCal 255 - turns on calibration mode for all buttons (Note the short spikes, which in this config only would need TouchNum 1 to get filtered out)","title":"Touch GPIOs"},{"location":"TouchPin/#capacitive-touch-gpio","text":"The ESP32 has 10 capacitive touch GPIOs. It is possible to use a maximum number of 4 as a touch button. Note Only special pins are usable and not all of these 10 pins are exposed on every dev-board. More info in this article After wiring a cable or electrode to a supported pin you have to configure it in Configure Module as \"button_tc\". It is helpful to understand, what is going on under the hood: The continuous pin reading gives a unitless value, that will decrease when the pin (or connected cable) is touched. The touch pin driver will report a button touch when the pin reading falls below a threshold value for a certain amount of read cycles. The latter is important to filter out spikes. The default values are very conservative in order to rule out unwanted actions. In most cases it will be desirable to do a calibration.","title":"Capacitive Touch GPIO "},{"location":"TouchPin/#commands","text":"Command Description TouchCal x x=button 1 .. 4. This plots the sensor values to the console, to get information regarding the setting of the 2 following commands 0 will turn off calibration 255 will turn on calibration for all buttons TouchThres x x=button 1 .. 4. This plots the sensor values to the console, to get information regarding the setting of the 2 following commands TouchNum x sets number of ignored measurements below the threshold, because there will likely be spikes. The default value of 3 is very conservative and 1 should be fine most of the time. A higher value is safer in a noisy environment, but for obvious reasons you will have to touch the pin (or cable ...) longer to trigger the button press. While the calibration process is running, the raw data values will be printed in the console in the format: PLOT: g, v, h, g - number of the graph (= number of the button) v - raw value of the corresponding touch pin h - number of continous hits below current threshold, useful to see the number and length of \"spikes\", should be 0 without touching The new values for a personal configuration can be stored in RULE: Example rule1 on System#Init do TouchNum 1 endon","title":"Commands:"},{"location":"TouchPin/#tasmota-serial-plotter","text":"This little tool should be helpful to get a feel for the touch values. It is located in the /tools folder of the Tasmota repository and needs the installation of \"mathplotlib\" and \"pyserial\" in the active python environment. It is confirmed to work under Windows 10 and macOS Catalina. Example: ./serial-plotter.py --port /dev/XXX --baud 115200 You can send commands to Tasmota via SEND-box. For the touch button driver: TouchCal 255 - turns on calibration mode for all buttons (Note the short spikes, which in this config only would need TouchNum 1 to get filtered out)","title":"Tasmota Serial Plotter"},{"location":"Troubleshooting/","text":"Troubleshooting ~ Debugging ~ Logs ~ For debugging purposes you can use Level 4 or Level 5 logging to the MqttLog , WebLog , SerialLog , or remote SysLog . The logging level is set separately for each log destination. Log levels range from 0 to 5 . The higher the log level, the more information is logged. When troubleshooting your device its recommended to set the logging level to 4 . Web Logging ~ These show up in the Web UI Console (http://deviceip/cs). The default logging level for WebLog logging is 2. Serial Logging ~ Warning Never connect to serial while the device is connected to mains power. You can still collect the logs, but only when powering it via your serial connection. Some devices use the serial port to control the relays or an MCU, so serial logging might interfere with control and even switch relays or lights. The default logging level for SerialLog logging is 2. Unless explicitly set by a command (e.g., user input in the Console, a System#Boot triggered rule), SerialLog will be disabled automatically 10 minutes after the device reboots. Through a terminal program set the baud rate to 115200 (19200 for Sonoff Dual), both NL & CR, and disable hardware flow control. Debugging the Sonoff Pow is a bit tricky as the serial interface has a direct connection to one of the AC power lines . The schematic below uses two optocouplers separating the AC connection on the left from the low voltage connection on the right allowing for serial control at 115200 baud and uploading of firmware up to 57600 baud while AC is connected. Crashdumps ~ If the ESP8266 crashes, it frequently dumps information about the crash out the serial port, so the process listed above to see serial logs can provide extremely useful information Syslog Logging ~ If you have a Linux system, it is probably already running syslog . You just need to configure it to listen on the network. SysLog logging is disabled in Tasmota by default. On systems running rsyslog (most linux distros), edit the /etc/rsyslog.conf file. Adding (or uncommenting) the following lines will probably start making the logs show up in some file under /var/log $ModLoad imudp $UDPServerRun 514 If you do not have access to a Linux system, there are Microsoft Windows Syslog server options . MQTT Logging ~ These log messages show up as MQTT messages. MqttLog logging is disabled by default. MQTT traffic ~ To check the flow of MQTT traffic you can use MQTT Explorer which shows your entire MQTT traffic in an organised and structured way. Tasmota Device Manager offers an overview of all your Tasmota devices using MQTT protocol. You can manage them, use device features and do basic troubleshooting with ease. It also cleanly displays if your device is dropping from the network often or reboots unexpectedly. Running out of RAM ~ This typically shows up in the device working when it first starts up (hitting the button toggles the relay), but some time later it either reboots or some function won't work. For example, you can't load the module configuration page. The only fix for this is to recompile the firmware and disable features you don't need. Known large features are web server and TLS, but other things to consider disabling if you don't need them are emulation support, Domoticz support and WS8212 support. Program Memory ~ A 512K firmware binary size is a good \"target\" and rule of thumb for allowing future OTA firmware updates. Flashing over the air (OTA) requires that there is enough free program memory available to upload the new firmware along with the existing copy before the old copy is deleted. If your firmware binary is larger than the available free program memory, you can replace the existing firmware with a minimal functionality version of Tasmota (roughly 375K). This leaves enough free in the 1024K program memory for the final copy of the firmware (i.e., larger than 512K). Flashing Tasmota makes it simpler to update to newer versions because it is built for OTA upgrades. In fact, if the new firmware is larger than the available free memory, Tasmota's OTA process will, automatically, first replace the existing firmware with \"minimal\" to then have enough space to put the new firmware in. If one is loading firmware only via the serial interface (i.e., wired), then theoretically you could load firmware as large at the program memory size. since you can erase the flash and then fill it to the rim with the new firmware. But then you'd be left with performing upgrades by having to have physical access to the device each time.","title":"Troubleshooting"},{"location":"Troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Troubleshooting/#debugging","text":"","title":"Debugging"},{"location":"Troubleshooting/#logs","text":"For debugging purposes you can use Level 4 or Level 5 logging to the MqttLog , WebLog , SerialLog , or remote SysLog . The logging level is set separately for each log destination. Log levels range from 0 to 5 . The higher the log level, the more information is logged. When troubleshooting your device its recommended to set the logging level to 4 .","title":"Logs"},{"location":"Troubleshooting/#mqtt-traffic","text":"To check the flow of MQTT traffic you can use MQTT Explorer which shows your entire MQTT traffic in an organised and structured way. Tasmota Device Manager offers an overview of all your Tasmota devices using MQTT protocol. You can manage them, use device features and do basic troubleshooting with ease. It also cleanly displays if your device is dropping from the network often or reboots unexpectedly.","title":"MQTT traffic"},{"location":"Troubleshooting/#running-out-of-ram","text":"This typically shows up in the device working when it first starts up (hitting the button toggles the relay), but some time later it either reboots or some function won't work. For example, you can't load the module configuration page. The only fix for this is to recompile the firmware and disable features you don't need. Known large features are web server and TLS, but other things to consider disabling if you don't need them are emulation support, Domoticz support and WS8212 support.","title":"Running out of RAM"},{"location":"Troubleshooting/#program-memory","text":"A 512K firmware binary size is a good \"target\" and rule of thumb for allowing future OTA firmware updates. Flashing over the air (OTA) requires that there is enough free program memory available to upload the new firmware along with the existing copy before the old copy is deleted. If your firmware binary is larger than the available free program memory, you can replace the existing firmware with a minimal functionality version of Tasmota (roughly 375K). This leaves enough free in the 1024K program memory for the final copy of the firmware (i.e., larger than 512K). Flashing Tasmota makes it simpler to update to newer versions because it is built for OTA upgrades. In fact, if the new firmware is larger than the available free memory, Tasmota's OTA process will, automatically, first replace the existing firmware with \"minimal\" to then have enough space to put the new firmware in. If one is loading firmware only via the serial interface (i.e., wired), then theoretically you could load firmware as large at the program memory size. since you can erase the flash and then fill it to the rim with the new firmware. But then you'd be left with performing upgrades by having to have physical access to the device each time.","title":"Program Memory"},{"location":"Tutorials/","text":"Projects and Tutorials ~ Find more projects and share them in Show and Tell ! Gallery of projects running Tasmota ~ Click on name for larger image TrDA's 3xINA219 (Solar+Sensor+Display) TrDA's Motorised Roller Blinds Solar and battery power monitoring station Schematic Water tank monitor Multisensor Aquarium controller External Links to cool/amazing projects made with Tasmota ~ LEGO Nightstand Switch Tasmota based drop pin door lock Installation Tutorials ~ Installing Tasmota using Tasmotizer Flash your device using a RaspberryPi instead of USB-to-TTL serial connector Video tutorials ~ Tasmota and Tasmotizer Easy Flashing Guide for ESP8266 devices Installation tutorial of Tasmota using PlatformIO made by QuickPi. True 3-Way Smart Switch Make a motion activated switch with temperature and humidity sensor Sonoff Basic as UK Light Switch 3D Printed Cases ~ Don't have 3D printer? Depending on where you live, you may be able to find a third party to print the model for you. Some schools and public libraries provide printing services. Search for a printing service using 3D Hubs or send your design to a service like Shapeways . - Thingiverse - Yeggi Related YouTube Channels ~ DigiblurDIY - Great and Easy Tasmota related Videos DrZzs - Great and Easy Tasmota related Videos Super House - Home Automation Tutorials The Hook Up - Home Automation Tutorials BRUH Automation - Home Automation Tutorials Burns Home Automation - Home Automation Tutorials Step to Step Tutorials - Hobbytronics Tutorials Kiril Peyanski - Tasmota Tutorials Non-English Tutorials ~ ES - Cayetano YouTube Channel DE - Tuya Ger\u00e4te Flashen DE - ESP8266 flashen von A - Z FR - Ajouter un bouton physique au Sonoff basic IT - Installazione firmware Tasmota su Sonoff Basic IL - Hebrew - Install Tasmota firmware on all Sonoff devices ?? - Yuval Mejahez - Tasmota Flash tutorials Channel","title":"Projects and Tutorials"},{"location":"Tutorials/#projects-and-tutorials","text":"Find more projects and share them in Show and Tell !","title":"Projects and Tutorials"},{"location":"Tutorials/#gallery-of-projects-running-tasmota","text":"Click on name for larger image TrDA's 3xINA219 (Solar+Sensor+Display) TrDA's Motorised Roller Blinds Solar and battery power monitoring station Schematic Water tank monitor Multisensor Aquarium controller","title":"Gallery of projects running Tasmota"},{"location":"Tutorials/#external-links-to-coolamazing-projects-made-with-tasmota","text":"LEGO Nightstand Switch Tasmota based drop pin door lock","title":"External Links to cool/amazing projects made with Tasmota"},{"location":"Tutorials/#installation-tutorials","text":"Installing Tasmota using Tasmotizer Flash your device using a RaspberryPi instead of USB-to-TTL serial connector","title":"Installation Tutorials"},{"location":"Tutorials/#video-tutorials","text":"Tasmota and Tasmotizer Easy Flashing Guide for ESP8266 devices Installation tutorial of Tasmota using PlatformIO made by QuickPi. True 3-Way Smart Switch Make a motion activated switch with temperature and humidity sensor Sonoff Basic as UK Light Switch","title":"Video tutorials"},{"location":"Tutorials/#3d-printed-cases","text":"Don't have 3D printer? Depending on where you live, you may be able to find a third party to print the model for you. Some schools and public libraries provide printing services. Search for a printing service using 3D Hubs or send your design to a service like Shapeways . - Thingiverse - Yeggi","title":"3D Printed Cases"},{"location":"Tutorials/#related-youtube-channels","text":"DigiblurDIY - Great and Easy Tasmota related Videos DrZzs - Great and Easy Tasmota related Videos Super House - Home Automation Tutorials The Hook Up - Home Automation Tutorials BRUH Automation - Home Automation Tutorials Burns Home Automation - Home Automation Tutorials Step to Step Tutorials - Hobbytronics Tutorials Kiril Peyanski - Tasmota Tutorials","title":"Related YouTube Channels"},{"location":"Tutorials/#non-english-tutorials","text":"ES - Cayetano YouTube Channel DE - Tuya Ger\u00e4te Flashen DE - ESP8266 flashen von A - Z FR - Ajouter un bouton physique au Sonoff basic IT - Installazione firmware Tasmota su Sonoff Basic IL - Hebrew - Install Tasmota firmware on all Sonoff devices ?? - Yuval Mejahez - Tasmota Flash tutorials Channel","title":"Non-English Tutorials"},{"location":"Tuya-Convert/","text":"Tuya devices are sold under numerous brand names but they're all identifiable by the fact that they connect with these phone apps: \" Smart Life \" or \" Tuya Smart \". They incorporate different types of Tuya Wi-Fi modules internally. Tuya has begun manufacturing some Wi-Fi modules using a Realtek RTL8710BN Wi-Fi SOC instead of an ESP82xx chip. Tasmota cannot run on Realtek devices and there are no plans on supporting them . Tuya-Convert is the most successful method of flashing Tuya modules without opening the device and soldering. Tuya-Convert comes with tasmota-lite.bin build which includes basic Tasmota features required for normal operation with Tuya devices, while removing sensors, IR, RF and home automation integration support for reduced filesize. It is recommended to upgrade to a full build of the firmware ( tasmota.bin ) if needed. To ensure Tasmota runs reliably execute the command reset 5 after Tuya-Convert is finished and Tasmota is up and running. Doing this removes fragments of the original firmware left in flash which can create issues in the future. After all that is done you can proceed with the needed configuration of your device. Help and troubleshooting for Tuya-Convert is done on Tuya-Convert's Github . Danger The fact that you can flash Tasmota on your device does not mean all of its features are currently supported. Please research before purchasing to see if other users have successfully flashed the device and are able to use it fully Tuya-Convert video walkthrough TuyOTA walkthrough Mock Tuya Cloud - A general purpose framework for interacting with Tuya devices without the Tuya operated cloud. Tuya API - A library for communicating with devices that use the Tuya cloud network.","title":"Tuya Convert"},{"location":"Tuya-Protocols/","text":"","title":"Tuya Protocols"},{"location":"Tuya-generic-wifi-curtain-motor-WIP/","text":"","title":"Tuya generic wifi curtain motor WIP"},{"location":"TuyaMCU-Devices/","text":"There are several Tuya dimmer and switch variants made by various manufacturers. The switches range from 1 to 8 gangs. The dimmers are usually 1 gang. They dim mains voltage for various lighting types: incandescent, CFL, and LED. Consult the specific device for the type of bulbs and capacity it supports as well as the bulbs themselves to verify they support dimming. Identification and Technical details ~ The basic identification of a Tuya device is when the device information references the \"Tuya Smart\", \"SmartLife\", or \"Smart Living\" app. These switches and dimmers are based on a Tuya TYWE3S Wi-Fi PCB module along with an MCU. TYWE3S is based on the ESP8266 which is supported by Tasmota. Wiki page for TYWE3S The TYWE3S module mostly takes care of Wi-Fi and software features while the MCU controls the actual hardware (buttons, relays, dimmer, power measurement, etc). The MCU is interfaced to TYWE3S using the serial interface which connects to the Rx and Tx pins. The easiest way to identify if your switch or dimmer uses MCU is by using a continuity tester (multimeter, ohmmeter) and checking continuity from the Rx and Tx pins on TYWE3S to any other chip. Then check the datasheet of that chip to see if it is an MCU. Flashing - Preparation ~ To boot the TYWE3S in flashing mode, GPIO0 needs to be connected to GND while powering up. It can be left grounded for the entire process. Flashing a TYWE3S connected to a MCU is a bit trickier than one without MCU. This is due the same Rx Tx pins used by MCU and serial programmer for flashing. The TYWE3S cannot be booted to flash mode with MCU sending data over the same pins. To be able to do that, we need to disable MCU from sending data over Rx and Tx pins. There are few ways to do it: 1. Disconnect TYWE3S module from the rest of board. (Naah, too much work) 2. Just break the Rx track from MCU to TYWE3S, flash and then reconnect. (Messy work, we want cleaner approach) 3. Just keep MCU disabled while flashing TYWE3S without any soldering / cutting. (We like that) The easiest is to keep MCU disabled is by identifying the NRST/RST (Reset) pin of the MCU from its datasheet and connect it to GND for the entire flashing process. This will keep MCU disabled while you flash TYWE3S. If there are some contacts or test points in switches that connect to the MCU, you might be lucky to find contacts for RST that you can easily solder onto. TYWE3S Connection Options ~ 3D print a flashing Jig and use pogo pins to make nice and easy to use flashing jig Solder wires directly onto TYWE3S Use a jumper header like the one below and bend the pins to match VCC, Rx Tx GPIO0 and GND. You can just press the jumper header to the contacts during the flashing process Flashing - Process ~ Once you are done identifying the pins and ready to connect, BEFORE connecting USB to PC you need to connect them as follows: NOTE : Use 3.3V NOT 5V TYWE3S Serial Programmer RX TX TX RX GPIO0 GND GND GND VCC 3.3V If an MCU is present, bridge RST to GND on the MCU Use a 6.6.0.10 Tasmota version or higher. There are lots of Tuya Serial fixes / features added in there and the tutorial below expects them. Now you need to follow the commands explained in the flashing tutorial . TIP: If you are using jumper headers use sleep 15 && before your commands, this would free your hand and give you some time to set the jumper pins and connect the USB to PC. Configuration ~ Once Tasmota is flashed on the TYWE3S, just disconnect GND -> GPIO0 (and RST if there is an MCU), and power your device again from USB. On your PC, you should see a Wi-Fi network named sonoff-xxxx where xxxx is a number from the ESP's MAC address. Connect to it and go to 192.168.4.1 in your browser. Enter the Wi-Fi credentials for your network and click save. Connect your PC back to your network. Now you need to find the IP of newly connected Tasmota device. Refer to this very good video from SuperHouseTV (ignore flashing information) about configuring Tasmota. Once you get to the Tasmota configuration you need to select TuyaMCU module assign GPIO components as indicated below depending on your hardware. You already know the pin connections to the MCU. GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) 13 Tuya Rx (108) 15 Tuya Tx (107) If the device is connecting fine to your network, now is the time to power it down and re-assemble it. Connect a test bulb (or to the final place if you don't mind testing there) Once this is saved and device is rebooted. Open the Tasmota configuration page and you should be able to use the Toggle button to toggle the dimmer or at least one of the gangs in a multi gang switch. Follow the process here depending on switch or dimmer. Product Specific guides ~ Otim Dimmer ~ This Device is based on a Tuya Wi-Fi Module. Refer to \"MCU Based Tuya Dimmers and Switches\" for details. Flashing and Setup Video Guide These devices use a Tuya TYWE3S Wi-Fi PCB module. Once the switch is carefully popped open you will need to remove the ribbon cables for flashing and ease of soldering. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. You may need to also connect MCU RST to GND during initial boot to get it into programming mode as described here . A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached. (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Product Links: Oittm Moes DS01 ( Template ) Konesky Heygo Costco Charging Essentials ~ This devices use a Tuya TYWE1S Wi-Fi PCB module. And it uses U1TX (GPIO15) and U1RX (GPIO13) to communicate between ESP8266 and MCU, no other GPIO is used in this device. Flashing ~ The CE dimmer uses standard Tuya GPIO Touch (EU and US) - Multiple manufacturers ~ Flashing ~ The procedure is similar to above, additionally NRST must be connected to GND during flashing. Optional configuration (recommended) ~ LedState 0 Only use the green LED for Wi-Fi/MQTT connectivity status. Product Links: ~ AIGLEN ALLOMN MakeGood Zemismart Curtain Motor ~ Curtain motors come in a confusing array. This one has a little Wi-Fi dongle, that looks like a USB stick. But it talks using 9600 8N1 , not USB. This means we can unplug the Tuya Dongle and flash it without worrying about the PCI micro. Excellent. U1RX and U1TX , top right of the module are connected to the USB plug on D- and D+ respectively. This dongle uses a Tuya TYWE1S, which is an ESP8266 with 2MB flash. USB3 pin R- connects the onboard LED to the MCU via a 4k7 resistor. R+ , T+ , and T- are all unused and unconnected on the motor PCB, so I liberated them for soldering to GPIO0 , U0RX and U0TX , to flash the chip. short GPIO0 and flash Tasmota Connect to your Wi-Fi and get MQTT and SSL working change to TuyaMCU with module 54 (will reboot) Switch from U0RX/TX to U1RX/TX with backlog gpio1 0; gpio3 0; gpio15 107; gpio13 108 (will reboot) Treat DpId 0x65 as a Dimmer with tuyamcu 21,101 Allow the dimmer to get down to 1% with setoption69 0 And done. The curtain motor now presents as a Dimmer, with 100% full brightness = fully closed, and 0% full darkness = fully open. The curtain motor also presents DpId 0x66 as a single event \"Full Open\" 00 , \"Full Close\" 01 , and \"Stop\" 02 command; but as of September 2019, I can't see how to get that working. The curtain motor also presents DpId 0x67 as a Boolean. I have only seen value 0x01 in all my prodding. 55 aa 00 07 00 05 67 01 00 01 01 75 = 07 Status, 0005 length, 67 DpId, 01 type, 0001 length, 01 value, 75 checksum Product Links: ~ ZemiSmart DM_WF_MDV4 Leading edge dimmer ~ This is a 240V Leading Edge Dimmer with a TYWE3S controller and an STM8 MCU Flashing: ~ The simplest approach is to use Tuya-Convert to flash the device In order to flash via serial, the NRST pin of the STM8 needs to be grounded upon boot to disable it, this is brought out to a header pin, along with ground and VCC from the TYWE3S. Confirm by checking continuity with a multimeter IO0 from the TYWE3s also needs to be grounded upon boot, otherwise it's normal tasmota flashing procedure. Header J3 (STM8 debug interface) pins from left to right (Pin 1 is the square shaped) *VCC *STM8 SWIM (Pin 18) *Ground *STM8 NRST (Pin 4) Config: ~ As per main TuyaMCU page using GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) Note that the push button is wired to the MCU (PA3 Pin 10) so it cannot be used by Tasmota. Similarlly the devices has a bi-color LED where one color (green) is wired to the TYWE3S (GPIO14) and the other one (red) to the MCU (PC5 Pin15). More information: ~ Bought from ebay More information on TYWE3S ] Product Links: ~ AIGLEN ALLOMN MakeGood ZemiSmart","title":"TuyaMCU Devices"},{"location":"TuyaMCU-Devices/#identification-and-technical-details","text":"The basic identification of a Tuya device is when the device information references the \"Tuya Smart\", \"SmartLife\", or \"Smart Living\" app. These switches and dimmers are based on a Tuya TYWE3S Wi-Fi PCB module along with an MCU. TYWE3S is based on the ESP8266 which is supported by Tasmota. Wiki page for TYWE3S The TYWE3S module mostly takes care of Wi-Fi and software features while the MCU controls the actual hardware (buttons, relays, dimmer, power measurement, etc). The MCU is interfaced to TYWE3S using the serial interface which connects to the Rx and Tx pins. The easiest way to identify if your switch or dimmer uses MCU is by using a continuity tester (multimeter, ohmmeter) and checking continuity from the Rx and Tx pins on TYWE3S to any other chip. Then check the datasheet of that chip to see if it is an MCU.","title":"Identification and Technical details"},{"location":"TuyaMCU-Devices/#flashing-preparation","text":"To boot the TYWE3S in flashing mode, GPIO0 needs to be connected to GND while powering up. It can be left grounded for the entire process. Flashing a TYWE3S connected to a MCU is a bit trickier than one without MCU. This is due the same Rx Tx pins used by MCU and serial programmer for flashing. The TYWE3S cannot be booted to flash mode with MCU sending data over the same pins. To be able to do that, we need to disable MCU from sending data over Rx and Tx pins. There are few ways to do it: 1. Disconnect TYWE3S module from the rest of board. (Naah, too much work) 2. Just break the Rx track from MCU to TYWE3S, flash and then reconnect. (Messy work, we want cleaner approach) 3. Just keep MCU disabled while flashing TYWE3S without any soldering / cutting. (We like that) The easiest is to keep MCU disabled is by identifying the NRST/RST (Reset) pin of the MCU from its datasheet and connect it to GND for the entire flashing process. This will keep MCU disabled while you flash TYWE3S. If there are some contacts or test points in switches that connect to the MCU, you might be lucky to find contacts for RST that you can easily solder onto.","title":"Flashing - Preparation"},{"location":"TuyaMCU-Devices/#tywe3s-connection-options","text":"3D print a flashing Jig and use pogo pins to make nice and easy to use flashing jig Solder wires directly onto TYWE3S Use a jumper header like the one below and bend the pins to match VCC, Rx Tx GPIO0 and GND. You can just press the jumper header to the contacts during the flashing process","title":"TYWE3S Connection Options"},{"location":"TuyaMCU-Devices/#flashing-process","text":"Once you are done identifying the pins and ready to connect, BEFORE connecting USB to PC you need to connect them as follows: NOTE : Use 3.3V NOT 5V TYWE3S Serial Programmer RX TX TX RX GPIO0 GND GND GND VCC 3.3V If an MCU is present, bridge RST to GND on the MCU Use a 6.6.0.10 Tasmota version or higher. There are lots of Tuya Serial fixes / features added in there and the tutorial below expects them. Now you need to follow the commands explained in the flashing tutorial . TIP: If you are using jumper headers use sleep 15 && before your commands, this would free your hand and give you some time to set the jumper pins and connect the USB to PC.","title":"Flashing - Process"},{"location":"TuyaMCU-Devices/#configuration","text":"Once Tasmota is flashed on the TYWE3S, just disconnect GND -> GPIO0 (and RST if there is an MCU), and power your device again from USB. On your PC, you should see a Wi-Fi network named sonoff-xxxx where xxxx is a number from the ESP's MAC address. Connect to it and go to 192.168.4.1 in your browser. Enter the Wi-Fi credentials for your network and click save. Connect your PC back to your network. Now you need to find the IP of newly connected Tasmota device. Refer to this very good video from SuperHouseTV (ignore flashing information) about configuring Tasmota. Once you get to the Tasmota configuration you need to select TuyaMCU module assign GPIO components as indicated below depending on your hardware. You already know the pin connections to the MCU. GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) 13 Tuya Rx (108) 15 Tuya Tx (107) If the device is connecting fine to your network, now is the time to power it down and re-assemble it. Connect a test bulb (or to the final place if you don't mind testing there) Once this is saved and device is rebooted. Open the Tasmota configuration page and you should be able to use the Toggle button to toggle the dimmer or at least one of the gangs in a multi gang switch. Follow the process here depending on switch or dimmer.","title":"Configuration"},{"location":"TuyaMCU-Devices/#product-specific-guides","text":"","title":"Product Specific guides"},{"location":"TuyaMCU-Devices/#otim-dimmer","text":"This Device is based on a Tuya Wi-Fi Module. Refer to \"MCU Based Tuya Dimmers and Switches\" for details. Flashing and Setup Video Guide These devices use a Tuya TYWE3S Wi-Fi PCB module. Once the switch is carefully popped open you will need to remove the ribbon cables for flashing and ease of soldering. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. You may need to also connect MCU RST to GND during initial boot to get it into programming mode as described here . A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached. (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Product Links: Oittm Moes DS01 ( Template ) Konesky Heygo","title":"Otim Dimmer"},{"location":"TuyaMCU-Devices/#costco-charging-essentials","text":"This devices use a Tuya TYWE1S Wi-Fi PCB module. And it uses U1TX (GPIO15) and U1RX (GPIO13) to communicate between ESP8266 and MCU, no other GPIO is used in this device.","title":"Costco Charging Essentials"},{"location":"TuyaMCU-Devices/#touch-eu-and-us-multiple-manufacturers","text":"","title":"Touch (EU and US) - Multiple manufacturers"},{"location":"TuyaMCU-Devices/#product-links","text":"AIGLEN ALLOMN MakeGood","title":"Product Links:"},{"location":"TuyaMCU-Devices/#zemismart-curtain-motor","text":"Curtain motors come in a confusing array. This one has a little Wi-Fi dongle, that looks like a USB stick. But it talks using 9600 8N1 , not USB. This means we can unplug the Tuya Dongle and flash it without worrying about the PCI micro. Excellent. U1RX and U1TX , top right of the module are connected to the USB plug on D- and D+ respectively. This dongle uses a Tuya TYWE1S, which is an ESP8266 with 2MB flash. USB3 pin R- connects the onboard LED to the MCU via a 4k7 resistor. R+ , T+ , and T- are all unused and unconnected on the motor PCB, so I liberated them for soldering to GPIO0 , U0RX and U0TX , to flash the chip. short GPIO0 and flash Tasmota Connect to your Wi-Fi and get MQTT and SSL working change to TuyaMCU with module 54 (will reboot) Switch from U0RX/TX to U1RX/TX with backlog gpio1 0; gpio3 0; gpio15 107; gpio13 108 (will reboot) Treat DpId 0x65 as a Dimmer with tuyamcu 21,101 Allow the dimmer to get down to 1% with setoption69 0 And done. The curtain motor now presents as a Dimmer, with 100% full brightness = fully closed, and 0% full darkness = fully open. The curtain motor also presents DpId 0x66 as a single event \"Full Open\" 00 , \"Full Close\" 01 , and \"Stop\" 02 command; but as of September 2019, I can't see how to get that working. The curtain motor also presents DpId 0x67 as a Boolean. I have only seen value 0x01 in all my prodding. 55 aa 00 07 00 05 67 01 00 01 01 75 = 07 Status, 0005 length, 67 DpId, 01 type, 0001 length, 01 value, 75 checksum","title":"Zemismart Curtain Motor"},{"location":"TuyaMCU-Devices/#product-links_1","text":"ZemiSmart","title":"Product Links:"},{"location":"TuyaMCU-Devices/#dm_wf_mdv4-leading-edge-dimmer","text":"This is a 240V Leading Edge Dimmer with a TYWE3S controller and an STM8 MCU","title":"DM_WF_MDV4 Leading edge dimmer"},{"location":"TuyaMCU-Devices/#flashing_2","text":"The simplest approach is to use Tuya-Convert to flash the device In order to flash via serial, the NRST pin of the STM8 needs to be grounded upon boot to disable it, this is brought out to a header pin, along with ground and VCC from the TYWE3S. Confirm by checking continuity with a multimeter IO0 from the TYWE3s also needs to be grounded upon boot, otherwise it's normal tasmota flashing procedure. Header J3 (STM8 debug interface) pins from left to right (Pin 1 is the square shaped) *VCC *STM8 SWIM (Pin 18) *Ground *STM8 NRST (Pin 4)","title":"Flashing:"},{"location":"TuyaMCU-Devices/#config","text":"As per main TuyaMCU page using GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) Note that the push button is wired to the MCU (PA3 Pin 10) so it cannot be used by Tasmota. Similarlly the devices has a bi-color LED where one color (green) is wired to the TYWE3S (GPIO14) and the other one (red) to the MCU (PC5 Pin15).","title":"Config:"},{"location":"TuyaMCU-Devices/#more-information","text":"Bought from ebay More information on TYWE3S ]","title":"More information:"},{"location":"TuyaMCU-Devices/#product-links_2","text":"AIGLEN ALLOMN MakeGood ZemiSmart","title":"Product Links:"},{"location":"TuyaMCU/","text":"TuyaMCU - Module (54) is configured for devices with a Tuya Wi-Fi module and a secondary MCU. Originally, in those devices, the Wi-Fi module takes care of network and software features. Meanwhile, the MCU controls the hardware based on commands received from the Wi-Fi module or built-in controls (buttons, switches, remotes and similar) and reports the status back to the Wi-Fi module. TuyaMCU module facilitates communication between Tasmota and the MCU using Tuya Serial Port Communication Protocol : TuyaMCU command maps device functions to Tasmota components TuyaSend<x> command calculates and sends complex serial commands using only two parameters TuyaReceived MCU response interpreted and publishes as status message and a JSON payload to an MQTT topic TuyaMCU Command ~ Command TuyaMCU is used to map Tasmota components to Tuya device dpId's. Warning Used only if your device is defined as module TuyaMCU (54) . Command value consists of two comma separated parameters: fnId and dpId. TuyaMCU <fnId>,<dpId> where <fnId> is a Tasmota component and <dpId> is the dpId to map the function to. Example TuyaMCU 11,1 maps Relay1 (fnId 11) to dpId 1. If any existing entry with same fnId or dpId is already present, it will be updated to the new value. Entry is removed when fnId or dpId is 0 . When no parameters are provided TuyaMCU prints the current mapped values. dpId ~ All the device functions controlled by the MCU are identified by a dpId. Whenever a command is sent to the MCU, this dpId determines which component needs to be controlled and the applies when the status is received from MCU. There is no way to autodetect dpId's and their functions. To assist in the process of determining what dpId does what, there is a bookmarklet available that can be used on the console screen. This will send the weblog and other required commands automatically, and present the TuyaMCU information in a single table allowing for easier testing. Use this procedure to determine which dpId's are available: Go to Configure -> Console option in Tasmota web interface. Use command weblog 4 to enable verbose logging in web interface. Observe the log. After every 9-10 seconds you should see Tuya specific messages labelled as TYA: . {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010010\",\"Cmnd\":7,\"CmndData\":\"0201000100\",\"DpType1Id2\":0,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010012\",\"Cmnd\":7,\"CmndData\":\"0401000100\",\"DpType1Id4\":0,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=4 Observe all lines printed as TYA: FnId=0 is set for dpId=XXX and note all dpId values. Now that you have a list of usable dpId's you need to determine what their functions are: Consulting our list of commonly used dpId's and existing device configurations Observing Tasmota logs while activating features of the device (with a remote or on device controls) and correlating log messages and looking at the DpIdType and DpIdData values (eg: boolean vs value) Extrapolating possible function of the dpId based on Data Type and Function Command, then testing using TuyaSend<x> fnId ~ Identifier used in TuyaMCU command to map a dpId to a Tasmota component. Component FnId Note Switch1 to Switch4 1 to 4 Map only to dpId with on / off function Relay1 to Relay8 11 to 18 Map only to dpId with on / off function Lights 21 to 28 21 for Dimmer 22 for Dimmer2 23 for CCT Light 24 for RGB light 25 for white light 26 for light mode set (0 = white and 1 = color) 27 to report the state of Dimmer1 28 to report the state of Dimmer2 Power Monitoring 31 to 33 31 for Power (in deci Watt) 32 for Current (in milli Amps) 33 for Voltage (in deci Volt) Relay1i to Relay8i 41 to 48 Map only to dpId with on / off function Battery powered sensor mode 51 Battery powered devices use a slightly different protocol Enum dpId 61 to 64 Range for each enum is 0 to 31 Sensors 71 to 79 Range of sensors (temperature, humidity, co2, gas, etc) Timers 81 to 84 Manage integer based timers Extra functions 97 to 99 97 for motor direction 98 for error logging (report only) 99 as a dummy function Note This component is under active development which means the function list may expand in the future. Since the majority of devices have a power on/off functions on dpId 1 its mapped to fnId 11 (Relay1) by default. If you don't need it, map it to fnId 99 with TuyaMcu 99,1 Danger Mapping a relay or switch to a dpId that is not a simple on/off function (data Type 1) might result in unwanted power toggling (i.e. dpId sends value of 4 which toggles the relay to Power 4 aka blink mode) TuyaSend Command ~ Command TuyaSend is used to send commands to dpId's. It is required for dpId's that shouldn't be mapped to a fnId. With this command it is possible to control every function of the dpId that is controllable, providing you know its data type and data length. With them provided, the rest of the protocol command is calculated. Command's value consists of two comma separated parameters: dpId and data. TuyaSend<x> dpId,data TuyaSend0 ~ Used without payload to query states of dpID's. TuyaSend1 ~ Sends boolean (Type 1) data ( 0/1 ) to dpId (Max data length 1 byte) Example TuyaSend1 1,0 sends vaue 0 to dpId=1 switching the device off TuyaSend2 ~ Sends integer or 4 byte (Type 2) data to dpId (Max data length 4 bytes) Example TuyaSend2 14,100 sends value 100 to dpId=14 setting timer to 100 minutes TuyaSend3 ~ Sends an ASCII string (Type 3) data to dpId (Max data length? Not known at this time). Warning Note that when sending color values, the MCU may interpret lower case and upper case hex codes differently. You may need to test with your specific MCU to ensure that the values sent properly render the color you desire. Example TuyaSend3 108,ff0000646464ff sends a 14 char hex string to dpId=108 (Type 3) containing RGBHSV values to control a light TuyaSend4 ~ Sends enum (Type 4) data ( 0/1/2/3/4/5 ) to dpId (Max data length 1 bytes) Example TuyaSend4 103,2 sends value 2 to dpId=103 to set fan speed to high TuyaSend5 ~ Sends an HEX string (Type 3) data to dpId (Max data length? Not known at this time). Does NOT require 0x prefix. Example TuyaSend5 108, ABCD sends a string of 2 bytes defined by hex codes to dpId=108 Differences between TuyaSend3 and TuyaSend5 : TuyaSend3 108, ABCD sends 55aa000600086c030004414243448a where the payload is 41424344 which is the ASCII bytes representing the string ABCD TuyaSend5 108, ABCD sends 55aa000600066c030002abcdf4 where the payload is a abcd which is a string of 2 bytes 0xAB and 0xCD TuyaSend6 ~ Sends payload with raw data (type 0) to dpId (Max data length? Not known at this time). Does NOT require 0x prefix. Example TuyaSend6 37, 060000DC08000096 sends raw data defined by hex codes to dpId=37 Differences between TuyaSend3 , TuyaSend5 and TuyaSend6 : * TuyaSend3 and TuyaSend5 sends payload with the data type 0x03 = string * TuyaSend6 sends payload with the data type 0x00 = raw TuyaSend8 ~ Used without payload to get device information and dpId states. Replaces SerialSend5 55aa000100000 TuyaSend9 ~ Use without any payload to toggle a new STAT topic reporting changes to a dpId, for example: 17 : 45 : 38 MQT: stat / TuyaMCU / DPTYPE1ID1 = 1 TuyaReceived ~ Every status message from the MCU gets a JSON response named TuyaReceived which contains the MCU protocol status message inside key/value pairs which are hidden from the user by default. To publish them to a MQTT Topic of tele/%topic%/RESULT you need to enable SetOption66 1 . To avoid some cyclic MCU <-> ESP messages published via MQTT to the topic tele/%topic%/RESULT you need to enable SetOption137 1 . If SetOption137 set to 1 the following cmds will not forwarded: - the heartbeat between the MCU <-> ESP (every 10 seconds, TUYA_CMD_HEARTBEAT ) - the Wifi-State between the MCU <-> ESP (during start-up and wifi events, TUYA_CMD_WIFI_STATE ) - the local time info query of the MCU (every minute, TUYA_CMD_SET_TIME ) - the received update package info from MCU (during firmware update of Tuya MCU, TUYA_CMD_UPGRADE_PACKAGE ) If SetOption137 set to 0 all received Tuya MCU messages will be published. SetOption137 is very useful to reduce the MQTT-traffic. Example ~ After issuing serial command 55aa0006000501010001010e (Device power (dpId=1) is mapped to Relay1 (fnId=11)) we get the following console output (with weblog 4 ): 19:54:18 TYA: Send \"55aa0006000501010001010e\" 19:54:18 MQT: stat/GD-30W/STATE = {\"Time\":\"2019-10-25T19:54:18\",\"Uptime\":\"0T01:45:51\",\"UptimeSec\":6351,\"Heap\":27,\"SleepMode\":\"Dynamic\",\"Sleep\":0,\"LoadAvg\":999,\"MqttCount\":1,\"POWER1\":\"ON\",\"POWER2\":\"OFF\",\"POWER3\":\"ON\",\"POWER4\":\"OFF\",\"POWER5\":\"ON\",\"Dimmer\":100,\"Fade\":\"OFF\",\"Speed\":1,\"LedTable\":\"OFF\",\"Wifi\":{\"AP\":1,\"SSId\":\"HTPC\",\"BSSId\":\"50:64:2B:5B:41:59\",\"Channel\":10,\"RSSI\":24,\"LinkCount\":1,\"Downtime\":\"0T00:00:08\"}} 19:54:18 MQT: stat/GD-30W/RESULT = {\"POWER1\":\"ON\"} 19:54:18 MQT: stat/GD-30W/POWER1 = ON 19:54:18 MQT: stat/GD-30W/RESULT = {\"TuyaReceived\":{\"Data\":\"55AA0007000501010001010F\",\"ChkSum\":\"0x0F\",\"Cmnd\":7,\"CmndDataLen\":5,\"CmndData\":\"0101000101\",\"DpId\":1,\"DpIdType\":1,\"DpIdLen\":1,\"DpIdData\":\"01\"}} 19:54:18 TYA: fnId=11 is set for dpId=1 19:54:18 TYA: RX Relay-1 --> MCU State: On Current State:On Above TYA: fnId=11 is set for dpId=1 you can see the JSON response for that dpId. This JSON string displays the response MCU gave to our command. \"Data\" field contains the complete response and the rest of the key/value pairs show the protocol broken into parts. \"DpId\", \"DpIdData\" and \"DpIdType\" are the ones we're most interested in since we can use them for TuyaSend . Tip Use command TuyaSend8 and/or TuyaSend0 at any time to request statuses of all dpId's from the MCU. Use in Rules ~ This data can also be used as a trigger for rules using TuyaReceivedData#Data=hex_string Rule1 on TuyaReceived # Data = 55 AA000700056E040001007E do publish2 stat / tuya_light / effect rgb_cycle endon will publish a status message to a custom topic when 55AA000700056E040001007E appears in \"Data\" field of the response. Device Configurations ~ Before proceeding identify dpId's and their function. Dimmer ~ We need to configure four functions of a dimmer: Dimming dpId Dimming Range Dimming less than 10% Dimming dpId ~ The dimmer FunctionId is 21 . On a dimmer dpId generally is 2 or 3 . Try both. Go to the Tasmota Console and type TuyaMCU 21,2 and wait for it to reboot. Enter Backlog Dimmer 10; Dimmer 100 in the Console. If your bulb responds to Dimmer commands, you have successfully configured the dimmer FunctionId. Make note of it. If not try id 3 and if even 3 doesn't work keep trying Ids from all unknown Ids from the log until one works. Dimming Range ~ Once you have figured out the dimming functionId, we need to find the maximum dimming range. Once the dimming Id is set, the logs will continue TYA: Heartbeat TYA: RX Packet: \"55aa03070005010100010011\" TYA: RX Relay-1 --> MCU State: Off Current State:Off TYA: RX Packet: \"55aa03070008020200040000000720\" TYA: FnId=21 is set for dpId=2 TYA: RX Dim State=7 Now using the hardware buttons increase the dimmer to its maximum and observe the log. The Dim State=XXX shows the current dimmer level reported by MCU. Once the dimmer is at max, note this number. Again using hardware buttons decrease dimmer to minimum and note the number for minimum. Now we need to tell Tasmota to use maximum and minimum values. This controlled by DimmerRange command. We can set it using DimmerRange <Min>,<Max> where <Min> is the minimum dimmer state and <Max> maximum dimmer state reported in logs. Once set, try dimmer 100 in the Console and check if the brightness of bulb is same is the same as when the maximum was set using hardware buttons. Warning Some Tuya devices automatically send the state of a dimmer after a power off. Tasmota could misunderstand the command and try to turn on the light even with SetOption20 and SetOption54 enabled. Dual Dimmer ~ To enable a dual dimmer setup assign fnId's: 21 as Dimmer1 22 as Dimmer2 11 as Relay1 12 as Relay2 Tasmota will automatically enable SetOption68 and the dimmers will respond to Channel1 and Channel2 commands. Warning The use of SetOption68 is limited to two channels and will be automatically disabled if any other combination of lights is used. Lights ~ CCT Light ~ To enable a CCT light assign fnId's: 21 as Dimmer1 11 as Relay1 23 as CT channel RGB Light ~ To enable an RGB light assign fnId's: 21 as Dimmer1 11 as Relay1 24 as RGB controller TuyaMCU uses different types of RGB Hex format where the most recent is 0HUE0SAT0BRI0 (type 1) and the older being RRGGBBFFFF6464 (type 2). Depending on the MCU, code can be case sensitive. After enabling the RGB function check the TuyaReceived information and use TuyaRGB to configure and store the correct (or the closest) format: TuyaRGB 0 - Type 1, 12 characters uppercase. Example: 00DF00DC0244 (default) TuyaRGB 1 - Type 1, 12 characters lowercase. Example: 008003e8037a TuyaRGB 2 - Type 2, 14 characters uppercase. Example: 00FF00FFFF6464 TuyaRGB 3 - Type 2, 14 characters lowercase. Example: 00e420ffff6464 TuyaRGB without payload will return the actual configured format. RGB+X Light ~ To enable an RGB+W light use RGB Light configuration and assign fnId 25 as white color. To enable an RGB+CCT light use RGB Light configuration and assign fnId 23 as CT channel. Light mode selector ~ The majority of TuyaMCU devices with an RGB+W or an RGB+CCT light have a button or app function to switch between White and Colored light. To do the same in Tasmota, assign function (fnId) 26 to the mode select dpId. The possible values are 0 (white) and 1 (colorful). A button on the WebUI will be available once configured. When the ModeSet function is enabled it is not possible to update both lights at the same time. Only the currently selected light mode will be updated. Warning Use of SetOption68 for more than two channels and the light split option ( SetOption37 >= 128 ) are not supported in TuyaMCU mode. Enums ~ Better control over Type4 or enum dpId's. Up to four can be added, with a range from 0 to 31. 61 as Enum1 62 as Enum2 63 as Enum3 64 as Enum4 After an enum is configured, use TuyaEnumList to declare the range it must respect (note 0 is always the first item in range). TuyaEnumlist <enum>,<range> where <enum> is declared using TuyaMCU and <range> is 0..31 . Example: configure Enum 1 with a range from 0 to 8. 21 : 14 : 52 CMD : tuyaenumlist 1 , 8 21 : 14 : 52 MQT : stat / TuyaMCU / RESULT = { \"TuyaEnumList\" :{ \"Enum1\" : 8 , \"Enum2\" : 9 , \"Enum4\" : 1 }} Entering a value greater than 31 will return an error TuyaEnumList without payload will return the configuration of all the enums enabled in the list. To update an enum use the command TuyaEnum : Usage TuyaEnum [1|2|3|4],[TuyaEnumList range] Example: update Enum 2 to 4. 21 : 14 : 12 CMD : tuyaenum2 4 21 : 14 : 12 MQT : stat / TuyaMCU / RESULT = { \"TuyaEnum2\" : 4 } Entering a value not in range will return an error TuyaEnum without payload will return the state of all the enums configured. Sensors ~ These are the currently available sensors: 71 as Temperature Sensor 73 as Humidity Sensor 75 as Illuminance Sensor 76 as TVOC Sensor 77 as CO 2 Sensor 78 as ECO 2 Sensor 79 as %LEL gas Sensor If your device has a dpId for setting a specific Temperature and/or Humidity: 72 for Temperature Set 74 for Humidity Set Use TuyaSend2 to manage them. Temperature and Temperature Set default to \u00b0C . If you need \u00b0F change SetOption8 to 1 . The TuyaMCU driver sends the temperature as a byte integer. As of 9.3.x, the integer is converted by Tasmota to a float based on the \"TempRes\" setting which indicates the number of places after the decimal. The TempRes setting is by default \"1\" which means a device which sends 101 will be intepreted as 10.1. If your device normaly returns an integer temperature, you may need to set TempRes to \"0\". If your device requires the temperature to be divided (eg. increases in .5\u00b0 increments), you may need to use the rules functionality to convert the temperature value. Please note this will not update the value sent by the MCU but will just change the unit of measure reported on /SENSOR topic. You have to find a dpid to set the correct unit and change reported values (if it exists) or perhaps use the rules functionality to do the conversion. Timers ~ 4 Type2 (integer) timers can be managed directly from Tasmota 81 as Timer1 82 as Timer2 83 as Timer3 84 as Timer4 Timers can be managed with TuyaSend2 and are visible in the WebUI. Covers ~ Single shutter or double shutters devices can be managed with a dimmer setup For devices that are reporting position to a another dpId assign fnId's: 27 to report the state of Dimmer1 28 to report the state of Dimmer2 If your cover device has a motor direction change option assign fnId 97 for motor direction. Switches ~ There is currenty no way to detect the number of relays present in an MCU based switch. We need to tell the number of relays to Tasmota using FunctionIDs 12 to 18 for Relay2 to Relay4. Example For a 4 gang switch set TuyaMCU 12,2 , TuyaMCU 13,3 and TuyaMCU 14,4 if the dpIds for Relays 2-4 are 2 , 3 , 4 . Tip You can configure all at once by using Backlog TuyaMCU 12,2; TuyaMCU 13,3; TuyaMCU 14,4 Power Metering ~ Some Tuya MCU devices support Power measurement support over serial. For this it is better to use a bulb with known wattage rating. Observe the logs in the Console TYA: Heartbeat {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010111\",\"Cmnd\":7,\"CmndData\":\"0201000101\",\"DpType1Id2\":1,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010113\",\"Cmnd\":7,\"CmndData\":\"0401000101\",\"DpType1Id4\":1,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=4 {\"TuyaReceived\":{\"Data\":\"55AA0107000807020004000000001C\",\"Cmnd\":7,\"CmndData\":\"0702000400000000\",\"DpType2Id7\":0,\"7\":{\"DpId\":7,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=7 {\"TuyaReceived\":{\"Data\":\"55AA0107000808020004000000001D\",\"Cmnd\":7,\"CmndData\":\"0802000400000000\",\"DpType2Id8\":0,\"8\":{\"DpId\":8,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=8 {\"TuyaReceived\":{\"Data\":\"55AA0107000809020004000000001E\",\"Cmnd\":7,\"CmndData\":\"0902000400000000\",\"DpType2Id9\":0,\"9\":{\"DpId\":9,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=9 {\"TuyaReceived\":{\"Data\":\"55AA010700080A020004000000001F\",\"Cmnd\":7,\"CmndData\":\"0A02000400000000\",\"DpType2Id10\":0,\"10\":{\"DpId\":10,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=10 {\"TuyaReceived\":{\"Data\":\"55AA0107000865020004000000007A\",\"Cmnd\":7,\"CmndData\":\"6502000400000000\",\"DpType2Id101\":0,\"101\":{\"DpId\":101,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=101 {\"TuyaReceived\":{\"Data\":\"55AA01070008660200040000009813\",\"Cmnd\":7,\"CmndData\":\"6602000400000098\",\"DpType2Id102\":152,\"102\":{\"DpId\":102,\"DpIdType\":2,\"DpIdData\":\"00000098\"}}} TYA: fnId=0 is set for dpId=102 {\"TuyaReceived\":{\"Data\":\"55AA01070008670200040000017EFB\",\"Cmnd\":7,\"CmndData\":\"670200040000017E\",\"DpType2Id103\":382,\"103\":{\"DpId\":103,\"DpIdType\":2,\"DpIdData\":\"0000017E\"}}} TYA: fnId=0 is set for dpId=103 {\"TuyaReceived\":{\"Data\":\"55AA0107000868020004000009951B\",\"Cmnd\":7,\"CmndData\":\"6802000400000995\",\"DpType2Id104\":2453,\"104\":{\"DpId\":104,\"DpIdType\":2,\"DpIdData\":\"00000995\"}}} TYA: fnId=0 is set for dpId=104 In the TuyaReceived we are interested in DpIdData . For example: 00000995 is the second last entry. Make sure the bulb if off. Find out the voltage standard of your country (generally 220, 240, 120v) from this table . Multiply that number by 10 (2400) and Convert that number (2400) to Hex using any hex converter (2400 = 0x960) Now look for the number nearest to 960 in the logs. In our case it is 00000995 . So we expect that's the voltage which is \"DpId\":104 in our example. Set voltage functionId 33 by entering TuyaMCU 33,104 . Now set dimmer to 100% using the dimmer 100 command, or power on using power1 on (depending on the device) and observe the logs. Now we need the power rating of your bulb, for example 40W . Multiply by 10 (400) and convert to hex which gives us 0x190. Check which unknown ID is close to 190 . I this example it is 17E for \"DpId\":103 . This is the Id of Active Power function. Set the active power functionId 31 by entering TuyaMCU 31,103 . Once Power and Voltage are set you should see something such as this in the logs: TYA: Heartbeat {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010111\",\"Cmnd\":7,\"CmndData\":\"0201000101\",\"DpType1Id2\":1,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010113\",\"Cmnd\":7,\"CmndData\":\"0401000101\",\"DpType1Id4\":1,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=4 {\"TuyaReceived\":{\"Data\":\"55AA0107000807020004000000001C\",\"Cmnd\":7,\"CmndData\":\"0702000400000000\",\"DpType2Id7\":0,\"7\":{\"DpId\":7,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=7 {\"TuyaReceived\":{\"Data\":\"55AA0107000808020004000000001D\",\"Cmnd\":7,\"CmndData\":\"0802000400000000\",\"DpType2Id8\":0,\"8\":{\"DpId\":8,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=8 {\"TuyaReceived\":{\"Data\":\"55AA0107000809020004000000001E\",\"Cmnd\":7,\"CmndData\":\"0902000400000000\",\"DpType2Id9\":0,\"9\":{\"DpId\":9,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=9 {\"TuyaReceived\":{\"Data\":\"55AA010700080A020004000000001F\",\"Cmnd\":7,\"CmndData\":\"0A02000400000000\",\"DpType2Id10\":0,\"10\":{\"DpId\":10,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=10 {\"TuyaReceived\":{\"Data\":\"55AA0107000865020004000000007A\",\"Cmnd\":7,\"CmndData\":\"6502000400000000\",\"DpType2Id101\":0,\"101\":{\"DpId\":101,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=101 {\"TuyaReceived\":{\"Data\":\"55AA01070008660200040000009712\",\"Cmnd\":7,\"CmndData\":\"6602000400000097\",\"DpType2Id102\":151,\"102\":{\"DpId\":102,\"DpIdType\":2,\"DpIdData\":\"00000097\"}}} TYA: fnId=0 is set for dpId=102 {\"TuyaReceived\":{\"Data\":\"55AA01070008670200040000017BF8\",\"Cmnd\":7,\"CmndData\":\"670200040000017B\",\"DpType2Id103\":379,\"103\":{\"DpId\":103,\"DpIdType\":2,\"DpIdData\":\"0000017B\"}}} TYA: fnId=31 is set for dpId=103 TYA: Rx ID=103 Active_Power=379 {\"TuyaReceived\":{\"Data\":\"55AA0107000868020004000009961C\",\"Cmnd\":7,\"CmndData\":\"6802000400000996\",\"DpType2Id104\":2454,\"104\":{\"DpId\":104,\"DpIdType\":2,\"DpIdData\":\"00000996\"}}} TYA: fnId=33 is set for dpId=104 TYA: Rx ID=104 Voltage=2454 To get the Id for the current, calculate Current = Power / Voltage ( 37.9 / 245.4 ) = ~0.1544 (Remember to divide each value by 10). Multiply this by 1000 = 154. Now convert 154 to hex which is 0x9A. This is closest to 97 which is Id \"DpId\":102 . Set the current FunctionId 32 using command TuyaMCU 32,102 . Observe the logs should start showing Current in addition to Active_Power and Voltage TYA: Heartbeat {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010111\",\"Cmnd\":7,\"CmndData\":\"0201000101\",\"DpType1Id2\":1,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010113\",\"Cmnd\":7,\"CmndData\":\"0401000101\",\"DpType1Id4\":1,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=4 {\"TuyaReceived\":{\"Data\":\"55AA0107000807020004000000001C\",\"Cmnd\":7,\"CmndData\":\"0702000400000000\",\"DpType2Id7\":0,\"7\":{\"DpId\":7,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=7 {\"TuyaReceived\":{\"Data\":\"55AA0107000808020004000000001D\",\"Cmnd\":7,\"CmndData\":\"0802000400000000\",\"DpType2Id8\":0,\"8\":{\"DpId\":8,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=8 {\"TuyaReceived\":{\"Data\":\"55AA0107000809020004000000001E\",\"Cmnd\":7,\"CmndData\":\"0902000400000000\",\"DpType2Id9\":0,\"9\":{\"DpId\":9,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=9 {\"TuyaReceived\":{\"Data\":\"55AA010700080A020004000000001F\",\"Cmnd\":7,\"CmndData\":\"0A02000400000000\",\"DpType2Id10\":0,\"10\":{\"DpId\":10,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=10 {\"TuyaReceived\":{\"Data\":\"55AA0107000865020004000000007A\",\"Cmnd\":7,\"CmndData\":\"6502000400000000\",\"DpType2Id101\":0,\"101\":{\"DpId\":101,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=101 {\"TuyaReceived\":{\"Data\":\"55AA01070008660200040000009712\",\"Cmnd\":7,\"CmndData\":\"6602000400000097\",\"DpType2Id102\":151,\"102\":{\"DpId\":102,\"DpIdType\":2,\"DpIdData\":\"00000097\"}}} TYA: fnId=32 is set for dpId=102 TYA: Rx ID=102 Current=151 {\"TuyaReceived\":{\"Data\":\"55AA01070008670200040000017BF8\",\"Cmnd\":7,\"CmndData\":\"670200040000017B\",\"DpType2Id103\":379,\"103\":{\"DpId\":103,\"DpIdType\":2,\"DpIdData\":\"0000017B\"}}} TYA: fnId=31 is set for dpId=103 TYA: Rx ID=103 Active_Power=379 {\"TuyaReceived\":{\"Data\":\"55AA0107000868020004000009961C\",\"Cmnd\":7,\"CmndData\":\"6802000400000996\",\"DpType2Id104\":2454,\"104\":{\"DpId\":104,\"DpIdType\":2,\"DpIdData\":\"00000996\"}}} TYA: fnId=33 is set for dpId=104 TYA: Rx ID=104 Voltage=2454 Power and current should change on dimming high / low or turning the device on and off. The Tasmota web UI should show power values now on the home page. Battery Powered Sensors ~ TYMC-1 Door/Window Sensor TY-01 Door/Window Sensor Gas Sensor Smoke Sensor PIR Sensor Specific Devices ~ Aromatherapy Diffuser Water Kettle Air Purifier Mouse Trap Humidifer Tuya Protocols ~ The MCU communicates with the Wi-Fi module through the serial port with a Tuya specified protocol. Those are classified into basic and functional protocols. Basic protocols ~ They are common protocols integrated in Tasmota's TuyaMCU module. They stay the same for each product and are mandatory for Tuya module to work correctly. Functional protocols ~ Functional protocols are used for delivering and reporting data of functions. These protocols differ between devices and manufacturers and might require configuration in Tasmota using TuyaMCU command or with TuyaSend<x> command. Anatomy of Tuya Protocol ~ Name Description Frame Header Version Fixed value of 0x55aa Command Word 0x06 - send commands 0x07 - report status Data Length defines expected length of data dpID numbered ID of a function (DP = Data Point or Define Product) Data Type see Data Type table below Function Length length of command Function Command formatted according to Data Type Verification Method checksum = remainder of the byte sum starting from Frame Header to 256 Data Type ~ Hex Tasmota Command Decription Max length 0x00 TuyaSend6 raw data unknown 0x01 TuyaSend1 boolean data 0/1 1 byte 0x02 TuyaSend2 value data. If a value contains less than 4 bytes, 0 is supplemented before 4 bytes 0x00 TuyaSend3 string data unknown 0x04 TuyaSend4 enum data 0/1/2/3/4/5 1 byte 0x05 ### fault data, report only 8 bytes Let's dissect and explain the MCU protocol using serial command 55aa0006000501010001010e : Frame Header Version Command Word Data Length dpID Data Type Function Length Function Command Verification Method 55aa00 06 0005 01 01 0001 01 0e This is the command which powers on the device sending Function Command = 1 to dpID 1 (Switch): Frame Header Version = 0x55aa00 which is a fixed value and always the same Command Word = 0x06 because we're sending a command Data Type = 0x01 since the command sent is a 1 byte boolean Function Length = 0x001 instruct 1 character only for function command length Function Command = 0x01 in hex which equals 1 in int Verification Method = 0e is calculated Protocol flow ~ On device boot, TuyaMCU executes the required basic protocols and reads the functional protocol data received, which are used to update status of components mapped in TuyaMCU (Relays, dimmer, power monitoring data). After receiving a command from Tasmota (Command Word 0x06 ), the MCU performs corresponding logical control. When the dpID status is changed, the MCU reports the data (Command Word 0x07 ) to TuyaMCU component. dpId Function Tables ~ This information is just for orientation. Functions are assigned by the manufacturer and can be on different dpId's DP ID: dpId. Function Point\uff1aUsed to describe the product function. Identifier: Function codename. Can only be letters, numbers and underscores Data type\uff1a Issue and report: command data can be sent and status data can be reported back to the Wi-Fi module Report only: supports only status reporting, no control options Function Type (Referred as Data Type): Boolean (bool): non-true or false binary variable, such as: switch function, on / off Value (value): suitable for linear adjustment of the type of data, such as: temperature regulation, temperature range 20-40 \u2103 Enum (enum): custom finite set value, such as: working levels, low / mid / high Fault (fault): dedicated to reporting and statistical failure of the function points. Support multi-fault, the data is reported only Integer\uff08integer\uff09: transmitted as integer Transparent (raw): data in binary Switches or Plugs/Power Strips ~ DP ID Identifier Data type Function type Properties 1 switch_1 Control and report Boolean 2 switch_2 Control and report Boolean 3 switch_3 Control and report Boolean 4 switch_4 Control and report Boolean 5 switch_5 Control and report Boolean 9 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 10 countdown_2 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 11 countdown_3 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 12 countdown_4 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 13 countdown_5 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s Aromatherapy Machine (Oil Diffuser) ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 6 Amount of fog fog Issue and report Enum Enumerated values:small, large 11 Light Light Issue and report Boolean 12 Fault alarm fault Only report Fault Barrier values:1 13 Countdown countdown Issue and report Enum Enumerated values: 0, 1, 2, 3 14 Countdown remaining time countdown_left Only report Integer Values range: 0-360, Pitch1, Scale0, Unit:min 101 Light mode work_mode Issue and report Enum Enumerated values: white, colour, scene, scene1, scene2, scene3, scene4 102 Color value colour_data Issue and report Char type *see below 103 Light mode lightmode Issue and report Enum Enumerated values: 1, 2, 3 104 Brightness setting setlight Issue and report Integer Values range: 0-255, Pitch1, Scale0, Unit:\\% colour_data format of the lights is a string of 14 characters, for example, 00112233334455, where 00 indicates R, 11 indicates G, 22 indicates B, 3333 indicates the hue, 44 indicates the saturation, and 55 indicates the value. The initial value is saved by default. If you do not want to adjust the light, set the data to the maximum value 100% (0x64). The last four characters have fixed values. Curtain Motor ~ DP ID Function points Identifier Data type Function type Properties 1 Percentage percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 2 Motor Direction control_back Issue and report Boolean 3 Auto Power auto_power Issue and report Boolean 4 Left time countdown Issue and report Enum Enumerated values:cancel, 1, 2, 3, 4 5 Total Time time_total Only report Integer Values range:0-120000, Pitch1, Scale0, Unit:m Complete document on protocols DP ID Function points Identifier Data type Function type Properties 1 Control (required) control Issue and report Enum Enumerated values:open, stop, close, continue 2 Curtain position setting percent_control Issue and report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Current curtain position percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 4 Mode mode Issue and report Enum Enumerated values:morning, night 5 Motor Direction control_back Issue and report Enum Enumerated values:forward, back 6 Auto Power auto_power Issue and report Boolean 7 Work State (required) work_state Only report Enum Enumerated values:opening, closing 11 Situation_set situation_set Only report Enum Enumerated values:fully_open, fully_close 12 Fault (required) fault Only report Fault Barrier values:motor_fault Power Monitoring Plug ~ DP ID Function points Identifier Data type Function type Properties 1 switch_1 switch_1 Control and report Boolean 9 countdown_1 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 17 statistics Function add_ele Control and report Integer undefined0-50000, undefined100, Scale3, Unit: 18 current cur_current Data report Integer undefined0-30000, undefined1, Scale0, Unit:mA 19 power cur_power Data report Integer undefined0-50000, undefined1, Scale1, Unit:W 20 voltage cur_voltage Data report Integer undefined0-5000, undefined1, Scale1, Unit:V 21 test flag test_bit Data report Integer undefined0-5, undefined1, Scale0, Unit: 22 voltage coefficient voltage_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 23 current coefficient electric_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 24 power coefficient power_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 25 statistics coefficient electricity_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 26 warning fault Data report Fault Barrier values:ov_cr Dehumidifier ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% Lighting ~ DP ID Function points Identifier Data type Function type Properties 1 Switch led_switch Control and report Boolean 2 Mode work_mode Control and report Enum Enumerated values:white, colour, scene, scene_1, scene_2, scene_3, scene_4 3 Bright bright_value Control and report Integer undefined25-255, undefined1, Scale0, Unit: 5 Colour mode colour_data Control and report Char type 6 Scene scene_data Control and report Char type 7 Scene1 flash_scene_1 Control and report Char type 8 Scene2 flash_scene_2 Control and report Char type 9 Scene3 flash_scene_3 Control and report Char type 10 Scene4 flash_scene_4 Control and report Char type Contact Sensor ~ DP ID Function points Identifier Data type Function type Properties 1 Door Sensor doorcontact_state Only report Boolean 2 Battery Level battery_percentage Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Battery Level battery_state Only report Enum Enumerated values:low, middle, high 4 Anti-remove Alarm temper_alarm Only report Boolean Air purifier ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% Heater ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p 5 Fault alarm Fault Only report Fault Barrier values:1, 2, 3 6 Gear position gear Issue and report Enum Enumerated values:low, mid, high, off 7 Conservation eco_mode Issue and report Boolean Smart fan ~ DP ID Function points Identifier Data type Function type Properties 1 Switch switch Issue and report Boolean 2 Wind Speed Level fan_speed Issue and report Enum Enumerated values:1, 2, 3, 4 3 Left-and-Right Swing fan_horizontal Issue and report Enum Enumerated values:on, off 4 Up-and-Down Swing fan_vertical Issue and report Enum Enumerated values:on, off 5 Fault Alarm fault Only report Fault Barrier values:1, 2 6 Anion anion Issue and report Boolean 7 Humidify humidifier Issue and report Boolean 8 Oxygen oxygan Issue and report Boolean 9 Child Lock lock Issue and report Boolean 10 Cool fan_cool Issue and report Boolean 11 Set Temperate temp Issue and report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 12 Current Temperature temp_current Only report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 Kettle ~ DP ID Function points Identifier Data type Function type Properties 1 Working switch start Issue and report Boolean 2 Heat to target temperature shortcut (\u00b0C) temp_setting_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 3 Heat to target temperature shortcut (\u00b0F) temp_setting_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 4 Cool to the target temperature shortcut after boiling (\u00b0C) temp_boiling_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 5 Cool to the target temperature shortcut after boiling (\u00b0F) temp_boiling_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 6 Temperature scale switching temp_unit_convert Issue and report Enum Enumerated values:c, f 7 Insulation switch switch_keep_warm Issue and report Boolean 8 Holding time setting keep_warm_setting Issue and report Integer Values range:0-360, Pitch1, Scale0, Unit:min 9 Mode work_type Issue and report Enum Enumerated values: setting_quick, boiling_quick, temp_setting, temp_ BecaThermostat ~ Work in progress DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p (wip) 102 Floor Temperature FloorCurrent Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 Inkbird ITC-308-Wifi ~ Temperature controller with individual plug in sockets for heating/cooling DP ID Function points Identifier Data type Function type Properties 101 Temperature unit Cf Issue and report Integer 0=C, 1=F 102 Calibration Ca Issue and report Integer Unit is 0.1C 104 Temperature sensor Issue and report Integer Unit is 0.1C 106 Temperature set point Ts Issue and report Integer Unit is 0.1C 108 Compressor delay time Pt Issue and report Integer Unit is minutes 109 Alarm high temperature Ah Issue and report Integer Unit is 0.1C 110 Alarm low temperature Al Issue and report Integer Unit is 0.1C, For negative values use -(0xFFFFFFFF - value) 115 Relay status Only report Integer 01=cool, 02=off, 03=heating 116 Temperature sensor Issue and report Integer Unit is 0.1F 117 Heating differential value Hd Issue and report Integer Unit is 0.1C 118 Cooling differential value Cd Issue and report Integer Unit is 0.1C The unit will constantly be sending the temperature sensor value in celcius and fahrenheit: 104 and 116. To trigger the unit to send all settings, send any value to a non-used register, e.g. TuyaSend1 2,1 Example: Tasmota command Result TuyaSend1 2,1 Trigger the unit to reveal all settings TuyaSend2 106,250 Change set-point to 25.0C TuyaSend2 101,1 Change units to Fahrenheit Inkbird IHC-200-Wifi ~ Humidity controller with two relay sockets very similar to the ITC-308-WIFI This unit ships with a RTL based WR3 module which cannot be flashed with Tasmota, however the WR3 module is pin compatible with a ESP12-F module and is on a daughter board similar to the one in the ITC-308-WIFI DP ID Function points Identifier Data type Function type Properties 104 Humidity sensor Only report Integer Unit is 0.1C 106 Humidity set point HS Issue and report Integer Unit is 0.1C Dpid 102,108,109,110,106,117,118 return data and are not yet reverse engineered but are likely similar to ITC-308 but related to humidity. Further Reading ~ TuyaMCU Flashing and Device Configuration","title":"TuyaMCU"},{"location":"TuyaMCU/#tuyamcu-command","text":"Command TuyaMCU is used to map Tasmota components to Tuya device dpId's. Warning Used only if your device is defined as module TuyaMCU (54) . Command value consists of two comma separated parameters: fnId and dpId. TuyaMCU <fnId>,<dpId> where <fnId> is a Tasmota component and <dpId> is the dpId to map the function to. Example TuyaMCU 11,1 maps Relay1 (fnId 11) to dpId 1. If any existing entry with same fnId or dpId is already present, it will be updated to the new value. Entry is removed when fnId or dpId is 0 . When no parameters are provided TuyaMCU prints the current mapped values.","title":"TuyaMCU Command"},{"location":"TuyaMCU/#dpid","text":"All the device functions controlled by the MCU are identified by a dpId. Whenever a command is sent to the MCU, this dpId determines which component needs to be controlled and the applies when the status is received from MCU. There is no way to autodetect dpId's and their functions. To assist in the process of determining what dpId does what, there is a bookmarklet available that can be used on the console screen. This will send the weblog and other required commands automatically, and present the TuyaMCU information in a single table allowing for easier testing. Use this procedure to determine which dpId's are available: Go to Configure -> Console option in Tasmota web interface. Use command weblog 4 to enable verbose logging in web interface. Observe the log. After every 9-10 seconds you should see Tuya specific messages labelled as TYA: . {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010010\",\"Cmnd\":7,\"CmndData\":\"0201000100\",\"DpType1Id2\":0,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010012\",\"Cmnd\":7,\"CmndData\":\"0401000100\",\"DpType1Id4\":0,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=4 Observe all lines printed as TYA: FnId=0 is set for dpId=XXX and note all dpId values. Now that you have a list of usable dpId's you need to determine what their functions are: Consulting our list of commonly used dpId's and existing device configurations Observing Tasmota logs while activating features of the device (with a remote or on device controls) and correlating log messages and looking at the DpIdType and DpIdData values (eg: boolean vs value) Extrapolating possible function of the dpId based on Data Type and Function Command, then testing using TuyaSend<x>","title":"dpId"},{"location":"TuyaMCU/#fnid","text":"Identifier used in TuyaMCU command to map a dpId to a Tasmota component. Component FnId Note Switch1 to Switch4 1 to 4 Map only to dpId with on / off function Relay1 to Relay8 11 to 18 Map only to dpId with on / off function Lights 21 to 28 21 for Dimmer 22 for Dimmer2 23 for CCT Light 24 for RGB light 25 for white light 26 for light mode set (0 = white and 1 = color) 27 to report the state of Dimmer1 28 to report the state of Dimmer2 Power Monitoring 31 to 33 31 for Power (in deci Watt) 32 for Current (in milli Amps) 33 for Voltage (in deci Volt) Relay1i to Relay8i 41 to 48 Map only to dpId with on / off function Battery powered sensor mode 51 Battery powered devices use a slightly different protocol Enum dpId 61 to 64 Range for each enum is 0 to 31 Sensors 71 to 79 Range of sensors (temperature, humidity, co2, gas, etc) Timers 81 to 84 Manage integer based timers Extra functions 97 to 99 97 for motor direction 98 for error logging (report only) 99 as a dummy function Note This component is under active development which means the function list may expand in the future. Since the majority of devices have a power on/off functions on dpId 1 its mapped to fnId 11 (Relay1) by default. If you don't need it, map it to fnId 99 with TuyaMcu 99,1 Danger Mapping a relay or switch to a dpId that is not a simple on/off function (data Type 1) might result in unwanted power toggling (i.e. dpId sends value of 4 which toggles the relay to Power 4 aka blink mode)","title":"fnId"},{"location":"TuyaMCU/#tuyasend-command","text":"Command TuyaSend is used to send commands to dpId's. It is required for dpId's that shouldn't be mapped to a fnId. With this command it is possible to control every function of the dpId that is controllable, providing you know its data type and data length. With them provided, the rest of the protocol command is calculated. Command's value consists of two comma separated parameters: dpId and data. TuyaSend<x> dpId,data","title":"TuyaSend Command"},{"location":"TuyaMCU/#tuyareceived","text":"Every status message from the MCU gets a JSON response named TuyaReceived which contains the MCU protocol status message inside key/value pairs which are hidden from the user by default. To publish them to a MQTT Topic of tele/%topic%/RESULT you need to enable SetOption66 1 . To avoid some cyclic MCU <-> ESP messages published via MQTT to the topic tele/%topic%/RESULT you need to enable SetOption137 1 . If SetOption137 set to 1 the following cmds will not forwarded: - the heartbeat between the MCU <-> ESP (every 10 seconds, TUYA_CMD_HEARTBEAT ) - the Wifi-State between the MCU <-> ESP (during start-up and wifi events, TUYA_CMD_WIFI_STATE ) - the local time info query of the MCU (every minute, TUYA_CMD_SET_TIME ) - the received update package info from MCU (during firmware update of Tuya MCU, TUYA_CMD_UPGRADE_PACKAGE ) If SetOption137 set to 0 all received Tuya MCU messages will be published. SetOption137 is very useful to reduce the MQTT-traffic.","title":"TuyaReceived"},{"location":"TuyaMCU/#device-configurations","text":"Before proceeding identify dpId's and their function.","title":"Device Configurations"},{"location":"TuyaMCU/#dimmer","text":"We need to configure four functions of a dimmer: Dimming dpId Dimming Range Dimming less than 10%","title":"Dimmer"},{"location":"TuyaMCU/#dual-dimmer","text":"To enable a dual dimmer setup assign fnId's: 21 as Dimmer1 22 as Dimmer2 11 as Relay1 12 as Relay2 Tasmota will automatically enable SetOption68 and the dimmers will respond to Channel1 and Channel2 commands. Warning The use of SetOption68 is limited to two channels and will be automatically disabled if any other combination of lights is used.","title":"Dual Dimmer"},{"location":"TuyaMCU/#lights","text":"","title":"Lights"},{"location":"TuyaMCU/#enums","text":"Better control over Type4 or enum dpId's. Up to four can be added, with a range from 0 to 31. 61 as Enum1 62 as Enum2 63 as Enum3 64 as Enum4 After an enum is configured, use TuyaEnumList to declare the range it must respect (note 0 is always the first item in range). TuyaEnumlist <enum>,<range> where <enum> is declared using TuyaMCU and <range> is 0..31 . Example: configure Enum 1 with a range from 0 to 8. 21 : 14 : 52 CMD : tuyaenumlist 1 , 8 21 : 14 : 52 MQT : stat / TuyaMCU / RESULT = { \"TuyaEnumList\" :{ \"Enum1\" : 8 , \"Enum2\" : 9 , \"Enum4\" : 1 }} Entering a value greater than 31 will return an error TuyaEnumList without payload will return the configuration of all the enums enabled in the list. To update an enum use the command TuyaEnum : Usage TuyaEnum [1|2|3|4],[TuyaEnumList range] Example: update Enum 2 to 4. 21 : 14 : 12 CMD : tuyaenum2 4 21 : 14 : 12 MQT : stat / TuyaMCU / RESULT = { \"TuyaEnum2\" : 4 } Entering a value not in range will return an error TuyaEnum without payload will return the state of all the enums configured.","title":"Enums"},{"location":"TuyaMCU/#sensors","text":"These are the currently available sensors: 71 as Temperature Sensor 73 as Humidity Sensor 75 as Illuminance Sensor 76 as TVOC Sensor 77 as CO 2 Sensor 78 as ECO 2 Sensor 79 as %LEL gas Sensor If your device has a dpId for setting a specific Temperature and/or Humidity: 72 for Temperature Set 74 for Humidity Set Use TuyaSend2 to manage them. Temperature and Temperature Set default to \u00b0C . If you need \u00b0F change SetOption8 to 1 . The TuyaMCU driver sends the temperature as a byte integer. As of 9.3.x, the integer is converted by Tasmota to a float based on the \"TempRes\" setting which indicates the number of places after the decimal. The TempRes setting is by default \"1\" which means a device which sends 101 will be intepreted as 10.1. If your device normaly returns an integer temperature, you may need to set TempRes to \"0\". If your device requires the temperature to be divided (eg. increases in .5\u00b0 increments), you may need to use the rules functionality to convert the temperature value. Please note this will not update the value sent by the MCU but will just change the unit of measure reported on /SENSOR topic. You have to find a dpid to set the correct unit and change reported values (if it exists) or perhaps use the rules functionality to do the conversion.","title":"Sensors"},{"location":"TuyaMCU/#timers","text":"4 Type2 (integer) timers can be managed directly from Tasmota 81 as Timer1 82 as Timer2 83 as Timer3 84 as Timer4 Timers can be managed with TuyaSend2 and are visible in the WebUI.","title":"Timers"},{"location":"TuyaMCU/#covers","text":"Single shutter or double shutters devices can be managed with a dimmer setup For devices that are reporting position to a another dpId assign fnId's: 27 to report the state of Dimmer1 28 to report the state of Dimmer2 If your cover device has a motor direction change option assign fnId 97 for motor direction.","title":"Covers"},{"location":"TuyaMCU/#switches","text":"There is currenty no way to detect the number of relays present in an MCU based switch. We need to tell the number of relays to Tasmota using FunctionIDs 12 to 18 for Relay2 to Relay4. Example For a 4 gang switch set TuyaMCU 12,2 , TuyaMCU 13,3 and TuyaMCU 14,4 if the dpIds for Relays 2-4 are 2 , 3 , 4 . Tip You can configure all at once by using Backlog TuyaMCU 12,2; TuyaMCU 13,3; TuyaMCU 14,4","title":"Switches"},{"location":"TuyaMCU/#power-metering","text":"Some Tuya MCU devices support Power measurement support over serial. For this it is better to use a bulb with known wattage rating. Observe the logs in the Console TYA: Heartbeat {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010111\",\"Cmnd\":7,\"CmndData\":\"0201000101\",\"DpType1Id2\":1,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010113\",\"Cmnd\":7,\"CmndData\":\"0401000101\",\"DpType1Id4\":1,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=4 {\"TuyaReceived\":{\"Data\":\"55AA0107000807020004000000001C\",\"Cmnd\":7,\"CmndData\":\"0702000400000000\",\"DpType2Id7\":0,\"7\":{\"DpId\":7,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=7 {\"TuyaReceived\":{\"Data\":\"55AA0107000808020004000000001D\",\"Cmnd\":7,\"CmndData\":\"0802000400000000\",\"DpType2Id8\":0,\"8\":{\"DpId\":8,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=8 {\"TuyaReceived\":{\"Data\":\"55AA0107000809020004000000001E\",\"Cmnd\":7,\"CmndData\":\"0902000400000000\",\"DpType2Id9\":0,\"9\":{\"DpId\":9,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=9 {\"TuyaReceived\":{\"Data\":\"55AA010700080A020004000000001F\",\"Cmnd\":7,\"CmndData\":\"0A02000400000000\",\"DpType2Id10\":0,\"10\":{\"DpId\":10,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=10 {\"TuyaReceived\":{\"Data\":\"55AA0107000865020004000000007A\",\"Cmnd\":7,\"CmndData\":\"6502000400000000\",\"DpType2Id101\":0,\"101\":{\"DpId\":101,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=101 {\"TuyaReceived\":{\"Data\":\"55AA01070008660200040000009813\",\"Cmnd\":7,\"CmndData\":\"6602000400000098\",\"DpType2Id102\":152,\"102\":{\"DpId\":102,\"DpIdType\":2,\"DpIdData\":\"00000098\"}}} TYA: fnId=0 is set for dpId=102 {\"TuyaReceived\":{\"Data\":\"55AA01070008670200040000017EFB\",\"Cmnd\":7,\"CmndData\":\"670200040000017E\",\"DpType2Id103\":382,\"103\":{\"DpId\":103,\"DpIdType\":2,\"DpIdData\":\"0000017E\"}}} TYA: fnId=0 is set for dpId=103 {\"TuyaReceived\":{\"Data\":\"55AA0107000868020004000009951B\",\"Cmnd\":7,\"CmndData\":\"6802000400000995\",\"DpType2Id104\":2453,\"104\":{\"DpId\":104,\"DpIdType\":2,\"DpIdData\":\"00000995\"}}} TYA: fnId=0 is set for dpId=104 In the TuyaReceived we are interested in DpIdData . For example: 00000995 is the second last entry. Make sure the bulb if off. Find out the voltage standard of your country (generally 220, 240, 120v) from this table . Multiply that number by 10 (2400) and Convert that number (2400) to Hex using any hex converter (2400 = 0x960) Now look for the number nearest to 960 in the logs. In our case it is 00000995 . So we expect that's the voltage which is \"DpId\":104 in our example. Set voltage functionId 33 by entering TuyaMCU 33,104 . Now set dimmer to 100% using the dimmer 100 command, or power on using power1 on (depending on the device) and observe the logs. Now we need the power rating of your bulb, for example 40W . Multiply by 10 (400) and convert to hex which gives us 0x190. Check which unknown ID is close to 190 . I this example it is 17E for \"DpId\":103 . This is the Id of Active Power function. Set the active power functionId 31 by entering TuyaMCU 31,103 . Once Power and Voltage are set you should see something such as this in the logs: TYA: Heartbeat {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010111\",\"Cmnd\":7,\"CmndData\":\"0201000101\",\"DpType1Id2\":1,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010113\",\"Cmnd\":7,\"CmndData\":\"0401000101\",\"DpType1Id4\":1,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=4 {\"TuyaReceived\":{\"Data\":\"55AA0107000807020004000000001C\",\"Cmnd\":7,\"CmndData\":\"0702000400000000\",\"DpType2Id7\":0,\"7\":{\"DpId\":7,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=7 {\"TuyaReceived\":{\"Data\":\"55AA0107000808020004000000001D\",\"Cmnd\":7,\"CmndData\":\"0802000400000000\",\"DpType2Id8\":0,\"8\":{\"DpId\":8,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=8 {\"TuyaReceived\":{\"Data\":\"55AA0107000809020004000000001E\",\"Cmnd\":7,\"CmndData\":\"0902000400000000\",\"DpType2Id9\":0,\"9\":{\"DpId\":9,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=9 {\"TuyaReceived\":{\"Data\":\"55AA010700080A020004000000001F\",\"Cmnd\":7,\"CmndData\":\"0A02000400000000\",\"DpType2Id10\":0,\"10\":{\"DpId\":10,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=10 {\"TuyaReceived\":{\"Data\":\"55AA0107000865020004000000007A\",\"Cmnd\":7,\"CmndData\":\"6502000400000000\",\"DpType2Id101\":0,\"101\":{\"DpId\":101,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=101 {\"TuyaReceived\":{\"Data\":\"55AA01070008660200040000009712\",\"Cmnd\":7,\"CmndData\":\"6602000400000097\",\"DpType2Id102\":151,\"102\":{\"DpId\":102,\"DpIdType\":2,\"DpIdData\":\"00000097\"}}} TYA: fnId=0 is set for dpId=102 {\"TuyaReceived\":{\"Data\":\"55AA01070008670200040000017BF8\",\"Cmnd\":7,\"CmndData\":\"670200040000017B\",\"DpType2Id103\":379,\"103\":{\"DpId\":103,\"DpIdType\":2,\"DpIdData\":\"0000017B\"}}} TYA: fnId=31 is set for dpId=103 TYA: Rx ID=103 Active_Power=379 {\"TuyaReceived\":{\"Data\":\"55AA0107000868020004000009961C\",\"Cmnd\":7,\"CmndData\":\"6802000400000996\",\"DpType2Id104\":2454,\"104\":{\"DpId\":104,\"DpIdType\":2,\"DpIdData\":\"00000996\"}}} TYA: fnId=33 is set for dpId=104 TYA: Rx ID=104 Voltage=2454 To get the Id for the current, calculate Current = Power / Voltage ( 37.9 / 245.4 ) = ~0.1544 (Remember to divide each value by 10). Multiply this by 1000 = 154. Now convert 154 to hex which is 0x9A. This is closest to 97 which is Id \"DpId\":102 . Set the current FunctionId 32 using command TuyaMCU 32,102 . Observe the logs should start showing Current in addition to Active_Power and Voltage TYA: Heartbeat {\"TuyaReceived\":{\"Data\":\"55AA0107000501010001000F\",\"Cmnd\":7,\"CmndData\":\"0101000100\",\"DpType1Id1\":0,\"1\":{\"DpId\":1,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=11 is set for dpId=1 TYA: RX Relay-1 --> MCU State: Off Current State:Off {\"TuyaReceived\":{\"Data\":\"55AA01070005020100010111\",\"Cmnd\":7,\"CmndData\":\"0201000101\",\"DpType1Id2\":1,\"2\":{\"DpId\":2,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=2 {\"TuyaReceived\":{\"Data\":\"55AA01070005030100010011\",\"Cmnd\":7,\"CmndData\":\"0301000100\",\"DpType1Id3\":0,\"3\":{\"DpId\":3,\"DpIdType\":1,\"DpIdData\":\"00\"}}} TYA: fnId=0 is set for dpId=3 {\"TuyaReceived\":{\"Data\":\"55AA01070005040100010113\",\"Cmnd\":7,\"CmndData\":\"0401000101\",\"DpType1Id4\":1,\"4\":{\"DpId\":4,\"DpIdType\":1,\"DpIdData\":\"01\"}}} TYA: fnId=0 is set for dpId=4 {\"TuyaReceived\":{\"Data\":\"55AA0107000807020004000000001C\",\"Cmnd\":7,\"CmndData\":\"0702000400000000\",\"DpType2Id7\":0,\"7\":{\"DpId\":7,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=7 {\"TuyaReceived\":{\"Data\":\"55AA0107000808020004000000001D\",\"Cmnd\":7,\"CmndData\":\"0802000400000000\",\"DpType2Id8\":0,\"8\":{\"DpId\":8,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=8 {\"TuyaReceived\":{\"Data\":\"55AA0107000809020004000000001E\",\"Cmnd\":7,\"CmndData\":\"0902000400000000\",\"DpType2Id9\":0,\"9\":{\"DpId\":9,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=9 {\"TuyaReceived\":{\"Data\":\"55AA010700080A020004000000001F\",\"Cmnd\":7,\"CmndData\":\"0A02000400000000\",\"DpType2Id10\":0,\"10\":{\"DpId\":10,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=10 {\"TuyaReceived\":{\"Data\":\"55AA0107000865020004000000007A\",\"Cmnd\":7,\"CmndData\":\"6502000400000000\",\"DpType2Id101\":0,\"101\":{\"DpId\":101,\"DpIdType\":2,\"DpIdData\":\"00000000\"}}} TYA: fnId=0 is set for dpId=101 {\"TuyaReceived\":{\"Data\":\"55AA01070008660200040000009712\",\"Cmnd\":7,\"CmndData\":\"6602000400000097\",\"DpType2Id102\":151,\"102\":{\"DpId\":102,\"DpIdType\":2,\"DpIdData\":\"00000097\"}}} TYA: fnId=32 is set for dpId=102 TYA: Rx ID=102 Current=151 {\"TuyaReceived\":{\"Data\":\"55AA01070008670200040000017BF8\",\"Cmnd\":7,\"CmndData\":\"670200040000017B\",\"DpType2Id103\":379,\"103\":{\"DpId\":103,\"DpIdType\":2,\"DpIdData\":\"0000017B\"}}} TYA: fnId=31 is set for dpId=103 TYA: Rx ID=103 Active_Power=379 {\"TuyaReceived\":{\"Data\":\"55AA0107000868020004000009961C\",\"Cmnd\":7,\"CmndData\":\"6802000400000996\",\"DpType2Id104\":2454,\"104\":{\"DpId\":104,\"DpIdType\":2,\"DpIdData\":\"00000996\"}}} TYA: fnId=33 is set for dpId=104 TYA: Rx ID=104 Voltage=2454 Power and current should change on dimming high / low or turning the device on and off. The Tasmota web UI should show power values now on the home page.","title":"Power Metering"},{"location":"TuyaMCU/#battery-powered-sensors","text":"TYMC-1 Door/Window Sensor TY-01 Door/Window Sensor Gas Sensor Smoke Sensor PIR Sensor","title":"Battery Powered Sensors"},{"location":"TuyaMCU/#specific-devices","text":"Aromatherapy Diffuser Water Kettle Air Purifier Mouse Trap Humidifer","title":"Specific Devices"},{"location":"TuyaMCU/#tuya-protocols","text":"The MCU communicates with the Wi-Fi module through the serial port with a Tuya specified protocol. Those are classified into basic and functional protocols.","title":"Tuya Protocols"},{"location":"TuyaMCU/#basic-protocols","text":"They are common protocols integrated in Tasmota's TuyaMCU module. They stay the same for each product and are mandatory for Tuya module to work correctly.","title":"Basic protocols"},{"location":"TuyaMCU/#functional-protocols","text":"Functional protocols are used for delivering and reporting data of functions. These protocols differ between devices and manufacturers and might require configuration in Tasmota using TuyaMCU command or with TuyaSend<x> command.","title":"Functional protocols"},{"location":"TuyaMCU/#anatomy-of-tuya-protocol","text":"Name Description Frame Header Version Fixed value of 0x55aa Command Word 0x06 - send commands 0x07 - report status Data Length defines expected length of data dpID numbered ID of a function (DP = Data Point or Define Product) Data Type see Data Type table below Function Length length of command Function Command formatted according to Data Type Verification Method checksum = remainder of the byte sum starting from Frame Header to 256","title":"Anatomy of Tuya Protocol"},{"location":"TuyaMCU/#dpid-function-tables","text":"This information is just for orientation. Functions are assigned by the manufacturer and can be on different dpId's DP ID: dpId. Function Point\uff1aUsed to describe the product function. Identifier: Function codename. Can only be letters, numbers and underscores Data type\uff1a Issue and report: command data can be sent and status data can be reported back to the Wi-Fi module Report only: supports only status reporting, no control options Function Type (Referred as Data Type): Boolean (bool): non-true or false binary variable, such as: switch function, on / off Value (value): suitable for linear adjustment of the type of data, such as: temperature regulation, temperature range 20-40 \u2103 Enum (enum): custom finite set value, such as: working levels, low / mid / high Fault (fault): dedicated to reporting and statistical failure of the function points. Support multi-fault, the data is reported only Integer\uff08integer\uff09: transmitted as integer Transparent (raw): data in binary","title":"dpId Function Tables"},{"location":"TuyaMCU/#switches-or-plugspower-strips","text":"DP ID Identifier Data type Function type Properties 1 switch_1 Control and report Boolean 2 switch_2 Control and report Boolean 3 switch_3 Control and report Boolean 4 switch_4 Control and report Boolean 5 switch_5 Control and report Boolean 9 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 10 countdown_2 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 11 countdown_3 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 12 countdown_4 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 13 countdown_5 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s","title":"Switches or Plugs/Power Strips"},{"location":"TuyaMCU/#aromatherapy-machine-oil-diffuser","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 6 Amount of fog fog Issue and report Enum Enumerated values:small, large 11 Light Light Issue and report Boolean 12 Fault alarm fault Only report Fault Barrier values:1 13 Countdown countdown Issue and report Enum Enumerated values: 0, 1, 2, 3 14 Countdown remaining time countdown_left Only report Integer Values range: 0-360, Pitch1, Scale0, Unit:min 101 Light mode work_mode Issue and report Enum Enumerated values: white, colour, scene, scene1, scene2, scene3, scene4 102 Color value colour_data Issue and report Char type *see below 103 Light mode lightmode Issue and report Enum Enumerated values: 1, 2, 3 104 Brightness setting setlight Issue and report Integer Values range: 0-255, Pitch1, Scale0, Unit:\\% colour_data format of the lights is a string of 14 characters, for example, 00112233334455, where 00 indicates R, 11 indicates G, 22 indicates B, 3333 indicates the hue, 44 indicates the saturation, and 55 indicates the value. The initial value is saved by default. If you do not want to adjust the light, set the data to the maximum value 100% (0x64). The last four characters have fixed values.","title":"Aromatherapy Machine (Oil Diffuser)"},{"location":"TuyaMCU/#curtain-motor","text":"DP ID Function points Identifier Data type Function type Properties 1 Percentage percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 2 Motor Direction control_back Issue and report Boolean 3 Auto Power auto_power Issue and report Boolean 4 Left time countdown Issue and report Enum Enumerated values:cancel, 1, 2, 3, 4 5 Total Time time_total Only report Integer Values range:0-120000, Pitch1, Scale0, Unit:m Complete document on protocols DP ID Function points Identifier Data type Function type Properties 1 Control (required) control Issue and report Enum Enumerated values:open, stop, close, continue 2 Curtain position setting percent_control Issue and report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Current curtain position percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 4 Mode mode Issue and report Enum Enumerated values:morning, night 5 Motor Direction control_back Issue and report Enum Enumerated values:forward, back 6 Auto Power auto_power Issue and report Boolean 7 Work State (required) work_state Only report Enum Enumerated values:opening, closing 11 Situation_set situation_set Only report Enum Enumerated values:fully_open, fully_close 12 Fault (required) fault Only report Fault Barrier values:motor_fault","title":"Curtain Motor"},{"location":"TuyaMCU/#power-monitoring-plug","text":"DP ID Function points Identifier Data type Function type Properties 1 switch_1 switch_1 Control and report Boolean 9 countdown_1 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 17 statistics Function add_ele Control and report Integer undefined0-50000, undefined100, Scale3, Unit: 18 current cur_current Data report Integer undefined0-30000, undefined1, Scale0, Unit:mA 19 power cur_power Data report Integer undefined0-50000, undefined1, Scale1, Unit:W 20 voltage cur_voltage Data report Integer undefined0-5000, undefined1, Scale1, Unit:V 21 test flag test_bit Data report Integer undefined0-5, undefined1, Scale0, Unit: 22 voltage coefficient voltage_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 23 current coefficient electric_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 24 power coefficient power_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 25 statistics coefficient electricity_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 26 warning fault Data report Fault Barrier values:ov_cr","title":"Power Monitoring Plug"},{"location":"TuyaMCU/#dehumidifier","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:%","title":"Dehumidifier"},{"location":"TuyaMCU/#lighting","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch led_switch Control and report Boolean 2 Mode work_mode Control and report Enum Enumerated values:white, colour, scene, scene_1, scene_2, scene_3, scene_4 3 Bright bright_value Control and report Integer undefined25-255, undefined1, Scale0, Unit: 5 Colour mode colour_data Control and report Char type 6 Scene scene_data Control and report Char type 7 Scene1 flash_scene_1 Control and report Char type 8 Scene2 flash_scene_2 Control and report Char type 9 Scene3 flash_scene_3 Control and report Char type 10 Scene4 flash_scene_4 Control and report Char type","title":"Lighting"},{"location":"TuyaMCU/#contact-sensor","text":"DP ID Function points Identifier Data type Function type Properties 1 Door Sensor doorcontact_state Only report Boolean 2 Battery Level battery_percentage Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Battery Level battery_state Only report Enum Enumerated values:low, middle, high 4 Anti-remove Alarm temper_alarm Only report Boolean","title":"Contact Sensor"},{"location":"TuyaMCU/#air-purifier","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:%","title":"Air purifier"},{"location":"TuyaMCU/#heater","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p 5 Fault alarm Fault Only report Fault Barrier values:1, 2, 3 6 Gear position gear Issue and report Enum Enumerated values:low, mid, high, off 7 Conservation eco_mode Issue and report Boolean","title":"Heater"},{"location":"TuyaMCU/#smart-fan","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch switch Issue and report Boolean 2 Wind Speed Level fan_speed Issue and report Enum Enumerated values:1, 2, 3, 4 3 Left-and-Right Swing fan_horizontal Issue and report Enum Enumerated values:on, off 4 Up-and-Down Swing fan_vertical Issue and report Enum Enumerated values:on, off 5 Fault Alarm fault Only report Fault Barrier values:1, 2 6 Anion anion Issue and report Boolean 7 Humidify humidifier Issue and report Boolean 8 Oxygen oxygan Issue and report Boolean 9 Child Lock lock Issue and report Boolean 10 Cool fan_cool Issue and report Boolean 11 Set Temperate temp Issue and report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 12 Current Temperature temp_current Only report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103","title":"Smart fan"},{"location":"TuyaMCU/#kettle","text":"DP ID Function points Identifier Data type Function type Properties 1 Working switch start Issue and report Boolean 2 Heat to target temperature shortcut (\u00b0C) temp_setting_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 3 Heat to target temperature shortcut (\u00b0F) temp_setting_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 4 Cool to the target temperature shortcut after boiling (\u00b0C) temp_boiling_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 5 Cool to the target temperature shortcut after boiling (\u00b0F) temp_boiling_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 6 Temperature scale switching temp_unit_convert Issue and report Enum Enumerated values:c, f 7 Insulation switch switch_keep_warm Issue and report Boolean 8 Holding time setting keep_warm_setting Issue and report Integer Values range:0-360, Pitch1, Scale0, Unit:min 9 Mode work_type Issue and report Enum Enumerated values: setting_quick, boiling_quick, temp_setting, temp_","title":"Kettle"},{"location":"TuyaMCU/#becathermostat","text":"Work in progress DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p (wip) 102 Floor Temperature FloorCurrent Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103","title":"BecaThermostat"},{"location":"TuyaMCU/#inkbird-itc-308-wifi","text":"Temperature controller with individual plug in sockets for heating/cooling DP ID Function points Identifier Data type Function type Properties 101 Temperature unit Cf Issue and report Integer 0=C, 1=F 102 Calibration Ca Issue and report Integer Unit is 0.1C 104 Temperature sensor Issue and report Integer Unit is 0.1C 106 Temperature set point Ts Issue and report Integer Unit is 0.1C 108 Compressor delay time Pt Issue and report Integer Unit is minutes 109 Alarm high temperature Ah Issue and report Integer Unit is 0.1C 110 Alarm low temperature Al Issue and report Integer Unit is 0.1C, For negative values use -(0xFFFFFFFF - value) 115 Relay status Only report Integer 01=cool, 02=off, 03=heating 116 Temperature sensor Issue and report Integer Unit is 0.1F 117 Heating differential value Hd Issue and report Integer Unit is 0.1C 118 Cooling differential value Cd Issue and report Integer Unit is 0.1C The unit will constantly be sending the temperature sensor value in celcius and fahrenheit: 104 and 116. To trigger the unit to send all settings, send any value to a non-used register, e.g. TuyaSend1 2,1 Example: Tasmota command Result TuyaSend1 2,1 Trigger the unit to reveal all settings TuyaSend2 106,250 Change set-point to 25.0C TuyaSend2 101,1 Change units to Fahrenheit","title":"Inkbird ITC-308-Wifi"},{"location":"TuyaMCU/#inkbird-ihc-200-wifi","text":"Humidity controller with two relay sockets very similar to the ITC-308-WIFI This unit ships with a RTL based WR3 module which cannot be flashed with Tasmota, however the WR3 module is pin compatible with a ESP12-F module and is on a daughter board similar to the one in the ITC-308-WIFI DP ID Function points Identifier Data type Function type Properties 104 Humidity sensor Only report Integer Unit is 0.1C 106 Humidity set point HS Issue and report Integer Unit is 0.1C Dpid 102,108,109,110,106,117,118 return data and are not yet reverse engineered but are likely similar to ITC-308 but related to humidity.","title":"Inkbird IHC-200-Wifi"},{"location":"TuyaMCU/#further-reading","text":"TuyaMCU Flashing and Device Configuration","title":"Further Reading"},{"location":"UFS/","text":"This feature is included in every precompiled binary with flash size >1M For ESP8266 modules that have more than 1MB of flash memory (NodeMCU, Wemos-D1) you can build a variant with a universal file system or UFS and store your files there (data, images, commands, etc). There are some special files that you can upload and use to execute actions. Warning The file partition DOES NOT get erased by reset commands. Only a complete flash erase will remove it. UFS in the Web GUI ~ After compiling and flashing you will find a new entry in Tasmota webUI: Consoles - Manage File system The \"Manage File System\" page provides: On top, the total size of the file system and the free size A button to upload a file from the host (1st select the file with the Choose File button, then Start Upload ) A list of available files with timestamp of upload and size in bytes The 'fire' icon allows to delete the file without any confirmation The 'memo' icon allows to edit the file and the \"Create and edit new file\" button launches the editor with a new file. The file editor allows to edit the content of a text file online, save it back to the UFS. By changing the name at the top, it will be saved-as the new name (original file remains unchanged). Changes can be discarded by clicking on the button \"Manage File System\" to returns to the manager. Commands ~ Complete list of UFS commands Also look into Berry scripting language for ESP32 which works with UFS. Special files ~ autoexec.bat ~ Stores commands that will be executed at every boot, similar to the backlog commands in rules trigger at System#Boot . Almost any command can be used in the file. However, avoid commands that will make the device reboot, such as: changing Wifi setting, MQTT settings, Templates & GPIO, etc. Commands that triggers reboot will create a boot loop which will force Tasmota to automatically disable autoexec.bat and other settings. See SetOption36 for more details. Commands must be kept one command per line and they will be executed sequentially. Lines starting with semicolon are ignored as comments. display.bat ~ Stores data that will be displayed at every boot, similar to the DisplayText commands in rules trigger at System#Init (as long as you have a display driver initializated). Example ; clr screen [z] ; draw full screen picture - corona.rgb file must exist in UFS storage [x0y0P/corona.rgb] ; define index color [dc19:31000] ; draw transparent text with new index color [x60y30f2Ci19D2]Tasmota autoexec.be ~ For ESP32 with Berry scripting language , autoexec.be file will be automatically loaded and executed at boot. Compiling for Universal File System ~ Copy platformio_override_sample.ini as platformio_override.ini For ESP8266 boards, activate by removing the ; in front of one of the below lines: board = esp8266_4M2M for 2Mb universal file system board = esp8266_2M1M for 1Mb universal file system About ESP32 ESP32 boards with default 4MB flash only support a file system limited to 320KB . You need a board with more than 4MB to enable a larger file system. Extending file system size on ESP32 is performed through the board_build.partitions setting. There are preconfigured settings for 4M, 8M and 16MB ESP32 devices. The are enabled in platformio_override.ini like for the ESP8266. Comment the standard setting and uncomment the variant you want. ; Build variant ESP32 4M Flash, Tasmota 1856k Code/OTA, 320k LITTLEFS (UFS) (default) board = esp32_4M ; Build variant ESP32 8M Flash, Tasmota 2944k Code/OTA, 2112k LITTLEFS (UFS) ;board = esp32_8M ; Build variant ESP32 16M Flash, Tasmota 2944k Code/OTA, 10M LITTLEFS (UFS) ;board = esp32_16M","title":"Universal File System"},{"location":"UFS/#ufs-in-the-web-gui","text":"After compiling and flashing you will find a new entry in Tasmota webUI: Consoles - Manage File system The \"Manage File System\" page provides: On top, the total size of the file system and the free size A button to upload a file from the host (1st select the file with the Choose File button, then Start Upload ) A list of available files with timestamp of upload and size in bytes The 'fire' icon allows to delete the file without any confirmation The 'memo' icon allows to edit the file and the \"Create and edit new file\" button launches the editor with a new file. The file editor allows to edit the content of a text file online, save it back to the UFS. By changing the name at the top, it will be saved-as the new name (original file remains unchanged). Changes can be discarded by clicking on the button \"Manage File System\" to returns to the manager.","title":"UFS in the Web GUI"},{"location":"UFS/#commands","text":"Complete list of UFS commands Also look into Berry scripting language for ESP32 which works with UFS.","title":"Commands"},{"location":"UFS/#special-files","text":"","title":"Special files"},{"location":"UFS/#autoexecbat","text":"Stores commands that will be executed at every boot, similar to the backlog commands in rules trigger at System#Boot . Almost any command can be used in the file. However, avoid commands that will make the device reboot, such as: changing Wifi setting, MQTT settings, Templates & GPIO, etc. Commands that triggers reboot will create a boot loop which will force Tasmota to automatically disable autoexec.bat and other settings. See SetOption36 for more details. Commands must be kept one command per line and they will be executed sequentially. Lines starting with semicolon are ignored as comments.","title":"autoexec.bat"},{"location":"UFS/#displaybat","text":"Stores data that will be displayed at every boot, similar to the DisplayText commands in rules trigger at System#Init (as long as you have a display driver initializated). Example ; clr screen [z] ; draw full screen picture - corona.rgb file must exist in UFS storage [x0y0P/corona.rgb] ; define index color [dc19:31000] ; draw transparent text with new index color [x60y30f2Ci19D2]Tasmota","title":"display.bat"},{"location":"UFS/#autoexecbe","text":"For ESP32 with Berry scripting language , autoexec.be file will be automatically loaded and executed at boot.","title":"autoexec.be"},{"location":"UFS/#compiling-for-universal-file-system","text":"Copy platformio_override_sample.ini as platformio_override.ini For ESP8266 boards, activate by removing the ; in front of one of the below lines: board = esp8266_4M2M for 2Mb universal file system board = esp8266_2M1M for 1Mb universal file system About ESP32 ESP32 boards with default 4MB flash only support a file system limited to 320KB . You need a board with more than 4MB to enable a larger file system. Extending file system size on ESP32 is performed through the board_build.partitions setting. There are preconfigured settings for 4M, 8M and 16MB ESP32 devices. The are enabled in platformio_override.ini like for the ESP8266. Comment the standard setting and uncomment the variant you want. ; Build variant ESP32 4M Flash, Tasmota 1856k Code/OTA, 320k LITTLEFS (UFS) (default) board = esp32_4M ; Build variant ESP32 8M Flash, Tasmota 2944k Code/OTA, 2112k LITTLEFS (UFS) ;board = esp32_8M ; Build variant ESP32 16M Flash, Tasmota 2944k Code/OTA, 10M LITTLEFS (UFS) ;board = esp32_16M","title":"Compiling for Universal File System"},{"location":"ULP/","text":"ULP for ESP32 ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_BERRY_ULP // (ESP32 only) Add support for the ULP via Berry (+5k flash) or add as a build flag to any build environment, i.e. in platformio_tasmota_cenv.ini: build_flags = ${env:tasmota32_base.build_flags} -DUSE_BERRY_ULP Ultra Low Power coprocessor ~ The purpose of this document is not to repeat every information of these documents: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/ulp.html https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/ulp_instruction_set.html It will also not make it easy to write assembler code for the ULP and embed it in Berry projects. But it shall guide you through the process of adapting one of many open source examples, do some little changes and setting up a toolchain for personal use cases. Tip It can even make it easier and substantially faster to rapidly develop assembler projects, because there is no flashing involved in the code deployment, which happens in Berry at runtime. Limits of the ULP ~ To simplify some things: Everything in the ULP is limited. There are only 4 registers, very few operations and limited memory access. For some operations it is not possible to use mutable values, but the code must be fixed (for pin/register access) at compile time. That's why you will see lots of defines and constants in basically every example project. This was the reason, why for projects like Tasmota it never made sense to include ULP code. Advantages of the ULP ~ Besides the possibility to run code in deep sleep and wake up the system, it can also make sense to run the ULP in parallel to the main system. To simplify again: Everything that is critical to precise timing and is somehow portable to ULP, should run better than on the main cores! This includes the internal temperature sensor and the hall sensor. Additionally it can free the main cores of some tasks. Data exchange between main system and ULP ~ There is a memory region which is located at fixed address 0x5000000, which is called RTC_SLOW_MEM. This is the only region that is accessible from main cores and the ULP. It is the coders job to find a way to control the data flow, by reading and writing from and to certain addresses. The toolchains down below will print out data, that will show, where accessible variable can be found to access from Berry with ULP.get_mem() and ULP.set_mem() . General program flow ~ A typical ULP program is started from the main core at the position of the so called global entry point . Then it executes its chain of commands and ends with a halt command. It is technically possible to create a run loop inside the code and to not end with halt . But typically such a loop is realized with a wakeup timer, that restarts the with a certain interval, which can be set with ULP.wake_period(register,time in microseconds) . The register is numbered from 0 to 4 and can be changed in the assembly code with sleep register . Tasmota conventions ~ The assembly code can be divided in different sections of which the so called .text sections contains the program, but can hold variables or arbitrary data too. In general for the assembler it is not so important, where the functions or the global entry point is located. But for Tasmota the rule is, that the global entry point or a jump to it is located at position 0 in RTC_SLOW_MEM. That way ULP.run() can always point to this address 0. It is a design decision to keep the ULP module as small as possible and the addition of more internal functions shall be avoided, i.e. for doing setup of GPIO/RTC pins. If possible, this should be done in assembly code. Example // rtc_gpio_isolate(12) translates to: WRITE_RTC_REG ( RTC_IO_TOUCH_PAD5_REG , 27 , 1 , 0 ) //disable pullup WRITE_RTC_REG ( RTC_IO_TOUCH_PAD5_REG , 28 , 1 , 0 ) //disable pulldown WRITE_RTC_REG ( RTC_IO_TOUCH_PAD5_REG , 13 , 1 , 0 ) //disable input WRITE_RTC_REG ( RTC_GPIO_ENABLE_W1TS_REG , 29 , 1 , 0 ) //disable output WRITE_RTC_REG ( RTC_IO_TOUCH_PAD5_REG , 31 , 1 , 1 ) //hold Using external toolchains for this driver ~ There are 2 ways to assemble code for later use in Tasmota. In theory every external ULP project, which fits in the reserved memory space that is defined in the framework package used to compile the Tasmota firmware, should be convertible. This limit is subject to change. Micropython and micropython-esp32-ulp ~ A great project to run ULP code in Micropython on the ESP32 can be used to assemble and export the same projects to Tasmota. There are ports of Micropython for Linux, Windows and Mac, which must be installed to the system of your choice. Run it and in the Micropython console install like that: import upip upip . install ( 'micropython-esp32-ulp' ) After that your are ready to assemble. The ULP code is embedded as a multiline string in Micropython scripts. For use in Tasmota it makes sense to make some changes, that are described in an ulp_template.py and to use this template by replacing the source code string with the new code. Tip The Micropython module can not really include external headers, but it offers a very convenient database function as described here: link:preprocess Otherwise the missing defines must be added annually. After you created or did download your ulp_app.py you can export the data with 'micropython ulp_app.py' to the console, from where it can be copy pasted to the Berry console or to your Berry project. Tip It is recommended to embed the setup steps for GPIO pins or ADC to the bottom part of this ulp_app.py by printing Berry commands for easier testing in the Berry console. Export from ESP-IDF project ~ Many projects are using the ESP-IDF with CMAKE and will be compiled with idf.py build . We can extract the ULP code without flashing this project, with two simple methods: Python script 'binS2Berry.py' ~ Start a helper Python binS2Berry.py script in the root level of the project, which prints the same information to console as the Micropython way. Web-App: ~ Use the embedded JS application right here. ESP-IDF build folder: (You can drag and drop the folder on the button too.) # Generate ULP code in your browser !! Parsing completely in JS, no file upload to a server. Thus the ULP projects that may fail to assemble in Micropython can be used too. But usually the route via Micropython makes it easier to pack everything nicely together. Examples ~ This is all about porting and adapting existing code. Thank you to everyone who is sharing their ULP code!! Blink an LED ~ Let's take a look at https://github.com/micropython/micropython-esp32-ulp/blob/master/examples/blink.py . Use a copy of ulp_template.py and name it to your liking. Replace the source string of the template with the version of the example. The .text section starts with: .text magic: .long 0 state: .long 0 this must become: .text jump entry magic: .long 0 state: .long 0 This is already enough to assemble. For convenience it is recommended to add a line to the last section (with multiple \"prints\") with content: print(\"ULP.wake_period(0, 500000)\") . Done! Now let's modify the code slightly for different intervals for \"on\" and \"off\". Add a second wake period with print(\"ULP.wake_period(1, 200000)\") . Add sleep commands to the source code like so: on: # turn on led (set GPIO) WRITE_RTC_REG ( RTC_GPIO_ENABLE_W1TS_REG , RTC_GPIO_ENABLE_W1TS_S + gpio , 1 , 1 ) sleep 0 jump exit off: # turn off led (clear GPIO) WRITE_RTC_REG ( RTC_GPIO_ENABLE_W1TC_REG , RTC_GPIO_ENABLE_W1TC_S + gpio , 1 , 1 ) sleep 1 jump exit The console output should look something like that: #You can paste the following snippet into Tasmotas Berry console: import ULP ULP . wake_period ( 0 , 500000 ) # on time ULP . wake_period ( 1 , 200000 ) # off time var c = bytes (). fromb64 ( \"dWxwAAwAaAAAAAAADAAAgAAAAAAAAAAAEACAcgEAANDlryxyMABAgCcFzBkABWgdEACAcuGvjHIBAABoIQCAcgQAANASAIByCAAgcAQAAGgBAAWCWAAAgAQFaB0AAACSZAAAgAUFaB0BAACSZAAAgAAAALA=\" ) ULP . load ( c ) ULP . run () After executing it the built in LED should blink (if wired to the usual GPIO 2). You can change the wake intervals on-the-fly with i.e. ULP.wake_period(1, 800000) in the Berry console. Now on to something more complex with wake from deep sleep. Hall sensor ~ We have a working example here: https://github.com/duff2013/ulptool/blob/master/src/ulp_examples/ulp_hall_sensor/hall_sensor.s Converting is possible in the same manner as before. Start with ulp_template.py , replace the string with the content of the .s file and make sure you have the include database properly populated or you add the missing defines from the header files manually. Additionally we need to setup the ADC pins with the help of ULP.adc_config() . In this particular example the resulting code is (in the form of print outputs placed in the .py file): print ( \"ULP.adc_config(0,2,3)\" ) # adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_6); print ( \"ULP.adc_config(3,2,3)\" ) # adc1_config_channel_atten(ADC1_CHANNEL_3, ADC_ATTEN_DB_6); + adc1_config_width(ADC_WIDTH_BIT_12); The entry point is already at address zero, so there are no changes needed to assemble, load and start he ULP program in Tasmota. In the console output we can find the positions of the variables which hold the voltage measurements and can read out it values: 0000 entry 0051 jmp_threshold 0052 exit 0053 wake_up 0059 Sens_Vp0 0060 Sens_Vn0 0061 Sens_Vp1 0062 Sens_Vn1 0063 Sens_Diff_p1 0064 Sens_Diff_n1 In order to use this whole construction to wake the ESP32 with the help of a magnet, we now have to do some measurements to find feasible threshold values. This can be done by calculating the difference between Sens_Vpx and Sens_Vnx in Berry. Then place the magnet of your choice near the ESP32 and note how these values change. If the magnet is strong enough, chances are great, that you find a stable threshold. Now let's add some assembly code! We can add some constants in the header part of the code (that worked with a tested weak magnet): .set threshold_pos , 7 .set threshold_neg , 2 Now append some variables to the end of the .bss section: .global Sens_Diff_p1 Sens_Diff_p1: .long 0 .global Sens_Diff_n1 Sens_Diff_n1: .long 0 The we need some code, which replaces line 135 and 136 of the original example: /* calculate differences */ move r3 , Sens_Vn1 ld r3 , r3 , 0 move r2 , Sens_Vn0 ld r2 , r2 , 0 sub r3 , r2 , r3 # eventually change to sub r3, r3, r2 for your setup move r2 , Sens_Diff_n1 st r3 , r2 , 0 move r3 , Sens_Vp1 ld r3 , r3 , 0 move r2 , Sens_Vp0 ld r2 , r2 , 0 sub r3 , r3 , r2 # eventually change to sub r3, r2, r3 for your setup move r2 , Sens_Diff_p1 st r3 , r2 , 0 /* wake up */ ld r0 , r2 , 0 # Sens_Diff_p1 JUMPR wake_up , threshold_pos , GE After loading and starting you can send the ESP to deep sleep. For testing it is recommended to add the optional wake timer as a fallback: ULP.sleep(30) Try to wake up the system with the magnet. But is there a way to circumvent the limitation of this example, that forces us to set the threshold value as a constant? Well ... yes, we can do some hacky stuff. We must dig a little deeper, to understand how the 32-bit instructions are constructed. Let's look at the jumpr command, which is defined in ulp.h like that: struct { uint32_t imm : 16 ; /*!< Immediate value to compare against */ uint32_t cmp : 1 ; /*!< Comparison to perform: B_CMP_L or B_CMP_GE */ uint32_t offset : 7 ; /*!< Absolute value of target PC offset w.r.t. current PC, expressed in words */ uint32_t sign : 1 ; /*!< Sign of target PC offset: 0: positive, 1: negative */ uint32_t sub_opcode : 3 ; /*!< Sub opcode (SUB_OPCODE_B) */ uint32_t opcode : 4 ; /*!< Opcode (OPCODE_BRANCH) */ } b ; /*!< Format of BRANCH instruction (relative address, conditional on R0) */ The constant (= immediate) value is stored in the upper 16 bits and we can access in the byte buffer. To find the address of the command we can simply add a label in the code: .global jmp_threshold jmp_threshold: JUMPR wake_up , threshold_pos , GE This will get printed to the console while assembling. Then in Berry we can do a: var c = bytes ( \"...\" ) # jmp_threshold is the 32-bit-address in RTC_SLOW_MEM var jmp_threshold = 51 var pos = ( 3 + jmp_threshold ) * 4 var cmd = c [ pos .. pos + 4 ] # we do not have uint32 in Berry cmd . set ( 0 , threshold , 2 ) # upper 16 bit ULP . set_mem ( 51 , cmd . get ( 0 , 4 )) # modify running ULP program Now we can change these constant values on the fly. Example driver in Berry allowing deep sleep with wake up via magnet: ~ Add commands: hall_thres x - shows current threshold for the p difference value or sets it to x. usleep x - start deep sleep for x seconds or infinitely ulp_hall.be I2C access ~ Although there are special assembler commands to access I2C devices the most common method in the examples on GitHub is bit banging. This is reported to be more reliable and circumvents some limitations (only 2 pin combinations and bytewise access with special I2C commands). Nearly every example is based on some very clever macros and control flow tricks, that replicate a simple stack and subroutines (similar to a library), which is a good example for the \"Art of coding\". To make it assemble in Micropython we need some functions in the Micropython-script, that can expand the macros. These functions are in a very early stage of development and might eventually later find their way into the micropython-esp32-ulp project after more refinement. Tip If your examples do not assemble in Micropython, please try out the ESP-IDF variant. An example for the BH-1750 light sensor can be found here: https://github.com/duff2013/ulptool/tree/master/src/ulp_examples/ulp_i2c_bitbang With our techniques from above the concatenation of the .s files results in: BH-1750 Example Berry driver: ~ ulp_bh1750.be","title":"ULP for ESP32 :material-cpu-32-bit:"},{"location":"ULP/#ulp-for-esp32","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #define USE_BERRY_ULP // (ESP32 only) Add support for the ULP via Berry (+5k flash) or add as a build flag to any build environment, i.e. in platformio_tasmota_cenv.ini: build_flags = ${env:tasmota32_base.build_flags} -DUSE_BERRY_ULP","title":"ULP for ESP32 "},{"location":"ULP/#ultra-low-power-coprocessor","text":"The purpose of this document is not to repeat every information of these documents: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/ulp.html https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/ulp_instruction_set.html It will also not make it easy to write assembler code for the ULP and embed it in Berry projects. But it shall guide you through the process of adapting one of many open source examples, do some little changes and setting up a toolchain for personal use cases. Tip It can even make it easier and substantially faster to rapidly develop assembler projects, because there is no flashing involved in the code deployment, which happens in Berry at runtime.","title":"Ultra Low Power coprocessor"},{"location":"ULP/#limits-of-the-ulp","text":"To simplify some things: Everything in the ULP is limited. There are only 4 registers, very few operations and limited memory access. For some operations it is not possible to use mutable values, but the code must be fixed (for pin/register access) at compile time. That's why you will see lots of defines and constants in basically every example project. This was the reason, why for projects like Tasmota it never made sense to include ULP code.","title":"Limits of the ULP"},{"location":"ULP/#advantages-of-the-ulp","text":"Besides the possibility to run code in deep sleep and wake up the system, it can also make sense to run the ULP in parallel to the main system. To simplify again: Everything that is critical to precise timing and is somehow portable to ULP, should run better than on the main cores! This includes the internal temperature sensor and the hall sensor. Additionally it can free the main cores of some tasks.","title":"Advantages of the ULP"},{"location":"ULP/#data-exchange-between-main-system-and-ulp","text":"There is a memory region which is located at fixed address 0x5000000, which is called RTC_SLOW_MEM. This is the only region that is accessible from main cores and the ULP. It is the coders job to find a way to control the data flow, by reading and writing from and to certain addresses. The toolchains down below will print out data, that will show, where accessible variable can be found to access from Berry with ULP.get_mem() and ULP.set_mem() .","title":"Data exchange between main system and ULP"},{"location":"ULP/#general-program-flow","text":"A typical ULP program is started from the main core at the position of the so called global entry point . Then it executes its chain of commands and ends with a halt command. It is technically possible to create a run loop inside the code and to not end with halt . But typically such a loop is realized with a wakeup timer, that restarts the with a certain interval, which can be set with ULP.wake_period(register,time in microseconds) . The register is numbered from 0 to 4 and can be changed in the assembly code with sleep register .","title":"General program flow"},{"location":"ULP/#tasmota-conventions","text":"The assembly code can be divided in different sections of which the so called .text sections contains the program, but can hold variables or arbitrary data too. In general for the assembler it is not so important, where the functions or the global entry point is located. But for Tasmota the rule is, that the global entry point or a jump to it is located at position 0 in RTC_SLOW_MEM. That way ULP.run() can always point to this address 0. It is a design decision to keep the ULP module as small as possible and the addition of more internal functions shall be avoided, i.e. for doing setup of GPIO/RTC pins. If possible, this should be done in assembly code. Example // rtc_gpio_isolate(12) translates to: WRITE_RTC_REG ( RTC_IO_TOUCH_PAD5_REG , 27 , 1 , 0 ) //disable pullup WRITE_RTC_REG ( RTC_IO_TOUCH_PAD5_REG , 28 , 1 , 0 ) //disable pulldown WRITE_RTC_REG ( RTC_IO_TOUCH_PAD5_REG , 13 , 1 , 0 ) //disable input WRITE_RTC_REG ( RTC_GPIO_ENABLE_W1TS_REG , 29 , 1 , 0 ) //disable output WRITE_RTC_REG ( RTC_IO_TOUCH_PAD5_REG , 31 , 1 , 1 ) //hold","title":"Tasmota conventions"},{"location":"ULP/#using-external-toolchains-for-this-driver","text":"There are 2 ways to assemble code for later use in Tasmota. In theory every external ULP project, which fits in the reserved memory space that is defined in the framework package used to compile the Tasmota firmware, should be convertible. This limit is subject to change.","title":"Using external toolchains for this driver"},{"location":"ULP/#micropython-and-micropython-esp32-ulp","text":"A great project to run ULP code in Micropython on the ESP32 can be used to assemble and export the same projects to Tasmota. There are ports of Micropython for Linux, Windows and Mac, which must be installed to the system of your choice. Run it and in the Micropython console install like that: import upip upip . install ( 'micropython-esp32-ulp' ) After that your are ready to assemble. The ULP code is embedded as a multiline string in Micropython scripts. For use in Tasmota it makes sense to make some changes, that are described in an ulp_template.py and to use this template by replacing the source code string with the new code. Tip The Micropython module can not really include external headers, but it offers a very convenient database function as described here: link:preprocess Otherwise the missing defines must be added annually. After you created or did download your ulp_app.py you can export the data with 'micropython ulp_app.py' to the console, from where it can be copy pasted to the Berry console or to your Berry project. Tip It is recommended to embed the setup steps for GPIO pins or ADC to the bottom part of this ulp_app.py by printing Berry commands for easier testing in the Berry console.","title":"Micropython and micropython-esp32-ulp"},{"location":"ULP/#export-from-esp-idf-project","text":"Many projects are using the ESP-IDF with CMAKE and will be compiled with idf.py build . We can extract the ULP code without flashing this project, with two simple methods:","title":"Export from ESP-IDF project"},{"location":"ULP/#examples","text":"This is all about porting and adapting existing code. Thank you to everyone who is sharing their ULP code!!","title":"Examples"},{"location":"ULP/#blink-an-led","text":"Let's take a look at https://github.com/micropython/micropython-esp32-ulp/blob/master/examples/blink.py . Use a copy of ulp_template.py and name it to your liking. Replace the source string of the template with the version of the example. The .text section starts with: .text magic: .long 0 state: .long 0 this must become: .text jump entry magic: .long 0 state: .long 0 This is already enough to assemble. For convenience it is recommended to add a line to the last section (with multiple \"prints\") with content: print(\"ULP.wake_period(0, 500000)\") . Done! Now let's modify the code slightly for different intervals for \"on\" and \"off\". Add a second wake period with print(\"ULP.wake_period(1, 200000)\") . Add sleep commands to the source code like so: on: # turn on led (set GPIO) WRITE_RTC_REG ( RTC_GPIO_ENABLE_W1TS_REG , RTC_GPIO_ENABLE_W1TS_S + gpio , 1 , 1 ) sleep 0 jump exit off: # turn off led (clear GPIO) WRITE_RTC_REG ( RTC_GPIO_ENABLE_W1TC_REG , RTC_GPIO_ENABLE_W1TC_S + gpio , 1 , 1 ) sleep 1 jump exit The console output should look something like that: #You can paste the following snippet into Tasmotas Berry console: import ULP ULP . wake_period ( 0 , 500000 ) # on time ULP . wake_period ( 1 , 200000 ) # off time var c = bytes (). fromb64 ( \"dWxwAAwAaAAAAAAADAAAgAAAAAAAAAAAEACAcgEAANDlryxyMABAgCcFzBkABWgdEACAcuGvjHIBAABoIQCAcgQAANASAIByCAAgcAQAAGgBAAWCWAAAgAQFaB0AAACSZAAAgAUFaB0BAACSZAAAgAAAALA=\" ) ULP . load ( c ) ULP . run () After executing it the built in LED should blink (if wired to the usual GPIO 2). You can change the wake intervals on-the-fly with i.e. ULP.wake_period(1, 800000) in the Berry console. Now on to something more complex with wake from deep sleep.","title":"Blink an LED"},{"location":"ULP/#hall-sensor","text":"We have a working example here: https://github.com/duff2013/ulptool/blob/master/src/ulp_examples/ulp_hall_sensor/hall_sensor.s Converting is possible in the same manner as before. Start with ulp_template.py , replace the string with the content of the .s file and make sure you have the include database properly populated or you add the missing defines from the header files manually. Additionally we need to setup the ADC pins with the help of ULP.adc_config() . In this particular example the resulting code is (in the form of print outputs placed in the .py file): print ( \"ULP.adc_config(0,2,3)\" ) # adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_6); print ( \"ULP.adc_config(3,2,3)\" ) # adc1_config_channel_atten(ADC1_CHANNEL_3, ADC_ATTEN_DB_6); + adc1_config_width(ADC_WIDTH_BIT_12); The entry point is already at address zero, so there are no changes needed to assemble, load and start he ULP program in Tasmota. In the console output we can find the positions of the variables which hold the voltage measurements and can read out it values: 0000 entry 0051 jmp_threshold 0052 exit 0053 wake_up 0059 Sens_Vp0 0060 Sens_Vn0 0061 Sens_Vp1 0062 Sens_Vn1 0063 Sens_Diff_p1 0064 Sens_Diff_n1 In order to use this whole construction to wake the ESP32 with the help of a magnet, we now have to do some measurements to find feasible threshold values. This can be done by calculating the difference between Sens_Vpx and Sens_Vnx in Berry. Then place the magnet of your choice near the ESP32 and note how these values change. If the magnet is strong enough, chances are great, that you find a stable threshold. Now let's add some assembly code! We can add some constants in the header part of the code (that worked with a tested weak magnet): .set threshold_pos , 7 .set threshold_neg , 2 Now append some variables to the end of the .bss section: .global Sens_Diff_p1 Sens_Diff_p1: .long 0 .global Sens_Diff_n1 Sens_Diff_n1: .long 0 The we need some code, which replaces line 135 and 136 of the original example: /* calculate differences */ move r3 , Sens_Vn1 ld r3 , r3 , 0 move r2 , Sens_Vn0 ld r2 , r2 , 0 sub r3 , r2 , r3 # eventually change to sub r3, r3, r2 for your setup move r2 , Sens_Diff_n1 st r3 , r2 , 0 move r3 , Sens_Vp1 ld r3 , r3 , 0 move r2 , Sens_Vp0 ld r2 , r2 , 0 sub r3 , r3 , r2 # eventually change to sub r3, r2, r3 for your setup move r2 , Sens_Diff_p1 st r3 , r2 , 0 /* wake up */ ld r0 , r2 , 0 # Sens_Diff_p1 JUMPR wake_up , threshold_pos , GE After loading and starting you can send the ESP to deep sleep. For testing it is recommended to add the optional wake timer as a fallback: ULP.sleep(30) Try to wake up the system with the magnet. But is there a way to circumvent the limitation of this example, that forces us to set the threshold value as a constant? Well ... yes, we can do some hacky stuff. We must dig a little deeper, to understand how the 32-bit instructions are constructed. Let's look at the jumpr command, which is defined in ulp.h like that: struct { uint32_t imm : 16 ; /*!< Immediate value to compare against */ uint32_t cmp : 1 ; /*!< Comparison to perform: B_CMP_L or B_CMP_GE */ uint32_t offset : 7 ; /*!< Absolute value of target PC offset w.r.t. current PC, expressed in words */ uint32_t sign : 1 ; /*!< Sign of target PC offset: 0: positive, 1: negative */ uint32_t sub_opcode : 3 ; /*!< Sub opcode (SUB_OPCODE_B) */ uint32_t opcode : 4 ; /*!< Opcode (OPCODE_BRANCH) */ } b ; /*!< Format of BRANCH instruction (relative address, conditional on R0) */ The constant (= immediate) value is stored in the upper 16 bits and we can access in the byte buffer. To find the address of the command we can simply add a label in the code: .global jmp_threshold jmp_threshold: JUMPR wake_up , threshold_pos , GE This will get printed to the console while assembling. Then in Berry we can do a: var c = bytes ( \"...\" ) # jmp_threshold is the 32-bit-address in RTC_SLOW_MEM var jmp_threshold = 51 var pos = ( 3 + jmp_threshold ) * 4 var cmd = c [ pos .. pos + 4 ] # we do not have uint32 in Berry cmd . set ( 0 , threshold , 2 ) # upper 16 bit ULP . set_mem ( 51 , cmd . get ( 0 , 4 )) # modify running ULP program Now we can change these constant values on the fly.","title":"Hall sensor"},{"location":"ULP/#i2c-access","text":"Although there are special assembler commands to access I2C devices the most common method in the examples on GitHub is bit banging. This is reported to be more reliable and circumvents some limitations (only 2 pin combinations and bytewise access with special I2C commands). Nearly every example is based on some very clever macros and control flow tricks, that replicate a simple stack and subroutines (similar to a library), which is a good example for the \"Art of coding\". To make it assemble in Micropython we need some functions in the Micropython-script, that can expand the macros. These functions are in a very early stage of development and might eventually later find their way into the micropython-esp32-ulp project after more refinement. Tip If your examples do not assemble in Micropython, please try out the ESP-IDF variant. An example for the BH-1750 light sensor can be found here: https://github.com/duff2013/ulptool/tree/master/src/ulp_examples/ulp_i2c_bitbang With our techniques from above the concatenation of the .s files results in: BH-1750","title":"I2C access"},{"location":"Upgrade/","text":"","title":"Upgrade"},{"location":"Upgrading/","text":"Easily upgrade Tasmota to a newer version or different build while keeping all your settings The first rule of upgrading: If it ain't broke, don't fix it! In other words, ensure that there is a good reason to mess with a working installation (e.g., a need to use a new feature or address a found problem fixed in the current version). Backup before upgrading Any time you upgrade it is highly recommended to back up your device settings . That is easily done from the webUI using Configuration - Backup Config . If you wish to switch to a different build or use development branch you need to download a binary file (gzipped or regular) or change the OTA Url link. Download binaries from: Official firmware server: Current release Development branch Older release binaries: 9.1.0 , 8.5.1 , 7.2.0 , 6.7.1 . You can build a similar URL for another release. Your personal OTA server .gz binaries ~ Gzipped binaries can be used only once you've upgraded to atleast Tasmota 8.2 Trying to upgrade with a gzipped binary using versions older than 8.2 will fail. Tasmota 8.2 introduced upgrading using gzipped binaries which are smaller in size and will likely skip the intermediary minimal build installation. This makes the upgrade process faster and straightforward. To use simply add .gz to the existing OTA Url or download the .bin.gz binary from the official OTA Server and the next upgrade will use the compressed file. Upgrade Flow ~ v1.0.11 v3.9.22 v4.2.0 v5.14.0 v6.7.1 v7.2.0 v8.5.1 v9.1 Current release Follow the path strictly to ensure success. Do not install only tasmota-minimal.bin but upgrade to full, working firmware. Linked -lite.bin binaries will do the job. If you want to download binaries from the upgrade flow links, you may need to do a right-click and save the file, depending on your browser security rules. Tasmota v9.1 introduced a major change in GPIO mapping Downgrading is not recommended and will probably not work correctly. Tasmota v8.1 introduced a major change in parameter storage. Downgrading is not recommended and upgrading to 8.1 has to follow the recommended path and can still fail in some cases. Don't forget to backup! Upgrade using webUI ~ Upgrading the device firmware over-the-air , aka OTA, is the most convenient way to upgrade. To start the upgrade, open a web browser to your device's web UI and select Firmware Upgrade . You are presented with two choices: Upgrade by webserver - use an OTA server Ugprade by file upload - uploading a downloaded or self-compiled binary file from your computer Upgrade by web server ~ If you want to upgrade to the latest release version click the first Start Upgrade button. This screen should appear During this process Tasmota will download the new firmware from the url and install it. If you're not using a gzipped binary it might need to download tasmota-minimal.bin first, but all that happens automatically. All you have to do is wait 2 to 5 minutes . After the upgrade is completed you can reconnect back to the web UI and check the firmware version on the bottom of the page or in the Information tab of the webUI. Upgrade by file upload ~ Go to Firmware Upgrade . This time browse to the binary you want to upgrade to with Choose File and click Start upgrade . In our example its tasmota-sensors.bin . You will see an Upload starting... and then Upload successful message. Wait until the device restarts, reconnect back to the web UI and check the firmware version on the bottom of the page or in the Information tab of the webUI. Minimal build upgrade step If the binary you're upgrading with is larger than 500kb you also need to download the minimal build ( tasmota-minimal.bin(.gz) ) since the upload process needs the space in flash memory to upload the new binary. When you try to immediately upgrade with the new binary without using smaller minimal firmware you will be greeted with this error. Upload Buffer Miscompare Error ~ This step is necessary only if you get the \"Upload buffer miscompare\" error This means your flash doesn't have enough free space to install the binary you're trying to upload. Use a .gz binary instead of the .bin one. If you still receive the same error download tasmota-minimal.bin(.gz) and follow instructions: Browse to the minimal binary with Choose File . The chosen filename should be visible. In our example its tasmota-minimal.bin . Wait until the device restarts. In the Main Menu web UI will display this warning message on top. Proceed to upgrade Using Commands ~ Your device can be upgraded using commands via MQTT, web requests or Console in the web UI. OtaUrl is used to set your OTA address. OtaUrl http :// ota . tasmota . com / tasmota / tasmota - sensors . bin In this example we chose a development branch version with additional sensors support Initiate upgrade from OTA server Upgrade 1 Wait for the upgrade process to complete and check the Tasmota version. In console you can use Status 2 . Serial Upgrade ~ Upgrade over the serial connection using serial-to-USB adapter. Upload the new version over serial using the same process as in Flashing but DO NOT erase flash. The new binary will overwrite the old one and keep your settings. External Programs ~ Tasmota Device Manager or TDM is a multiplatform GUI application written in Python for discovery and management of Tasmota devices. You can set up OTA url and initiate OTA upgrade from TDM using GUI. openHAB - implement an automation rule to upgrade devices from openHAB Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO Private OTA Server ~ It is possible to create your own simple http OTA server (https is not supported) using Python and perform upgrades from there. Install Python3 and from the folder where the binary resides (make sure tasmota-minimal.bin is located there too) run: python -m http.server 8000 (If the response is \"No module named http\" then try again with python3 instead of python .) Change your OtaUrl to http://ipoftheserver:8000/yourbinary.bin(.gz) and start the upgrade process. Note: do not use / , - , or . characters in the name of yourbinary . If your binary build (yourbinary.bin) is larger than the available free flash program space, Tasmota will need to first install the minimal version of Tasmota to make more space. To have this work via the web server OTA process, you have to copy the file tasmota-minimal.bin in the same folder where OTAURL for yourbinary.bin is placed, and rename tasmota-minimal.bin to yourbinary-minimal.bin . Migration Path ~ Until now several versions of Tasmota have been released starting with the C version Sonoff-MQTT-OTA followed by Sonoff-MQTT-OTA-Arduino, Sonoff-Tasmota and ultimately Tasmota. Intermediate upgrade steps are needed to migrate from older firmware to the current version. No migration is possible from original Sonoff-MQTT-OTA to Sonoff-MQTT-OTA-Arduino v1.0.11. DO NOT ATTEMPT TO UPGRADE VERSIONS PRIOR TO v7.x STRAIGHT TO THE CURRENT VERSION Remember that you must take each individual step between the device firmware version and the latest available.You can find all the required binaries in Tasmota Releases listed by version number. Tip As a safeguard perform \"Backup Configuration\" before upgrading. If settings are lost \"Restore Configuration\" should bring them back. Upgrading from one minor version to the next is mostly painless as the settings are saved in the same location in flash and newer settings are appended. As said, mostly painless! There are some deviations to this rule as the flash settings changed. Notice for versions between 6.6.0.7 and 6.6.0.11 If you've used development versions between 6.6.0.7 and 6.6.0.11 back up your device settings . Convert the backup to human readable form as you MUST restore these settings manually. Perform a Reset 6 before upgrading the firmware and, for safe measure, after the upgrade completes. Downgrading ~ While fallback or downgrading is common practice it was never supported due to Settings additions or changes in newer releases. Starting with release v8.1.0 Doris settings in flash are re-allocated in such a way that fallback is only allowed and possible to v7.2.0. Once at v7.2.0 you're on your own when downgrading even further. Backing Up Settings ~ Tasmota uses flash memory to store options and settings. New versions add (or remove) features that use various regions of that memory. If you did not erase flash when you flashed your device, an updated version of Tasmota may be accessing areas with values left over from the old Tasmota or even the original factory firmware. This might cause unexpected and unwanted behavior or even major problems (constant reboots or reconnects). To avoid this use our decode-config tool to easily create and restore backups in Tasmota: decode-config tool ~ decode-config - OS independent Python program to backup and restore Tasmota configuration data, also available as precompiled executables for Windows, MacOS and Linux. See Using instructions for details. If using one of the precompiled binary for your OS replace decode-config.py with decode-config_win32.exe , decode-config_win64.exe , decode-config_mac or decode-config_linux from the instruction examples. 1. make a configuration backup: ~ Create a new backup straight from your device decode-config.py --source <deviceIP> --backup-file Config-@f @f will be replaced by decode-config to device's FriendlyName or Create a backup from previously made .dmp file decode-config.py --source <dmp_filename> --backup-file Config-@f 2. perform a device reset ~ Erase flash settings area but keep Wi-Fi and MQTT settings Reset 6 3. upgrade the firmware via OTA or file upload ~ 4. restore configuration ~ decode-config.py --source <deviceIP> --restore-file <backupfile> ...and you're done! If you can't restore configuration directly you can configure the device manually referring to the Commands article and the settings (e.g., SetOptions, Rules, etc.) in the JSON file you created in step #1. You can paste the JSON into a JSON parser to make it easily readable. Tip If Backup Configuration -> Restore Configuration fails, reset to firmware defaults and use decode-config tool to restore your backed up configuration.","title":"Upgrading"},{"location":"Upgrading/#gz-binaries","text":"Gzipped binaries can be used only once you've upgraded to atleast Tasmota 8.2 Trying to upgrade with a gzipped binary using versions older than 8.2 will fail. Tasmota 8.2 introduced upgrading using gzipped binaries which are smaller in size and will likely skip the intermediary minimal build installation. This makes the upgrade process faster and straightforward. To use simply add .gz to the existing OTA Url or download the .bin.gz binary from the official OTA Server and the next upgrade will use the compressed file.","title":".gz binaries"},{"location":"Upgrading/#upgrade-flow","text":"v1.0.11 v3.9.22 v4.2.0 v5.14.0 v6.7.1 v7.2.0 v8.5.1 v9.1 Current release Follow the path strictly to ensure success. Do not install only tasmota-minimal.bin but upgrade to full, working firmware. Linked -lite.bin binaries will do the job. If you want to download binaries from the upgrade flow links, you may need to do a right-click and save the file, depending on your browser security rules. Tasmota v9.1 introduced a major change in GPIO mapping Downgrading is not recommended and will probably not work correctly. Tasmota v8.1 introduced a major change in parameter storage. Downgrading is not recommended and upgrading to 8.1 has to follow the recommended path and can still fail in some cases. Don't forget to backup!","title":"Upgrade Flow"},{"location":"Upgrading/#upgrade-using-webui","text":"Upgrading the device firmware over-the-air , aka OTA, is the most convenient way to upgrade. To start the upgrade, open a web browser to your device's web UI and select Firmware Upgrade . You are presented with two choices: Upgrade by webserver - use an OTA server Ugprade by file upload - uploading a downloaded or self-compiled binary file from your computer","title":"Upgrade using webUI"},{"location":"Upgrading/#upgrade-by-web-server","text":"If you want to upgrade to the latest release version click the first Start Upgrade button. This screen should appear During this process Tasmota will download the new firmware from the url and install it. If you're not using a gzipped binary it might need to download tasmota-minimal.bin first, but all that happens automatically. All you have to do is wait 2 to 5 minutes . After the upgrade is completed you can reconnect back to the web UI and check the firmware version on the bottom of the page or in the Information tab of the webUI.","title":"Upgrade by web server"},{"location":"Upgrading/#upgrade-by-file-upload","text":"Go to Firmware Upgrade . This time browse to the binary you want to upgrade to with Choose File and click Start upgrade . In our example its tasmota-sensors.bin . You will see an Upload starting... and then Upload successful message. Wait until the device restarts, reconnect back to the web UI and check the firmware version on the bottom of the page or in the Information tab of the webUI. Minimal build upgrade step If the binary you're upgrading with is larger than 500kb you also need to download the minimal build ( tasmota-minimal.bin(.gz) ) since the upload process needs the space in flash memory to upload the new binary. When you try to immediately upgrade with the new binary without using smaller minimal firmware you will be greeted with this error.","title":"Upgrade by file upload"},{"location":"Upgrading/#upload-buffer-miscompare-error","text":"This step is necessary only if you get the \"Upload buffer miscompare\" error This means your flash doesn't have enough free space to install the binary you're trying to upload. Use a .gz binary instead of the .bin one. If you still receive the same error download tasmota-minimal.bin(.gz) and follow instructions: Browse to the minimal binary with Choose File . The chosen filename should be visible. In our example its tasmota-minimal.bin . Wait until the device restarts. In the Main Menu web UI will display this warning message on top. Proceed to upgrade","title":"Upload Buffer Miscompare Error"},{"location":"Upgrading/#using-commands","text":"Your device can be upgraded using commands via MQTT, web requests or Console in the web UI. OtaUrl is used to set your OTA address. OtaUrl http :// ota . tasmota . com / tasmota / tasmota - sensors . bin In this example we chose a development branch version with additional sensors support Initiate upgrade from OTA server Upgrade 1 Wait for the upgrade process to complete and check the Tasmota version. In console you can use Status 2 .","title":"Using Commands"},{"location":"Upgrading/#serial-upgrade","text":"Upgrade over the serial connection using serial-to-USB adapter. Upload the new version over serial using the same process as in Flashing but DO NOT erase flash. The new binary will overwrite the old one and keep your settings.","title":"Serial Upgrade"},{"location":"Upgrading/#external-programs","text":"Tasmota Device Manager or TDM is a multiplatform GUI application written in Python for discovery and management of Tasmota devices. You can set up OTA url and initiate OTA upgrade from TDM using GUI. openHAB - implement an automation rule to upgrade devices from openHAB Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO","title":"External Programs"},{"location":"Upgrading/#private-ota-server","text":"It is possible to create your own simple http OTA server (https is not supported) using Python and perform upgrades from there. Install Python3 and from the folder where the binary resides (make sure tasmota-minimal.bin is located there too) run: python -m http.server 8000 (If the response is \"No module named http\" then try again with python3 instead of python .) Change your OtaUrl to http://ipoftheserver:8000/yourbinary.bin(.gz) and start the upgrade process. Note: do not use / , - , or . characters in the name of yourbinary . If your binary build (yourbinary.bin) is larger than the available free flash program space, Tasmota will need to first install the minimal version of Tasmota to make more space. To have this work via the web server OTA process, you have to copy the file tasmota-minimal.bin in the same folder where OTAURL for yourbinary.bin is placed, and rename tasmota-minimal.bin to yourbinary-minimal.bin .","title":"Private OTA Server"},{"location":"Upgrading/#migration-path","text":"Until now several versions of Tasmota have been released starting with the C version Sonoff-MQTT-OTA followed by Sonoff-MQTT-OTA-Arduino, Sonoff-Tasmota and ultimately Tasmota. Intermediate upgrade steps are needed to migrate from older firmware to the current version. No migration is possible from original Sonoff-MQTT-OTA to Sonoff-MQTT-OTA-Arduino v1.0.11. DO NOT ATTEMPT TO UPGRADE VERSIONS PRIOR TO v7.x STRAIGHT TO THE CURRENT VERSION Remember that you must take each individual step between the device firmware version and the latest available.You can find all the required binaries in Tasmota Releases listed by version number. Tip As a safeguard perform \"Backup Configuration\" before upgrading. If settings are lost \"Restore Configuration\" should bring them back. Upgrading from one minor version to the next is mostly painless as the settings are saved in the same location in flash and newer settings are appended. As said, mostly painless! There are some deviations to this rule as the flash settings changed. Notice for versions between 6.6.0.7 and 6.6.0.11 If you've used development versions between 6.6.0.7 and 6.6.0.11 back up your device settings . Convert the backup to human readable form as you MUST restore these settings manually. Perform a Reset 6 before upgrading the firmware and, for safe measure, after the upgrade completes.","title":"Migration Path"},{"location":"Upgrading/#downgrading","text":"While fallback or downgrading is common practice it was never supported due to Settings additions or changes in newer releases. Starting with release v8.1.0 Doris settings in flash are re-allocated in such a way that fallback is only allowed and possible to v7.2.0. Once at v7.2.0 you're on your own when downgrading even further.","title":"Downgrading"},{"location":"Upgrading/#backing-up-settings","text":"Tasmota uses flash memory to store options and settings. New versions add (or remove) features that use various regions of that memory. If you did not erase flash when you flashed your device, an updated version of Tasmota may be accessing areas with values left over from the old Tasmota or even the original factory firmware. This might cause unexpected and unwanted behavior or even major problems (constant reboots or reconnects). To avoid this use our decode-config tool to easily create and restore backups in Tasmota:","title":"Backing Up Settings"},{"location":"Upgrading/#decode-config-tool","text":"decode-config - OS independent Python program to backup and restore Tasmota configuration data, also available as precompiled executables for Windows, MacOS and Linux. See Using instructions for details. If using one of the precompiled binary for your OS replace decode-config.py with decode-config_win32.exe , decode-config_win64.exe , decode-config_mac or decode-config_linux from the instruction examples.","title":"decode-config tool"},{"location":"User-created-templates/","text":"Follow this link to new templates repository .","title":"User created templates"},{"location":"VEML6070/","text":"VEML6070 UV light sensor ~ This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VEML6070 #define USE_VEML6070 // [I2cDriver12] Enable VEML6070 sensor (I2C addresses 0x38 and 0x39) (+1k5 code) #define USE_VEML6070_RSET 270000 // VEML6070, Rset in Ohm used on PCB board, default 270K = 270000ohm, range for this sensor: 220K ... 1Meg #define USE_VEML6070_SHOW_RAW // VEML6070, shows the raw value of UV-A #endif This little sensor is a great way to add UV light sensing to any microcontroller project. The VEML6070 from Vishay has a true UV A light sensor and an I 2 C-controlled ADC that will take readings and integrate them for you over ~60ms to 500ms.\" See VEML6070 UV Sensor for more information. Configuration ~ Wiring ~ VEML6070 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL Tasmota Main ~ After a reboot the driver will detect VEML6070 automatically and display UV light intensity. Breakout Boards ~","title":"VEML6070 UV light sensor"},{"location":"VEML6070/#veml6070-uv-light-sensor","text":"This feature is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VEML6070 #define USE_VEML6070 // [I2cDriver12] Enable VEML6070 sensor (I2C addresses 0x38 and 0x39) (+1k5 code) #define USE_VEML6070_RSET 270000 // VEML6070, Rset in Ohm used on PCB board, default 270K = 270000ohm, range for this sensor: 220K ... 1Meg #define USE_VEML6070_SHOW_RAW // VEML6070, shows the raw value of UV-A #endif This little sensor is a great way to add UV light sensing to any microcontroller project. The VEML6070 from Vishay has a true UV A light sensor and an I 2 C-controlled ADC that will take readings and integrate them for you over ~60ms to 500ms.\" See VEML6070 UV Sensor for more information.","title":"VEML6070 UV light sensor"},{"location":"VEML6070/#configuration","text":"","title":"Configuration"},{"location":"VEML6070/#wiring","text":"VEML6070 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VEML6070/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL","title":"Tasmota Settings"},{"location":"VEML6070/#tasmota-main","text":"After a reboot the driver will detect VEML6070 automatically and display UV light intensity.","title":"Tasmota Main"},{"location":"VEML6070/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"VEML6075/","text":"VEML6075 UVA/UVB/UVINDEX Sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VEML6075 #define USE_VEML6075 // [I2cDriver49] Enable VEML6075 UVA/UVB/UVINDEX Sensor (I2C address 0x10) (+2k1 code) #endif This little sensor is a great way to add UVA and UVB light sensing to any microcontroller project. The VEML6075 from Vishay has both true UVA and UVB band light sensors and an I2C-controlled ADC that will take readings and integrate them. The sensor also comes with calibration registers so you can easily convert the UVA/UVB readings into the UV Index. Configuration ~ Wiring ~ VEML6075 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL Commands and Use ~ Console Commands Description values VEML6075power Power on/off the module 0/1 VEML6075inttime UV integration time (50ms, 100ms, 200ms, 400ms, 800ms) 0/1/2/3/4 VEML6075dynamic dynamic setting (low, high) 0/1 Tasmota Main ~ After a reboot the driver will detect VEML6075 automatically and display UVA/UVB/UVindex intensity. Breakout Boards ~","title":"VEML6075 UVA/UVB/UVINDEX Sensor"},{"location":"VEML6075/#veml6075-uvauvbuvindex-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VEML6075 #define USE_VEML6075 // [I2cDriver49] Enable VEML6075 UVA/UVB/UVINDEX Sensor (I2C address 0x10) (+2k1 code) #endif This little sensor is a great way to add UVA and UVB light sensing to any microcontroller project. The VEML6075 from Vishay has both true UVA and UVB band light sensors and an I2C-controlled ADC that will take readings and integrate them. The sensor also comes with calibration registers so you can easily convert the UVA/UVB readings into the UV Index.","title":"VEML6075 UVA/UVB/UVINDEX Sensor"},{"location":"VEML6075/#configuration","text":"","title":"Configuration"},{"location":"VEML6075/#wiring","text":"VEML6075 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VEML6075/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL","title":"Tasmota Settings"},{"location":"VEML6075/#commands-and-use","text":"Console Commands Description values VEML6075power Power on/off the module 0/1 VEML6075inttime UV integration time (50ms, 100ms, 200ms, 400ms, 800ms) 0/1/2/3/4 VEML6075dynamic dynamic setting (low, high) 0/1","title":"Commands and Use"},{"location":"VEML6075/#tasmota-main","text":"After a reboot the driver will detect VEML6075 automatically and display UVA/UVB/UVindex intensity.","title":"Tasmota Main"},{"location":"VEML6075/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"VEML7700/","text":"VEML7700 Ambient light sensor ~ This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VEML7700 #define USE_VEML7700 // [I2cDriver50] Enable VEML7700 Ambient Light sensor (I2C addresses 0x10) (+4k5 code) #endif VEML7700 is a high accuracy ambient light digital 16-bit resolution sensor in a miniature transparent 6.8 mm x 2.35 mm x 3.0 mm package. It includes a high sensitive photo diode, a low noise amplifier, a 16-bit A/D converter and supports an easy to use I2C bus communication interface. The ambient light result is available as digital value. Configuration ~ Wiring ~ VEML7700 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL Commands and Use ~ Console Commands Description values VEML7700power Power on/off the module 0/1 VEML7700inttime Integration time in ms 25, 50, 100, 200, 400, 800 VEML7700gain Gain setting (x1, x2, x1/8, x1/4) 0 = x1 1 = x2 2 = x1/8 3 = x1/4 VEML7700persist ALS persistence protect number setting 0 = 1 1 = 2 2 = 4 3 = 8 With gain 1/8 and inttime 25 the sensor goes up to 120.000 Lux if someone needs it. Tasmota Main ~ After a reboot the driver will detect VEML7700 automatically and display light intensity. Breakout Boards ~","title":"VEML7700 Ambient light sensor"},{"location":"VEML7700/#veml7700-ambient-light-sensor","text":"This feature is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VEML7700 #define USE_VEML7700 // [I2cDriver50] Enable VEML7700 Ambient Light sensor (I2C addresses 0x10) (+4k5 code) #endif VEML7700 is a high accuracy ambient light digital 16-bit resolution sensor in a miniature transparent 6.8 mm x 2.35 mm x 3.0 mm package. It includes a high sensitive photo diode, a low noise amplifier, a 16-bit A/D converter and supports an easy to use I2C bus communication interface. The ambient light result is available as digital value.","title":"VEML7700 Ambient light sensor"},{"location":"VEML7700/#configuration","text":"","title":"Configuration"},{"location":"VEML7700/#wiring","text":"VEML7700 ESP GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VEML7700/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA GPIOy to I2C SCL","title":"Tasmota Settings"},{"location":"VEML7700/#commands-and-use","text":"Console Commands Description values VEML7700power Power on/off the module 0/1 VEML7700inttime Integration time in ms 25, 50, 100, 200, 400, 800 VEML7700gain Gain setting (x1, x2, x1/8, x1/4) 0 = x1 1 = x2 2 = x1/8 3 = x1/4 VEML7700persist ALS persistence protect number setting 0 = 1 1 = 2 2 = 4 3 = 8 With gain 1/8 and inttime 25 the sensor goes up to 120.000 Lux if someone needs it.","title":"Commands and Use"},{"location":"VEML7700/#tasmota-main","text":"After a reboot the driver will detect VEML7700 automatically and display light intensity.","title":"Tasmota Main"},{"location":"VEML7700/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"VL53Lxx/","text":"VL53L0X and VL53L1X laser ranging modules ~ Support for VL53L0X is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VL53L0X #define USE_VL53L0X // [I2cDriver31] Enable VL53L0x time of flight sensor (I2C address 0x29) (+4k code) #define VL53L0X_XSHUT_ADDRESS 0x78 // VL53L0X base address when used with XSHUT control #endif Support for VL53L1X is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VL53L1X #define #define USE_VL53L1X // [I2cDriver54] Enable VL53L1X time of flight sensor (I2C address 0x29) using Pololu VL53L1X library (+2k9 code) #define VL53L1X_XSHUT_ADDRESS 0x78 // VL53L1X base address when used with XSHUT control #define VL53L1X_DISTANCE_MODE Long // VL53L1X distance mode : Long | Medium | Short #endif The VL53L0X and VL53L1X are Time-of-Flight (ToF) laser-ranging devices from ST MicroElectronics commonly available on small modules. In the documentation below, VL53LXX is used whenever the information applies to either VL53L0X or VL53L1X. The exact name is used for any information that is specific to the specific model. The devices ~ About how to install those sensor and how to adapt the laser operation for several use-cases, please check: Datasheet VL53L0X Datasheet VL53L1X Characteristic VL53L0X VL53L1X Unit Max distance 2000 4000 mm Field of vision 25 27 \u00b0 For more details on the supported distance range depending on the mode, the reflectance of the object and the ambient light regarding the different modes, please refer to the datasheets. If you are going to use long I2C wires read this article Breakout Boards ~ Sample boards for VL53L0X. Similar boards exist for VL53L1X. Configuration for single sensor ~ Wiring for single sensor ~ VL53LXX ESP GND GND VCC 3.3V SDA GPIOa SCL GPIOb Tasmota Settings for single sensor ~ In order to use a VL53LXX sensor you need to: - configure ESP GPIOs for I2C bus - enable the right driver Step 1 - Configure I2C ~ In the Configuration -> Configure Module page assign: GPIOa to I2C SDA GPIOb to I2C SCL On ESP8266 almost any GPIO can be used for I2C except for GPIO15. However the standard is to use GPIO4 (D1) for I2C SCL and GPIO5 (D2) for I2C SDA. On ESP32 any pin can be assigned to I2C. Step 2 - Enable the proper driver ~ I2C devices are identified on the I2C bus by their address. Because the number of possible addresses are limited (127) a lot of devices are sharing the same address. This as means that it is not possible to use simultaneously on the same I2C bus 2 devices that are using the same address. Beside, in most cases, a driver cannot correctly identify the chip it is talking to. This is why in most of the case it is important to disable Tasmota drivers for devices that you are not using and leave enabled only driver for a device you are going to use. In the list of I2CDEVICES supported by Tasmota it is listed that the address 0x29 can be used by either TSL2561 (driver 16), VL53L0X (driver 31), TSL2591 (driver 40) and VL53L1X (driver VL53L1X). It means that you can't use a TSL2561 or a TSL2591 at the same time as a VL53L0X/VL53L1X. ANd you can't use a VL53L0X at the same time as a VL53L1X. If you have build a tasmota binary that include the driver for TSL2561 and/or TSL2591 you must disable those drivers. You must also disable the driver for the other VL53LXX device. As a summary, here are the command to type in the console: To use a VL53L0X : backlog i2cdriver16 0;i2cdriver40 0;i2cdriver31 1;i2cdriver54 0 To use a VL53L1X : backlog i2cdriver16 0;i2cdriver40 0;i2cdriver31 0;i2cdriver54 1 After a reboot Tasmota will detect the VL53LXX automatically is the proper driver has been enabled. Sensor sends a tele/%topic%/SENSOR JSON reponse: For VL53L0X: { \"Time\" : \"2019-12-20T11:29:22\" , \"VL53L0X\" :{ \"Distance\" : 263 }} Or for VL53L1X { \"Time\" : \"2019-12-20T11:29:22\" , \"VL53L1X\" :{ \"Distance\" : 263 }} Configuration for Multiple VL53LXX sensors in parallel ~ Tasmota supports by default up to 8 of these sensors in parallel. Note that they all must be of the same model (either all VL53L0X or all VL53L1X). In any case, the above I2C GPIO and I2C driver configuration remain valid. When using multiple VL53LXX, it is required to wire the XSHUT pin of each sensors to a dedicated free GPIO and assign as VL53LXX XSHUT 1 to 8. This is to let Tasmota change by software the I2C address of those and give them an unique address for operation. The sensor don't save its address and this procedure is performed automatically at every restart. The Addresses used for this are by default 0x78 (120) to 0x7F (127). As for a single sensor, you must not use any other I2C device on those addresses. As the date of writing, there is currently no I2C device supported by Tasmota with those addresses. However such devices exists and may be supported by later versions of Tasmota. You can change the relocation address by a compile option, see the compile options section. Wiring for Multiple Sensors ~ VL53LXX-1 VL53LXX-2 VL53LXX-3 ... ESP GND GND GND GND GND VCC VCC VCC VCC 3.3V SDA SDA SDA SDA GPIOa SCL SCL SCL SCL GPIOb XSHUT - - - GPIOc - XSHUT - - GPIOd - - XSHUT - GPIOe - - - XSHUT GPIOz On ESP8266, please refer to the guide Expending Tasmota for suitable GPIOs. GPIO 1 and 3 being used by serial console are generally unadvised. GPIO15 has a pull-down on every ESP board to allow proper boot. If you want to use this GPIO for a XSHUT, you must remove the pull-up resistor that is on the VL53LXX module otherwise your ESP will not boot. On ESP32 any GPIO that can be an output can be used. Tasmota Settings for multiple sensors ~ In the Configuration -> Configure Module page assign: GPIOa to I2C SDA GPIOb to I2C SCL GPIOc to XSHUT 1 GPIOd to XSHUT 2 GPIOe to XSHUT 3 ... After a reboot Tasmota will detect each VL53LXX in sequence and after auto-configuring them, it will display distance in mm. Example: for VL53L0X it sends tele/%topic%/SENSOR JSON such as: { \"Time\" : \"2019-12-20T11:29:22\" , \"VL53L0X_1\" :{ \"Distance\" : 263 }, \"VL53L0X_2\" :{ \"Distance\" : 344 }, \"VL53L0X_3\" :{ \"Distance\" : 729 }} With VL053L1X, the name of the sensor is adapted. The index separator is either a - if SetOption4 is 0 or a _ if it is 1 . See SetOption4 . Compile options ~ General ~ MAXIMUM AMOUNT OF SENSORS: Tasmota supports by default up to 8 of these sensors in parallel. Expanding this limit is possible but backwards incompatible. The default value of VL53LXX_MAX_SENSORS is set in the file tasmota.h XHUT Relocation address The addresses at which the VL53LXX are relocated when using XSHUT can be changed by a define in user_config_override.h file. Replace the 0x78 for the 1st address. You need that as many consecutives address are free for the number of devices you are using. For VL53L0X use: #define VL53L0X_XSHUT_ADDRESS 0x78 For VL53L1X use: #define VL53L1X_XSHUT_ADDRESS 0x78 VL53L0X options ~ VL53L0X LONG RANGE: By default VL53L0X reads up to 1.2 meters. If you want to use the long range mode (up to 2.2 meters), you need to add a define in user_config_override.h file: #define VL53L0X_LONG_RANGE This increases the sensitivity of the sensor and extends its potential range, but increases the likelihood of getting an inaccurate reading because of reflections from objects other than the intended target. It works best in dark conditions. VL53L0X_HIGH_SPEED vs VL53L0X_HIGH_ACCURACY Either or the other can be added in user_config_override.h file to change the default compromise to either proceed at higher speed (but at the cost of accuracy) or at higher accuracy. #define VL53L0X_HIGH_SPEED or #define VL53L0X_HIGH_ACCURACY VL53L1X options ~ Distance range can be changed between Long , Medium or Short by copying one (and only one) of the below lines in user_config_override.h . The default value is Long . For details on those range, please refer to the datasheet of the device. #define VL53L1X_DISTANCE_MODE Long #define VL53L1X_DISTANCE_MODE Medium #define VL53L1X_DISTANCE_MODE Short","title":"VL53L0X and VL53L1X laser ranging modules"},{"location":"VL53Lxx/#vl53l0x-and-vl53l1x-laser-ranging-modules","text":"Support for VL53L0X is included only in tasmota-sensors and tasmota32 binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VL53L0X #define USE_VL53L0X // [I2cDriver31] Enable VL53L0x time of flight sensor (I2C address 0x29) (+4k code) #define VL53L0X_XSHUT_ADDRESS 0x78 // VL53L0X base address when used with XSHUT control #endif Support for VL53L1X is not included in precompiled binaries When compiling your build add the following to user_config_override.h : #ifndef USE_VL53L1X #define #define USE_VL53L1X // [I2cDriver54] Enable VL53L1X time of flight sensor (I2C address 0x29) using Pololu VL53L1X library (+2k9 code) #define VL53L1X_XSHUT_ADDRESS 0x78 // VL53L1X base address when used with XSHUT control #define VL53L1X_DISTANCE_MODE Long // VL53L1X distance mode : Long | Medium | Short #endif The VL53L0X and VL53L1X are Time-of-Flight (ToF) laser-ranging devices from ST MicroElectronics commonly available on small modules. In the documentation below, VL53LXX is used whenever the information applies to either VL53L0X or VL53L1X. The exact name is used for any information that is specific to the specific model.","title":"VL53L0X and VL53L1X laser ranging modules"},{"location":"VL53Lxx/#the-devices","text":"About how to install those sensor and how to adapt the laser operation for several use-cases, please check: Datasheet VL53L0X Datasheet VL53L1X Characteristic VL53L0X VL53L1X Unit Max distance 2000 4000 mm Field of vision 25 27 \u00b0 For more details on the supported distance range depending on the mode, the reflectance of the object and the ambient light regarding the different modes, please refer to the datasheets. If you are going to use long I2C wires read this article","title":"The devices"},{"location":"VL53Lxx/#breakout-boards","text":"Sample boards for VL53L0X. Similar boards exist for VL53L1X.","title":"Breakout Boards"},{"location":"VL53Lxx/#configuration-for-single-sensor","text":"","title":"Configuration for single sensor"},{"location":"VL53Lxx/#wiring-for-single-sensor","text":"VL53LXX ESP GND GND VCC 3.3V SDA GPIOa SCL GPIOb","title":"Wiring for single sensor"},{"location":"VL53Lxx/#tasmota-settings-for-single-sensor","text":"In order to use a VL53LXX sensor you need to: - configure ESP GPIOs for I2C bus - enable the right driver","title":"Tasmota Settings for single sensor"},{"location":"VL53Lxx/#configuration-for-multiple-vl53lxx-sensors-in-parallel","text":"Tasmota supports by default up to 8 of these sensors in parallel. Note that they all must be of the same model (either all VL53L0X or all VL53L1X). In any case, the above I2C GPIO and I2C driver configuration remain valid. When using multiple VL53LXX, it is required to wire the XSHUT pin of each sensors to a dedicated free GPIO and assign as VL53LXX XSHUT 1 to 8. This is to let Tasmota change by software the I2C address of those and give them an unique address for operation. The sensor don't save its address and this procedure is performed automatically at every restart. The Addresses used for this are by default 0x78 (120) to 0x7F (127). As for a single sensor, you must not use any other I2C device on those addresses. As the date of writing, there is currently no I2C device supported by Tasmota with those addresses. However such devices exists and may be supported by later versions of Tasmota. You can change the relocation address by a compile option, see the compile options section.","title":"Configuration for Multiple VL53LXX sensors in parallel"},{"location":"VL53Lxx/#wiring-for-multiple-sensors","text":"VL53LXX-1 VL53LXX-2 VL53LXX-3 ... ESP GND GND GND GND GND VCC VCC VCC VCC 3.3V SDA SDA SDA SDA GPIOa SCL SCL SCL SCL GPIOb XSHUT - - - GPIOc - XSHUT - - GPIOd - - XSHUT - GPIOe - - - XSHUT GPIOz On ESP8266, please refer to the guide Expending Tasmota for suitable GPIOs. GPIO 1 and 3 being used by serial console are generally unadvised. GPIO15 has a pull-down on every ESP board to allow proper boot. If you want to use this GPIO for a XSHUT, you must remove the pull-up resistor that is on the VL53LXX module otherwise your ESP will not boot. On ESP32 any GPIO that can be an output can be used.","title":"Wiring for Multiple Sensors"},{"location":"VL53Lxx/#tasmota-settings-for-multiple-sensors","text":"In the Configuration -> Configure Module page assign: GPIOa to I2C SDA GPIOb to I2C SCL GPIOc to XSHUT 1 GPIOd to XSHUT 2 GPIOe to XSHUT 3 ... After a reboot Tasmota will detect each VL53LXX in sequence and after auto-configuring them, it will display distance in mm. Example: for VL53L0X it sends tele/%topic%/SENSOR JSON such as: { \"Time\" : \"2019-12-20T11:29:22\" , \"VL53L0X_1\" :{ \"Distance\" : 263 }, \"VL53L0X_2\" :{ \"Distance\" : 344 }, \"VL53L0X_3\" :{ \"Distance\" : 729 }} With VL053L1X, the name of the sensor is adapted. The index separator is either a - if SetOption4 is 0 or a _ if it is 1 . See SetOption4 .","title":"Tasmota Settings for multiple sensors"},{"location":"VL53Lxx/#compile-options","text":"","title":"Compile options"},{"location":"VL53Lxx/#general","text":"MAXIMUM AMOUNT OF SENSORS: Tasmota supports by default up to 8 of these sensors in parallel. Expanding this limit is possible but backwards incompatible. The default value of VL53LXX_MAX_SENSORS is set in the file tasmota.h XHUT Relocation address The addresses at which the VL53LXX are relocated when using XSHUT can be changed by a define in user_config_override.h file. Replace the 0x78 for the 1st address. You need that as many consecutives address are free for the number of devices you are using. For VL53L0X use: #define VL53L0X_XSHUT_ADDRESS 0x78 For VL53L1X use: #define VL53L1X_XSHUT_ADDRESS 0x78","title":"General"},{"location":"VL53Lxx/#vl53l0x-options","text":"VL53L0X LONG RANGE: By default VL53L0X reads up to 1.2 meters. If you want to use the long range mode (up to 2.2 meters), you need to add a define in user_config_override.h file: #define VL53L0X_LONG_RANGE This increases the sensitivity of the sensor and extends its potential range, but increases the likelihood of getting an inaccurate reading because of reflections from objects other than the intended target. It works best in dark conditions. VL53L0X_HIGH_SPEED vs VL53L0X_HIGH_ACCURACY Either or the other can be added in user_config_override.h file to change the default compromise to either proceed at higher speed (but at the cost of accuracy) or at higher accuracy. #define VL53L0X_HIGH_SPEED or #define VL53L0X_HIGH_ACCURACY","title":"VL53L0X options"},{"location":"VL53Lxx/#vl53l1x-options","text":"Distance range can be changed between Long , Medium or Short by copying one (and only one) of the below lines in user_config_override.h . The default value is Long . For details on those range, please refer to the datasheet of the device. #define VL53L1X_DISTANCE_MODE Long #define VL53L1X_DISTANCE_MODE Medium #define VL53L1X_DISTANCE_MODE Short","title":"VL53L1X options"},{"location":"Visual-Studio-Code/","text":"How to setup and configure Visual Studio Code with PlatformIO for Tasmota compilation and upload. Easy way (only Windows): Portable install of Visual Studio Code for Tasmota ~ Download the ready made Portable Installation of VSC/PlatformIO and extract the ZIP to a folder or a fast extern drive. Grab the Tasmota compile package and extract it to the same destination. Start VS Code.exe (in folder VSC) Full Install (Windows, Linux and Mac) ~ Download and Install Visual Studio Code ~ Download Visual Studio Code (VSC) from https://code.visualstudio.com/ Install PlatformIO Extension ~ Install the PlatformIO IDE extension in VSC. Select View - Extensions and type PlatformIO in the search box. Make sure to select the official PlatformIO.org PlatformIO IDE extension and select Install . Accept to install dependencies. Download Tasmota ~ Download the latest Tasmota version from https://github.com/arendst/Tasmota and unzip to a known folder. Copy files ~ Copy all files from the Tasmota Source code into your VSC working folder. Compile Tasmota ~ Start VSC and select File - Open Folder... to point to the working folder. Note: Press Ctrl + Shift + P and type PlatformIO to see all options. Select the desired firmware via VSC menu . Easy compilation can be performed from the icons at the bottom of the VSC screen. Upload Tasmota ~ Enable desired options in platformio.ini for serial upload like: ; *** Upload Serial reset method for Wemos and NodeMCU upload_port = COM5 ;upload_speed = 512000 upload_speed = 115200 ;upload_resetmethod = nodemcu Special options (not needed for compiling Tasmota!) are enabled in platformio_override.ini : ; *** Upload file to OTA server using HTTP upload_port = domus1:80/api/upload-arduino.php extra_scripts = pio/http-uploader.py Easy compilation and upload can be performed from the icons at the bottom of the VSC screen or use Ctrl + Alt + U to upload (will build if needed). Hint: ~ In case vscode shows a huge amount of errors using PlatformIO - Intellisense a possible \"solution\" is to change the cpp-Intelli Sense Engine type to \"TAG PARSER\" This setting can be changed in workspace settings by: Use Ctrl + Shift + P and type Preferences: Open Workspace Settings and type intelli Sense in the search box. Now change the value for Intelli Sense Engine to Tag Parser .","title":"Visual Studio Code"},{"location":"Visual-Studio-Code/#easy-way-only-windows-portable-install-of-visual-studio-code-for-tasmota","text":"Download the ready made Portable Installation of VSC/PlatformIO and extract the ZIP to a folder or a fast extern drive. Grab the Tasmota compile package and extract it to the same destination. Start VS Code.exe (in folder VSC)","title":"Easy way (only Windows): Portable install of Visual Studio Code for Tasmota"},{"location":"Visual-Studio-Code/#full-install-windows-linux-and-mac","text":"","title":"Full Install (Windows, Linux and Mac)"},{"location":"Visual-Studio-Code/#download-and-install-visual-studio-code","text":"Download Visual Studio Code (VSC) from https://code.visualstudio.com/","title":"Download and Install Visual Studio Code"},{"location":"Visual-Studio-Code/#install-platformio-extension","text":"Install the PlatformIO IDE extension in VSC. Select View - Extensions and type PlatformIO in the search box. Make sure to select the official PlatformIO.org PlatformIO IDE extension and select Install . Accept to install dependencies.","title":"Install PlatformIO Extension"},{"location":"Visual-Studio-Code/#download-tasmota","text":"Download the latest Tasmota version from https://github.com/arendst/Tasmota and unzip to a known folder.","title":"Download Tasmota"},{"location":"Visual-Studio-Code/#copy-files","text":"Copy all files from the Tasmota Source code into your VSC working folder.","title":"Copy files"},{"location":"Visual-Studio-Code/#compile-tasmota","text":"Start VSC and select File - Open Folder... to point to the working folder. Note: Press Ctrl + Shift + P and type PlatformIO to see all options. Select the desired firmware via VSC menu . Easy compilation can be performed from the icons at the bottom of the VSC screen.","title":"Compile Tasmota"},{"location":"Visual-Studio-Code/#upload-tasmota","text":"Enable desired options in platformio.ini for serial upload like: ; *** Upload Serial reset method for Wemos and NodeMCU upload_port = COM5 ;upload_speed = 512000 upload_speed = 115200 ;upload_resetmethod = nodemcu Special options (not needed for compiling Tasmota!) are enabled in platformio_override.ini : ; *** Upload file to OTA server using HTTP upload_port = domus1:80/api/upload-arduino.php extra_scripts = pio/http-uploader.py Easy compilation and upload can be performed from the icons at the bottom of the VSC screen or use Ctrl + Alt + U to upload (will build if needed).","title":"Upload Tasmota"},{"location":"Visual-Studio-Code/#hint","text":"In case vscode shows a huge amount of errors using PlatformIO - Intellisense a possible \"solution\" is to change the cpp-Intelli Sense Engine type to \"TAG PARSER\" This setting can be changed in workspace settings by: Use Ctrl + Shift + P and type Preferences: Open Workspace Settings and type intelli Sense in the search box. Now change the value for Intelli Sense Engine to Tag Parser .","title":"Hint:"},{"location":"WS2812B-RGB-Shield/","text":"WS2812B RGB Shield (single pin) ~ From the Wemos WS2812b shield specs the DATA pin is connected to D2 of the Wemos. Tasmota Settings ~ In Configuration -> Configure Module page assign: D2 GPIO4 to WS2812 After a reboot of the device the toggle button and light controls are displayed in the webUI.","title":"WS2812B RGB Shield"},{"location":"WS2812B-RGB-Shield/#ws2812b-rgb-shield-single-pin","text":"From the Wemos WS2812b shield specs the DATA pin is connected to D2 of the Wemos.","title":"WS2812B RGB Shield (single pin)"},{"location":"WS2812B-RGB-Shield/#tasmota-settings","text":"In Configuration -> Configure Module page assign: D2 GPIO4 to WS2812 After a reboot of the device the toggle button and light controls are displayed in the webUI.","title":"Tasmota Settings"},{"location":"WS2812B-and-WS2813/","text":"WS2813B versus WS2812B ~ The newer version of ws2812b is the ws2813b, which has dual signal lines to prevent a led failure also consecutive leds fail. ESP8266 needs Level shifting - WS281x schematic ~ Below the schematics to connect a ESP82xx to a WS281x. About this circuit diagram and the oscilloscope traces ~ Channel 1 (yellow) is connected to an output of the ESP8266 Chip, and therefore shows the input voltage of the level shifting circuit. Channel 2 (green) is connected to the output of the level shifting circuit, and therefore shows the input voltage to the first WS281X pixel. How does the MOSFET circuit work and what are the challenges? When the GPIO is HIGH (3.3V), the voltage between Gate and Source of the FET is zero since the Gate is tied to +3.3V through R4 and the Source follows the GPIO. The FET is not conducting between its Source and Drain connections. In this state the Output is pulled to +5V by R5. (BTW: R4 is only there to charge/discharge the parasitic input capacitance of the FET and could be omitted entirely for an ideal FET.) When the GPIO goes low, it pulls the Source of the FET to GND (0V). That increases the voltage across Gate and Source of the FET (VGS) to 3.3V, causing the FET to become conductive between Source and Drain, and consequently pull the output to GND. The major flaw of this circuit is that its usefulness degrades towards higher frequencies (shorter pulses) and capacitive loads because the only force pulling the output to HIGH is the pull-up resistor R5. So the load capacitance gets charged through R5 only. You can mitigate the effect partially by selecting a smaller R5 but the tradeoff will be increased power consumption of the circuit. A WS2813 signal input imposes a capacitive load of 15 pF onto the level shifter\u2019s output according to its datasheet. That doesn\u2019t sound like a lot, but you can see from the plots that we have only few nanoseconds time to charge the parasitic capacitor. It also partially adds up with the reverse transfer capacitance of the BSS138 FET (Crss=6pF according to the datasheet). The result is clearly visible in the oscilloscope plot: the leading edges are not sharp and therefore reducing the pulse duration acquired by the pixel\u2019s input, depending on the input voltage threshold of the pixel (0.7 x VDD = 3.5V @ 5V according to the datasheet). The effect of sampled pulse shortening gets worse with rising input HIGH threshold of the pixel. NB: The design frequency of this circuit would be 1 / (433 ns x 2) = 1.155 MHz So what would be a better solution? Better Circuit: TTL logic gates We need a circuit with well-defined and matching input voltage thresholds. TTL gates represent such circuits. For a power supply of 5V, a TTL input is guaranteed logic LOW when the input voltage is below 0.8V. That same input is guaranteed logic HIGH when the input voltage is above 2.0V. That perfectly matches our 3.3V GPIO output voltage! The output weakness of the MOSFET circuit does not apply to a TTL gate\u2019s output since it can drive to HIGH as well as to LOW by means of a circuit known as \u201cTotem Pole\u201d push-pull transistor output stage. 74HCT and 74AHCT chips will drive the output to a voltage close to VCC. This output stage gives much sharper leading edges as can be seen on the lower right oscilloscope picture. So this is actually the circuit I would suggest for the application. A large variety of TTL chips can be used: 74HCTXX series, 74AHCTXX series, but not 74HC or 74AHC! Which logic function you choose is up to your liking and availability in your parts bin. The input characteristics are the same for all of them (with a slight deviation for those with Schmitt trigger inputs like the 74XX14). 5V power supply: the power of the power supply depends on the number of leds. A pixel has 3 leds (RGB), each led drains a max of 20mA, so a pixel drains a max of 60mA (3 * 20mA). So the total current that the power supply must deliver is 60mA times the number of pixels. For example 80 pixels: 60mA * 80 = 4800mA = 4.8A. Also the ESP8266 is powered by the power supply so in this example a power supply of 6A (30W) will do. note: connect the ledstrip from both sides to the power supply Tasmota Configuration ~ In the Configuration -> Configure Module page, select the following: D1 GPIO5 : WS2812 Tasmota Main ~","title":"WS2812B and WS2813"},{"location":"WS2812B-and-WS2813/#ws2813b-versus-ws2812b","text":"The newer version of ws2812b is the ws2813b, which has dual signal lines to prevent a led failure also consecutive leds fail.","title":"WS2813B versus WS2812B"},{"location":"WS2812B-and-WS2813/#esp8266-needs-level-shifting-ws281x-schematic","text":"Below the schematics to connect a ESP82xx to a WS281x.","title":"ESP8266 needs Level shifting - WS281x schematic"},{"location":"WS2812B-and-WS2813/#about-this-circuit-diagram-and-the-oscilloscope-traces","text":"Channel 1 (yellow) is connected to an output of the ESP8266 Chip, and therefore shows the input voltage of the level shifting circuit. Channel 2 (green) is connected to the output of the level shifting circuit, and therefore shows the input voltage to the first WS281X pixel. How does the MOSFET circuit work and what are the challenges? When the GPIO is HIGH (3.3V), the voltage between Gate and Source of the FET is zero since the Gate is tied to +3.3V through R4 and the Source follows the GPIO. The FET is not conducting between its Source and Drain connections. In this state the Output is pulled to +5V by R5. (BTW: R4 is only there to charge/discharge the parasitic input capacitance of the FET and could be omitted entirely for an ideal FET.) When the GPIO goes low, it pulls the Source of the FET to GND (0V). That increases the voltage across Gate and Source of the FET (VGS) to 3.3V, causing the FET to become conductive between Source and Drain, and consequently pull the output to GND. The major flaw of this circuit is that its usefulness degrades towards higher frequencies (shorter pulses) and capacitive loads because the only force pulling the output to HIGH is the pull-up resistor R5. So the load capacitance gets charged through R5 only. You can mitigate the effect partially by selecting a smaller R5 but the tradeoff will be increased power consumption of the circuit. A WS2813 signal input imposes a capacitive load of 15 pF onto the level shifter\u2019s output according to its datasheet. That doesn\u2019t sound like a lot, but you can see from the plots that we have only few nanoseconds time to charge the parasitic capacitor. It also partially adds up with the reverse transfer capacitance of the BSS138 FET (Crss=6pF according to the datasheet). The result is clearly visible in the oscilloscope plot: the leading edges are not sharp and therefore reducing the pulse duration acquired by the pixel\u2019s input, depending on the input voltage threshold of the pixel (0.7 x VDD = 3.5V @ 5V according to the datasheet). The effect of sampled pulse shortening gets worse with rising input HIGH threshold of the pixel. NB: The design frequency of this circuit would be 1 / (433 ns x 2) = 1.155 MHz So what would be a better solution? Better Circuit: TTL logic gates We need a circuit with well-defined and matching input voltage thresholds. TTL gates represent such circuits. For a power supply of 5V, a TTL input is guaranteed logic LOW when the input voltage is below 0.8V. That same input is guaranteed logic HIGH when the input voltage is above 2.0V. That perfectly matches our 3.3V GPIO output voltage! The output weakness of the MOSFET circuit does not apply to a TTL gate\u2019s output since it can drive to HIGH as well as to LOW by means of a circuit known as \u201cTotem Pole\u201d push-pull transistor output stage. 74HCT and 74AHCT chips will drive the output to a voltage close to VCC. This output stage gives much sharper leading edges as can be seen on the lower right oscilloscope picture. So this is actually the circuit I would suggest for the application. A large variety of TTL chips can be used: 74HCTXX series, 74AHCTXX series, but not 74HC or 74AHC! Which logic function you choose is up to your liking and availability in your parts bin. The input characteristics are the same for all of them (with a slight deviation for those with Schmitt trigger inputs like the 74XX14). 5V power supply: the power of the power supply depends on the number of leds. A pixel has 3 leds (RGB), each led drains a max of 20mA, so a pixel drains a max of 60mA (3 * 20mA). So the total current that the power supply must deliver is 60mA times the number of pixels. For example 80 pixels: 60mA * 80 = 4800mA = 4.8A. Also the ESP8266 is powered by the power supply so in this example a power supply of 6A (30W) will do. note: connect the ledstrip from both sides to the power supply","title":"About this circuit diagram and the oscilloscope traces"},{"location":"WS2812B-and-WS2813/#tasmota-configuration","text":"In the Configuration -> Configure Module page, select the following: D1 GPIO5 : WS2812","title":"Tasmota Configuration"},{"location":"WS2812B-and-WS2813/#tasmota-main","text":"","title":"Tasmota Main"},{"location":"WebUI/","text":"Tasmota's web user interface is a practical way to control and manage your tasmotized device. Warning WebUI does not and can not have all the features and commands implemented. For precise and complete control use Console or MQTT commands! To access the WebUI use your device's IP address in your favorite web browser. By default, WebUI starts in unprotected admin mode which allows complete access to your device to anyone with access to that IP. If you want to restrict other users to only control through the WebUI, use WebServer 1 . Command WebPassword will set up a password that needs to be entered when trying to access WebUI. This is a very thin layer of protection since everything is transmitted over unencrypted HTTP protocol. Menus ~ Configuration ~ Configuration menu allows you to configure everything from components to Wi-Fi and gives you the option to backup and restore the configuration in a secure location. Information ~ Displays a single page loaded with information about the device including: current Tasmota version, Wi-Fi AP data, MQTT host data, and more Firmware Upgrade ~ An easy to use menu to initiate a firmware upgrade from an uploaded .bin file or an OTA server. Console ~ Terminal access to Tasmota. Issue commands here or follow the information stream. Useful for debugging when using \u02d9Weblog 4` . Customizing ~ WebButton ~ Change names of the toggle buttons using WebButton . Themes ~ WebUI is themable using WebColor commands. To apply a theme from below copy the entire code block and send it using the console or via MQTT. Dark (default theme) ~ WebColor { \"WebColor\" : [ \"#eaeaea\" , \"#252525\" , \"#4f4f4f\" , \"#000000\" , \"#dddddd\" , \"#65c115\" , \"#1f1f1f\" , \"#ff5661\" , \"#008000\" , \"#faffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#faffff\" , \"#999999\" , \"#eaeaea\" ]} Light (default until 6.7.1.) ~ WebColor { \"WebColor\" : [ \"#000000\" , \"#ffffff\" , \"#f2f2f2\" , \"#000000\" , \"#ffffff\" , \"#000000\" , \"#ffffff\" , \"#ff0000\" , \"#008000\" , \"#ffffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#000000\" ]} Halloween ~ WebColor { \"WebColor\" : [ \"#cccccc\" , \"#2f3133\" , \"#3d3f41\" , \"#dddddd\" , \"#293134\" , \"#ffb000\" , \"#293134\" , \"#ff5661\" , \"#008000\" , \"#ffffff\" , \"#ec7600\" , \"#bf5f00\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#bc4d90\" ]} Navy ~ WebColor { \"WebColor\" : [ \"#e0e0c0\" , \"#000033\" , \"#4f4f4f\" , \"#000000\" , \"#dddddd\" , \"#a7f432\" , \"#1e1e1e\" , \"#ff0000\" , \"#008000\" , \"#ffffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#eedd77\" ]} Purple Rain ~ WebColor { \"WebColor\" : [ \"#eaeaea\" , \"#252525\" , \"#282531\" , \"#eaeaea\" , \"#282531\" , \"#d7ccff\" , \"#1d1b26\" , \"#ff5661\" , \"#008000\" , \"#faffff\" , \"#694fa8\" , \"#4d3e7f\" , \"#b73d5d\" , \"#822c43\" , \"#1f917c\" , \"#156353\" , \"#faffff\" , \"#716b7f\" , \"#eaeaea\" ]} Solarized Dark ~ WebColor { \"WebColor\" : [ \"#839496\" , \"#002b36\" , \"#073642\" , \"#839496\" , \"#002b36\" , \"#839496\" , \"#073642\" , \"#b58900\" , \"#859900\" , \"#eee8d5\" , \"#268bd2\" , \"#185886\" , \"#dc322f\" , \"#90211f\" , \"#859900\" , \"#647300\" , \"#839496\" , \"#073642\" , \"#839496\" ]} Tip When using an MQTT client such as mosquitto_pub , enclose the message payload in single quotes ( ' ) mosquitto_pub -h 192.168.1.20 -t \"cmnd/myTopic/WebColor\" -m '{\"WebColor\":[\"#eaeaea\",\"#252525\",\"#4f4f4f\",\"#000000\",\"#dddddd\",\"#65c115\",\"#1f1f1f\",\"#ff5661\",\"#008000\",\"#faffff\",\"#1fa3ec\",\"#0e70a4\",\"#d43535\",\"#931f1f\",\"#47c266\",\"#5aaf6f\",\"#faffff\",\"#999999\",\"#eaeaea\"]}'","title":"WebUI"},{"location":"WebUI/#menus","text":"","title":"Menus"},{"location":"WebUI/#customizing","text":"","title":"Customizing"},{"location":"WebUI/#webbutton","text":"Change names of the toggle buttons using WebButton .","title":"WebButton"},{"location":"WebUI/#themes","text":"WebUI is themable using WebColor commands. To apply a theme from below copy the entire code block and send it using the console or via MQTT.","title":"Themes"},{"location":"White-Blend-Mode/","text":"White Blend Mode for lights ~ White Blend Mode is used for 4 channel (RGBW) and 5 channel (RGBWC) devices. It is enabled by setting the last PWM channel to zero (e.g., RGBWWTable 255,255,255,<n>,0 ) to lower the white channel intensity. Generally, white LEDs are brighter than RGB LEDs. If you want to keep the same brightness, you need to calibrate the white level. In this mode, any white component will be removed from RGB LEDs and sent to the white LEDs. This makes whites look much better. Example: Color 30508000 will be converted to Color 0020503000 (0x30 is subtracted from R,G,B channels and added to the White channel) To calibrate: Color FFFFFF00 RGBWWTable 255,255,255,255,255 - reset to RGB mode RGBWWTable 255,255,255,<n>,0 (begin the calibration process with <n> == 150) If too bright, decrease <n> . If too dim, increase <n> Go back to step 2 and iterate until satisfied with the color intensities. Examples: * Sonoff B1: RGBWWTable 255,255,255,35,0 * Teckin SB50: RGBWWTable 255,255,255,80,0","title":"White Blend Mode for lights"},{"location":"White-Blend-Mode/#white-blend-mode-for-lights","text":"White Blend Mode is used for 4 channel (RGBW) and 5 channel (RGBWC) devices. It is enabled by setting the last PWM channel to zero (e.g., RGBWWTable 255,255,255,<n>,0 ) to lower the white channel intensity. Generally, white LEDs are brighter than RGB LEDs. If you want to keep the same brightness, you need to calibrate the white level. In this mode, any white component will be removed from RGB LEDs and sent to the white LEDs. This makes whites look much better. Example: Color 30508000 will be converted to Color 0020503000 (0x30 is subtracted from R,G,B channels and added to the White channel) To calibrate: Color FFFFFF00 RGBWWTable 255,255,255,255,255 - reset to RGB mode RGBWWTable 255,255,255,<n>,0 (begin the calibration process with <n> == 150) If too bright, decrease <n> . If too dim, increase <n> Go back to step 2 and iterate until satisfied with the color intensities. Examples: * Sonoff B1: RGBWWTable 255,255,255,35,0 * Teckin SB50: RGBWWTable 255,255,255,80,0","title":"White Blend Mode for lights"},{"location":"WifiPower/","text":"WifiPower Command ~ WifiPower allows you to fine tune the Wi-Fi transmission power level. The default is 17dBm which should be enough power for the device to transmit to the Wi-Fi access point (AP) in a normal network environment use case. Changing this setting will impact the Wi-Fi range of the device. The general rule of thumb is for every 3dBm change up or down will double or halve the range, respectively. However, this is largely dependent on the Wi-Fi router's capabilities. Use the RSSI signal level reported by the router for a particular Tasmota device to adjust the power level of a device. Lower the value incrementally until you achieve a balance between connection stability and energy saving. In some cases a device may require slightly more power to maintain a stable connection to the Wi-Fi network. In this case, increment the value in 1 dBm increments until stable connectivity is observed. Do not exceed 17dBm! Exceeding the default 17dBm transmit power setting may cause unreliable device operation. Most devices have been designed with the 17dBm theoretical power setting and may not have the ability to dissipate the additional heat generated. Setting the transmit power too high may cause interference in the device antenna causing Wi-Fi reception problems. This setting will not affect the signal level received from the AP (i.e., the RSSI reading that Tasmota reports). Improper setting of this parameter may cause operational instability and can generate exceptions. Increasing WifiPower puts additional demand on the device electrical power supply. Exceeding the capabilities of the power supply can cause other erratic device behaviors. Of course, the opposite may be the case when reducing transmit power levels allowing a device with a borderline power regulator to operate reliably. You should perform substantial testing and monitoring to find the sweet spot for WifiPower .","title":"WifiPower Command"},{"location":"WifiPower/#wifipower-command","text":"WifiPower allows you to fine tune the Wi-Fi transmission power level. The default is 17dBm which should be enough power for the device to transmit to the Wi-Fi access point (AP) in a normal network environment use case. Changing this setting will impact the Wi-Fi range of the device. The general rule of thumb is for every 3dBm change up or down will double or halve the range, respectively. However, this is largely dependent on the Wi-Fi router's capabilities. Use the RSSI signal level reported by the router for a particular Tasmota device to adjust the power level of a device. Lower the value incrementally until you achieve a balance between connection stability and energy saving. In some cases a device may require slightly more power to maintain a stable connection to the Wi-Fi network. In this case, increment the value in 1 dBm increments until stable connectivity is observed. Do not exceed 17dBm! Exceeding the default 17dBm transmit power setting may cause unreliable device operation. Most devices have been designed with the 17dBm theoretical power setting and may not have the ability to dissipate the additional heat generated. Setting the transmit power too high may cause interference in the device antenna causing Wi-Fi reception problems. This setting will not affect the signal level received from the AP (i.e., the RSSI reading that Tasmota reports). Improper setting of this parameter may cause operational instability and can generate exceptions. Increasing WifiPower puts additional demand on the device electrical power supply. Exceeding the capabilities of the power supply can cause other erratic device behaviors. Of course, the opposite may be the case when reducing transmit power levels allowing a device with a borderline power regulator to operate reliably. You should perform substantial testing and monitoring to find the sweet spot for WifiPower .","title":"WifiPower Command"},{"location":"Zigbee-CCLib-Flashing/","text":"Flash using CClib ~ To simplify this procedure, a ready to use fork of the needed firmware files is available. Flash CCLib on an ESP82xx Device ~ Flashing the CC2530 normally requires a CC_DEBUGGER . Using an ESP82xx device like a Wemos D1 Mini is a lower cost alternative. If you are using a Wemos D1 Mini or NodeMCU, just plug the microUSB port. Vcc (3.3V), GND, Tx (GPIO1), and Rx (GPIO3) are connected via the microUSB port. Be sure that you are using a USB data cable. For ESP devices that do not have a microUSB connector, make the following connections: ESP Device Serial Programming Adapter Vcc Vcc GND GND GPIO0 GND GPIO1 Rx GPIO3 Tx Follow the usual ESP82xx flashing process - you are just using CCLib_proxy.ino.bin instead of Tasmota. Once the firmware upload completes, retain the serial interface connections (3.3V, GND, Tx, Rx). These will be used later for flashing the CC2530. C. Flash a DL-20 Zigbee module The DL-20 Zigbee module has a 5-pin 1.27mm pitch unpopulated header with 0.6mm througholes. For flashing any of the Zigbee modules, you need the following connections: ESP Pin D1 Mini NodeMCU CC2530 Pin DL-20 J2 Pin Location GPIO12 D6 CC_DD (A.K.A. P2_1 ('P21') or Debug Data) 5 GPIO4 D2 CC_DC (A.K.A. P2_2 ('P22') or Debug Clock) 4 Vcc 3.3v Vcc 3 GPIO5 D1 CC_RST 2 GND GND GND 1 DL-20 Flashing Jumpers Insert alternating male Dupont jumpers; one jumper on one side, the next one on other side. This allows the pins to provide the friction themselves to maintain contact and remain firmly in place. You only need DD, DC, and RST (a fourth jumper is shown which is used to keep the RST jumper in place). Vcc and GND are available on the main serial interface pins. D. Upload the firmware to the CC2530 The CC2530 requires Z-Stack_Home_1.2 , of type Default (not Source Routing ). For convenience, ready to use firmware files are provided. Select the right one for your hardware: CC2530 , CC2530 + CC2591 or CC2530 + CC2592 . These Python scripts require Python 2.7. 1) Ensure that you have Python 2.7 installed 2) Install pyserial 3.0.1: pip install pyserial==3.0.1 3) Check for connectivity before flashing: python Python/cc_info.py -p <serial_port> where <serial_port> is the serial port for the ESP82xx device. e.g. /dev/cu.usbserial-xxxx or COM7 Example of result: INFO: Found a CC2530 chip on /dev/cu.usbserial-xxxx Chip information: Chip ID : 0xa524 Flash size : 16 Kb Page size : 2 Kb SRAM size : 1 Kb USB : No Device information: IEEE Address : 000000000000 PC : 0000 Debug status: [ ] CHIP_ERASE_BUSY [ ] PCON_IDLE [X] CPU_HALTED [ ] PM_ACTIVE [ ] HALT_STATUS [X] DEBUG_LOCKED [X] OSCILLATOR_STABLE [ ] STACK_OVERFLOW Debug config: [ ] SOFT_POWER_MODE [ ] TIMERS_OFF [ ] DMA_PAUSE [ ] TIMER_SUSPEND If your CC2530 is DEBUG_LOCKED, then the flash size will be incorrectly reported as 16kB. Dont worry flashing the Z-Stack firmware will work and reset the DEBUG_LOCKED bit. In some situation flashing fails with a error message flash have not enough space . If this happens do the following: python Python/cc_read_flash.py -p <serial_port> -o x.hex python Python/cc_write_flash.py --erase -p <serial_port> -i x.hex Recheck for connectivity and the correct flash size by repeating step #3. 4) Flash the Z-Stack firmware using the following command: Flashing the CC2530 takes about 20 minutes python Python/cc_write_flash.py -e -p <serial_port> -i Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex INFO: Found a CC2530 chip on /dev/cu.usbserial-xxxx Chip information: Chip ID : 0xa524 Flash size : 256 Kb Page size : 2 Kb SRAM size : 8 Kb USB : No Sections in Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex: Addr. Size -------- ------------- 0x0000 8176 B 0x1ff6 10 B 0x3fff0 1 B 0x2000 239616 B This is going to ERASE and REPROGRAM the chip. Are you sure? <y/N>: y Flashing: - Chip erase... - Flashing 4 memory blocks... -> 0x0000 : 8176 bytes Progress 100%... OK -> 0x1ff6 : 10 bytes Progress 100%... OK -> 0x3fff0 : 1 bytes Progress 100%... OK -> 0x2000 : 239616 bytes Progress 100%... OK Completed If you don't see any on screen activity that flashing has begun (i.e., progress percentages increasing) within a couple minutes, then abort the command, cycle power on the ESP82xx, and start this step over. Described in greater detail in this blog post .","title":"Zigbee CCLib Flashing"},{"location":"Zigbee-CCLib-Flashing/#flash-using-cclib","text":"To simplify this procedure, a ready to use fork of the needed firmware files is available.","title":"Flash using CClib"},{"location":"Zigbee-CCLib-Flashing/#flash-cclib-on-an-esp82xx-device","text":"Flashing the CC2530 normally requires a CC_DEBUGGER . Using an ESP82xx device like a Wemos D1 Mini is a lower cost alternative. If you are using a Wemos D1 Mini or NodeMCU, just plug the microUSB port. Vcc (3.3V), GND, Tx (GPIO1), and Rx (GPIO3) are connected via the microUSB port. Be sure that you are using a USB data cable. For ESP devices that do not have a microUSB connector, make the following connections: ESP Device Serial Programming Adapter Vcc Vcc GND GND GPIO0 GND GPIO1 Rx GPIO3 Tx Follow the usual ESP82xx flashing process - you are just using CCLib_proxy.ino.bin instead of Tasmota. Once the firmware upload completes, retain the serial interface connections (3.3V, GND, Tx, Rx). These will be used later for flashing the CC2530. C. Flash a DL-20 Zigbee module The DL-20 Zigbee module has a 5-pin 1.27mm pitch unpopulated header with 0.6mm througholes. For flashing any of the Zigbee modules, you need the following connections: ESP Pin D1 Mini NodeMCU CC2530 Pin DL-20 J2 Pin Location GPIO12 D6 CC_DD (A.K.A. P2_1 ('P21') or Debug Data) 5 GPIO4 D2 CC_DC (A.K.A. P2_2 ('P22') or Debug Clock) 4 Vcc 3.3v Vcc 3 GPIO5 D1 CC_RST 2 GND GND GND 1 DL-20 Flashing Jumpers Insert alternating male Dupont jumpers; one jumper on one side, the next one on other side. This allows the pins to provide the friction themselves to maintain contact and remain firmly in place. You only need DD, DC, and RST (a fourth jumper is shown which is used to keep the RST jumper in place). Vcc and GND are available on the main serial interface pins. D. Upload the firmware to the CC2530 The CC2530 requires Z-Stack_Home_1.2 , of type Default (not Source Routing ). For convenience, ready to use firmware files are provided. Select the right one for your hardware: CC2530 , CC2530 + CC2591 or CC2530 + CC2592 . These Python scripts require Python 2.7. 1) Ensure that you have Python 2.7 installed 2) Install pyserial 3.0.1: pip install pyserial==3.0.1 3) Check for connectivity before flashing: python Python/cc_info.py -p <serial_port> where <serial_port> is the serial port for the ESP82xx device. e.g. /dev/cu.usbserial-xxxx or COM7 Example of result: INFO: Found a CC2530 chip on /dev/cu.usbserial-xxxx Chip information: Chip ID : 0xa524 Flash size : 16 Kb Page size : 2 Kb SRAM size : 1 Kb USB : No Device information: IEEE Address : 000000000000 PC : 0000 Debug status: [ ] CHIP_ERASE_BUSY [ ] PCON_IDLE [X] CPU_HALTED [ ] PM_ACTIVE [ ] HALT_STATUS [X] DEBUG_LOCKED [X] OSCILLATOR_STABLE [ ] STACK_OVERFLOW Debug config: [ ] SOFT_POWER_MODE [ ] TIMERS_OFF [ ] DMA_PAUSE [ ] TIMER_SUSPEND If your CC2530 is DEBUG_LOCKED, then the flash size will be incorrectly reported as 16kB. Dont worry flashing the Z-Stack firmware will work and reset the DEBUG_LOCKED bit. In some situation flashing fails with a error message flash have not enough space . If this happens do the following: python Python/cc_read_flash.py -p <serial_port> -o x.hex python Python/cc_write_flash.py --erase -p <serial_port> -i x.hex Recheck for connectivity and the correct flash size by repeating step #3. 4) Flash the Z-Stack firmware using the following command: Flashing the CC2530 takes about 20 minutes python Python/cc_write_flash.py -e -p <serial_port> -i Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex INFO: Found a CC2530 chip on /dev/cu.usbserial-xxxx Chip information: Chip ID : 0xa524 Flash size : 256 Kb Page size : 2 Kb SRAM size : 8 Kb USB : No Sections in Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex: Addr. Size -------- ------------- 0x0000 8176 B 0x1ff6 10 B 0x3fff0 1 B 0x2000 239616 B This is going to ERASE and REPROGRAM the chip. Are you sure? <y/N>: y Flashing: - Chip erase... - Flashing 4 memory blocks... -> 0x0000 : 8176 bytes Progress 100%... OK -> 0x1ff6 : 10 bytes Progress 100%... OK -> 0x3fff0 : 1 bytes Progress 100%... OK -> 0x2000 : 239616 bytes Progress 100%... OK Completed If you don't see any on screen activity that flashing has begun (i.e., progress percentages increasing) within a couple minutes, then abort the command, cycle power on the ESP82xx, and start this step over. Described in greater detail in this blog post .","title":"Flash CCLib on an ESP82xx Device"},{"location":"Zigbee-Internals/","text":"Zigbee internals ~ Back to Zigbee This page is for developers who want to understand how Zigbee2Tasmota (Z2T) works and its implementation details. CC2530 Serial protocol ~ The CC2530 is flashed with Texas Instrument ZNP Software version 1.2. The protocol is build on a serial communication between the main cpu and the CC2530. Z-Stack 1.2 Monitor and Test API Serial communication is configured as 8N1, 115200 bauds. We suggest to use GPIO13/15 because they have hardware serial support. Please note that there is only one usable hardware serial, either on GPIO1/3 or GPIO13/15. To enable hardware serial on GPIO13/15 for Tasmota, set Serial 0 and restart. Otherwise Z2T will use Software serial provided by TasmotaSerial. Receiving 115200 bauds in software is a timing challenge. Here is the anatomy of a byte transmitted in serial mode. Each bit is 8.7\u00b5s, or ~700 CPU cycles at 80MHz (1400 cycles at 160MHz). It all starts with a LOW \"start bit\" that generates an interrupt transferred to TasmotaSerial. Then TasmotaSerial enters a tightly controlled loop to read each bit (least sifnificant first). The frame stops with a HIGH stop bit. What can go wrong? Tasmota may be already handling an interrupt when the start bit arrives, potentially causing a shift by 1 bit and a wrong message. Here is a 0xFE byte correctly received: Same frame with a delay in the interrupt handler, and mistakenly read 0xFF: TasmotaSerial has been improved to allow receiving a train of bytes withtout any disruption. CC2530 generally sends all the bytes one after the other for a single ZNP message (up to 250 bytes). Instead of giving back control after the first byte, the TasmotaSerial interrupt handler continues to monitor the serial RX line for the next 4 bits and checks whether a new start bit arrived. It avoids any error after the first byte was received. Still the first byte in the message could have been wrong. Fortunately, the first byte sent by ZNP is always 0xFE (see below). This means that if the interrupt arrives too late, Tasmota will read 0xFF instead of 0xFE. Z2T software does automatic error correction in this case, i.e. if the first byte received is 0xFF, it is automatically assumed to be 0xFE and the rest of the message is read normally. With these two schemes, software serial for Zigbee proved to be extremely reliable, even at 80MHz. It is highly recommended though to run at 160MHz. State machine - CC2530 initialization and configuration ~ After Tasmota boots, it sends the sequence 410001 to force a CC2530 hardware reset. Z2T implements an asynchronous state machine to handle the initialization and configuration of the CC2530. The state machine sends commands and waits for responses (with time-outs) and takes different branches depending on the responses. Instruction set ~ The program is encoded as a list of 32 bits instructions, stored in Flash in the zb_prog array of type Zigbee_Instruction[] . There is a PC (program counter) that is increased at each tick (i.e. every 50ms). The state machine has very simple instructions. Instructions encoded with 4 bytes: NOOP : no-operation, do nothing and move to the next instruction LABEL(x) : no-operation, and defines a Label (8 bits) that can be called by code. GOTO(x) : moves the PC to the instruction with LABEL(x) ZI_ON_ERROR_GOTO(x) : if an error occurs, move to label ZI_ON_TIMEOUT_GOTO(x) : if a timeout occurs, move to lavel WAIT(y) : wait for milliseconds (unsigned 16 bits). Note the granularity is 50ms and the wait is non-blocking WAIT_FOREVER : pause the state machine and wait for an external goto STOP : stop completely the state machine, only used after an unrecoverable error Instructions encoded with 8 bytes: CALL(f, x) : call a function, is the address of the function of type uint32_t f(uint8_t) . The input parameter is . The response is according to callbacks responses, except -1 (time-out) simply continues the flow. LOG(m) : log the string . can be in PROGMEM. For debugging only. MQTT_STATE(x, m) : sends a MQTT ZbState message, with status code and message . can be in PROGMEM. SEND(d) : send a ZNP sequence to CC2530. is an array of , a macro computes automatically the size of the array. can be in PROGMEM. WAIT_RECV(x, m) : wait for a specific message to be received with a time-out of (uint16_t). Messages take into account are owly those matching the first 2 bytes. The complete message match is expected or an error is generated. If the message received is longer than , additional bytes are ignored WAIT_UNTIL(x, m) : similar to WAIT_RECV but message that don't match are ignored, until a matching message is received. ON_RECV_UNEXPECTED(f) : if we received an unexpected (or unsupported) zigbee message, call function Instructions encoded with 12 bytes: WAIT_RECV_FUNC(x, m, f) : similar to WAIT_RECV and a function is called when the message matches. All callbacks return int32_t with the following effect: > 0 : goto the corresponding label 0 : continue -1 : signal a time-out < -1 : trigger an error (goto on_error) Initialization code for the state machine ~ At Tasmota start-up, the state-machine fires. The current Z2T pseudo-code does the following: Init: Set-up all the error handling functions Wait for 10.5 seconds after boot Send a RESET to CC2530 Wait for CC2530 boot Check configuration (if something is wrong, go to CONFIGURE): Check if the CC2530 was previously configured. It uses the same 1-byte Non-Volatile 0xF00 address and stores 0x55. Checks the Z-Stack version Checks the internal configuration: PanID, Ext PanID, Channel, PFGK and PFGKEN. If all good, emit an MQTT message saying Zigbee is configured Goto Start Configure (only if needed): Emit an MQTT message for reconfiguration Do a factory reset of CC2530 Reset the device once again Configure the following: PanId, Ext PanId, Channel, set type to Coordinator, PFKEY, PFKEYEN, Security Module Create NF 0xF00 location and store 0x55 Goto Start Start: Wait for CC2530 message saying the coordinator sucessfully started Query DeviceInfo Query Node Descriptor Query Active Endpoints Register 2 endpoints with profile 0x0104 (Home Automation) : 0x01 (default), 0x0B (for Xiaomi) Query Active Endpoints to verify 0x01 and 0x0B are active Close PermitJoin: don't accept any pairing Emit an MQTT message to indicate Zigbee started Mark Zigbee as initialized, accept incoming messages Load device configuration from Flash Query any lights declared with ZbLight to read their current states Pause the state machine Pairing devices ~ When you open pairing with ZbPermitJoin 1 (60 seconds) or ZbPermitJoin 99 (until next reboot), you allow new devices to join the network. Example below is for an OSRAM Plug. When a new devices joins, Z2T receives a TC Device Indication: ZDO_TC_DEV_IND (45CA) message with the device short (16 bits) address and IEEEAddress (64 bits). 16 : 39 : 26 MQT : tele /Zigbee_home/RESULT = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ShortAddr\" : \"0xF75D\" , \"PowerSource\" : true , \"ReceiveWhenIdle\" : true , \"Security\" : false }} Z2T then queries the device for additional information, like ZbProbe would do. First probe for Active Endpoint ZDO_ACTIVE_EP_REQ 16 : 39 : 26 MQT : tele /Zigbee_home/RESULT = { \"ZbState\" :{ \"Status\" : 32 , \"ActiveEndpoints\" :[ \"0x03\" ]}} Finally query for the following general attributes: Manufacturer Id and Model Id. 16:39:26 ZIG: ZbZCLRawReceived: {\"0xF75D\":{\"0000/0004\":\"OSRAM\",\"0000/0005\":\"Plug 01\"}} 16:39:26 MQT: tele/tasmota/Zigbee_home/SENSOR = {\"ZbReceived\":{\"0xF75D\":{\"Manufacturer\":\"OSRAM\",\"ModelId\":\"Plug 01\",\"Endpoint\":3,\"LinkQuality\":36}}} Code flow when a message is received ~ Message Serial decoding ~ Here is a detailed view of the code flow and transformations applied when a Zigbee message is received. It's simple but has many ramifications. During the Tasmota event loop, Z2T first checks any incoming message by calling ZigbeeInputLoop() , and after parsing incoming messages, it sends any outgoing message by calling ZigbeeOutputLoop() . Note: outgoing messages are not sent directly but stacked into a buffer and sent once per event tick. This avoids lost messages when sending them too fast. For ZNP , the serial buffer is read if there is any incoming data. The message is checked for checksum and put into a SBuffer object of maximum size of 256 bytes. If a message is ready, it calls ZigbeeProcessInput(znp_buffer) For EZSP , the flow is a little more complex because multiple layers of decoding are required. The first layer receives the message and handles UART-EZSP protocol messages: ignores XON/XOFF, decodes ESCAPE characters, CANCEL... It then decodes according to the pseudo-random generator, and checks the final CRC. If ok, it calls the second stage via ZigbeeProcessInputRaw(ezsp_buffer) . Note: the green light of the ZBBridge Led_i 1 is set to blink when a message is received from EZSP (which does not mean an actual Zigbee radio message was received). EZSP second stage decodes the ASH protocol, including ACK/NAK of messages, RSTACK (reset confirmation) and ERROR. In case of ERROR, the EZSP stack is not able to respond anymore and requires a complete reset. In this case a log entry is produced and the entire Tasmota is automatically restarted. This stage automatically sends ACK messages to confirm reception of messages. If a DATA frame is received, it then calls the third stage via ZigbeeProcessInputEZSP(buf) . The third stage of EZSP decoding extracts the message, logs if needed and then calls ZigbeeProcessInput(buf) . State machine handling ~ The message is passed to the state machine that will either automatically match the message and pass to the next state, or pass it to the default handler. When the stack is fully initialized, zigbee.init_phase == false , the default handler is ZNP_Recv_Default() for ZNP or EZ_Recv_Default() for EZSP. For ZNP , ZDO messages are dispatched to the relevant handlers: ZDO_END_DEVICE_ANNCE_IND , ZDO_TC_DEV_IND , ZDO_PERMIT_JOIN_IND , ZDO_NODE_DESC_RSP , ZDO_ACTIVE_EP_RSP , ZDO_SIMPLE_DESC_RSP , ZDO_IEEE_ADDR_RSP , ZDO_BIND_RSP , ZDO_UNBIND_RSP , ZDO_MGMT_LQI_RSP , ZDO_MGMT_BIND_RSP . Note: PARENT_ANNCE is handled at ZNP level and not passed to the application. AF_DATA_CONFIRM emits a log message, and data messages are handled in ZNP_ReceiveAfIncomingMessage() . The ZCL frame is decoded into a ZCLFrame object and sent to Z_IncomingMessage() . For EZSP , messages are directly dispatched for trustCenterJoinHandler , incomingRouteErrorHandler , permitJoining and messageSentHandler . All other incoming messages, including ZDO, are sent to EZ_IncomingMessage() . EZSP : EZ_IncomingMessage() then decodes ZDO messages and dispatches them: ZDO_Device_annce , ZDO_Active_EP_rsp , ZDO_IEEE_addr_rsp , ZDO_Simple_Desc_rsp , ZDO_Bind_rsp , Z_UnbindRsp , Z_MgmtLqiRsp , Z_MgmtBindRsp , ZDO_Parent_annce , ZDO_Parent_annce_rsp . Other non-ZDO messages decoded into a ZCLFrame object and sent to Z_IncomingMessage() . Incoming messages handling: Z_IncomingMessage ~ The starting point is Z_IncomingMessage() with a ZCLFrame object corresponding to the received Zigbee message. Details of Z_IncomingMessage() : 1. Log the raw message at LogLevel 3 (DEBUG) ~ 2. Update the LQI for the device ~ 3. Update the last_seen value ~ 4. Dispatch according to message type ~ If ZCL_DEFAULT_RESPONSE , log and ignore (it's just the device acknowledge for the last message). If ZCL_REPORT_ATTRIBUTES , call parseReportAttributes() . This is the general case for sensor values (temperature...) If ZCL_READ_ATTRIBUTES_RESPONSE , call parseReadAttributesResponse() . This happens as a response to reading attributes, and the handling is similar to the attribute reporting (although the syntax of the message is slightly differen). If ZCL_READ_ATTRIBUTES , call parseReadAttributes() . This happens rarely, typically when a device asks the coordinator for attributes like the local_time . If ZCL_READ_REPORTING_CONFIGURATION_RESPONSE , call parseReadConfigAttributes() . This is the response to ZbBindState command. If ZCL_CONFIGURE_REPORTING_RESPONSE , call parseConfigAttributes() . This is the response to ZbBind command. For cluster specific commands, call parseClusterSpecificCommand() . This is the general case when a command is received (for ex \"Power\":\"toggle\" ). All the previous commands add attributes to a local attr_list object. These attributes are have a key of eiher Cluster/Attribute type of String type. Note: it is important to keep attributes as Cluster/Attribute types so that we can later apply transformations on them. Note2: LinkQuality , Device , Name , Group and Endpoint are special values that do are not registered as actual attributes. 6. Apply transoformations to the attributes. ~ There are many transformations that are required because some device use proprietary values, or we need to compute new values out of the existing attributes. Generate synthetic attributes generateSyntheticAttributes() . This is mainly used for Xiaomi Aqara devices. Aqara uses cluster 0xFF01 and 0xFF02 to send structured messages. The good side is that it allows to send attributes from different clusters in a single message, whereas the ZCL standard would have required several messages. The bad side is that Aqara reuses the same attribute numbers for different value, and you need to know the device type to decode; which makes the whole process work only if the pairing process sucessfully got the ModelId. Compute synthetic attributes computeSyntheticAttributes() . This is used to add computed attributes or fix some bugs in devices. Currently it computes the BatteryPercentage from the BatteryVoltage if the BatteryPercentage is not already present. It computes SeaPressure using the Tasmota Altitude setting. It fixes an Eurotronic bug in the encoding of Pi Heating Demand which is sent in the 0..255 range instead of 0..100 range. It fixes the IKEA Remote battery value which is half what it needs to be. Generate callbacks and timers generateCallBacks() . This is used to register deferres callbacks. It is only used for Occypancy for now. Many PIR sensors report \"Occupancy\":1 but don't report the lack of occupancy. This function sets a timer to artificially generate \"Occupancy\":0 after a definite amount of time (defaults to 90 seconds). Post-process attributes Z_postProcessAttributes() . This function does the final transformation of attributes to their human readable format. First the endpoint is added as suffix if SetOption101 1 is set, if the source endpoint is not 1 , and if the device is known to have more than one endpoint (check with ZbStatus2 ). Then the attribute is looked-up from the global Z_PostProcess table. If the attribute is mapped into Z_Data , the value is saved into its corresponding object. See ZbData . This allows for keeping last seen values for the Web UI. Similarly, some device specific values are recorded: ModelId , ManufacturerId , BatteryPercent . If the attribute as a multiplier value, the raw value is multiplied/divided by this value (ex: Temperature raw value is 1/100th of degrees, so the raw value is divided by 100). Finally the attribute name is replaced by its string value (ex: 0402/0000 is replace with Temperature ). 7. Publish the final message to MQTT or defer the message. ~ In the general case, attributes are not published immediately but kept in memory for a short period of time. This allows for debouncing of identical messages, and coalescing of values (Temperature, Pressure, Humidity) in a single MQTT message, even if there were received in 3 seperate messages. The default timer is a compile time #define USE_ZIGBEE_COALESCE_ATTR_TIMER with a default value of 350 ms. Once a message is ready, it first checks if the value conflict with previously held values. If so, the previous message is immediately sent, and the new values are held in memory. Then is sets a timer to publish the values after the timer expired.","title":"Zigbee internals"},{"location":"Zigbee-Internals/#zigbee-internals","text":"Back to Zigbee This page is for developers who want to understand how Zigbee2Tasmota (Z2T) works and its implementation details.","title":"Zigbee internals"},{"location":"Zigbee-Internals/#cc2530-serial-protocol","text":"The CC2530 is flashed with Texas Instrument ZNP Software version 1.2. The protocol is build on a serial communication between the main cpu and the CC2530. Z-Stack 1.2 Monitor and Test API Serial communication is configured as 8N1, 115200 bauds. We suggest to use GPIO13/15 because they have hardware serial support. Please note that there is only one usable hardware serial, either on GPIO1/3 or GPIO13/15. To enable hardware serial on GPIO13/15 for Tasmota, set Serial 0 and restart. Otherwise Z2T will use Software serial provided by TasmotaSerial. Receiving 115200 bauds in software is a timing challenge. Here is the anatomy of a byte transmitted in serial mode. Each bit is 8.7\u00b5s, or ~700 CPU cycles at 80MHz (1400 cycles at 160MHz). It all starts with a LOW \"start bit\" that generates an interrupt transferred to TasmotaSerial. Then TasmotaSerial enters a tightly controlled loop to read each bit (least sifnificant first). The frame stops with a HIGH stop bit. What can go wrong? Tasmota may be already handling an interrupt when the start bit arrives, potentially causing a shift by 1 bit and a wrong message. Here is a 0xFE byte correctly received: Same frame with a delay in the interrupt handler, and mistakenly read 0xFF: TasmotaSerial has been improved to allow receiving a train of bytes withtout any disruption. CC2530 generally sends all the bytes one after the other for a single ZNP message (up to 250 bytes). Instead of giving back control after the first byte, the TasmotaSerial interrupt handler continues to monitor the serial RX line for the next 4 bits and checks whether a new start bit arrived. It avoids any error after the first byte was received. Still the first byte in the message could have been wrong. Fortunately, the first byte sent by ZNP is always 0xFE (see below). This means that if the interrupt arrives too late, Tasmota will read 0xFF instead of 0xFE. Z2T software does automatic error correction in this case, i.e. if the first byte received is 0xFF, it is automatically assumed to be 0xFE and the rest of the message is read normally. With these two schemes, software serial for Zigbee proved to be extremely reliable, even at 80MHz. It is highly recommended though to run at 160MHz.","title":"CC2530 Serial protocol"},{"location":"Zigbee-Internals/#state-machine-cc2530-initialization-and-configuration","text":"After Tasmota boots, it sends the sequence 410001 to force a CC2530 hardware reset. Z2T implements an asynchronous state machine to handle the initialization and configuration of the CC2530. The state machine sends commands and waits for responses (with time-outs) and takes different branches depending on the responses.","title":"State machine - CC2530 initialization and configuration"},{"location":"Zigbee-Internals/#instruction-set","text":"The program is encoded as a list of 32 bits instructions, stored in Flash in the zb_prog array of type Zigbee_Instruction[] . There is a PC (program counter) that is increased at each tick (i.e. every 50ms). The state machine has very simple instructions. Instructions encoded with 4 bytes: NOOP : no-operation, do nothing and move to the next instruction LABEL(x) : no-operation, and defines a Label (8 bits) that can be called by code. GOTO(x) : moves the PC to the instruction with LABEL(x) ZI_ON_ERROR_GOTO(x) : if an error occurs, move to label ZI_ON_TIMEOUT_GOTO(x) : if a timeout occurs, move to lavel WAIT(y) : wait for milliseconds (unsigned 16 bits). Note the granularity is 50ms and the wait is non-blocking WAIT_FOREVER : pause the state machine and wait for an external goto STOP : stop completely the state machine, only used after an unrecoverable error Instructions encoded with 8 bytes: CALL(f, x) : call a function, is the address of the function of type uint32_t f(uint8_t) . The input parameter is . The response is according to callbacks responses, except -1 (time-out) simply continues the flow. LOG(m) : log the string . can be in PROGMEM. For debugging only. MQTT_STATE(x, m) : sends a MQTT ZbState message, with status code and message . can be in PROGMEM. SEND(d) : send a ZNP sequence to CC2530. is an array of , a macro computes automatically the size of the array. can be in PROGMEM. WAIT_RECV(x, m) : wait for a specific message to be received with a time-out of (uint16_t). Messages take into account are owly those matching the first 2 bytes. The complete message match is expected or an error is generated. If the message received is longer than , additional bytes are ignored WAIT_UNTIL(x, m) : similar to WAIT_RECV but message that don't match are ignored, until a matching message is received. ON_RECV_UNEXPECTED(f) : if we received an unexpected (or unsupported) zigbee message, call function Instructions encoded with 12 bytes: WAIT_RECV_FUNC(x, m, f) : similar to WAIT_RECV and a function is called when the message matches. All callbacks return int32_t with the following effect: > 0 : goto the corresponding label 0 : continue -1 : signal a time-out < -1 : trigger an error (goto on_error)","title":"Instruction set"},{"location":"Zigbee-Internals/#initialization-code-for-the-state-machine","text":"At Tasmota start-up, the state-machine fires. The current Z2T pseudo-code does the following: Init: Set-up all the error handling functions Wait for 10.5 seconds after boot Send a RESET to CC2530 Wait for CC2530 boot Check configuration (if something is wrong, go to CONFIGURE): Check if the CC2530 was previously configured. It uses the same 1-byte Non-Volatile 0xF00 address and stores 0x55. Checks the Z-Stack version Checks the internal configuration: PanID, Ext PanID, Channel, PFGK and PFGKEN. If all good, emit an MQTT message saying Zigbee is configured Goto Start Configure (only if needed): Emit an MQTT message for reconfiguration Do a factory reset of CC2530 Reset the device once again Configure the following: PanId, Ext PanId, Channel, set type to Coordinator, PFKEY, PFKEYEN, Security Module Create NF 0xF00 location and store 0x55 Goto Start Start: Wait for CC2530 message saying the coordinator sucessfully started Query DeviceInfo Query Node Descriptor Query Active Endpoints Register 2 endpoints with profile 0x0104 (Home Automation) : 0x01 (default), 0x0B (for Xiaomi) Query Active Endpoints to verify 0x01 and 0x0B are active Close PermitJoin: don't accept any pairing Emit an MQTT message to indicate Zigbee started Mark Zigbee as initialized, accept incoming messages Load device configuration from Flash Query any lights declared with ZbLight to read their current states Pause the state machine","title":"Initialization code for the state machine"},{"location":"Zigbee-Internals/#pairing-devices","text":"When you open pairing with ZbPermitJoin 1 (60 seconds) or ZbPermitJoin 99 (until next reboot), you allow new devices to join the network. Example below is for an OSRAM Plug. When a new devices joins, Z2T receives a TC Device Indication: ZDO_TC_DEV_IND (45CA) message with the device short (16 bits) address and IEEEAddress (64 bits). 16 : 39 : 26 MQT : tele /Zigbee_home/RESULT = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ShortAddr\" : \"0xF75D\" , \"PowerSource\" : true , \"ReceiveWhenIdle\" : true , \"Security\" : false }} Z2T then queries the device for additional information, like ZbProbe would do. First probe for Active Endpoint ZDO_ACTIVE_EP_REQ 16 : 39 : 26 MQT : tele /Zigbee_home/RESULT = { \"ZbState\" :{ \"Status\" : 32 , \"ActiveEndpoints\" :[ \"0x03\" ]}} Finally query for the following general attributes: Manufacturer Id and Model Id. 16:39:26 ZIG: ZbZCLRawReceived: {\"0xF75D\":{\"0000/0004\":\"OSRAM\",\"0000/0005\":\"Plug 01\"}} 16:39:26 MQT: tele/tasmota/Zigbee_home/SENSOR = {\"ZbReceived\":{\"0xF75D\":{\"Manufacturer\":\"OSRAM\",\"ModelId\":\"Plug 01\",\"Endpoint\":3,\"LinkQuality\":36}}}","title":"Pairing devices"},{"location":"Zigbee-Internals/#code-flow-when-a-message-is-received","text":"","title":"Code flow when a message is received"},{"location":"Zigbee-Internals/#message-serial-decoding","text":"Here is a detailed view of the code flow and transformations applied when a Zigbee message is received. It's simple but has many ramifications. During the Tasmota event loop, Z2T first checks any incoming message by calling ZigbeeInputLoop() , and after parsing incoming messages, it sends any outgoing message by calling ZigbeeOutputLoop() . Note: outgoing messages are not sent directly but stacked into a buffer and sent once per event tick. This avoids lost messages when sending them too fast. For ZNP , the serial buffer is read if there is any incoming data. The message is checked for checksum and put into a SBuffer object of maximum size of 256 bytes. If a message is ready, it calls ZigbeeProcessInput(znp_buffer) For EZSP , the flow is a little more complex because multiple layers of decoding are required. The first layer receives the message and handles UART-EZSP protocol messages: ignores XON/XOFF, decodes ESCAPE characters, CANCEL... It then decodes according to the pseudo-random generator, and checks the final CRC. If ok, it calls the second stage via ZigbeeProcessInputRaw(ezsp_buffer) . Note: the green light of the ZBBridge Led_i 1 is set to blink when a message is received from EZSP (which does not mean an actual Zigbee radio message was received). EZSP second stage decodes the ASH protocol, including ACK/NAK of messages, RSTACK (reset confirmation) and ERROR. In case of ERROR, the EZSP stack is not able to respond anymore and requires a complete reset. In this case a log entry is produced and the entire Tasmota is automatically restarted. This stage automatically sends ACK messages to confirm reception of messages. If a DATA frame is received, it then calls the third stage via ZigbeeProcessInputEZSP(buf) . The third stage of EZSP decoding extracts the message, logs if needed and then calls ZigbeeProcessInput(buf) .","title":"Message Serial decoding"},{"location":"Zigbee-Internals/#state-machine-handling","text":"The message is passed to the state machine that will either automatically match the message and pass to the next state, or pass it to the default handler. When the stack is fully initialized, zigbee.init_phase == false , the default handler is ZNP_Recv_Default() for ZNP or EZ_Recv_Default() for EZSP. For ZNP , ZDO messages are dispatched to the relevant handlers: ZDO_END_DEVICE_ANNCE_IND , ZDO_TC_DEV_IND , ZDO_PERMIT_JOIN_IND , ZDO_NODE_DESC_RSP , ZDO_ACTIVE_EP_RSP , ZDO_SIMPLE_DESC_RSP , ZDO_IEEE_ADDR_RSP , ZDO_BIND_RSP , ZDO_UNBIND_RSP , ZDO_MGMT_LQI_RSP , ZDO_MGMT_BIND_RSP . Note: PARENT_ANNCE is handled at ZNP level and not passed to the application. AF_DATA_CONFIRM emits a log message, and data messages are handled in ZNP_ReceiveAfIncomingMessage() . The ZCL frame is decoded into a ZCLFrame object and sent to Z_IncomingMessage() . For EZSP , messages are directly dispatched for trustCenterJoinHandler , incomingRouteErrorHandler , permitJoining and messageSentHandler . All other incoming messages, including ZDO, are sent to EZ_IncomingMessage() . EZSP : EZ_IncomingMessage() then decodes ZDO messages and dispatches them: ZDO_Device_annce , ZDO_Active_EP_rsp , ZDO_IEEE_addr_rsp , ZDO_Simple_Desc_rsp , ZDO_Bind_rsp , Z_UnbindRsp , Z_MgmtLqiRsp , Z_MgmtBindRsp , ZDO_Parent_annce , ZDO_Parent_annce_rsp . Other non-ZDO messages decoded into a ZCLFrame object and sent to Z_IncomingMessage() .","title":"State machine handling"},{"location":"Zigbee-Internals/#incoming-messages-handling-z_incomingmessage","text":"The starting point is Z_IncomingMessage() with a ZCLFrame object corresponding to the received Zigbee message. Details of Z_IncomingMessage() :","title":"Incoming messages handling: Z_IncomingMessage"},{"location":"Zigbee/","text":"Zigbee2Tasmota serves as a gateway for devices connected to a Zigbee wireless network to bridge their communications over to Wi-Fi If you are using ZHA or Zigbee2MQTT via Ser2Net , Tasmota is only passing bytes between the controller (HA or Z2M) and the Zigbee MCU. Please refer to their respective sites to ask any question. All of the below is dedicated to Zigbee2Tasmota mode. Some sections are marked as 'Advanced topic', you can skip them at first and read them only when you need to go deeper. Zigbee2Tasmota (Z2T) is a lightweight Zigbee gateway/bridge solution running on ESP8266/ESP8285 or ESP32 Wi-Fi chips. Hence it is easier to deploy wherever you want in your home. It was inspired by Zigbee2MQTT but it was written from scratch to make it fit into the resource constraints of a ESP82xx chip with just 80kB of RAM and only 1MB of flash memory. For quick reference about Zigbee commands see Zigbee Commands . Hardware ~ Zigbee2Tasmota (Z2T) supports a wide variety of Zigbee MCUs from Texas Instruments (CC253X, CC26x2, CC13x2) and from Silicon Labs (EFR32MG12/EFRMG21), and runs on ESP8266 or any variant of ESP32. Since ESP8266 has very limited resources, we strongly advise to prefer ESP32 based Zigbee gateways. Flashing and installation instructions for ESP32 based: Sonoff Zigbee Bridge Pro ZB-GW03 eWeLink Ethernet Zigbee Gateway (also sold as EACHEN Zigbee Smart Hub and SmartWise Zigbee Bridge Pro) Tube's Ethernet Zigbee Gateway (EFR32 varient) DIY Zigbee gateway/bridge device example based on Ebyte E180-ZG120B or E180-ZG120B-TB Flashing and installation instructions for ESP8266 based: Sonoff ZBBridge by ITead CC2530 based devices DIY Zigbee gateway/bridge device example based on IKEA TR\u00c5DFRI ICC-A-1 Module A complete list of compatible Zigbee coordinators and Zigbee devices compatible with Z2T is in the Zigbee Device Compatibility Repository . Advanced topic: ZNP or EZSP ~ Z2T supports MCU running either the ZNP or EZSP zigbee stack. They require different compilation options but from a user point of view the features are very similar. Z-Stack or ZNP (Zigbee Network Processor) is an open-source Zigbee stack from Texas Instruments and run TI MCUs. Ready to use firmwares are found on Koenkk's Github . Older CC2530 require special wiring or external devices for flashing, while more recent like Sonoff Zigbee Bridge Pro (CC2652P) can be flashed directly from Tasmota. Z2T supports ZNP version 2.6 (Z-Stack 1.3) and version 2.7 (Z-Stack 3.x). EZSP (EmberZNet Serial Protocol) is a commercial Zigbee stack from Silicon Labs . Sonoff/Eachen require encrypted signed firmwares, they can be found in here . Z2T supports EZSP versions 6.7.6 or above (EZSP protocol v8), recommended is v6.7.9 . Introduction ~ Before using Zigbee with Tasmota, you need to understand a few concepts. Here is a simplified comparison to the Wi-Fi equivalent (sort of). Zigbee concept Wi-Fi equivalent Zigbee coordinator The coordinator is responsible for selecting the channel, PanID, security policy, and stack profile for a network. Zigbee2Tasmota will act as a coordinator. You can have multiple coordinators as long as they have different PanIDs. Wi-Fi Access Point PanID (Personal Area Network IDentifier) This parameter is unique in a Zigbee network (16-bit integer, 0x0000\u20130x3FFF). At initial start a pseudo-random PanID is derived from the ESP MAC address. SSID (the Wi-Fi network name) ShortAddr Address of the device on the Zigbee network. This address is randomly assigned when the device first connects to the coordinator (16 bits integer, 0x0000\u20130xFFF7). The coordinator has address 0x0000. You need to track which device has which address or assign a \"Friendly Name\" to each new discovered device. IP address GroupAddr Group address of a collection of devices, it allows a single message to address multiple devices at once (16 bits integer, 0x0000\u20130xFFFF). For example a remote can turn on/off a group of lights. GroupAddr 0x0000 is not assigned. Multicast Endpoint The endpoint on the coordinator or on the Zigbee device the message is sent from/to. You can see endpoints as logical device providing distinct features (8 bits integer, 1\u2013240). IP Port IEEEAddr Device hardware address (64 bits). This is unique per device and factory assigned. MAC address Channel 11-26 Default: 11 (See Zigbee-Wifi coexistence ) Wi-Fi Channel Encryption Key 128-bit encryption key. At initial start a pesudo-random Encryption key is derived from the ESP MAC address. Wi-Fi password Pairing By default the coordinator does not accept new devices unless put in pairing mode. When in pairing mode, it will accept pairing requests from any device within range. Default: pairing disabled WPS Cluster Clusters are a group of commands and attributes that define what a device can do. Think of clusters as a group of actions by function. A device can support multiple clusters to do a whole variety of tasks. The majority of clusters are defined by the ZigBee Alliance and listed in the ZigBee Cluster Library Configuration ~ Initial start ~ When you first start Z2T, pseudo-random parameters are derived from your device unique identifiers (MAC address...) for PanID and network encryption keys. Sonoff Zigbee Bridge Pro (ESP32 + CC2652P with ZNP) 19 : 02 : 20.659 ZIG : reboo t i n g ZNP device 19 : 02 : 22.960 ZbI n pu t discardi n g by te 00 19 : 02 : 22.962 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CCxxxx ZNP booted\" , \"RestartReason\" : \"Power-up\" , \"MajorRel\" : 2 , \"MinorRel\" : 7 }} 19 : 02 : 23.160 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 7 , \"MaintRel\" : 1 , \"Revision\" : 20220219 }} 19 : 02 : 23.311 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 2 , \"Message\" : \"Resetting configuration\" }} 19 : 02 : 25.359 ZbI n pu t discardi n g by te 00 19 : 02 : 25.911 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} 19 : 02 : 30.062 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 40 , \"NewState\" : 9 , \"Message\" : \"Started as coordinator\" }} 19 : 02 : 30.162 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B0026B684E4\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} 19 : 02 : 30.713 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} 19 : 02 : 30.715 ZIG : Zigbee s tarte d 19 : 02 : 30.720 ZIG : No Zigbee device i nf orma t io n 19 : 02 : 30.732 ZIG : Zigbee device da ta i n File Sys te m ( 31 by tes ) Sonoff Zigbee Bridge (ESP8266 + EFR32 with EZSP) 19 : 08 : 26.057 ZIG : Rese tt i n g EZSP device 19 : 08 : 27.261 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"EFR32 EZSP booted\" , \"RestartReason\" : \"Power-on\" , \"Code\" : 2 }} 19 : 08 : 27.315 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 55 , \"Version\" : \"6.7.8.0\" , \"Protocol\" : 8 , \"Stack\" : 2 }} 19 : 08 : 27.316 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} 19 : 08 : 28.758 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 56 , \"IEEEAddr\" : \"0x680AE2FFFE6E103B\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 1 }} 19 : 08 : 28.759 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 2 , \"Message\" : \"Resetting configuration\" }} 19 : 08 : 44.260 ZIG : Rese tt i n g EZSP device 19 : 08 : 45.463 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"EFR32 EZSP booted\" , \"RestartReason\" : \"Power-on\" , \"Code\" : 2 }} 19 : 08 : 45.518 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 55 , \"Version\" : \"6.7.8.0\" , \"Protocol\" : 8 , \"Stack\" : 2 }} 19 : 08 : 45.520 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} 19 : 08 : 46.822 ZIG : Fac t ory rese t EZSP device 19 : 08 : 47.053 ZIG : Subscribe t o group 0 'ZbLis ten 0 0 ' 19 : 08 : 47.108 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} 19 : 08 : 47.108 ZIG : Zigbee s tarte d 19 : 08 : 47.138 ZIG : No Zigbee device i nf orma t io n 19 : 08 : 47.145 ZIG : No Zigbee device da ta When you further restart, logs are slightly shorter (less lines) since the MCU is already configured. Customize Zigbee configuration ~ At initial start, Tasmota generates pseudo-random Zigbee parameters. They should work out of the box but you also may want to choose different values: You the command ZbConfig to dump the current configuration. For example it might return {\"ZbConfig\":{\"Channel\":11,\"PanID\":\"0x1A63\",\"ExtPanID\":\"0xCCCCCCCCCCCCCCCC\",\"KeyL\":\"0x0F0D0B0907050301\",\"KeyH\":\"0x0D0C0A0806040200\"}} To apply a new configuration, populate the fields you want to change in a single-level JSON: ZbConfig {\"Channel\":11,\"PanID\":\"0x1A63\",\"ExtPanID\":\"0xCCCCCCCCCCCCCCCC\",\"KeyL\":\"0x0F0D0B0907050301\",\"KeyH\":\"0x0D0C0A0806040200\"} !!! info \"Changing any parameter with ZbConfig requires to re-pair all devices. Parameter Description Channel 11-26 Zigbee radio channel, see above PanID 0x0001-0x3FFF unique Zigbee network identifier. You should not have too coordinator using the same PanID, or bad things happen. If your coordinator fails to start, try changing the PanID as it may conflict with one already in use. ExtPanID This is a 64 bit unique identifier for the network. It is not much used in Z2T but needs to be unique. KeyL KeyH This is the 128 bit network encryption key split into High and Low 64 bit parts. Do not reveal this key or anyone can decrypt your Zigbee traffic TxRadio On some devices you can set the radio power in dBm. You generally don't need to change it Advanced topic: GPIOs ~ You will usually find a ready to use template in the Zigbee Device Compatibility Repository Below are the details for GPIO configuration needed by Zigbee: GPIO Description Zigbee Tx and Zigbee Rx GPIOs used for serial communication between Tasmota and the MCU (needed for both ZNP and EZSP). Communication is always 115200 bps 8N1. Zigbee Rst 1 (optional) defines the hardware Reset for the Zigbee MCU. If not defined, Z2T will fallback to sending a soft-reset the MCU using a special serial sequence (which may fail on rare occasions). Zigbee Rst 2 (optional) defines a special pin used to put the MCU in bootloader and flashing mode when the hardware reset is pulled down. This is used both by EFR32 and CC2652P based devices. It allows to flash the MCU directly from Tasmota. LedLink or LedLink_i (optional) when defined, this led keeps its normal Wifi/MQTT status indicator (blinking) and adds a glowing light when Permit Join is active (i.e. new devices are allowed to pair). Led 1 or Led_i 1 (optional) when defined, is used as an indicator of traffic between Tasmota and MCU, which generally means Zigbee traffic is sent or received Advanced topic: Hardware or Software serial ~ On ESP32 serial is always handled by hardware so you don't need to bother. On ESP8266 using the hardware serial is preferred. To do so, you need to use GPIOs 13/15 for Zigbee Rx/Tx and set SerialLog 0 . Doing such, Z2T 'steals' the hardware UART from the serial console and uses it for communicating with the MCU. Otherwise Z2T uses Software Serial which requires compiling at 160MHz and might be unreliable on very rare occasions. Usage ~ For a list of available commands see Zigbee Commands . Quick start ~ In this section, we'll give a quick overview of 2 devices: Sonoff SNZB-02 Temperature And Humidity Sensor BlitzWolf SHP15 Power Monitoring Plug Sonoff SNZB-02 Sensor ~ Put Z2T in pairing mode (command zbpermitjoin 1 or via WebUI) and keep the button of the sensor for 5 seconds. Wait a for 20 seconds, you should see something similar in the logs: 17 : 07 : 53.015 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 34 , \"IEEEAddr\" : \"0x00124B001F841E41\" , \"ShortAddr\" : \"0x2916\" , \"ParentNetwork\" : \"0x0000\" }} 17 : 07 : 53.465 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x00124B001F841E41\" , \"ShortAddr\" : \"0x2916\" , \"PowerSource\" : false , \"ReceiveWhenIdle\" : false , \"Security\" : false }} 17 : 07 : 54.565 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 32 , \"ActiveEndpoints\" :[ \"0x01\" ]}} 17 : 07 : 55.037 ZIG : Zigbee Devices Da ta saved i n File Sys te m ( 18 by tes ) 17 : 07 : 55.168 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"ModelId\" : \"TH01\" , \"Manufacturer\" : \"eWeLink\" , \"Endpoint\" : 1 , \"LinkQuality\" : 120 }}} 17 : 07 : 56.667 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 33 , \"Device\" : \"0x2916\" , \"Endpoint\" : \"0x01\" , \"ProfileId\" : \"0x0104\" , \"DeviceId\" : \"0x0302\" , \"DeviceVersion\" : 0 , \"InClusters\" :[ \"0x0000\" , \"0x0003\" , \"0x0402\" , \"0x0405\" , \"0x0001\" ], \"OutClusters\" :[ \"0x0003\" ]}} 17 : 07 : 57.241 ZIG : Zigbee Devices Da ta saved i n File Sys te m ( 29 by tes ) 17 : 07 : 58.667 ZIG : au t o - bi n d `ZbBi n d { \"Device\" : \"0x2916\" , \"Endpoint\" : 1 , \"Cluster\" : \"0x0001\" } ` 17 : 07 : 59.217 RSL : RESULT = { \"ZbBind\" :{ \"Device\" : \"0x2916\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} 17 : 08 : 00.717 ZIG : au t o - bi n d `ZbBi n d { \"Device\" : \"0x2916\" , \"Endpoint\" : 1 , \"Cluster\" : \"0x0402\" } ` 17 : 08 : 01.018 RSL : RESULT = { \"ZbBind\" :{ \"Device\" : \"0x2916\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} 17 : 08 : 02.669 ZIG : au t o - bi n d `ZbBi n d { \"Device\" : \"0x2916\" , \"Endpoint\" : 1 , \"Cluster\" : \"0x0405\" } ` 17 : 08 : 03.618 RSL : RESULT = { \"ZbBind\" :{ \"Device\" : \"0x2916\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} 17 : 08 : 04.670 ZIG : au t o - bi n d `ZbSe n d { \"Device\" : \"0x2916\" , \"Config\" :{ \"BatteryVoltage\" :{ \"MinInterval\" : 3600 , \"MaxInterval\" : 14400 , \"ReportableChange\" : 0.2 }, \"BatteryPercentage\" :{ \"MinInterval\" : 3600 , \"MaxInterval\" : 14400 , \"ReportableChange\" : 5 }}} ` 17 : 08 : 05.271 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"ConfigResponse\" :{}, \"Endpoint\" : 1 , \"LinkQuality\" : 123 }}} 17 : 08 : 06.670 ZIG : au t o - bi n d `ZbSe n d { \"Device\" : \"0x2916\" , \"Config\" :{ \"Temperature\" :{ \"MinInterval\" : 30 , \"MaxInterval\" : 3600 , \"ReportableChange\" : 0.5 }}} ` 17 : 08 : 06.871 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"ConfigResponse\" :{}, \"Endpoint\" : 1 , \"LinkQuality\" : 120 }}} 17 : 08 : 08.670 ZIG : au t o - bi n d `ZbSe n d { \"Device\" : \"0x2916\" , \"Config\" :{ \"Humidity\" :{ \"MinInterval\" : 30 , \"MaxInterval\" : 3600 , \"ReportableChange\" : 1 }}} ` 17 : 08 : 09.421 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"ConfigResponse\" :{}, \"Endpoint\" : 1 , \"LinkQuality\" : 120 }}} 17 : 08 : 14.221 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"Temperature\" : 25.72 , \"Humidity\" : 47.73 , \"Endpoint\" : 1 , \"LinkQuality\" : 116 }}} These logs are quite rich and we'll dive into the details later. Basically it says that the device paired succesfully and is configured. Next step is setting a friendly name with zbname 0x2916,SNZB-02 17 : 09 : 27.294 CMD : zb na me 0 x 2916 , SNZB -02 17 : 09 : 27.297 RSL : RESULT = { \"0x2916\" :{ \"Name\" : \"SNZB-02\" }} 17 : 09 : 29.375 ZIG : Zigbee Devices Da ta saved i n File Sys te m ( 37 by tes ) The device will regularly report readings like this: 17 : 09 : 44.351 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"Name\" : \"SNZB-02\" , \"Temperature\" : 26.27 , \"Endpoint\" : 1 , \"LinkQuality\" : 105 }}} Information is also displayed in the WebUI. When you hover the arrow on the name, you get additional information like short-address and manufacturer. When you hover over the battery icon, you get a more precise reading. BlitzWolf SHP15 Plug ~ Put Z2T in pairing mode (command zbpermitjoin 1 or via WebUI) and keep the button of the sensor for 5 seconds. Wait a for 20 seconds, you should see something similar in the logs: 16 : 17 : 40.804 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 34 , \"IEEEAddr\" : \"0x842E14FFFE13A51E\" , \"ShortAddr\" : \"0x7120\" , \"ParentNetwork\" : \"0x0000\" }} 16 : 17 : 40.854 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x842E14FFFE13A51E\" , \"ShortAddr\" : \"0x7120\" , \"PowerSource\" : true , \"ReceiveWhenIdle\" : true , \"Security\" : false }} 16 : 17 : 41.003 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 32 , \"ActiveEndpoints\" :[ \"0x01\" ]}} 16 : 17 : 41.408 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"ModelId\" : \"TS0121\" , \"Manufacturer\" : \"_TZ3000_g5xawfcq\" , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} 16 : 17 : 42.655 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 33 , \"Device\" : \"0x7120\" , \"Endpoint\" : \"0x01\" , \"ProfileId\" : \"0x0104\" , \"DeviceId\" : \"0x0051\" , \"DeviceVersion\" : 1 , \"InClusters\" :[ \"0x0000\" , \"0x0004\" , \"0x0005\" , \"0x0006\" , \"0x0702\" , \"0x0B04\" ], \"OutClusters\" :[ \"0x0019\" , \"0x000A\" ]}} 16 : 17 : 43.442 ZIG : Zigbee Devices Da ta saved i n File Sys te m ( 40 by tes ) 16 : 17 : 44.516 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Power\" : 1 , \"0006/4001\" : 0 , \"0006/4002\" : 0 , \"0006/8001\" : 1 , \"0006/8002\" : 2 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} 16 : 17 : 44.664 ZIG : au t o - bi n d `ZbBi n d { \"Device\" : \"0x7120\" , \"Endpoint\" : 1 , \"Cluster\" : \"0x0006\" } ` 16 : 17 : 44.863 RSL : RESULT = { \"ZbBind\" :{ \"Device\" : \"0x7120\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} 16 : 17 : 46.466 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"EnergyTotal\" : \"0x000000000000\" , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} 16 : 17 : 46.664 ZIG : au t o - bi n d `ZbSe n d { \"Device\" : \"0x7120\" , \"Config\" :{ \"Power\" :{ \"MinInterval\" : 1 , \"MaxInterval\" : 3600 }}} ` 16 : 17 : 46.916 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"ConfigResponse\" :{}, \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} 16 : 17 : 47.815 ZIG : Au t o - respo n der : ZbSe n d { \"Device\" : \"0x7120\" , \"Cluster\" : \"0x000A\" , \"Endpoint\" : 1 , \"Response\" : \"000A/0007\" : 711476267 } 16 : 17 : 47.819 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Cluster\" : 10 , \"Read\" :[ 7 ], \"ReadNames\" :{ \"LocalTime\" : true }, \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} Again lots of lines we'll not explore for now. You can turn on the plug: zbsend {\"device\":\"SHP15\",\"send\":{\"power\":true}} 16 : 24 : 24.208 RSL : RESULT = { \"ZbSend\" : \"Done\" } 16 : 24 : 25.005 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} You can turn off the plug: (you can use \"powe\"\":0 or \"power\":false ) zbsend {\"device\":\"SHP15\",\"send\":{\"power\":0}} 16 : 24 : 01.456 RSL : RESULT = { \"ZbSend\" : \"Done\" } 16 : 24 : 02.252 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 0 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} You can read the current state : (you can use \"power\":1 or \"power\":true ) zbsend {\"device\":\"SHP15\",\"read\":{\"power\":true}} 16 : 24 : 45.265 RSL : RESULT = { \"ZbSend\" : \"Done\" } 16 : 24 : 45.815 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} You can read the current power : (here 0W) zbsend {\"device\":\"SHP15\",\"read\":{\"activepower\":true}} 16 : 29 : 17.309 RSL : RESULT = { \"ZbSend\" : \"Done\" } 16 : 29 : 17.860 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"ActivePower\" : 0 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} When you directly turn on or off the plug with its button, it also spontaneously report the changes: 16 : 29 : 45.660 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 0 , \"Endpoint\" : 1 , \"LinkQuality\" : 218 }}} 16 : 29 : 52.460 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 218 }}} The WebUI is also reporting the last known values: Advanced topic: logs when pairing ~ This is an example of a pairing process for the Aqara Temperature & Humidity Sensor . To pair this sensor, issue ZbPermitJoin 1 and then press and hold the reset button for 5 seconds. The sensor LED will flash several times and you will see log entries in the console, especially this one: MQT : tele /% t opic%/SENSOR = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ShortAddr\" : \"0x8F20\" , \"PowerSource\" : false , \"ReceiveWhenIdle\" : false , \"Security\" : false }} Message with \"Status\":30 shows some characteristics of the device: Field name Value Status 30 indicates a device connect or reconnect. This is the opportunity to match IEEEAddress and short address IEEEAddr Long unique address (64 bits) of the device - factory set ShortAddr Short address (16 bits) randomly assigned to the device on this Zigbee network PowerSource true = the device is connected to a power source false = the device runs on battery ReceiveWhenIdle true = the device can receive commands when idle false = the device is not listening. Commands should be sent when the device reconnects and is idle Security Security capability (meaning unknown, to be determined) Pairing Devices ~ When you create a new Zigbee network, it contains no devices except the coordinator (your Zigbee gateway). The first step is to add devices to the network, which is called pairing . By default, and for security reasons, the Zigbee coordinator does not automatically accept new devices. To pair new devices, use ZbPermitJoin 1 or press Permit Join in the WebUI and allows accepting new devices for the next 60 seconds. Then put your Zigbee device pairing mode. This is usually accomplished by pressing the button on the device for 5 seconds or more. ZbPermitJoin 1 CMD : ZbPermi t Joi n 1 MQT : s tat /% t opic%/RESULT = { \"ZbPermitJoin\" : \"Done\" } MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 21 , \"Message\" : \"Enable Pairing mode for 60 seconds\" }} 60 seconds later: MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 20 , \"Message\" : \"Disable Pairing mode\" }} After the device has successfully paired it will be shown in the webui with its short address and its link quality number (LQI). When it is a battery powered device, the battery percentage will be displayed as soon as it is received from the device. Devices will show friendly name once you set it. Setting Friendly Name ~ Instead of a short address like 0x8F20 you can assign a, memorable, friendly name such as \"Bedroom_Sensor\" . See ZbName command for all options. Xiaomi Aqara Cube with address 0x128F MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"0x128F\" :{ \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 162 , \"AqaraAccelerometer\" :[ -690 , 2 , 138 ], \"AqaraAngles\" :[ -78 , 0 , 11 ], \"LinkQuality\" : 158 }}} Setting its friendly name to Vibration_sensor : ZbName 0 x 128 F , Vibra t io n _se ns or CMD : ZbName 0 x 128 F , Vibra t io n _se ns or MQT : s tat /% t opic%/RESULT = { \"0x128F\" :{ \"Name\" : \"Vibration_sensor\" }} ( 10 seco n ds la ter ) ZIG : Zigbee Devices Da ta s t ore i n Flash ( 0 x 402 FF 800 - 270 by tes ) Now the sensor readings includes the friendly name: MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"0x128F\" :{ \"Name\" : \"Vibration_sensor\" , \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 171 , \"AqaraAccelerometer\" :[ -691 , 12 , 130 ], \"AqaraAngles\" :[ -78 , 1 , 11 ], \"LinkQuality\" : 153 }}} If you set SetOption83 1 sensor readings will use the friendly name as JSON key, short address is added as Device : MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"Vibration_sensor\" :{ \"Device\" : \"0x128F\" , \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 171 , \"AqaraAccelerometer\" :[ -691 , 8 , 136 ], \"AqaraAngles\" :[ -78 , 1 , 11 ], \"LinkQuality\" : 153 }}} Removing Devices ~ A zigbee will continue to connect to a coordinator unless you ask it to \"leave\" or if you change the network configuration (change of PanID or network key - which means losing ALL devices). To ask a device to leave the network, use command ZbLeave <device> or ZbLeave <friendlyname> . This sends a message to the device, which needs to be awake to process it. For battery powered devices, you need to wake them up when sending this command. Unfortunately there is no confirmation message sent back. Note: even if the device left the network, it is still registered in Z2T and continues to appear on the UI. To remove it from the list, use ZbForget below. To remove a device from Zigbee2Tasmota list of devices and from the UI, use command ZbForget <device> or ZbForget <friendlyname> . If the device is still connected to the network, it will pop up again later. I.e. ZbForget does not remove a device from the network; else use ZbLeave above. Advanced topic: Device Information ~ You can get a quick list of Zigbee devices with the command ZbStatus . Example: 18 : 30 : 58.972 CMD : ZbS tatus 18 : 30 : 58.980 MQT : s tat /xxx/RESULT = { \"ZbStatus1\" :[{ \"Device\" : \"0xECD0\" , \"Name\" : \"IKEA_Bulb\" },{ \"Device\" : \"0x8959\" , \"Name\" : \"Plug\" }]} You can use the command ZbInfo . to display all information, endpoints and last knwon values for main attributes. There are variants in the commands arguments: - ZbInfo (no arg): lists all known device one after the other - ZbInfo 0xECD0 : show information of a device by short address - Zbinfo IKEA_Bulb : show information of a device by friendly name - Zbinfo 0x90FD9FFFFE03B051 : show information of a device by long address (IEEE address) - ZbInfo 1 , ZbInfo 2 ... iterate through devices in sequence ZbInfo does not query the device, it only shows the last known state of the device from Tasmota memory Example: 18 : 38 : 51.523 CMD : zbi nf o 18 : 38 : 51.532 MQT : tele /xxx/SENSOR = { \"ZbInfo\" :{ \"0xECD0\" :{ \"Device\" : \"0xECD0\" , \"Name\" : \"IKEA_Bulb\" , \"IEEEAddr\" : \"0x90FD9FFFFE03B051\" , \"ModelId\" : \"TRADFRI bulb E27 WS opal 980lm\" , \"Manufacturer\" : \"IKEA of Sweden\" , \"Endpoints\" :[ 1 ], \"Config\" :[ \"O01\" , \"L01.2\" ], \"Power\" : 1 , \"Dimmer\" : 160 , \"X\" : 30138 , \"Y\" : 26909 , \"CT\" : 350 , \"ColorMode\" : 2 , \"RGB\" : \"FFC773\" , \"RGBb\" : \"A17E49\" , \"Reachable\" : true , \"LastSeen\" : 353 , \"LastSeenEpoch\" : 1658349178 , \"LinkQuality\" : 79 }}} 18 : 38 : 51.570 MQT : tele /xxxx/SENSOR = { \"ZbInfo\" :{ \"0x8959\" :{ \"Device\" : \"0x8959\" , \"Name\" : \"Plug\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" :[ 3 ], \"Config\" :[ \"L03.0\" , \"O03\" ], \"Dimmer\" : 254 , \"Power\" : 0 , \"Reachable\" : false , \"LastSeen\" : 16607299 , \"LastSeenEpoch\" : 1641742232 , \"LinkQuality\" : 147 }}} (formatted for readability) 18 : 38 : 51.532 MQT : tele /xxx/SENSOR = { \"ZbInfo\" : { \"0xECD0\" : { \"Device\" : \"0xECD0\" , \"Name\" : \"IKEA_Bulb\" , \"IEEEAddr\" : \"0x90FD9FFFFE03B051\" , \"ModelId\" : \"TRADFRI bulb E27 WS opal 980lm\" , \"Manufacturer\" : \"IKEA of Sweden\" , \"Endpoints\" : [ 1 ], \"Config\" : [ \"O01\" , \"L01.2\" ], \"Power\" : 1 , \"Dimmer\" : 160 , \"X\" : 30138 , \"Y\" : 26909 , \"CT\" : 350 , \"ColorMode\" : 2 , \"RGB\" : \"FFC773\" , \"RGBb\" : \"A17E49\" , \"Reachable\" : true , \"LastSeen\" : 353 , \"LastSeenEpoch\" : 1658349178 , \"LinkQuality\" : 79 } } } 18 : 38 : 51.570 MQT : tele /xxxx/SENSOR = { \"ZbInfo\" : { \"0x8959\" : { \"Device\" : \"0x8959\" , \"Name\" : \"Plug\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" : [ 3 ], \"Config\" : [ \"L03.0\" , \"O03\" ], \"Dimmer\" : 254 , \"Power\" : 0 , \"Reachable\" : false , \"LastSeen\" : 145 , \"LastSeenEpoch\" : 1641742232 , \"LinkQuality\" : 147 } } } Most common attributes: Attribute Description Device Zigbee device short address Name Friendly name IEEEAddr Zigbee device long address (does not change after new pairing) ModelID Zigbee Model name as configured by manufacturer (cannot be changed) Manufacturer Manufacturer name Endpoints List of endpoints Config (used internaly) (attributes) attributes tracked by Z2T LastSeen Number of seconds since the last message was received LastSeenEpoch Timestamp when the last message was received [LinkQuality Radio power of the last message received Advanced topic: Sending sensor values to separated MQTT topics ~ It is possible to publish the sensor values to their own MQTT topic. For this functionality the following rule can be applied in the console: Rule<x> on zbreceived#<zigbee_id>#<zigbee_sensorname> do publish home/zigbee/<zigbee_name>/<sensorname> %value% endon Rule<x> 1 For example: Rule1 on zbreceived#0xAA7C#humidity do publish home/zigbee/office/humidity %value% endon on zbreceived#0xAA7C#temperature do publish home/zigbee/office/temperature %value% endon Rule1 1 If retained values are prefered use publish2 instead of publish. Understanding Zigbee messages ~ There are 2 main types of Zigbee messages, commands and reaading/writing attributes . For example, you can send a command \"Power\":1 to turn a bulb on or \"Power\":0 to turn it off. Simultaneously you can read the \"Power\" attribute to know the state of the bulb. Some attribuutes are writable, but this corresponds to a change of configuration of the device. You generally can't change the status of a device writing to attributes, you need to use commands instead. Internally, Zigbee uses low-level identifiers and Z2T provides human readable versions for the main attributes and commands. In the example above, although the command and the attribute have the same name \"Power\" , they have different low-lever identifiers. Operations on attributes and commands ~ Below are the possible Zigbee messages (we consider here messages between the coordinator and the Zigbee device): Read attribute(s) : send a 'read-attribute' message to the Zigbee device, the device then responds with the value of the attributes it supports. Ex: read the current brightness of a bulb or a sensor. ZbSend {\"Device\":\"<device>\", \"Read\":{...}} Write attribute(s) : send a 'write-attribute' message to the Zigbee device with a value, the device confirms or sends an error. Ex: change the sensitivity of an illuminance sensor. ZbSend {\"Device\":\"<device>\", \"Write\":{...}} Report attribute(s) : Zigbee device may spontaneously report attributes without polling. This happens typically with sensors. New attribute values are sent after a certain time or when the value changes above a threshold. Send a command : send a command to a Zigbee device, ex: turn on a bulb, change its color... ZbSend {\"Device\":\"<device>\", \"Send\":{...}} Receive a command : Zigbee device may send commands to the coordinator. (less frequent). Ex: an alarm sensor sends an 'Intruder Alert' command to the coordinator. When a command is sent or an attribute is written to a device, the device may or may not acknowledge. However it will always report an error if the message is malformed or if some attributes/commands are not supported. Sleeping devices ~ Devices connected to mains (smart plugs, smart bulbs...) are always reachable and can accept Zigbee messages at any time. Devices that are powered by batteries, are not always reachable. Most of the time they are in sleep mode and not reachable. They regularly connect back to the coordinator to send new values and get messages (ex: once per hour). When you need to send messages to battery-powered devices, you must first wake them up, for ex pressing on a button. They device may stay awake for a couple of seconds so you must send the message just before or just after pressing the button on the device. Advanced topic: Endpoints and Clusters ~ An endpoint supports different functions separated in clusters and a device can have multiple endpoints to do different things. To simplify, think of your Zigbee device as a normal Tasmota device with a Zigbee radio instead of Wi-Fi. Each endpoint is akin to a GPIO that has connected Components or Clusters, in Zigbee terms. Cluster definitions in relation to their endpoint are determined by Zigbee Alliance . Not all manufacturers followed the proposed allocations but in general it is a cornerstone document. Z2T will automatically take the first endpoint in the list which works most of the time. You normally don't need to specify the endpoint number. In rare cases, you can force a specific endpoint. Reading Sensors ~ Most sensors will publish their readings regularly or once a significant change has happened: temperature, pressure, humidity, presence, illuminance... Sensor messages are published via MQTT when they are received from the Zigbee device. Similar to Zigbee2MQTT, Z2T tries to group and debounce sensor values when they are received within a 350ms window (can be change with USE_ZIGBEE_COALESCE_ATTR_TIMER compile option). Aqara Temperature & Humidity Sensor This sensor monitors humidity, temperature, and air pressure. Its Zigbee model ID is lumi.weather . This device publishes sensor values roughly every hour or when a change occurs. You can also force an update pressing the device's button. It sends two kinds of messages, either 3x standard Zigbee messages, or a single proprietary message containing all sensor values. 0x8F20 is the ShortAddress of the sensor, and its name is Kitchen if you used ZbName 0x8F20,Kithchen . MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" : { \"0x8F20\" : { \"Name\" : \"Kitchen\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} or prefixed by name if you set SetOption83 1 MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Topic is device specific, to allow more effective retained messages, if you set SetOption89 1 MQT : tele /% t opic%/ 8 F 20 /SENSOR = { \"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Supported values: Field name Value LinkQuality Stength of the Zigbee signal, between 1 and 254 (integer). See this ZigBee and WiFi Coexistence Humidity Humidity in percentage (float) Pressure and PressureUnit Atmospheric pressure (float) and unit (string) Currently only hPa (A.K.A. mbar) is supported Temperature Temperature in Celsius (float) Voltage Battery voltage (float) Battery Battery charge in percentage (integer) ModelId Model name of the Zigbee device (string) Ex: lumi.weather ScaledValue and Scale Give the raw measure and the scale correction as 10^scale And many more... If a value is not decoded, it will appear as \"<cluster>_<attr>\":<value> where <cluster> is the Zigbee ZCL Cluster of the attribute (family), <attr> is the attribute number and <value> its published value. Example \"0402_0000\":2240 is attribute 0x0000 from cluster 0x0402, which is the temperature in hundredth of \u00b0C. It is automatically converted to \"Temperature\":22.40 . Sending Device Commands ~ You can send commands to a device or groups of devices similar to a normal Tasmota command. For example to turn on a light or switch off a plug. Here is a list of supported commands, see below how to send any unlisted command. Command Parameters Cluster number Power 1 or true or \"true\" or \"on\" : On 0 or false or \"false\" or \"off\" : Off 2 or \"toggle\" : Toggle 0x0006 Dimmer 0..254 : Dimmer value 255 is normally considered as invalid, and may be converted to 254 0x0008 DimmerUp : no parameter. Increases dimmer by 10% 0x0008 DimmerDown : no parameter. Decreases dimmer by 10% 0x0008 DimmerStop : no parameter. Stops any running increase of decrease of dimmer. 0x0008 ResetAlarm <alarmcode>,<clusterid> : (to be documented later) 0x0009 ResetAllAlarms : no parameter, (to be documented later) 0x0009 Hue 0..254 : change Hue value 0x0300 Sat 0..254 : change Sat value 0x0300 HueSat 0..254,0..254 : change both Hue and Sat values 0x0300 Color 0..65534,0..65534 : change the color using [x,y] coordinates 0x0300 CT 0..65534 : change the white color-temperature in mireds 0x0300 Shutter 0..254 : send any Shutter command (prefer the commands below) 0x0102 ShutterOpen : no parameter, open shutter 0x0102 ShutterClose : no parameter, close shutter 0x0102 ShutterStop : no parameter, stop shutter movement 0x0102 ShutterLift 0..100 : move shutter to a specific position in percent 0 %=open, 100 %=closed 0x0102 ShutterTilt 0..100 : move the shutter to the specific tilt position in percent 0x0102 The format of the command is following: ZbSend {\"Device\":\"<device>\",\"Send\":{\"<sendcmd>\":<sendparam>}} where <device> identifies the target and can be a shortaddr 0x1234 , a longaddr 0x1234567812345678 or a friendly name Kitchen . \u2003 \"<sendcmd>\":<sendparam> is the command and its parameters from the table. If the device has been correctly paired and its endpoints recorded by Z2T, you shouldn't need to specify a target endpoint. You can use an option \"endpoint\":<endpoint> parameter if Z2T can't find the correct endpoint or if you want to change from the default endpoint. MQTT command example Topic = cmnd/ZigbeeGateway/ZbSend Payload = {\"Device\":\"0x1234\",\"Send\":{\"Power\":0}} or {\"Device\":\"0x1234\",\"Write\":{\"Power\":0}} Low-level Commands ~ There is a special syntax if you want to send arbitrary commands: \"Send\":\"<send_bytes>\" where <send_bytes> has the following syntax: \"<cluster>_<cmd>/<bytes>\" : send a non-cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example ZbSend {\"Device\":\"0x1234\",\"Send\":\"0000_00/0500\"} Send a Read command (0x00) to the general cluster (0x0000) for attribute ManufId (0x0005). Note: all values are little-endian. Or use '!' instead of '_' to specify cluster-specific commands: \"<cluster>!<cmd>/<bytes>\" : send a cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example ZbSend {\"Device\":\"0x1234\",\"Send\":\"0008!04/800A00\"} Send a Dimmer command (0x04) from Level Control cluster (0x0008) with payload being: Dimmer value 0x80, and transition time of 1 second (0x000A = 10 tenths of seconds). Of course the latter example could be simply: ZbSend {\"Device\":\"0x1234\",\"Send\":{\"Dimmer\":\"0x80\"} Examples ~ Plug ~ ZbSe n d { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : \"On\" } } ZbSe n d { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : 1 } } ZbSe n d { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : false } } ZbSe n d { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : \"Toggle\" } } Read the On/Off status: (all three commands below are synonyms) ZbSe n d { \"device\" : \"0x4773\" , \"endpoint\" : \"0x03\" , \"cluster\" : \"0x0006\" , \"read\" : \"0x0000\" } ZbSe n d { \"device\" : \"0x4773\" , \"endpoint\" : \"0x03\" , \"cluster\" : \"0x0006\" , \"read\" :[ \"0x0000\" ] } ZbSe n d { \"device\" : \"0x4773\" , \"endpoint\" : 3 , \"cluster\" : 6 , \"read\" : 0 } MQT : tele / tas mo ta /SENSOR = { \"ZbReceived\" :{ \"0x4773\" :{ \"Power\" : true , \"LinkQuality\" : 52 }}} Bulb ~ ZbSe n d { \"device\" : \"0x3D82\" , \"send\" :{ \"Power\" : \"Off\" } } ZbSe n d { \"device\" : \"0x3D82\" , \"send\" :{ \"Dimmer\" : 128 } } ZbSe n d { \"device\" : \"0x3D82\" , \"send\" :{ \"Dimmer\" : 254 } } ZbSe n d { \"device\" : \"0x3D82\" , \"endpoint\" : \"0x0B\" , \"send\" :{ \"Dimmer\" : 0 } } Receiving Commands ~ If you pair devices such as switches or remotes, you will also receive commands from those devices. When a command is received, attributes are published both in their low-level and high-level formats (if known). Low level format is the following: \"<cluster>!<cmd>\":\"<payload\" IKEA On/Off Switch {\"ZbReceived\":{\"0x3476\":{\"Device\":\"0x3476\",\"Name\":\"ikea_switch\",\"0006!01\":\"\",\"Power\":1,\"Endpoint\":1,\"LinkQuality\":134}}} The command received \"0006!01\":\"\" is Power On (0x01) from On/Off cluster (0x0006) with no payload. It is also translated as \"Power\":1 . \"Endpoint\":1 tells you from which endpoint the command was sent. Light State Tracking ~ Once Z2T receives a command related to a light (Power, Dimmer, Color, ColorTemp), it sends right after a Read command to get the actual state of the light. This is used for Hue Emulation and Alexa support. The final attributes are read betwenn 200ms and 1000ms later, to allow for the light to achieve its target state. Example 16 : 02 : 04 MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_remote\" :{ \"Device\" : \"0xF72F\" , \"0006!02\" : \"\" , \"Power\" : 2 , \"Endpoint\" : 1 , \"Group\" : 100 , \"LinkQuality\" : 75 }}} 16 : 02 : 05 MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"Power\" : true , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} 16 : 02 : 06 MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_remote\" :{ \"Device\" : \"0xF72F\" , \"0008!06\" : \"002B0500\" , \"DimmerUp\" : true , \"Endpoint\" : 1 , \"Group\" : 100 , \"LinkQuality\" : 75 }}} 16 : 02 : 08 MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"Dimmer\" : 102 , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Example ~ Ikea Tradfri Remote received commands: Short press center button - \"0006!02\":\"\" and \"Power\":2 Short press dimmer up - \"0008!06\":\"002B0500\" and \"DimmerUp\":true Short press dimmer down - \"0008!02\":\"012B05000000\" and \"DimmerStep\":1 Short press arrow right - \"0005!07\":\"00010D00\" and \"ArrowClick\":0 Short press arrow left - \"0xF72F\",\"0005!07\":\"01010D00\" and \"ArrowClick\":1 Long press dimmer up - \"0008!05\":\"0054\" and \"DimmerMove\":0 Long press dimmer up release - \"0008!07\":\"\" and \"DimmerStop\":true Long press dimmer down - \"0008!01\":\"01540000\" and \"DimmerMove\":1 Long press dimmer down release - ,\"0008!03\":\"0000\" and \"DimmerStop\":true Zigbee Binding ~ Binding allows a device to send command to another device in the same Zigbee network, without any additional logic. For example, you can set a remote to control directly a group of lights, without any rules on the coordinator. The coordinator will still receive all commands. Example of direct binding ZbBind {\"Device\":\"0xC2EF\",\"ToDevice\":\"0x5ADF\",\"Endpoint\":1,\"ToEndpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off cluster) frome endpoint 1 to the target device 0x5ADF on endpoint 1 . Example of group binding ZbBind {\"Device\":\"0xC2EF\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off clustre) and from endpoint 1 to the group 100 . Reponse in case of success MQT : tele /% t opic%/RESULT = { \"ZbBind\" :{ \"Device\" : \"0xF72F\" , \"Name\" : \"IKEA_Remote\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} Example: IKEA remote and IKEA Light ~ IKEA remotes only support 1 group and can be linked to a light only via group numbers (no direct binding). Add the light to group 100 ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"AddGroup\":100}} Bind the remote to group 100. Note: you need to press a button on the remote right before sending this command to make sure it's not in sleep mode ZbBind {\"Device\":\"IKEA_Remote\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} Zigbee Groups ~ Zigbee has a unique feature call Groups. It allows you to send a single command to a group of devices. For example: a remote can control a group of multiple lights when grouped. Zigbee groups are 16 bits arbitrary numbers that you can freely assign. When you send to a group, you don't specify a target address anymore, nor an endpoint. Groups works in two steps: first you add devices to groups, second you send commands to groups. See Zigbee Binding on how to configure a remote to send commands to a specific group. Configuring groups for devices requires to send commands. Make sure the device is powered and awake (wake-up battery powered devices). List all groups for a device ~ ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"GetAllGroups\":true}} MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<02\" : \"FF00\" , \"GetGroupCapacity\" : 255 , \"GetGroupCount\" : 0 , \"GetGroup\" :[], \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} The following response tells you: \"GetGroupCount\":1 the light belongs to one group \"GetGroup\":[100] and the group number is 100 . MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<02\" : \"FF016400\" , \"GetGroupCapacity\" : 255 , \"GetGroupCount\" : 1 , \"GetGroup\" :[ 100 ], \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Assign a group to a device ~ ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"AddGroup\":100}} MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<00\" : \"006400\" , \"AddGroup\" : 100 , \"AddGroupStatus\" : 0 , \"AddGroupStatusMsg\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Or if the group already exists: MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<00\" : \"8A6400\" , \"AddGroup\" : 100 , \"AddGroupStatus\" : 138 , \"AddGroupStatusMsg\" : \"DUPLICATE_EXISTS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Remove a group ~ ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"RemoveGroup\":100}} MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<03\" : \"006400\" , \"RemoveGroup\" : 100 , \"RemoveGroupStatus\" : 0 , \"RemoveGroupStatusMsg\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} or if the group does not exist MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<03\" : \"8B6400\" , \"RemoveGroup\" : 100 , \"RemoveGroupStatus\" : 139 , \"RemoveGroupStatusMsg\" : \"NOT_FOUND\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Remove all groups ~ ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"RemoveAllGroups\":true}} MQT : tele /% t opic%/SENSOR = { \"ZbResponse\" :{ \"Device\" : \"0x5ADF\" , \"Name\" : \"IKEA_Light\" , \"Command\" : \"0004!04\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }} Sending commands to a group ~ Just use the attribute \"Group\":<group_id> instead of \"Device\":<device> when sending a command. Example: power on all light in group 100: ZbSend {\"group\":100,\"Send\":{\"Power\":1}} set all dimmers in group 100 to 50%: ZbSend {\"group\":100,\"Send\":{\"Dimmer\":127}} Zigbee and Hue Emulation for Alexa ~ Z2T now supports Hue Emulation for Zigbee lights. It will mimic most of Zigbee gateways, and allows you to control Zigbee lights directly with Alexa, without any MQTT broker nor Alexa skill. Command ZbLight configures a Zigbee device to be Alexa controllable. Specify the number of channels the light supports: 0 Simple On/Off light 1 White Light with Dimmer 2 White Light with Dimmer and Cold/Warm White 3 RGB Light 4 RGBW Light 5 RGBCW Light, RGB and Cold/Warm White To set the light, use ZbLight <device>,<nb_of_channels . Ex: ZbLight 0x1234 , 2 ZbLight Kitchen_Light , 1 ( see ZbName ) Once a light is declared, Z2T will monitor any change made to the light via Z2T or via remotes, either from a direct message or via a group message. Z2T will then send a read command to the light, between 200ms and 1000ms later, and memorize the last value. To read the last known status of a light, use ZbLight <device> Example ZbLight Kitchen_Light MQT : s tat /% t opic%/RESULT = { \"ZbLight\" :{ \"Kitchen_Light\" :{ \"Device\" : \"0x5ADF\" , \"Light\" : 2 , \"Power\" : 0 , \"Dimmer\" : 130 , \"Colormode\" : 2 , \"CT\" : 350 }}} Specific Device Configuration ~ If your device pairs successfully with Zigbee2Tasmota but doesn't report on standardised endpoints you will see messages similar to: {\"ZbReceived\":{\"0x099F\":{\"0500!00\":\"010000FF0000\",\"LinkQuality\":70}}} {\"ZbReceived\":{\"0x7596\":{\"0006!01\":\"\",\"LinkQuality\":65}}} In this case you will have to use rules or an external home automation solution to parse those messages. The following section will focus only on rules to utilize the device inside Tasmota ecosystem. Aqara Water Leak Sensor ~ \"ModelId\":\"lumi.sensor_wleak.aq1\" In this example sensor reports on 0x099F and sends an mqtt message to topic stat/leak_sensor/LEAK : Rule on ZbReceived # 0x099F # 0500 ! 00 = 010000 FF0000 do publish stat / leak_sensor / LEAK ON endon on ZbReceived # 0x099F # 0500 ! 00 = 000000 FF0000 do publish stat / leak_sensor / LEAK OFF endon Aqara Vibration Sensor ~ \"ModelId\":\"lumi.vibration.aq1\" To modify sensor sensitivity use command. Replace \"device\" with your own device name: # for high sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x01\" }} # for medium sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x0B\" }} # for low sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x15\" }} Command needs to be issued shortly after pressing the device button. There will be no response to the command but you can check if the new option is active by using ZbSend { \"Device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Read\" : \"0xFF0D\" } Received response will be : { \"ZbReceived\" : { \"vibration\" : { \"Device\" : \"0x0B2D\" , \"Name\" : \"vibration\" , \"0000/FF0D\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 72 }}} \"0000/FF0D\" is the key, value 1 is high sensitivity, 11 medium and 21 is low. Osram/Ledvance Smart+ Switch Mini ~ \"ModelId\":\"Lightify Switch Mini\" To pair the Smart+ Switch Mini with the Bridge you need to hold Arrow Up and Middel Button for 3 Seconds. Each Button is linked to another Endpoint. Arrow Up is Endpoint 1, Arrow Down is Endpoint 2 and Middle Button is Endpoint 3. To link the Smart+ Switch Mini with IKEA Tradfri dimmable lights i used the followin commands The IKEA light needs to be Group 100 for this example. # for Power On and Power Off ZbBind { \"Device\" : \"Name\" , \"ToGroup\" : 100 , \"Endpoint\" : 1 , \"Cluster\" : 6 } ZbBind { \"Device\" : \"Name\" , \"ToGroup\" : 100 , \"Endpoint\" : 2 , \"Cluster\" : 6 } # for dimming ZbBind { \"Device\" : \"Name\" , \"ToGroup\" : 100 , \"Endpoint\" : 1 , \"Cluster\" : 8 } ZbBind { \"Device\" : \"Name\" , \"ToGroup\" : 100 , \"Endpoint\" : 2 , \"Cluster\" : 8 } Sandy Beach/Tuya Thermostatic Radiator Valve (TS0601) ~ To pair the TRV to the Bridge you need to press and hold the Auto/Manual (8 o'clock position) and the Comfort/Energy Saving (4 o'clock position) buttons at the same time until the signal indicator flashes. The Bridge will then automatically find the following useful parameters Ambient temperature (C) (LocalTemperature) Temperature set point (C) (TuyaTempTarget) Valve position (0-100%) (TuyaValvePosition) To set the Temperature Set Point use ZbSend { \"Device\" : \"0xXXXX\" , \"Write\" : { \"TuyaTempTarget\" :XX }} The 'Device' can be the DeviceID 0x0000 or the ZbName so if a device has been named ZbName 0x1234 , Utility ZbSend { \"Device\" : \"0x1234\" , \"Write\" : { \"TuyaTempTarget\" : 20 }} and ZbSend { \"Device\" : \"Utility\" , \"Write\" : { \"TuyaTempTarget\" : 20 }} will set the TRV setpoint to 20C. Other commands will be available and will be added when clarified Zigbee2Tasmota Status Codes ~ You can inspect the log output to determine whether Zigbee2Tasmota started correctly. Zigbee2Tasmota sends several status messages to inform the MQTT host about initialization. { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} Status contains a numeric code about the status message 0 : initialization complete, Zigbee2Tasmota is running normally 1 : booting 2 : resetting CC2530 configuration 3 : starting Zigbee coordinator 20 : disabling Permit Join 21 : allowing Permit Join for 60 seconds 22 : allowing Permit Join until next boot 30 : Zigbee device connects or reconnects 31 : Received Node Descriptor information for a Zigbee device 32 : Received the list of active endpoints for a Zigbee device 33 : Received the simple Descriptor with active ZCL clusters for a Zigbee device 50 : reporting CC2530 firmware version 51 : reporting CC2530 device information and associated devices 98 : error, unsupported CC2530 firmware 99 : general error, Zigbee2Tasmota was unable to start Message (optional) a human-readable message other fields depending on the message (e.g., Status= 50 or Status= 51 ) Zigbee Internals ~ If you want a more technical explanation on how all this works read Zigbee-Internals","title":"Zigbee"},{"location":"Zigbee/#hardware","text":"Zigbee2Tasmota (Z2T) supports a wide variety of Zigbee MCUs from Texas Instruments (CC253X, CC26x2, CC13x2) and from Silicon Labs (EFR32MG12/EFRMG21), and runs on ESP8266 or any variant of ESP32. Since ESP8266 has very limited resources, we strongly advise to prefer ESP32 based Zigbee gateways. Flashing and installation instructions for ESP32 based: Sonoff Zigbee Bridge Pro ZB-GW03 eWeLink Ethernet Zigbee Gateway (also sold as EACHEN Zigbee Smart Hub and SmartWise Zigbee Bridge Pro) Tube's Ethernet Zigbee Gateway (EFR32 varient) DIY Zigbee gateway/bridge device example based on Ebyte E180-ZG120B or E180-ZG120B-TB Flashing and installation instructions for ESP8266 based: Sonoff ZBBridge by ITead CC2530 based devices DIY Zigbee gateway/bridge device example based on IKEA TR\u00c5DFRI ICC-A-1 Module A complete list of compatible Zigbee coordinators and Zigbee devices compatible with Z2T is in the Zigbee Device Compatibility Repository .","title":"Hardware"},{"location":"Zigbee/#advanced-topic-znp-or-ezsp","text":"Z2T supports MCU running either the ZNP or EZSP zigbee stack. They require different compilation options but from a user point of view the features are very similar. Z-Stack or ZNP (Zigbee Network Processor) is an open-source Zigbee stack from Texas Instruments and run TI MCUs. Ready to use firmwares are found on Koenkk's Github . Older CC2530 require special wiring or external devices for flashing, while more recent like Sonoff Zigbee Bridge Pro (CC2652P) can be flashed directly from Tasmota. Z2T supports ZNP version 2.6 (Z-Stack 1.3) and version 2.7 (Z-Stack 3.x). EZSP (EmberZNet Serial Protocol) is a commercial Zigbee stack from Silicon Labs . Sonoff/Eachen require encrypted signed firmwares, they can be found in here . Z2T supports EZSP versions 6.7.6 or above (EZSP protocol v8), recommended is v6.7.9 .","title":"Advanced topic: ZNP or EZSP"},{"location":"Zigbee/#introduction","text":"Before using Zigbee with Tasmota, you need to understand a few concepts. Here is a simplified comparison to the Wi-Fi equivalent (sort of). Zigbee concept Wi-Fi equivalent Zigbee coordinator The coordinator is responsible for selecting the channel, PanID, security policy, and stack profile for a network. Zigbee2Tasmota will act as a coordinator. You can have multiple coordinators as long as they have different PanIDs. Wi-Fi Access Point PanID (Personal Area Network IDentifier) This parameter is unique in a Zigbee network (16-bit integer, 0x0000\u20130x3FFF). At initial start a pseudo-random PanID is derived from the ESP MAC address. SSID (the Wi-Fi network name) ShortAddr Address of the device on the Zigbee network. This address is randomly assigned when the device first connects to the coordinator (16 bits integer, 0x0000\u20130xFFF7). The coordinator has address 0x0000. You need to track which device has which address or assign a \"Friendly Name\" to each new discovered device. IP address GroupAddr Group address of a collection of devices, it allows a single message to address multiple devices at once (16 bits integer, 0x0000\u20130xFFFF). For example a remote can turn on/off a group of lights. GroupAddr 0x0000 is not assigned. Multicast Endpoint The endpoint on the coordinator or on the Zigbee device the message is sent from/to. You can see endpoints as logical device providing distinct features (8 bits integer, 1\u2013240). IP Port IEEEAddr Device hardware address (64 bits). This is unique per device and factory assigned. MAC address Channel 11-26 Default: 11 (See Zigbee-Wifi coexistence ) Wi-Fi Channel Encryption Key 128-bit encryption key. At initial start a pesudo-random Encryption key is derived from the ESP MAC address. Wi-Fi password Pairing By default the coordinator does not accept new devices unless put in pairing mode. When in pairing mode, it will accept pairing requests from any device within range. Default: pairing disabled WPS Cluster Clusters are a group of commands and attributes that define what a device can do. Think of clusters as a group of actions by function. A device can support multiple clusters to do a whole variety of tasks. The majority of clusters are defined by the ZigBee Alliance and listed in the ZigBee Cluster Library","title":"Introduction"},{"location":"Zigbee/#configuration","text":"","title":"Configuration"},{"location":"Zigbee/#initial-start","text":"When you first start Z2T, pseudo-random parameters are derived from your device unique identifiers (MAC address...) for PanID and network encryption keys. Sonoff Zigbee Bridge Pro (ESP32 + CC2652P with ZNP) 19 : 02 : 20.659 ZIG : reboo t i n g ZNP device 19 : 02 : 22.960 ZbI n pu t discardi n g by te 00 19 : 02 : 22.962 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CCxxxx ZNP booted\" , \"RestartReason\" : \"Power-up\" , \"MajorRel\" : 2 , \"MinorRel\" : 7 }} 19 : 02 : 23.160 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 7 , \"MaintRel\" : 1 , \"Revision\" : 20220219 }} 19 : 02 : 23.311 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 2 , \"Message\" : \"Resetting configuration\" }} 19 : 02 : 25.359 ZbI n pu t discardi n g by te 00 19 : 02 : 25.911 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} 19 : 02 : 30.062 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 40 , \"NewState\" : 9 , \"Message\" : \"Started as coordinator\" }} 19 : 02 : 30.162 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B0026B684E4\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} 19 : 02 : 30.713 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} 19 : 02 : 30.715 ZIG : Zigbee s tarte d 19 : 02 : 30.720 ZIG : No Zigbee device i nf orma t io n 19 : 02 : 30.732 ZIG : Zigbee device da ta i n File Sys te m ( 31 by tes ) Sonoff Zigbee Bridge (ESP8266 + EFR32 with EZSP) 19 : 08 : 26.057 ZIG : Rese tt i n g EZSP device 19 : 08 : 27.261 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"EFR32 EZSP booted\" , \"RestartReason\" : \"Power-on\" , \"Code\" : 2 }} 19 : 08 : 27.315 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 55 , \"Version\" : \"6.7.8.0\" , \"Protocol\" : 8 , \"Stack\" : 2 }} 19 : 08 : 27.316 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} 19 : 08 : 28.758 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 56 , \"IEEEAddr\" : \"0x680AE2FFFE6E103B\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 1 }} 19 : 08 : 28.759 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 2 , \"Message\" : \"Resetting configuration\" }} 19 : 08 : 44.260 ZIG : Rese tt i n g EZSP device 19 : 08 : 45.463 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"EFR32 EZSP booted\" , \"RestartReason\" : \"Power-on\" , \"Code\" : 2 }} 19 : 08 : 45.518 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 55 , \"Version\" : \"6.7.8.0\" , \"Protocol\" : 8 , \"Stack\" : 2 }} 19 : 08 : 45.520 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} 19 : 08 : 46.822 ZIG : Fac t ory rese t EZSP device 19 : 08 : 47.053 ZIG : Subscribe t o group 0 'ZbLis ten 0 0 ' 19 : 08 : 47.108 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} 19 : 08 : 47.108 ZIG : Zigbee s tarte d 19 : 08 : 47.138 ZIG : No Zigbee device i nf orma t io n 19 : 08 : 47.145 ZIG : No Zigbee device da ta When you further restart, logs are slightly shorter (less lines) since the MCU is already configured.","title":"Initial start"},{"location":"Zigbee/#customize-zigbee-configuration","text":"At initial start, Tasmota generates pseudo-random Zigbee parameters. They should work out of the box but you also may want to choose different values: You the command ZbConfig to dump the current configuration. For example it might return {\"ZbConfig\":{\"Channel\":11,\"PanID\":\"0x1A63\",\"ExtPanID\":\"0xCCCCCCCCCCCCCCCC\",\"KeyL\":\"0x0F0D0B0907050301\",\"KeyH\":\"0x0D0C0A0806040200\"}} To apply a new configuration, populate the fields you want to change in a single-level JSON: ZbConfig {\"Channel\":11,\"PanID\":\"0x1A63\",\"ExtPanID\":\"0xCCCCCCCCCCCCCCCC\",\"KeyL\":\"0x0F0D0B0907050301\",\"KeyH\":\"0x0D0C0A0806040200\"} !!! info \"Changing any parameter with ZbConfig requires to re-pair all devices. Parameter Description Channel 11-26 Zigbee radio channel, see above PanID 0x0001-0x3FFF unique Zigbee network identifier. You should not have too coordinator using the same PanID, or bad things happen. If your coordinator fails to start, try changing the PanID as it may conflict with one already in use. ExtPanID This is a 64 bit unique identifier for the network. It is not much used in Z2T but needs to be unique. KeyL KeyH This is the 128 bit network encryption key split into High and Low 64 bit parts. Do not reveal this key or anyone can decrypt your Zigbee traffic TxRadio On some devices you can set the radio power in dBm. You generally don't need to change it","title":"Customize Zigbee configuration"},{"location":"Zigbee/#advanced-topic-gpios","text":"You will usually find a ready to use template in the Zigbee Device Compatibility Repository Below are the details for GPIO configuration needed by Zigbee: GPIO Description Zigbee Tx and Zigbee Rx GPIOs used for serial communication between Tasmota and the MCU (needed for both ZNP and EZSP). Communication is always 115200 bps 8N1. Zigbee Rst 1 (optional) defines the hardware Reset for the Zigbee MCU. If not defined, Z2T will fallback to sending a soft-reset the MCU using a special serial sequence (which may fail on rare occasions). Zigbee Rst 2 (optional) defines a special pin used to put the MCU in bootloader and flashing mode when the hardware reset is pulled down. This is used both by EFR32 and CC2652P based devices. It allows to flash the MCU directly from Tasmota. LedLink or LedLink_i (optional) when defined, this led keeps its normal Wifi/MQTT status indicator (blinking) and adds a glowing light when Permit Join is active (i.e. new devices are allowed to pair). Led 1 or Led_i 1 (optional) when defined, is used as an indicator of traffic between Tasmota and MCU, which generally means Zigbee traffic is sent or received","title":"Advanced topic: GPIOs"},{"location":"Zigbee/#advanced-topic-hardware-or-software-serial","text":"On ESP32 serial is always handled by hardware so you don't need to bother. On ESP8266 using the hardware serial is preferred. To do so, you need to use GPIOs 13/15 for Zigbee Rx/Tx and set SerialLog 0 . Doing such, Z2T 'steals' the hardware UART from the serial console and uses it for communicating with the MCU. Otherwise Z2T uses Software Serial which requires compiling at 160MHz and might be unreliable on very rare occasions.","title":"Advanced topic: Hardware or Software serial"},{"location":"Zigbee/#usage","text":"For a list of available commands see Zigbee Commands .","title":"Usage"},{"location":"Zigbee/#quick-start","text":"In this section, we'll give a quick overview of 2 devices: Sonoff SNZB-02 Temperature And Humidity Sensor BlitzWolf SHP15 Power Monitoring Plug","title":"Quick start"},{"location":"Zigbee/#sonoff-snzb-02-sensor","text":"Put Z2T in pairing mode (command zbpermitjoin 1 or via WebUI) and keep the button of the sensor for 5 seconds. Wait a for 20 seconds, you should see something similar in the logs: 17 : 07 : 53.015 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 34 , \"IEEEAddr\" : \"0x00124B001F841E41\" , \"ShortAddr\" : \"0x2916\" , \"ParentNetwork\" : \"0x0000\" }} 17 : 07 : 53.465 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x00124B001F841E41\" , \"ShortAddr\" : \"0x2916\" , \"PowerSource\" : false , \"ReceiveWhenIdle\" : false , \"Security\" : false }} 17 : 07 : 54.565 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 32 , \"ActiveEndpoints\" :[ \"0x01\" ]}} 17 : 07 : 55.037 ZIG : Zigbee Devices Da ta saved i n File Sys te m ( 18 by tes ) 17 : 07 : 55.168 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"ModelId\" : \"TH01\" , \"Manufacturer\" : \"eWeLink\" , \"Endpoint\" : 1 , \"LinkQuality\" : 120 }}} 17 : 07 : 56.667 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 33 , \"Device\" : \"0x2916\" , \"Endpoint\" : \"0x01\" , \"ProfileId\" : \"0x0104\" , \"DeviceId\" : \"0x0302\" , \"DeviceVersion\" : 0 , \"InClusters\" :[ \"0x0000\" , \"0x0003\" , \"0x0402\" , \"0x0405\" , \"0x0001\" ], \"OutClusters\" :[ \"0x0003\" ]}} 17 : 07 : 57.241 ZIG : Zigbee Devices Da ta saved i n File Sys te m ( 29 by tes ) 17 : 07 : 58.667 ZIG : au t o - bi n d `ZbBi n d { \"Device\" : \"0x2916\" , \"Endpoint\" : 1 , \"Cluster\" : \"0x0001\" } ` 17 : 07 : 59.217 RSL : RESULT = { \"ZbBind\" :{ \"Device\" : \"0x2916\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} 17 : 08 : 00.717 ZIG : au t o - bi n d `ZbBi n d { \"Device\" : \"0x2916\" , \"Endpoint\" : 1 , \"Cluster\" : \"0x0402\" } ` 17 : 08 : 01.018 RSL : RESULT = { \"ZbBind\" :{ \"Device\" : \"0x2916\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} 17 : 08 : 02.669 ZIG : au t o - bi n d `ZbBi n d { \"Device\" : \"0x2916\" , \"Endpoint\" : 1 , \"Cluster\" : \"0x0405\" } ` 17 : 08 : 03.618 RSL : RESULT = { \"ZbBind\" :{ \"Device\" : \"0x2916\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} 17 : 08 : 04.670 ZIG : au t o - bi n d `ZbSe n d { \"Device\" : \"0x2916\" , \"Config\" :{ \"BatteryVoltage\" :{ \"MinInterval\" : 3600 , \"MaxInterval\" : 14400 , \"ReportableChange\" : 0.2 }, \"BatteryPercentage\" :{ \"MinInterval\" : 3600 , \"MaxInterval\" : 14400 , \"ReportableChange\" : 5 }}} ` 17 : 08 : 05.271 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"ConfigResponse\" :{}, \"Endpoint\" : 1 , \"LinkQuality\" : 123 }}} 17 : 08 : 06.670 ZIG : au t o - bi n d `ZbSe n d { \"Device\" : \"0x2916\" , \"Config\" :{ \"Temperature\" :{ \"MinInterval\" : 30 , \"MaxInterval\" : 3600 , \"ReportableChange\" : 0.5 }}} ` 17 : 08 : 06.871 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"ConfigResponse\" :{}, \"Endpoint\" : 1 , \"LinkQuality\" : 120 }}} 17 : 08 : 08.670 ZIG : au t o - bi n d `ZbSe n d { \"Device\" : \"0x2916\" , \"Config\" :{ \"Humidity\" :{ \"MinInterval\" : 30 , \"MaxInterval\" : 3600 , \"ReportableChange\" : 1 }}} ` 17 : 08 : 09.421 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"ConfigResponse\" :{}, \"Endpoint\" : 1 , \"LinkQuality\" : 120 }}} 17 : 08 : 14.221 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"Temperature\" : 25.72 , \"Humidity\" : 47.73 , \"Endpoint\" : 1 , \"LinkQuality\" : 116 }}} These logs are quite rich and we'll dive into the details later. Basically it says that the device paired succesfully and is configured. Next step is setting a friendly name with zbname 0x2916,SNZB-02 17 : 09 : 27.294 CMD : zb na me 0 x 2916 , SNZB -02 17 : 09 : 27.297 RSL : RESULT = { \"0x2916\" :{ \"Name\" : \"SNZB-02\" }} 17 : 09 : 29.375 ZIG : Zigbee Devices Da ta saved i n File Sys te m ( 37 by tes ) The device will regularly report readings like this: 17 : 09 : 44.351 RSL : SENSOR = { \"ZbReceived\" :{ \"0x2916\" :{ \"Device\" : \"0x2916\" , \"Name\" : \"SNZB-02\" , \"Temperature\" : 26.27 , \"Endpoint\" : 1 , \"LinkQuality\" : 105 }}} Information is also displayed in the WebUI. When you hover the arrow on the name, you get additional information like short-address and manufacturer. When you hover over the battery icon, you get a more precise reading.","title":"Sonoff SNZB-02 Sensor"},{"location":"Zigbee/#blitzwolf-shp15-plug","text":"Put Z2T in pairing mode (command zbpermitjoin 1 or via WebUI) and keep the button of the sensor for 5 seconds. Wait a for 20 seconds, you should see something similar in the logs: 16 : 17 : 40.804 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 34 , \"IEEEAddr\" : \"0x842E14FFFE13A51E\" , \"ShortAddr\" : \"0x7120\" , \"ParentNetwork\" : \"0x0000\" }} 16 : 17 : 40.854 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x842E14FFFE13A51E\" , \"ShortAddr\" : \"0x7120\" , \"PowerSource\" : true , \"ReceiveWhenIdle\" : true , \"Security\" : false }} 16 : 17 : 41.003 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 32 , \"ActiveEndpoints\" :[ \"0x01\" ]}} 16 : 17 : 41.408 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"ModelId\" : \"TS0121\" , \"Manufacturer\" : \"_TZ3000_g5xawfcq\" , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} 16 : 17 : 42.655 RSL : RESULT = { \"ZbState\" :{ \"Status\" : 33 , \"Device\" : \"0x7120\" , \"Endpoint\" : \"0x01\" , \"ProfileId\" : \"0x0104\" , \"DeviceId\" : \"0x0051\" , \"DeviceVersion\" : 1 , \"InClusters\" :[ \"0x0000\" , \"0x0004\" , \"0x0005\" , \"0x0006\" , \"0x0702\" , \"0x0B04\" ], \"OutClusters\" :[ \"0x0019\" , \"0x000A\" ]}} 16 : 17 : 43.442 ZIG : Zigbee Devices Da ta saved i n File Sys te m ( 40 by tes ) 16 : 17 : 44.516 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Power\" : 1 , \"0006/4001\" : 0 , \"0006/4002\" : 0 , \"0006/8001\" : 1 , \"0006/8002\" : 2 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} 16 : 17 : 44.664 ZIG : au t o - bi n d `ZbBi n d { \"Device\" : \"0x7120\" , \"Endpoint\" : 1 , \"Cluster\" : \"0x0006\" } ` 16 : 17 : 44.863 RSL : RESULT = { \"ZbBind\" :{ \"Device\" : \"0x7120\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} 16 : 17 : 46.466 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"EnergyTotal\" : \"0x000000000000\" , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} 16 : 17 : 46.664 ZIG : au t o - bi n d `ZbSe n d { \"Device\" : \"0x7120\" , \"Config\" :{ \"Power\" :{ \"MinInterval\" : 1 , \"MaxInterval\" : 3600 }}} ` 16 : 17 : 46.916 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"ConfigResponse\" :{}, \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} 16 : 17 : 47.815 ZIG : Au t o - respo n der : ZbSe n d { \"Device\" : \"0x7120\" , \"Cluster\" : \"0x000A\" , \"Endpoint\" : 1 , \"Response\" : \"000A/0007\" : 711476267 } 16 : 17 : 47.819 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Cluster\" : 10 , \"Read\" :[ 7 ], \"ReadNames\" :{ \"LocalTime\" : true }, \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} Again lots of lines we'll not explore for now. You can turn on the plug: zbsend {\"device\":\"SHP15\",\"send\":{\"power\":true}} 16 : 24 : 24.208 RSL : RESULT = { \"ZbSend\" : \"Done\" } 16 : 24 : 25.005 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} You can turn off the plug: (you can use \"powe\"\":0 or \"power\":false ) zbsend {\"device\":\"SHP15\",\"send\":{\"power\":0}} 16 : 24 : 01.456 RSL : RESULT = { \"ZbSend\" : \"Done\" } 16 : 24 : 02.252 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 0 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} You can read the current state : (you can use \"power\":1 or \"power\":true ) zbsend {\"device\":\"SHP15\",\"read\":{\"power\":true}} 16 : 24 : 45.265 RSL : RESULT = { \"ZbSend\" : \"Done\" } 16 : 24 : 45.815 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} You can read the current power : (here 0W) zbsend {\"device\":\"SHP15\",\"read\":{\"activepower\":true}} 16 : 29 : 17.309 RSL : RESULT = { \"ZbSend\" : \"Done\" } 16 : 29 : 17.860 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"ActivePower\" : 0 , \"Endpoint\" : 1 , \"LinkQuality\" : 229 }}} When you directly turn on or off the plug with its button, it also spontaneously report the changes: 16 : 29 : 45.660 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 0 , \"Endpoint\" : 1 , \"LinkQuality\" : 218 }}} 16 : 29 : 52.460 RSL : SENSOR = { \"ZbReceived\" :{ \"0x7120\" :{ \"Device\" : \"0x7120\" , \"Name\" : \"SHP15\" , \"Power\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 218 }}} The WebUI is also reporting the last known values:","title":"BlitzWolf SHP15 Plug"},{"location":"Zigbee/#advanced-topic-logs-when-pairing","text":"This is an example of a pairing process for the Aqara Temperature & Humidity Sensor . To pair this sensor, issue ZbPermitJoin 1 and then press and hold the reset button for 5 seconds. The sensor LED will flash several times and you will see log entries in the console, especially this one: MQT : tele /% t opic%/SENSOR = { \"ZbState\" :{ \"Status\" : 30 , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ShortAddr\" : \"0x8F20\" , \"PowerSource\" : false , \"ReceiveWhenIdle\" : false , \"Security\" : false }} Message with \"Status\":30 shows some characteristics of the device: Field name Value Status 30 indicates a device connect or reconnect. This is the opportunity to match IEEEAddress and short address IEEEAddr Long unique address (64 bits) of the device - factory set ShortAddr Short address (16 bits) randomly assigned to the device on this Zigbee network PowerSource true = the device is connected to a power source false = the device runs on battery ReceiveWhenIdle true = the device can receive commands when idle false = the device is not listening. Commands should be sent when the device reconnects and is idle Security Security capability (meaning unknown, to be determined)","title":"Advanced topic: logs when pairing"},{"location":"Zigbee/#pairing-devices","text":"When you create a new Zigbee network, it contains no devices except the coordinator (your Zigbee gateway). The first step is to add devices to the network, which is called pairing . By default, and for security reasons, the Zigbee coordinator does not automatically accept new devices. To pair new devices, use ZbPermitJoin 1 or press Permit Join in the WebUI and allows accepting new devices for the next 60 seconds. Then put your Zigbee device pairing mode. This is usually accomplished by pressing the button on the device for 5 seconds or more. ZbPermitJoin 1 CMD : ZbPermi t Joi n 1 MQT : s tat /% t opic%/RESULT = { \"ZbPermitJoin\" : \"Done\" } MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 21 , \"Message\" : \"Enable Pairing mode for 60 seconds\" }} 60 seconds later: MQT : tele /% t opic%/RESULT = { \"ZbState\" :{ \"Status\" : 20 , \"Message\" : \"Disable Pairing mode\" }} After the device has successfully paired it will be shown in the webui with its short address and its link quality number (LQI). When it is a battery powered device, the battery percentage will be displayed as soon as it is received from the device. Devices will show friendly name once you set it.","title":"Pairing Devices"},{"location":"Zigbee/#setting-friendly-name","text":"Instead of a short address like 0x8F20 you can assign a, memorable, friendly name such as \"Bedroom_Sensor\" . See ZbName command for all options. Xiaomi Aqara Cube with address 0x128F MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"0x128F\" :{ \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 162 , \"AqaraAccelerometer\" :[ -690 , 2 , 138 ], \"AqaraAngles\" :[ -78 , 0 , 11 ], \"LinkQuality\" : 158 }}} Setting its friendly name to Vibration_sensor : ZbName 0 x 128 F , Vibra t io n _se ns or CMD : ZbName 0 x 128 F , Vibra t io n _se ns or MQT : s tat /% t opic%/RESULT = { \"0x128F\" :{ \"Name\" : \"Vibration_sensor\" }} ( 10 seco n ds la ter ) ZIG : Zigbee Devices Da ta s t ore i n Flash ( 0 x 402 FF 800 - 270 by tes ) Now the sensor readings includes the friendly name: MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"0x128F\" :{ \"Name\" : \"Vibration_sensor\" , \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 171 , \"AqaraAccelerometer\" :[ -691 , 12 , 130 ], \"AqaraAngles\" :[ -78 , 1 , 11 ], \"LinkQuality\" : 153 }}} If you set SetOption83 1 sensor readings will use the friendly name as JSON key, short address is added as Device : MQT : tele /% t opic%/RESULT = { \"ZbReceived\" :{ \"Vibration_sensor\" :{ \"Device\" : \"0x128F\" , \"AqaraVibrationMode\" : \"tilt\" , \"AqaraVibrationsOrAngle\" : 171 , \"AqaraAccelerometer\" :[ -691 , 8 , 136 ], \"AqaraAngles\" :[ -78 , 1 , 11 ], \"LinkQuality\" : 153 }}}","title":"Setting Friendly Name"},{"location":"Zigbee/#removing-devices","text":"A zigbee will continue to connect to a coordinator unless you ask it to \"leave\" or if you change the network configuration (change of PanID or network key - which means losing ALL devices). To ask a device to leave the network, use command ZbLeave <device> or ZbLeave <friendlyname> . This sends a message to the device, which needs to be awake to process it. For battery powered devices, you need to wake them up when sending this command. Unfortunately there is no confirmation message sent back. Note: even if the device left the network, it is still registered in Z2T and continues to appear on the UI. To remove it from the list, use ZbForget below. To remove a device from Zigbee2Tasmota list of devices and from the UI, use command ZbForget <device> or ZbForget <friendlyname> . If the device is still connected to the network, it will pop up again later. I.e. ZbForget does not remove a device from the network; else use ZbLeave above.","title":"Removing Devices"},{"location":"Zigbee/#advanced-topic-device-information","text":"You can get a quick list of Zigbee devices with the command ZbStatus . Example: 18 : 30 : 58.972 CMD : ZbS tatus 18 : 30 : 58.980 MQT : s tat /xxx/RESULT = { \"ZbStatus1\" :[{ \"Device\" : \"0xECD0\" , \"Name\" : \"IKEA_Bulb\" },{ \"Device\" : \"0x8959\" , \"Name\" : \"Plug\" }]} You can use the command ZbInfo . to display all information, endpoints and last knwon values for main attributes. There are variants in the commands arguments: - ZbInfo (no arg): lists all known device one after the other - ZbInfo 0xECD0 : show information of a device by short address - Zbinfo IKEA_Bulb : show information of a device by friendly name - Zbinfo 0x90FD9FFFFE03B051 : show information of a device by long address (IEEE address) - ZbInfo 1 , ZbInfo 2 ... iterate through devices in sequence ZbInfo does not query the device, it only shows the last known state of the device from Tasmota memory Example: 18 : 38 : 51.523 CMD : zbi nf o 18 : 38 : 51.532 MQT : tele /xxx/SENSOR = { \"ZbInfo\" :{ \"0xECD0\" :{ \"Device\" : \"0xECD0\" , \"Name\" : \"IKEA_Bulb\" , \"IEEEAddr\" : \"0x90FD9FFFFE03B051\" , \"ModelId\" : \"TRADFRI bulb E27 WS opal 980lm\" , \"Manufacturer\" : \"IKEA of Sweden\" , \"Endpoints\" :[ 1 ], \"Config\" :[ \"O01\" , \"L01.2\" ], \"Power\" : 1 , \"Dimmer\" : 160 , \"X\" : 30138 , \"Y\" : 26909 , \"CT\" : 350 , \"ColorMode\" : 2 , \"RGB\" : \"FFC773\" , \"RGBb\" : \"A17E49\" , \"Reachable\" : true , \"LastSeen\" : 353 , \"LastSeenEpoch\" : 1658349178 , \"LinkQuality\" : 79 }}} 18 : 38 : 51.570 MQT : tele /xxxx/SENSOR = { \"ZbInfo\" :{ \"0x8959\" :{ \"Device\" : \"0x8959\" , \"Name\" : \"Plug\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" :[ 3 ], \"Config\" :[ \"L03.0\" , \"O03\" ], \"Dimmer\" : 254 , \"Power\" : 0 , \"Reachable\" : false , \"LastSeen\" : 16607299 , \"LastSeenEpoch\" : 1641742232 , \"LinkQuality\" : 147 }}} (formatted for readability) 18 : 38 : 51.532 MQT : tele /xxx/SENSOR = { \"ZbInfo\" : { \"0xECD0\" : { \"Device\" : \"0xECD0\" , \"Name\" : \"IKEA_Bulb\" , \"IEEEAddr\" : \"0x90FD9FFFFE03B051\" , \"ModelId\" : \"TRADFRI bulb E27 WS opal 980lm\" , \"Manufacturer\" : \"IKEA of Sweden\" , \"Endpoints\" : [ 1 ], \"Config\" : [ \"O01\" , \"L01.2\" ], \"Power\" : 1 , \"Dimmer\" : 160 , \"X\" : 30138 , \"Y\" : 26909 , \"CT\" : 350 , \"ColorMode\" : 2 , \"RGB\" : \"FFC773\" , \"RGBb\" : \"A17E49\" , \"Reachable\" : true , \"LastSeen\" : 353 , \"LastSeenEpoch\" : 1658349178 , \"LinkQuality\" : 79 } } } 18 : 38 : 51.570 MQT : tele /xxxx/SENSOR = { \"ZbInfo\" : { \"0x8959\" : { \"Device\" : \"0x8959\" , \"Name\" : \"Plug\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" : [ 3 ], \"Config\" : [ \"L03.0\" , \"O03\" ], \"Dimmer\" : 254 , \"Power\" : 0 , \"Reachable\" : false , \"LastSeen\" : 145 , \"LastSeenEpoch\" : 1641742232 , \"LinkQuality\" : 147 } } } Most common attributes: Attribute Description Device Zigbee device short address Name Friendly name IEEEAddr Zigbee device long address (does not change after new pairing) ModelID Zigbee Model name as configured by manufacturer (cannot be changed) Manufacturer Manufacturer name Endpoints List of endpoints Config (used internaly) (attributes) attributes tracked by Z2T LastSeen Number of seconds since the last message was received LastSeenEpoch Timestamp when the last message was received [LinkQuality Radio power of the last message received","title":"Advanced topic: Device Information"},{"location":"Zigbee/#advanced-topic-sending-sensor-values-to-separated-mqtt-topics","text":"It is possible to publish the sensor values to their own MQTT topic. For this functionality the following rule can be applied in the console: Rule<x> on zbreceived#<zigbee_id>#<zigbee_sensorname> do publish home/zigbee/<zigbee_name>/<sensorname> %value% endon Rule<x> 1 For example: Rule1 on zbreceived#0xAA7C#humidity do publish home/zigbee/office/humidity %value% endon on zbreceived#0xAA7C#temperature do publish home/zigbee/office/temperature %value% endon Rule1 1 If retained values are prefered use publish2 instead of publish.","title":"Advanced topic: Sending sensor values to separated MQTT topics"},{"location":"Zigbee/#understanding-zigbee-messages","text":"There are 2 main types of Zigbee messages, commands and reaading/writing attributes . For example, you can send a command \"Power\":1 to turn a bulb on or \"Power\":0 to turn it off. Simultaneously you can read the \"Power\" attribute to know the state of the bulb. Some attribuutes are writable, but this corresponds to a change of configuration of the device. You generally can't change the status of a device writing to attributes, you need to use commands instead. Internally, Zigbee uses low-level identifiers and Z2T provides human readable versions for the main attributes and commands. In the example above, although the command and the attribute have the same name \"Power\" , they have different low-lever identifiers.","title":"Understanding Zigbee messages"},{"location":"Zigbee/#operations-on-attributes-and-commands","text":"Below are the possible Zigbee messages (we consider here messages between the coordinator and the Zigbee device): Read attribute(s) : send a 'read-attribute' message to the Zigbee device, the device then responds with the value of the attributes it supports. Ex: read the current brightness of a bulb or a sensor. ZbSend {\"Device\":\"<device>\", \"Read\":{...}} Write attribute(s) : send a 'write-attribute' message to the Zigbee device with a value, the device confirms or sends an error. Ex: change the sensitivity of an illuminance sensor. ZbSend {\"Device\":\"<device>\", \"Write\":{...}} Report attribute(s) : Zigbee device may spontaneously report attributes without polling. This happens typically with sensors. New attribute values are sent after a certain time or when the value changes above a threshold. Send a command : send a command to a Zigbee device, ex: turn on a bulb, change its color... ZbSend {\"Device\":\"<device>\", \"Send\":{...}} Receive a command : Zigbee device may send commands to the coordinator. (less frequent). Ex: an alarm sensor sends an 'Intruder Alert' command to the coordinator. When a command is sent or an attribute is written to a device, the device may or may not acknowledge. However it will always report an error if the message is malformed or if some attributes/commands are not supported.","title":"Operations on attributes and commands"},{"location":"Zigbee/#sleeping-devices","text":"Devices connected to mains (smart plugs, smart bulbs...) are always reachable and can accept Zigbee messages at any time. Devices that are powered by batteries, are not always reachable. Most of the time they are in sleep mode and not reachable. They regularly connect back to the coordinator to send new values and get messages (ex: once per hour). When you need to send messages to battery-powered devices, you must first wake them up, for ex pressing on a button. They device may stay awake for a couple of seconds so you must send the message just before or just after pressing the button on the device.","title":"Sleeping devices"},{"location":"Zigbee/#advanced-topic-endpoints-and-clusters","text":"An endpoint supports different functions separated in clusters and a device can have multiple endpoints to do different things. To simplify, think of your Zigbee device as a normal Tasmota device with a Zigbee radio instead of Wi-Fi. Each endpoint is akin to a GPIO that has connected Components or Clusters, in Zigbee terms. Cluster definitions in relation to their endpoint are determined by Zigbee Alliance . Not all manufacturers followed the proposed allocations but in general it is a cornerstone document. Z2T will automatically take the first endpoint in the list which works most of the time. You normally don't need to specify the endpoint number. In rare cases, you can force a specific endpoint.","title":"Advanced topic: Endpoints and Clusters"},{"location":"Zigbee/#reading-sensors","text":"Most sensors will publish their readings regularly or once a significant change has happened: temperature, pressure, humidity, presence, illuminance... Sensor messages are published via MQTT when they are received from the Zigbee device. Similar to Zigbee2MQTT, Z2T tries to group and debounce sensor values when they are received within a 350ms window (can be change with USE_ZIGBEE_COALESCE_ATTR_TIMER compile option). Aqara Temperature & Humidity Sensor This sensor monitors humidity, temperature, and air pressure. Its Zigbee model ID is lumi.weather . This device publishes sensor values roughly every hour or when a change occurs. You can also force an update pressing the device's button. It sends two kinds of messages, either 3x standard Zigbee messages, or a single proprietary message containing all sensor values. 0x8F20 is the ShortAddress of the sensor, and its name is Kitchen if you used ZbName 0x8F20,Kithchen . MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" : { \"0x8F20\" : { \"Name\" : \"Kitchen\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} or prefixed by name if you set SetOption83 1 MQT : tele /% t opic%/SENSOR = { \"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Topic is device specific, to allow more effective retained messages, if you set SetOption89 1 MQT : tele /% t opic%/ 8 F 20 /SENSOR = { \"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Supported values: Field name Value LinkQuality Stength of the Zigbee signal, between 1 and 254 (integer). See this ZigBee and WiFi Coexistence Humidity Humidity in percentage (float) Pressure and PressureUnit Atmospheric pressure (float) and unit (string) Currently only hPa (A.K.A. mbar) is supported Temperature Temperature in Celsius (float) Voltage Battery voltage (float) Battery Battery charge in percentage (integer) ModelId Model name of the Zigbee device (string) Ex: lumi.weather ScaledValue and Scale Give the raw measure and the scale correction as 10^scale And many more... If a value is not decoded, it will appear as \"<cluster>_<attr>\":<value> where <cluster> is the Zigbee ZCL Cluster of the attribute (family), <attr> is the attribute number and <value> its published value. Example \"0402_0000\":2240 is attribute 0x0000 from cluster 0x0402, which is the temperature in hundredth of \u00b0C. It is automatically converted to \"Temperature\":22.40 .","title":"Reading Sensors"},{"location":"Zigbee/#sending-device-commands","text":"You can send commands to a device or groups of devices similar to a normal Tasmota command. For example to turn on a light or switch off a plug. Here is a list of supported commands, see below how to send any unlisted command. Command Parameters Cluster number Power 1 or true or \"true\" or \"on\" : On 0 or false or \"false\" or \"off\" : Off 2 or \"toggle\" : Toggle 0x0006 Dimmer 0..254 : Dimmer value 255 is normally considered as invalid, and may be converted to 254 0x0008 DimmerUp : no parameter. Increases dimmer by 10% 0x0008 DimmerDown : no parameter. Decreases dimmer by 10% 0x0008 DimmerStop : no parameter. Stops any running increase of decrease of dimmer. 0x0008 ResetAlarm <alarmcode>,<clusterid> : (to be documented later) 0x0009 ResetAllAlarms : no parameter, (to be documented later) 0x0009 Hue 0..254 : change Hue value 0x0300 Sat 0..254 : change Sat value 0x0300 HueSat 0..254,0..254 : change both Hue and Sat values 0x0300 Color 0..65534,0..65534 : change the color using [x,y] coordinates 0x0300 CT 0..65534 : change the white color-temperature in mireds 0x0300 Shutter 0..254 : send any Shutter command (prefer the commands below) 0x0102 ShutterOpen : no parameter, open shutter 0x0102 ShutterClose : no parameter, close shutter 0x0102 ShutterStop : no parameter, stop shutter movement 0x0102 ShutterLift 0..100 : move shutter to a specific position in percent 0 %=open, 100 %=closed 0x0102 ShutterTilt 0..100 : move the shutter to the specific tilt position in percent 0x0102 The format of the command is following: ZbSend {\"Device\":\"<device>\",\"Send\":{\"<sendcmd>\":<sendparam>}} where <device> identifies the target and can be a shortaddr 0x1234 , a longaddr 0x1234567812345678 or a friendly name Kitchen . \u2003 \"<sendcmd>\":<sendparam> is the command and its parameters from the table. If the device has been correctly paired and its endpoints recorded by Z2T, you shouldn't need to specify a target endpoint. You can use an option \"endpoint\":<endpoint> parameter if Z2T can't find the correct endpoint or if you want to change from the default endpoint. MQTT command example Topic = cmnd/ZigbeeGateway/ZbSend Payload = {\"Device\":\"0x1234\",\"Send\":{\"Power\":0}} or {\"Device\":\"0x1234\",\"Write\":{\"Power\":0}}","title":"Sending Device Commands"},{"location":"Zigbee/#low-level-commands","text":"There is a special syntax if you want to send arbitrary commands: \"Send\":\"<send_bytes>\" where <send_bytes> has the following syntax: \"<cluster>_<cmd>/<bytes>\" : send a non-cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example ZbSend {\"Device\":\"0x1234\",\"Send\":\"0000_00/0500\"} Send a Read command (0x00) to the general cluster (0x0000) for attribute ManufId (0x0005). Note: all values are little-endian. Or use '!' instead of '_' to specify cluster-specific commands: \"<cluster>!<cmd>/<bytes>\" : send a cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example ZbSend {\"Device\":\"0x1234\",\"Send\":\"0008!04/800A00\"} Send a Dimmer command (0x04) from Level Control cluster (0x0008) with payload being: Dimmer value 0x80, and transition time of 1 second (0x000A = 10 tenths of seconds). Of course the latter example could be simply: ZbSend {\"Device\":\"0x1234\",\"Send\":{\"Dimmer\":\"0x80\"}","title":"Low-level Commands"},{"location":"Zigbee/#examples","text":"","title":"Examples"},{"location":"Zigbee/#receiving-commands","text":"If you pair devices such as switches or remotes, you will also receive commands from those devices. When a command is received, attributes are published both in their low-level and high-level formats (if known). Low level format is the following: \"<cluster>!<cmd>\":\"<payload\" IKEA On/Off Switch {\"ZbReceived\":{\"0x3476\":{\"Device\":\"0x3476\",\"Name\":\"ikea_switch\",\"0006!01\":\"\",\"Power\":1,\"Endpoint\":1,\"LinkQuality\":134}}} The command received \"0006!01\":\"\" is Power On (0x01) from On/Off cluster (0x0006) with no payload. It is also translated as \"Power\":1 . \"Endpoint\":1 tells you from which endpoint the command was sent.","title":"Receiving Commands"},{"location":"Zigbee/#zigbee-binding","text":"Binding allows a device to send command to another device in the same Zigbee network, without any additional logic. For example, you can set a remote to control directly a group of lights, without any rules on the coordinator. The coordinator will still receive all commands. Example of direct binding ZbBind {\"Device\":\"0xC2EF\",\"ToDevice\":\"0x5ADF\",\"Endpoint\":1,\"ToEndpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off cluster) frome endpoint 1 to the target device 0x5ADF on endpoint 1 . Example of group binding ZbBind {\"Device\":\"0xC2EF\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off clustre) and from endpoint 1 to the group 100 . Reponse in case of success MQT : tele /% t opic%/RESULT = { \"ZbBind\" :{ \"Device\" : \"0xF72F\" , \"Name\" : \"IKEA_Remote\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }}","title":"Zigbee Binding"},{"location":"Zigbee/#zigbee-groups","text":"Zigbee has a unique feature call Groups. It allows you to send a single command to a group of devices. For example: a remote can control a group of multiple lights when grouped. Zigbee groups are 16 bits arbitrary numbers that you can freely assign. When you send to a group, you don't specify a target address anymore, nor an endpoint. Groups works in two steps: first you add devices to groups, second you send commands to groups. See Zigbee Binding on how to configure a remote to send commands to a specific group. Configuring groups for devices requires to send commands. Make sure the device is powered and awake (wake-up battery powered devices).","title":"Zigbee Groups"},{"location":"Zigbee/#zigbee-and-hue-emulation-for-alexa","text":"Z2T now supports Hue Emulation for Zigbee lights. It will mimic most of Zigbee gateways, and allows you to control Zigbee lights directly with Alexa, without any MQTT broker nor Alexa skill. Command ZbLight configures a Zigbee device to be Alexa controllable. Specify the number of channels the light supports: 0 Simple On/Off light 1 White Light with Dimmer 2 White Light with Dimmer and Cold/Warm White 3 RGB Light 4 RGBW Light 5 RGBCW Light, RGB and Cold/Warm White To set the light, use ZbLight <device>,<nb_of_channels . Ex: ZbLight 0x1234 , 2 ZbLight Kitchen_Light , 1 ( see ZbName ) Once a light is declared, Z2T will monitor any change made to the light via Z2T or via remotes, either from a direct message or via a group message. Z2T will then send a read command to the light, between 200ms and 1000ms later, and memorize the last value. To read the last known status of a light, use ZbLight <device> Example ZbLight Kitchen_Light MQT : s tat /% t opic%/RESULT = { \"ZbLight\" :{ \"Kitchen_Light\" :{ \"Device\" : \"0x5ADF\" , \"Light\" : 2 , \"Power\" : 0 , \"Dimmer\" : 130 , \"Colormode\" : 2 , \"CT\" : 350 }}}","title":"Zigbee and Hue Emulation for Alexa"},{"location":"Zigbee/#specific-device-configuration","text":"If your device pairs successfully with Zigbee2Tasmota but doesn't report on standardised endpoints you will see messages similar to: {\"ZbReceived\":{\"0x099F\":{\"0500!00\":\"010000FF0000\",\"LinkQuality\":70}}} {\"ZbReceived\":{\"0x7596\":{\"0006!01\":\"\",\"LinkQuality\":65}}} In this case you will have to use rules or an external home automation solution to parse those messages. The following section will focus only on rules to utilize the device inside Tasmota ecosystem.","title":"Specific Device Configuration"},{"location":"Zigbee/#aqara-water-leak-sensor","text":"\"ModelId\":\"lumi.sensor_wleak.aq1\" In this example sensor reports on 0x099F and sends an mqtt message to topic stat/leak_sensor/LEAK : Rule on ZbReceived # 0x099F # 0500 ! 00 = 010000 FF0000 do publish stat / leak_sensor / LEAK ON endon on ZbReceived # 0x099F # 0500 ! 00 = 000000 FF0000 do publish stat / leak_sensor / LEAK OFF endon","title":"Aqara Water Leak Sensor"},{"location":"Zigbee/#aqara-vibration-sensor","text":"\"ModelId\":\"lumi.vibration.aq1\" To modify sensor sensitivity use command. Replace \"device\" with your own device name: # for high sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x01\" }} # for medium sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x0B\" }} # for low sensitivity ZbSend { \"device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Write\" : { \"0000/FF0D%20\" : \"0x15\" }} Command needs to be issued shortly after pressing the device button. There will be no response to the command but you can check if the new option is active by using ZbSend { \"Device\" : \"vibration\" , \"Endpoint\" : 1 , \"Cluster\" : 0 , \"Manuf\" : \"0x115F\" , \"Read\" : \"0xFF0D\" } Received response will be : { \"ZbReceived\" : { \"vibration\" : { \"Device\" : \"0x0B2D\" , \"Name\" : \"vibration\" , \"0000/FF0D\" : 1 , \"Endpoint\" : 1 , \"LinkQuality\" : 72 }}} \"0000/FF0D\" is the key, value 1 is high sensitivity, 11 medium and 21 is low.","title":"Aqara Vibration Sensor"},{"location":"Zigbee/#osramledvance-smart-switch-mini","text":"\"ModelId\":\"Lightify Switch Mini\" To pair the Smart+ Switch Mini with the Bridge you need to hold Arrow Up and Middel Button for 3 Seconds. Each Button is linked to another Endpoint. Arrow Up is Endpoint 1, Arrow Down is Endpoint 2 and Middle Button is Endpoint 3. To link the Smart+ Switch Mini with IKEA Tradfri dimmable lights i used the followin commands The IKEA light needs to be Group 100 for this example. # for Power On and Power Off ZbBind { \"Device\" : \"Name\" , \"ToGroup\" : 100 , \"Endpoint\" : 1 , \"Cluster\" : 6 } ZbBind { \"Device\" : \"Name\" , \"ToGroup\" : 100 , \"Endpoint\" : 2 , \"Cluster\" : 6 } # for dimming ZbBind { \"Device\" : \"Name\" , \"ToGroup\" : 100 , \"Endpoint\" : 1 , \"Cluster\" : 8 } ZbBind { \"Device\" : \"Name\" , \"ToGroup\" : 100 , \"Endpoint\" : 2 , \"Cluster\" : 8 }","title":"Osram/Ledvance Smart+ Switch Mini"},{"location":"Zigbee/#sandy-beachtuya-thermostatic-radiator-valve-ts0601","text":"To pair the TRV to the Bridge you need to press and hold the Auto/Manual (8 o'clock position) and the Comfort/Energy Saving (4 o'clock position) buttons at the same time until the signal indicator flashes. The Bridge will then automatically find the following useful parameters Ambient temperature (C) (LocalTemperature) Temperature set point (C) (TuyaTempTarget) Valve position (0-100%) (TuyaValvePosition) To set the Temperature Set Point use ZbSend { \"Device\" : \"0xXXXX\" , \"Write\" : { \"TuyaTempTarget\" :XX }} The 'Device' can be the DeviceID 0x0000 or the ZbName so if a device has been named ZbName 0x1234 , Utility ZbSend { \"Device\" : \"0x1234\" , \"Write\" : { \"TuyaTempTarget\" : 20 }} and ZbSend { \"Device\" : \"Utility\" , \"Write\" : { \"TuyaTempTarget\" : 20 }} will set the TRV setpoint to 20C. Other commands will be available and will be added when clarified","title":"Sandy Beach/Tuya Thermostatic Radiator Valve (TS0601)"},{"location":"Zigbee/#zigbee2tasmota-status-codes","text":"You can inspect the log output to determine whether Zigbee2Tasmota started correctly. Zigbee2Tasmota sends several status messages to inform the MQTT host about initialization. { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} Status contains a numeric code about the status message 0 : initialization complete, Zigbee2Tasmota is running normally 1 : booting 2 : resetting CC2530 configuration 3 : starting Zigbee coordinator 20 : disabling Permit Join 21 : allowing Permit Join for 60 seconds 22 : allowing Permit Join until next boot 30 : Zigbee device connects or reconnects 31 : Received Node Descriptor information for a Zigbee device 32 : Received the list of active endpoints for a Zigbee device 33 : Received the simple Descriptor with active ZCL clusters for a Zigbee device 50 : reporting CC2530 firmware version 51 : reporting CC2530 device information and associated devices 98 : error, unsupported CC2530 firmware 99 : general error, Zigbee2Tasmota was unable to start Message (optional) a human-readable message other fields depending on the message (e.g., Status= 50 or Status= 51 )","title":"Zigbee2Tasmota Status Codes"},{"location":"Zigbee/#zigbee-internals","text":"If you want a more technical explanation on how all this works read Zigbee-Internals","title":"Zigbee Internals"},{"location":"changelog/","text":"CHANGELOG.md tracks changes after 8.5.1 Version 8.5.1 Hannah ~ Fix energy total counters #9263 , #9266 Fix crash in ZbRestore Fix reset BMP sensors when executing command SaveData and define USE_DEEPSLEEP enabled #9300 Fix status 0 message when using define USE_MQTT_TLS due to small log buffer #9305 Fix status 13 exception 9 when more than one shutter is configured Fix status 13 json message Fix Shelly 2.5 higher temperature regression from 8.2.0.1 #7991 Change replace ArduinoJson with JSMN for JSON parsing Change WakeUp uses 256 steps instead of 100 #9241 Add command SetOption110 1 to disable Zigbee auto-config when pairing new devices Add command SetOption111 1 to enable frequency output for buzzer GPIO #8994 Add command SetOption112 1 to enable friendly name in zigbee topic (use with SetOption89) Add #define USE_MQTT_AWS_IOT_LIGHT for password based AWS IoT authentication Add #define MQTT_LWT_OFFLINE and #define MQTT_LWT_ONLINE to user_config.h #9395 Add new shutter modes #9244 Add Zigbee auto-config when pairing Add support for MLX90640 IR array temperature sensor by Christian Baars Add support for VL53L1X time of flight sensor by Johann Obermeier Version 8.5.0 Hannah ~ Remove support for direct upgrade from versions before 6.6.0.11 to versions after 8.4.0.1 Change references from http://thehackbox.org/tasmota/ to http://ota.tasmota.com/tasmota/ Change triple-mode TLS via configuration in a single firmware (TLS AWS IoT, Letsencrypt and No-TLS) Change White blend mode to using command SetOption 105 instead of RGBWWTable Fix ESP32 PWM range Fix display power control #9114 Add command SetOption102 0/1 to set Baud rate for Teleinfo communication (0 = 1200 or 1 = 9600) Add command SetOption103 0/1 to set TLS mode when TLS is selected Add command SetOption104 1 to disable all MQTT retained messages Add command SetOption105 1 to enable White Blend Mode Add command SetOption106 1 to create a virtual White ColorTemp for RGBW lights Add command SetOption107 0/1 to select virtual White as (0) Warm or (1) Cold Add command SetOption108 0/1 to enable Teleinfo telemetry into Tasmota Energy MQTT (0) or Teleinfo only (1) Add command SetOption109 1 to force gen1 Alexa mode, for Echo Dot 2nd gen devices only Add command Restart 2 to halt system. Needs hardware reset or power cycle to restart #9046 Add command PowerDelta1 to PowerDelta3 to trigger on up to three phases #9134 Add Zigbee options to ZbSend Config and ReadCondig Add Zigbee better support for IKEA Motion Sensor Add Zigbee web gui widget for Battery and Temp/Humidity/Pressure sensors Add Zigbee web ui for power metering plugs Add better configuration corruption recovery #9046 Add virtual CT for 4 channels lights, emulating a 5th channel Add support for DYP ME007 ultrasonic distance sensor by Janusz Kostorz #9113 Add ESP32 Analog input support for GPIO32 to GPIO39 Add experimental support for ESP32 TTGO Watch and I2S Audio by Gerhard Mutz Version 8.4.0 George ~ BREAKING CHANGE Remove Arduino ESP8266 Core support for versions before 2.7.1 BREAKING CHANGE Change to limited support of Arduino IDE as an increasing amount of features cannot be compiled with Arduino IDE Change IRRemoteESP8266 library from v2.7.6 to v2.7.8.10, fixing Samsung and Pioneer protocols #8938 Change Adafruit_SGP30 library from v1.0.3 to v1.2.0 #8519 Change Energy JSON Total field from \"Total\":[33.736,11.717,16.978] to \"Total\":33.736,\"TotalTariff\":[11.717,16.978] Change Energy JSON ExportActive field from \"ExportActive\":[33.736,11.717,16.978] to \"ExportActive\":33.736,\"ExportTariff\":[11.717,16.978] Change ESP32 USER GPIO template representation decreasing template message size Change define USE_TASMOTA_SLAVE into USE_TASMOTA_CLIENT Change commands SlaveSend and SlaveReset into ClientSend and ClientReset Change all timer references from Arm to Enable in GUI, Timer command and JSON message BREAKING CHANGE Change Domoticz commands prefix from Domoticz to Dz Change Zigbee randomizing of parameters at first run or after Reset Fix escape of non-JSON received serial data #8329 Fix exception or watchdog on rule re-entry #8757 Add command Rule0 to change global rule parameters Add command Time 4 to display timestamp using milliseconds #8537 Add command SetOption94 0/1 to select MAX31855 or MAX6675 thermocouple support #8616 Add command SetOption97 0/1 to switch between Tuya serial speeds 9600 bps (0) or 115200 bps (1) Add command SetOption98 0/1 to provide rotary rule triggers (1) instead of controlling light (0) Add command SetOption99 0/1 to enable zero cross detection on PWM dimmer Add command SetOption100 0/1 to remove Zigbee ZbReceived value from {\"ZbReceived\":{xxx:yyy}} JSON message Add command SetOption101 0/1 to add the Zigbee source endpoint as suffix to attributes, ex Power3 instead of Power if sent from endpoint 3 Add command DzSend<type> <index>,<value1(;value2)|state> to send values or state to Domoticz Add command Module2 to configure fallback module on fast reboot #8464 Add command ( S ) SerialSend6 \\<comma seperated values> #8937 Add commands LedPwmOn 0..255 , LedPwmOff 0..255 and LedPwmMode1 0/1 to control led brightness by George #8491 Add ESP32 ethernet commands EthType 0/1 , EthAddress 0..31 and EthClockMode 0..3 Add more functionality to command Switchmode 11 and 12 #8450 Add rule trigger System#Init to allow early rule execution without wifi and mqtt initialized yet Add support for unique MQTTClient (and inherited fallback topic) by full Mac address using mqttclient DVES_%12X #8300 Add wildcard pattern ? for JSON matching in rules Add Three Phase Export Active Energy to SDM630 driver Add Zigbee options to ZbSend to write and report attributes Add Zigbee auto-responder for common attributes Add CpuFrequency to status 2 Add FlashFrequency to status 4 Add compile time interlock parameters #8759 Add compile time user template #8766 Add support for VEML6075 UVA/UVB/UVINDEX Sensor by device111 #8432 Add support for VEML7700 Ambient light intensity Sensor by device111 #8432 Add support for up to two BH1750 sensors controlled by commands BH1750Resolution and BH1750MTime #8139 Add support for up to eight MCP9808 temperature sensors by device111 #8594 Add support for BL0940 energy monitor as used in Blitzwolf BW-SHP10 #8175 Add support for Telegram bot #8619 Add support for HP303B Temperature and Pressure sensor by Robert Jaakke #8638 Add support for Energy sensor (Denky) for French Smart Metering meter provided by global Energy Providers, need a adaptater. See dedicated full blog about French teleinformation stuff Add support for ESP32 ethernet adding commands Wifi 0/1 and Ethernet 0/1 both default ON Add support for single wire LMT01 temperature Sensor by justifiably #8713 Add support for rotary encoder as light dimmer and optional color temperature if button1 still pressed #8670 Add support for switches/relays using an AC detection circuitry e.g. MOES MS-104B or BlitzWolf SS5 #8606 Add support for Schneider Electric iEM3000 series Modbus energy meter by Marius Bezuidenhout Add support for Sonoff Zigbee Bridge as module 75 #8583 Version 8.3.1 Fred ~ Change Hass discovery from using Template or Module name to new Device name #8462 Change KNX pow function to approximative pow saving 5k of code space Change Mutichannel Gas sensor pow function to approximative pow saving 5k of code space Change Quick Power Cycle detection from 4 to 7 power interrupts #4066 Fix default state of SetOption73 0 for button decoupling and send multi-press and hold MQTT messages Add command DeviceName defaults to FriendlyName1 and replaces FriendlyName1 in GUI Version 8.3.0 Fred ~ Breaking Change Device Groups multicast address and port 8270 Change PWM implementation to Arduino #7231 removing support for Core versions before 2.6.3 Change default PWM Frequency to 977 Hz from 880 Hz Change minimum PWM Frequency from 100 Hz to 40 Hz Change flash access removing support for any Core before 2.6.3 Change HM-10 sensor type detection and add features 7962 Change light scheme 2,3,4 cycle time speed from 24,48,72,... seconds to 4,6,12,24,36,48,... seconds 8034 Change remove floating point libs from IRAM Change remove MQTT Info messages on restart for DeepSleep Wake 8044 Change IRremoteESP8266 library updated to v2.7.6 Change HAss discovery by Federico Leoni 8370 Fix possible Relay toggle on (OTA) restart Fix PWM flickering during wifi connection 8046 Fix Zigbee sending wrong Sat value with Hue emulation Fix Zigbee crash with Occupancy sensor 8089 Add Zigbee command ZbRestore to restore device configuration dumped with ZbStatus 2 Add Zigbee command ZbUnbind Add Zigbee command ZbBindState and manuf attribute Add Zigbee command ZbConfig and configuration in Settings Add commands CounterDebounceLow and CounterDebounceHigh to control debouncing 8021 Add commands NrfPage , NrfIgnore , NrfScan and NrfBeacon to NRF24 Bluetooth driver 8075 Add commands GlobalTemp and GlobalHum to init sensor data 8152 Add command SO as shortcut for command SetOption Add command SetOption41 <x> to force sending gratuitous ARP every seconds Add command SetOption73 1 for button decoupling and send multi-press and hold MQTT messages by Federico Leoni 8235 Add command SetOption90 1 to disable non-json MQTT messages 8044 Add command SetOption91 1 to enable fading at startup / power on Add command SetOption92 1 to set PWM Mode from regular PWM to ColorTemp control (Xiaomi Philips ...) Add command SetOption93 1 to control caching of compressed rules Add command Sensor10 0/1/2 to control BH1750 resolution - 0 = High (default), 1 = High2, 2 = Low 8016 Add command Sensor10 31..254 to control BH1750 measurement time which defaults to 69 8016 Add command Sensor18 0..32000 to control PMS5003 sensor interval to extend lifetime by Gene Ruebsamen 8128 Add command DevGroupName to specify up to four Device Group Names 8087 Add command DevGroupSend to send an update to a Device Group 8093 Add command Ping 7176 Add command Palette to add the ability to specify a palette of colors 8150 Add support for unreachable (unplugged) Zigbee devices in Philips Hue emulation and Alexa Add support for 64x48 SSD1306 OLED 6740 Add support for Seven Segment display using HT16K33 8116 Add support for up to four MQTT GroupTopics 8014 Add support for longer template names Add support for an iAQ sensor 8107 Add support for AS3935 Lightning Sensor by device111 8130 Add console command history 7483, #8015 Add quick wifi reconnect using saved AP parameters when SetOption56 0 3189 Add more accuracy to GPS NTP server 8088 Add support for analog anemometer by Matteo Albinola 8283 Add support for OpenTherm by Yuriy Sannikov 8373 Add support for Thermostat control by arijav 8212 Add experimental basic support for Tasmota on ESP32 based on work by Joerg Schueler-Maroldt Add automatic compression of Rules to achieve ~60% compression by Stefan Hadinger Add rule trigger at root level like on loadavg<50 do power 2 endon after state command Version 8.2.0 Elliot ~ Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Changelog"},{"location":"changelog/#version-851-hannah","text":"Fix energy total counters #9263 , #9266 Fix crash in ZbRestore Fix reset BMP sensors when executing command SaveData and define USE_DEEPSLEEP enabled #9300 Fix status 0 message when using define USE_MQTT_TLS due to small log buffer #9305 Fix status 13 exception 9 when more than one shutter is configured Fix status 13 json message Fix Shelly 2.5 higher temperature regression from 8.2.0.1 #7991 Change replace ArduinoJson with JSMN for JSON parsing Change WakeUp uses 256 steps instead of 100 #9241 Add command SetOption110 1 to disable Zigbee auto-config when pairing new devices Add command SetOption111 1 to enable frequency output for buzzer GPIO #8994 Add command SetOption112 1 to enable friendly name in zigbee topic (use with SetOption89) Add #define USE_MQTT_AWS_IOT_LIGHT for password based AWS IoT authentication Add #define MQTT_LWT_OFFLINE and #define MQTT_LWT_ONLINE to user_config.h #9395 Add new shutter modes #9244 Add Zigbee auto-config when pairing Add support for MLX90640 IR array temperature sensor by Christian Baars Add support for VL53L1X time of flight sensor by Johann Obermeier","title":"Version 8.5.1 Hannah"},{"location":"changelog/#version-850-hannah","text":"Remove support for direct upgrade from versions before 6.6.0.11 to versions after 8.4.0.1 Change references from http://thehackbox.org/tasmota/ to http://ota.tasmota.com/tasmota/ Change triple-mode TLS via configuration in a single firmware (TLS AWS IoT, Letsencrypt and No-TLS) Change White blend mode to using command SetOption 105 instead of RGBWWTable Fix ESP32 PWM range Fix display power control #9114 Add command SetOption102 0/1 to set Baud rate for Teleinfo communication (0 = 1200 or 1 = 9600) Add command SetOption103 0/1 to set TLS mode when TLS is selected Add command SetOption104 1 to disable all MQTT retained messages Add command SetOption105 1 to enable White Blend Mode Add command SetOption106 1 to create a virtual White ColorTemp for RGBW lights Add command SetOption107 0/1 to select virtual White as (0) Warm or (1) Cold Add command SetOption108 0/1 to enable Teleinfo telemetry into Tasmota Energy MQTT (0) or Teleinfo only (1) Add command SetOption109 1 to force gen1 Alexa mode, for Echo Dot 2nd gen devices only Add command Restart 2 to halt system. Needs hardware reset or power cycle to restart #9046 Add command PowerDelta1 to PowerDelta3 to trigger on up to three phases #9134 Add Zigbee options to ZbSend Config and ReadCondig Add Zigbee better support for IKEA Motion Sensor Add Zigbee web gui widget for Battery and Temp/Humidity/Pressure sensors Add Zigbee web ui for power metering plugs Add better configuration corruption recovery #9046 Add virtual CT for 4 channels lights, emulating a 5th channel Add support for DYP ME007 ultrasonic distance sensor by Janusz Kostorz #9113 Add ESP32 Analog input support for GPIO32 to GPIO39 Add experimental support for ESP32 TTGO Watch and I2S Audio by Gerhard Mutz","title":"Version 8.5.0 Hannah"},{"location":"changelog/#version-840-george","text":"BREAKING CHANGE Remove Arduino ESP8266 Core support for versions before 2.7.1 BREAKING CHANGE Change to limited support of Arduino IDE as an increasing amount of features cannot be compiled with Arduino IDE Change IRRemoteESP8266 library from v2.7.6 to v2.7.8.10, fixing Samsung and Pioneer protocols #8938 Change Adafruit_SGP30 library from v1.0.3 to v1.2.0 #8519 Change Energy JSON Total field from \"Total\":[33.736,11.717,16.978] to \"Total\":33.736,\"TotalTariff\":[11.717,16.978] Change Energy JSON ExportActive field from \"ExportActive\":[33.736,11.717,16.978] to \"ExportActive\":33.736,\"ExportTariff\":[11.717,16.978] Change ESP32 USER GPIO template representation decreasing template message size Change define USE_TASMOTA_SLAVE into USE_TASMOTA_CLIENT Change commands SlaveSend and SlaveReset into ClientSend and ClientReset Change all timer references from Arm to Enable in GUI, Timer command and JSON message BREAKING CHANGE Change Domoticz commands prefix from Domoticz to Dz Change Zigbee randomizing of parameters at first run or after Reset Fix escape of non-JSON received serial data #8329 Fix exception or watchdog on rule re-entry #8757 Add command Rule0 to change global rule parameters Add command Time 4 to display timestamp using milliseconds #8537 Add command SetOption94 0/1 to select MAX31855 or MAX6675 thermocouple support #8616 Add command SetOption97 0/1 to switch between Tuya serial speeds 9600 bps (0) or 115200 bps (1) Add command SetOption98 0/1 to provide rotary rule triggers (1) instead of controlling light (0) Add command SetOption99 0/1 to enable zero cross detection on PWM dimmer Add command SetOption100 0/1 to remove Zigbee ZbReceived value from {\"ZbReceived\":{xxx:yyy}} JSON message Add command SetOption101 0/1 to add the Zigbee source endpoint as suffix to attributes, ex Power3 instead of Power if sent from endpoint 3 Add command DzSend<type> <index>,<value1(;value2)|state> to send values or state to Domoticz Add command Module2 to configure fallback module on fast reboot #8464 Add command ( S ) SerialSend6 \\<comma seperated values> #8937 Add commands LedPwmOn 0..255 , LedPwmOff 0..255 and LedPwmMode1 0/1 to control led brightness by George #8491 Add ESP32 ethernet commands EthType 0/1 , EthAddress 0..31 and EthClockMode 0..3 Add more functionality to command Switchmode 11 and 12 #8450 Add rule trigger System#Init to allow early rule execution without wifi and mqtt initialized yet Add support for unique MQTTClient (and inherited fallback topic) by full Mac address using mqttclient DVES_%12X #8300 Add wildcard pattern ? for JSON matching in rules Add Three Phase Export Active Energy to SDM630 driver Add Zigbee options to ZbSend to write and report attributes Add Zigbee auto-responder for common attributes Add CpuFrequency to status 2 Add FlashFrequency to status 4 Add compile time interlock parameters #8759 Add compile time user template #8766 Add support for VEML6075 UVA/UVB/UVINDEX Sensor by device111 #8432 Add support for VEML7700 Ambient light intensity Sensor by device111 #8432 Add support for up to two BH1750 sensors controlled by commands BH1750Resolution and BH1750MTime #8139 Add support for up to eight MCP9808 temperature sensors by device111 #8594 Add support for BL0940 energy monitor as used in Blitzwolf BW-SHP10 #8175 Add support for Telegram bot #8619 Add support for HP303B Temperature and Pressure sensor by Robert Jaakke #8638 Add support for Energy sensor (Denky) for French Smart Metering meter provided by global Energy Providers, need a adaptater. See dedicated full blog about French teleinformation stuff Add support for ESP32 ethernet adding commands Wifi 0/1 and Ethernet 0/1 both default ON Add support for single wire LMT01 temperature Sensor by justifiably #8713 Add support for rotary encoder as light dimmer and optional color temperature if button1 still pressed #8670 Add support for switches/relays using an AC detection circuitry e.g. MOES MS-104B or BlitzWolf SS5 #8606 Add support for Schneider Electric iEM3000 series Modbus energy meter by Marius Bezuidenhout Add support for Sonoff Zigbee Bridge as module 75 #8583","title":"Version 8.4.0 George"},{"location":"changelog/#version-831-fred","text":"Change Hass discovery from using Template or Module name to new Device name #8462 Change KNX pow function to approximative pow saving 5k of code space Change Mutichannel Gas sensor pow function to approximative pow saving 5k of code space Change Quick Power Cycle detection from 4 to 7 power interrupts #4066 Fix default state of SetOption73 0 for button decoupling and send multi-press and hold MQTT messages Add command DeviceName defaults to FriendlyName1 and replaces FriendlyName1 in GUI","title":"Version 8.3.1 Fred"},{"location":"changelog/#version-830-fred","text":"Breaking Change Device Groups multicast address and port 8270 Change PWM implementation to Arduino #7231 removing support for Core versions before 2.6.3 Change default PWM Frequency to 977 Hz from 880 Hz Change minimum PWM Frequency from 100 Hz to 40 Hz Change flash access removing support for any Core before 2.6.3 Change HM-10 sensor type detection and add features 7962 Change light scheme 2,3,4 cycle time speed from 24,48,72,... seconds to 4,6,12,24,36,48,... seconds 8034 Change remove floating point libs from IRAM Change remove MQTT Info messages on restart for DeepSleep Wake 8044 Change IRremoteESP8266 library updated to v2.7.6 Change HAss discovery by Federico Leoni 8370 Fix possible Relay toggle on (OTA) restart Fix PWM flickering during wifi connection 8046 Fix Zigbee sending wrong Sat value with Hue emulation Fix Zigbee crash with Occupancy sensor 8089 Add Zigbee command ZbRestore to restore device configuration dumped with ZbStatus 2 Add Zigbee command ZbUnbind Add Zigbee command ZbBindState and manuf attribute Add Zigbee command ZbConfig and configuration in Settings Add commands CounterDebounceLow and CounterDebounceHigh to control debouncing 8021 Add commands NrfPage , NrfIgnore , NrfScan and NrfBeacon to NRF24 Bluetooth driver 8075 Add commands GlobalTemp and GlobalHum to init sensor data 8152 Add command SO as shortcut for command SetOption Add command SetOption41 <x> to force sending gratuitous ARP every seconds Add command SetOption73 1 for button decoupling and send multi-press and hold MQTT messages by Federico Leoni 8235 Add command SetOption90 1 to disable non-json MQTT messages 8044 Add command SetOption91 1 to enable fading at startup / power on Add command SetOption92 1 to set PWM Mode from regular PWM to ColorTemp control (Xiaomi Philips ...) Add command SetOption93 1 to control caching of compressed rules Add command Sensor10 0/1/2 to control BH1750 resolution - 0 = High (default), 1 = High2, 2 = Low 8016 Add command Sensor10 31..254 to control BH1750 measurement time which defaults to 69 8016 Add command Sensor18 0..32000 to control PMS5003 sensor interval to extend lifetime by Gene Ruebsamen 8128 Add command DevGroupName to specify up to four Device Group Names 8087 Add command DevGroupSend to send an update to a Device Group 8093 Add command Ping 7176 Add command Palette to add the ability to specify a palette of colors 8150 Add support for unreachable (unplugged) Zigbee devices in Philips Hue emulation and Alexa Add support for 64x48 SSD1306 OLED 6740 Add support for Seven Segment display using HT16K33 8116 Add support for up to four MQTT GroupTopics 8014 Add support for longer template names Add support for an iAQ sensor 8107 Add support for AS3935 Lightning Sensor by device111 8130 Add console command history 7483, #8015 Add quick wifi reconnect using saved AP parameters when SetOption56 0 3189 Add more accuracy to GPS NTP server 8088 Add support for analog anemometer by Matteo Albinola 8283 Add support for OpenTherm by Yuriy Sannikov 8373 Add support for Thermostat control by arijav 8212 Add experimental basic support for Tasmota on ESP32 based on work by Joerg Schueler-Maroldt Add automatic compression of Rules to achieve ~60% compression by Stefan Hadinger Add rule trigger at root level like on loadavg<50 do power 2 endon after state command","title":"Version 8.3.0 Fred"},{"location":"changelog/#version-820-elliot","text":"Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Version 8.2.0 Elliot"},{"location":"nymea/","text":"nymea ~ nymea is an open source IoT platform. It can be used in various IoT applications such as smart home appliances, IoT technology gateways or general \"thing\" automation. nymea is technology agnostic and uses a plugin framework to extend functionality towards different device types, online services or data transports. Using nymea-plugin-tasmota it can also interact with tasmota based devices. nymea consists of three main parts: nymea:core, nymea:app and nymea:cloud. nymea:core is the core piece of nymea and is meant to be installed on a persistent node in your network or the internet. It connects to devices and services and manages them using automation rules. Typically, nymea:core is installed on a IoT \"box\", such as a raspberry Pi or the nymea:box, however, it can be installed on Desktop PCs (Linux based), cloud servers, VM's or any other machine running Linux. nymea hosts pre-built packages for Ubuntu and Debian GNU/Linux as well as Snap packages which can be installed on any major Linux Distribution. nymea:app is the frontend for nymea:core. It is used to configure the system as well as interact with it. It allows to control configured IoT devices, monitor states and logs and set up automation rules. nymea:cloud is the cloud connectivity suite. It is optional (nymea can work fully offline, not requiring any registration or online service at all) and extends nymea with features such as easy remote connection without having to fiddle with firewall ports and allows to send nymea:core push notifications to phones/tablets having nymea:app installed. More information about nymea can be found at the nymea website and the nymea wiki . Configuring Sonoff/Tasmota devices for use with nymea ~ Requirements ~ A working nymea installation (see nymea wiki for install instructions) A Tasmota device connected to the same network as nymea:core Once those above requirements are met, use nymea:app to add the sonoff device. Depending how you've set it up it will appear as a switch or light bulb in nymea. How does it work? ~ nymea:core features an internal MQTT broker. There is no need to set up an external MQTT broker. Also, during the setup, nymea will configure the Tasmota device. The only thing required is the IP address of the Tasmota device. Please note that for this to work the nymea internal MQTT broker needs to be enabled. This is the default setting so there should not be the need to manually configure anything unless you've previously disabled the internal MQTT broker. Support, troubleshooting, contributing ~ You are welcome to report issues and feature requests in the nymea bug trackers on nymea:core's github page and the nymea app github page as well as ask for help or just discuss about Tasmota and nymea in the nymea forum .","title":"nymea"},{"location":"nymea/#nymea","text":"nymea is an open source IoT platform. It can be used in various IoT applications such as smart home appliances, IoT technology gateways or general \"thing\" automation. nymea is technology agnostic and uses a plugin framework to extend functionality towards different device types, online services or data transports. Using nymea-plugin-tasmota it can also interact with tasmota based devices. nymea consists of three main parts: nymea:core, nymea:app and nymea:cloud. nymea:core is the core piece of nymea and is meant to be installed on a persistent node in your network or the internet. It connects to devices and services and manages them using automation rules. Typically, nymea:core is installed on a IoT \"box\", such as a raspberry Pi or the nymea:box, however, it can be installed on Desktop PCs (Linux based), cloud servers, VM's or any other machine running Linux. nymea hosts pre-built packages for Ubuntu and Debian GNU/Linux as well as Snap packages which can be installed on any major Linux Distribution. nymea:app is the frontend for nymea:core. It is used to configure the system as well as interact with it. It allows to control configured IoT devices, monitor states and logs and set up automation rules. nymea:cloud is the cloud connectivity suite. It is optional (nymea can work fully offline, not requiring any registration or online service at all) and extends nymea with features such as easy remote connection without having to fiddle with firewall ports and allows to send nymea:core push notifications to phones/tablets having nymea:app installed. More information about nymea can be found at the nymea website and the nymea wiki .","title":"nymea"},{"location":"nymea/#configuring-sonofftasmota-devices-for-use-with-nymea","text":"","title":"Configuring Sonoff/Tasmota devices for use with nymea"},{"location":"nymea/#requirements","text":"A working nymea installation (see nymea wiki for install instructions) A Tasmota device connected to the same network as nymea:core Once those above requirements are met, use nymea:app to add the sonoff device. Depending how you've set it up it will appear as a switch or light bulb in nymea.","title":"Requirements"},{"location":"nymea/#how-does-it-work","text":"nymea:core features an internal MQTT broker. There is no need to set up an external MQTT broker. Also, during the setup, nymea will configure the Tasmota device. The only thing required is the IP address of the Tasmota device. Please note that for this to work the nymea internal MQTT broker needs to be enabled. This is the default setting so there should not be the need to manually configure anything unless you've previously disabled the internal MQTT broker.","title":"How does it work?"},{"location":"nymea/#support-troubleshooting-contributing","text":"You are welcome to report issues and feature requests in the nymea bug trackers on nymea:core's github page and the nymea app github page as well as ask for help or just discuss about Tasmota and nymea in the nymea forum .","title":"Support, troubleshooting, contributing"},{"location":"openHAB/","text":"The \"open Home Automation Bus\" ( openHAB ) is an open source, technology agnostic home automation platform which runs as the center of your smart home. Besides more than 400 other add-ons for all kinds of technologies, openHAB provides an MQTT add-on (\"binding\") to interface with systems like Tasmota. By following the guide below you'll be able to observe, control and manage your Tasmota modules from your openHAB system. If you are new to openHAB, please learn about the basic concepts and the initial setup. The below article will not cover any basics which are out of scope to the Tasmota integration. Example Result: The screenshot of an openHAB Sitemap below features a few Sonoff modules for lighting, two modified Sonoff Basic with sensors for temperature and humidity readings and two Sonoff Pow for power measurements of a washing machine and dishwasher: Requirements ~ Working openHAB installation ( see documentation ) Configured Tasmota device (accessible from your local network) MQTT broker available (e.g. Eclipse Mosquitto via openHABian ) A basic understanding of MQTT Working and tested connection between openHAB and the MQTT broker (optional) Standalone MQTT client (e.g. MQTT Explorer ) to observe and identify messages on the MQTT broker If not done yet, you first need to install and activate the MQTT and the JsonPath transformation , e.g. via the openHAB Paper UI Add-ons section. MQTTv1 vs. MQTTv2 Binding Information Please note that since mqtt1 is a legacy binding for years now, it will no longer receive updates or fixes. See older version of this tutorial on how to integrate Tasmota using this binding if you are using mqtt1 - but be advised that it's not recommended anymore, it's better to upgrade to MQTTv2 binding. See openHAB announcement of MQTTv2 for details on how to change your configuration. MQTTv2 Integration ~ Configuration is split throughout some openHAB configuration files. First we need to set up a MQTT connection and Tasmota things - you will need a separate thing for every Tasmota device you use. In the example configuration you can see a non-default Full Topic definition. For your real world device simply set up items for all Tasmota MQTT topics you are interested in. Examples for most needed topics are given below, see section Discovering Interesting Topics below on how to watch the raw MQTT data. Some Tasmota topics are JSON encoded, the JSONPATH transformation can be used to extract this data. You'll need to replace the given example device topic name (e.g. \"Tasmota_TH\") by the one chosen for your module. .things File: Bridge mqtt : broker : myMQTTBroker \"My only one and best MQTT server\" [ host = \"IPofBroker\" , username = \"myUser\" , password = \"myPassword\" , clientID = \"myopenHABMQTTClient\" ] Thing mqtt : topic : tasmota : tasmota_TH \"Light_TH\" ( mqtt : broker : myMQTTBroker ) [ availabilityTopic = \"tele/tasmota_TH/LWT\" , payloadAvailable = \"Online\" , payloadNotAvailable = \"Offline\" ] { Channels : // Sonoff Basic / Sonoff S20 Smart Socket (Read and switch on-state) Type switch : PowerSwitch [ stateTopic = \"stat/tasmota_TH/POWER\" , commandTopic = \"cmnd/tasmota_TH/POWER\" , on = \"ON\" , off = \"OFF\" ] // Sonoff Pow (read current wattage; for read and switch on-state see above) Type number : Power [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.ENERGY.Power\" ] // devices including AM2301 temperature sensor Type number : Temperature [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.AM2301.Temperature\" ] // Tasmota Status Type string : Version [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] Type switch : Reachable [ stateTopic = \"tele/tasmota_TH/LWT\" , transformationPattern = \"MAP:tasmota-reachable.map\" ] // Diagnostics: Define specific for what you really need on a regular basis, use standalone MQTT client for troubleshooting Type string : RestartReason [ stateTopic = \"tele/tasmota_TH/INFO3\" , transformationPattern = \"JSONPATH:$.Info3.RestartReason\" ] // old one, have to query it Type string : Version2 [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] // new one - comes for free at startup Type string : Version [ stateTopic = \"tele/tasmota_TH/INFO1\" , transformationPattern = \"JSONPATH:$.Info1.Version\" ] Type number : RSSI [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.Wifi.RSSI\" ] Type string : WifiDowntime [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.Wifi.Downtime\" ] Type number : LoadAvg [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.LoadAvg\" ] Type number : Uptime [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.UptimeSec\" ] Type string : Result [ stateTopic = \"stat/tasmota_TH/RESULT\" ] } .items File: For every property your device exposes, you need to define an item, linked to corresponding channel of your Tasmota thing. // device specific properties Switch Switch_TH \"Switch_TH\" { channel = \"mqtt:topic:tasmota:tasmota_TH:PowerSwitch\" } Number : Temperature Switch_TH_Temp \"Temperature [%.1f \u00b0C]\" < temperature > { channel = \"mqtt:topic:tasmota:tasmota_TH:Temperature\" } Number : Power Power \"Power [%.1f W]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Power\" } // Tasmota Status String Tasmota_Version \"Tasmota Version [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Version\" , channel = \"mqtt:topic:tasmota:tasmota_TH:Version2\" } Switch Tasmota_Reachable \"Reachable\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Reachable\" } // Diagnostics String Tasmota_RestartReason \"Restart Reason [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:RestartReason\" } Number : Dimensionless Tasmota_RSSI \"Signal [%d %%]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:RSSI\" } String Tasmota_WifiDowntime \"Wifi Downtime [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:WifiDowntime\" } Number : Dimensionless Tasmota_LoadAvg \"Load [%d %%]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:LoadAvg\" } String Tasmota_Result \"Result [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Result\" } Number : Time Tasmota_Uptime \"Uptime [%.1f s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Uptime\" } // Maintenance (described below) String Tasmota_Action \"Tasmota Action\" .sitemap File: // device specific properties Switch item = Switch_TH Text item = Switch_TH_Temp Text item = Power // Maintenance Switch item = Tasmota_Action mappings = [ restart = \"Restart\" , queryFW = \"Query FW\" , upgrade = \"Upgrade FW\" ] // Tasmota Status Text item = Tasmota_Version Text item = Tasmota_Reachable // Diagnostics Text item = Tasmota_RestartReason Text item = Tasmota_RSSI Text item = Tasmota_WifiDowntime Text item = Tasmota_LoadAvg Text item = Tasmota_Uptime label = \"Uptime [%.1f d]\" Text item = Tasmota_Result The \"LWT\" topic ( \"Last Will and Testament\" ) will receive regular \"Online\" messages by the module and an \"Offline\" message a short time after the module is disconnected, generated by the MQTT broker. These messages are transformed to a valid ON / OFF state by the MAP transformation. Of course you can implement Unreachable instead of Reachable if you prefer. The following transformation file is needed: tasmota-reachable.map F\u00edle: Online = ON Offline = OFF Maintenance Actions ~ A home automation system setup would not be complete without a certain maintenance automation! Add the following elements to your openHAB setup to be able to perform actions on your Tasmota devices by the press of a simple sitemap button. The example below includes upgrading the firmware of all devices. A shoutout to @evilgreen for the idea and a big thanks to @smadds for providing the idea of a public firmware server. tasmota_maintenance.rules File for Maintenance Actions: // Work with grouptopic, addressing ALL modules at once, easiest solution val tasmota_device_ids = newArrayList ( \"tasmotas\" ) // OR // Work with a list of selected Tasmota modules //val tasmota_device_ids = newArrayList( // \"tasmota_A00EEA\", // //\u2026 add all your modules here, don't forget some! // \"tasmota_E8A6E4\" //) rule \"Tasmota Maintenance\" when Item Tasmota_Action received command then logInfo ( \"tasmota_maintenance.rules\" , \"Tasmota Maintenance on all devices: \" + receivedCommand ) val actionsBroker = getActions ( \"mqtt\" , \"mqtt:broker:MyMQTTBroker\" ) // change to your broker name! for ( String device_id : tasmota_device_ids ) { switch ( receivedCommand ) { case \"restart\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/restart\" , \"1\" ) case \"queryFW\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/status\" , \"2\" ) case \"upgrade\" : { // one could change OTA URL using MQTT but if you use different breeds (basic, ir, sensor, ...) of Tasmota, you would lose them // it's better to configure OTA url at each device (default) and just trigger upgrade - they will use OTA URL saved in your device. //actionsBroker.publishMQTT( \"cmnd/\" + device_id + \"/otaurl\", \"http://ota.tasmota.com/tasmota/release/tasmota.bin\") actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/upgrade\" , \"1\" ) } } } createTimer ( now . plusSeconds ( 1 ))[ | Tasmota_Action . postUpdate ( UNDEF )] end Comparing your device firmware with the current Tasmota GitHub Release ~ Knowing your devices firmware version(s) is good. Being able to compare it with the current release directly, is even better. You can achieve this by combining the maintenance actions with the openHAB http binding, the JsonPath transformation and the GitHub API. Just extend the maintenance setup with the following Item and config (make sure you have the binding addon http and transformation addon jsonpath installed): tasmota.things: Thing http : url : TasmotaVersion [ baseURL = \"https://api.github.com/repos/arendst/Tasmota/tags\" , refresh = 86400 ] { // refresh once a day Channels : Type string : Version \"Version\" [ stateTransformation = \"JSONPATH:$[0].name\" ] } tasmota.items: String Tasmota_Current_FW_Available \"Current Release [%s]\" { channel = \"http:url:TasmotaVersion:Version\" } With this item in your sitemap, you will now see the latest release/tag from Tasmota repository. Discovering Interesting Topics ~ Additional or further interesting topics are easily identified by reading up on the Tasmota wiki and by subscribing to the modules topics. Subscribe to all topics of one module using MQTT wildcard topic string +/tasmota_XYZ/# (string depends on your user-configured Topic/FullTopic). Configure items for the identified topics similar to the ones below. Example: MQTT messages published by a Sonoff Pow module are shown below (using mosquitto_sub ). The module reports its device state and energy readings periodically. In the second half of the example the module relay was switched into the OFF position. $ mosquitto_sub - h localhost - t \"+/tasmota_E8A6E4/#\" - v tele / tasmota - E8A6E4 / LWT Online tele / tasmota - E8A6E4 / UPTIME { \"Time\" : \"2017-07-25T12:02:00\" , \"Uptime\" : 68 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:06:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:06:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:11:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:11:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } cmnd / tasmota - E8A6E4 / POWER OFF stat / tasmota - E8A6E4 / RESULT { \"POWER\" : \"OFF\" } stat / tasmota - E8A6E4 / POWER OFF Following this method, the behavior-linked messages can be identified and bound to openHAB items. Community Forum ~ For more openHAB related details and questions, please visit the openHAB community forum thread on Sonoff and Tasmota .","title":"openHAB"},{"location":"openHAB/#requirements","text":"Working openHAB installation ( see documentation ) Configured Tasmota device (accessible from your local network) MQTT broker available (e.g. Eclipse Mosquitto via openHABian ) A basic understanding of MQTT Working and tested connection between openHAB and the MQTT broker (optional) Standalone MQTT client (e.g. MQTT Explorer ) to observe and identify messages on the MQTT broker If not done yet, you first need to install and activate the MQTT and the JsonPath transformation , e.g. via the openHAB Paper UI Add-ons section. MQTTv1 vs. MQTTv2 Binding Information Please note that since mqtt1 is a legacy binding for years now, it will no longer receive updates or fixes. See older version of this tutorial on how to integrate Tasmota using this binding if you are using mqtt1 - but be advised that it's not recommended anymore, it's better to upgrade to MQTTv2 binding. See openHAB announcement of MQTTv2 for details on how to change your configuration.","title":"Requirements"},{"location":"openHAB/#mqttv2-integration","text":"Configuration is split throughout some openHAB configuration files. First we need to set up a MQTT connection and Tasmota things - you will need a separate thing for every Tasmota device you use. In the example configuration you can see a non-default Full Topic definition. For your real world device simply set up items for all Tasmota MQTT topics you are interested in. Examples for most needed topics are given below, see section Discovering Interesting Topics below on how to watch the raw MQTT data. Some Tasmota topics are JSON encoded, the JSONPATH transformation can be used to extract this data. You'll need to replace the given example device topic name (e.g. \"Tasmota_TH\") by the one chosen for your module. .things File: Bridge mqtt : broker : myMQTTBroker \"My only one and best MQTT server\" [ host = \"IPofBroker\" , username = \"myUser\" , password = \"myPassword\" , clientID = \"myopenHABMQTTClient\" ] Thing mqtt : topic : tasmota : tasmota_TH \"Light_TH\" ( mqtt : broker : myMQTTBroker ) [ availabilityTopic = \"tele/tasmota_TH/LWT\" , payloadAvailable = \"Online\" , payloadNotAvailable = \"Offline\" ] { Channels : // Sonoff Basic / Sonoff S20 Smart Socket (Read and switch on-state) Type switch : PowerSwitch [ stateTopic = \"stat/tasmota_TH/POWER\" , commandTopic = \"cmnd/tasmota_TH/POWER\" , on = \"ON\" , off = \"OFF\" ] // Sonoff Pow (read current wattage; for read and switch on-state see above) Type number : Power [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.ENERGY.Power\" ] // devices including AM2301 temperature sensor Type number : Temperature [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.AM2301.Temperature\" ] // Tasmota Status Type string : Version [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] Type switch : Reachable [ stateTopic = \"tele/tasmota_TH/LWT\" , transformationPattern = \"MAP:tasmota-reachable.map\" ] // Diagnostics: Define specific for what you really need on a regular basis, use standalone MQTT client for troubleshooting Type string : RestartReason [ stateTopic = \"tele/tasmota_TH/INFO3\" , transformationPattern = \"JSONPATH:$.Info3.RestartReason\" ] // old one, have to query it Type string : Version2 [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] // new one - comes for free at startup Type string : Version [ stateTopic = \"tele/tasmota_TH/INFO1\" , transformationPattern = \"JSONPATH:$.Info1.Version\" ] Type number : RSSI [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.Wifi.RSSI\" ] Type string : WifiDowntime [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.Wifi.Downtime\" ] Type number : LoadAvg [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.LoadAvg\" ] Type number : Uptime [ stateTopic = \"tele/tasmota_TH/STATE\" , transformationPattern = \"JSONPATH:$.UptimeSec\" ] Type string : Result [ stateTopic = \"stat/tasmota_TH/RESULT\" ] } .items File: For every property your device exposes, you need to define an item, linked to corresponding channel of your Tasmota thing. // device specific properties Switch Switch_TH \"Switch_TH\" { channel = \"mqtt:topic:tasmota:tasmota_TH:PowerSwitch\" } Number : Temperature Switch_TH_Temp \"Temperature [%.1f \u00b0C]\" < temperature > { channel = \"mqtt:topic:tasmota:tasmota_TH:Temperature\" } Number : Power Power \"Power [%.1f W]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Power\" } // Tasmota Status String Tasmota_Version \"Tasmota Version [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Version\" , channel = \"mqtt:topic:tasmota:tasmota_TH:Version2\" } Switch Tasmota_Reachable \"Reachable\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Reachable\" } // Diagnostics String Tasmota_RestartReason \"Restart Reason [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:RestartReason\" } Number : Dimensionless Tasmota_RSSI \"Signal [%d %%]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:RSSI\" } String Tasmota_WifiDowntime \"Wifi Downtime [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:WifiDowntime\" } Number : Dimensionless Tasmota_LoadAvg \"Load [%d %%]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:LoadAvg\" } String Tasmota_Result \"Result [%s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Result\" } Number : Time Tasmota_Uptime \"Uptime [%.1f s]\" { channel = \"mqtt:topic:tasmota:tasmota_TH:Uptime\" } // Maintenance (described below) String Tasmota_Action \"Tasmota Action\" .sitemap File: // device specific properties Switch item = Switch_TH Text item = Switch_TH_Temp Text item = Power // Maintenance Switch item = Tasmota_Action mappings = [ restart = \"Restart\" , queryFW = \"Query FW\" , upgrade = \"Upgrade FW\" ] // Tasmota Status Text item = Tasmota_Version Text item = Tasmota_Reachable // Diagnostics Text item = Tasmota_RestartReason Text item = Tasmota_RSSI Text item = Tasmota_WifiDowntime Text item = Tasmota_LoadAvg Text item = Tasmota_Uptime label = \"Uptime [%.1f d]\" Text item = Tasmota_Result The \"LWT\" topic ( \"Last Will and Testament\" ) will receive regular \"Online\" messages by the module and an \"Offline\" message a short time after the module is disconnected, generated by the MQTT broker. These messages are transformed to a valid ON / OFF state by the MAP transformation. Of course you can implement Unreachable instead of Reachable if you prefer. The following transformation file is needed: tasmota-reachable.map F\u00edle: Online = ON Offline = OFF","title":"MQTTv2 Integration"},{"location":"openHAB/#maintenance-actions","text":"A home automation system setup would not be complete without a certain maintenance automation! Add the following elements to your openHAB setup to be able to perform actions on your Tasmota devices by the press of a simple sitemap button. The example below includes upgrading the firmware of all devices. A shoutout to @evilgreen for the idea and a big thanks to @smadds for providing the idea of a public firmware server. tasmota_maintenance.rules File for Maintenance Actions: // Work with grouptopic, addressing ALL modules at once, easiest solution val tasmota_device_ids = newArrayList ( \"tasmotas\" ) // OR // Work with a list of selected Tasmota modules //val tasmota_device_ids = newArrayList( // \"tasmota_A00EEA\", // //\u2026 add all your modules here, don't forget some! // \"tasmota_E8A6E4\" //) rule \"Tasmota Maintenance\" when Item Tasmota_Action received command then logInfo ( \"tasmota_maintenance.rules\" , \"Tasmota Maintenance on all devices: \" + receivedCommand ) val actionsBroker = getActions ( \"mqtt\" , \"mqtt:broker:MyMQTTBroker\" ) // change to your broker name! for ( String device_id : tasmota_device_ids ) { switch ( receivedCommand ) { case \"restart\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/restart\" , \"1\" ) case \"queryFW\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/status\" , \"2\" ) case \"upgrade\" : { // one could change OTA URL using MQTT but if you use different breeds (basic, ir, sensor, ...) of Tasmota, you would lose them // it's better to configure OTA url at each device (default) and just trigger upgrade - they will use OTA URL saved in your device. //actionsBroker.publishMQTT( \"cmnd/\" + device_id + \"/otaurl\", \"http://ota.tasmota.com/tasmota/release/tasmota.bin\") actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/upgrade\" , \"1\" ) } } } createTimer ( now . plusSeconds ( 1 ))[ | Tasmota_Action . postUpdate ( UNDEF )] end","title":"Maintenance Actions"},{"location":"openHAB/#comparing-your-device-firmware-with-the-current-tasmota-github-release","text":"Knowing your devices firmware version(s) is good. Being able to compare it with the current release directly, is even better. You can achieve this by combining the maintenance actions with the openHAB http binding, the JsonPath transformation and the GitHub API. Just extend the maintenance setup with the following Item and config (make sure you have the binding addon http and transformation addon jsonpath installed): tasmota.things: Thing http : url : TasmotaVersion [ baseURL = \"https://api.github.com/repos/arendst/Tasmota/tags\" , refresh = 86400 ] { // refresh once a day Channels : Type string : Version \"Version\" [ stateTransformation = \"JSONPATH:$[0].name\" ] } tasmota.items: String Tasmota_Current_FW_Available \"Current Release [%s]\" { channel = \"http:url:TasmotaVersion:Version\" } With this item in your sitemap, you will now see the latest release/tag from Tasmota repository.","title":"Comparing your device firmware with the current Tasmota GitHub Release"},{"location":"openHAB/#discovering-interesting-topics","text":"Additional or further interesting topics are easily identified by reading up on the Tasmota wiki and by subscribing to the modules topics. Subscribe to all topics of one module using MQTT wildcard topic string +/tasmota_XYZ/# (string depends on your user-configured Topic/FullTopic). Configure items for the identified topics similar to the ones below. Example: MQTT messages published by a Sonoff Pow module are shown below (using mosquitto_sub ). The module reports its device state and energy readings periodically. In the second half of the example the module relay was switched into the OFF position. $ mosquitto_sub - h localhost - t \"+/tasmota_E8A6E4/#\" - v tele / tasmota - E8A6E4 / LWT Online tele / tasmota - E8A6E4 / UPTIME { \"Time\" : \"2017-07-25T12:02:00\" , \"Uptime\" : 68 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:06:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:06:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:11:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:11:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } cmnd / tasmota - E8A6E4 / POWER OFF stat / tasmota - E8A6E4 / RESULT { \"POWER\" : \"OFF\" } stat / tasmota - E8A6E4 / POWER OFF Following this method, the behavior-linked messages can be identified and bound to openHAB items.","title":"Discovering Interesting Topics"},{"location":"openHAB/#community-forum","text":"For more openHAB related details and questions, please visit the openHAB community forum thread on Sonoff and Tasmota .","title":"Community Forum"},{"location":"otto/","text":"\u0298tt\u0298 is a web interface for controlling devices, such as Tasmota enabled devices, over MQTT. See the quick-start guide and instructions for Tasmota devices .","title":"Otto"},{"location":"Commands/timezone_table/","text":"Tasmota Timezone Table ~ Use this table to look up the correct Timezone , TimeStd , and TimeDst commands to configure a Tasmota device for your local timezone. Timezone Commands Africa/Abidjan Timezone +0:00 Africa/Accra Timezone +0:00 Africa/Addis_Ababa Timezone +3:00 Africa/Algiers Timezone +1:00 Africa/Asmara Timezone +3:00 Africa/Asmera Timezone +3:00 Africa/Bamako Timezone +0:00 Africa/Bangui Timezone +1:00 Africa/Banjul Timezone +0:00 Africa/Bissau Timezone +0:00 Africa/Blantyre Timezone +2:00 Africa/Brazzaville Timezone +1:00 Africa/Bujumbura Timezone +2:00 Africa/Cairo Timezone +2:00 Africa/Casablanca Timezone +1:00 Africa/Ceuta Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Africa/Conakry Timezone +0:00 Africa/Dakar Timezone +0:00 Africa/Dar_es_Salaam Timezone +3:00 Africa/Djibouti Timezone +3:00 Africa/Douala Timezone +1:00 Africa/El_Aaiun Timezone +1:00 Africa/Freetown Timezone +0:00 Africa/Gaborone Timezone +2:00 Africa/Harare Timezone +2:00 Africa/Johannesburg Timezone +2:00 Africa/Juba Timezone +2:00 Africa/Kampala Timezone +3:00 Africa/Khartoum Timezone +2:00 Africa/Kigali Timezone +2:00 Africa/Kinshasa Timezone +1:00 Africa/Lagos Timezone +1:00 Africa/Libreville Timezone +1:00 Africa/Lome Timezone +0:00 Africa/Luanda Timezone +1:00 Africa/Lubumbashi Timezone +2:00 Africa/Lusaka Timezone +2:00 Africa/Malabo Timezone +1:00 Africa/Maputo Timezone +2:00 Africa/Maseru Timezone +2:00 Africa/Mbabane Timezone +2:00 Africa/Mogadishu Timezone +3:00 Africa/Monrovia Timezone +0:00 Africa/Nairobi Timezone +3:00 Africa/Ndjamena Timezone +1:00 Africa/Niamey Timezone +1:00 Africa/Nouakchott Timezone +0:00 Africa/Ouagadougou Timezone +0:00 Africa/Porto-Novo Timezone +1:00 Africa/Sao_Tome Timezone +0:00 Africa/Timbuktu Timezone +0:00 Africa/Tripoli Timezone +2:00 Africa/Tunis Timezone +1:00 Africa/Windhoek Timezone +2:00 America/Adak Backlog0 Timezone 99; TimeStd 0,1,11,1,2,0; TimeDst 0,2,3,1,2,60 America/Anchorage Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Anguilla Timezone -4:00 America/Antigua Timezone -4:00 America/Araguaina Timezone -3:00 America/Argentina/Buenos_Aires Timezone -3:00 America/Argentina/Catamarca Timezone -3:00 America/Argentina/ComodRivadavia Timezone -3:00 America/Argentina/Cordoba Timezone -3:00 America/Argentina/Jujuy Timezone -3:00 America/Argentina/La_Rioja Timezone -3:00 America/Argentina/Mendoza Timezone -3:00 America/Argentina/Rio_Gallegos Timezone -3:00 America/Argentina/Salta Timezone -3:00 America/Argentina/San_Juan Timezone -3:00 America/Argentina/San_Luis Timezone -3:00 America/Argentina/Tucuman Timezone -3:00 America/Argentina/Ushuaia Timezone -3:00 America/Aruba Timezone -4:00 America/Asuncion Backlog0 Timezone 99; TimeStd 1,4,3,1,0,-240; TimeDst 1,1,10,1,0,-180 America/Atikokan Timezone -5:00 America/Atka Backlog0 Timezone 99; TimeStd 0,1,11,1,2,0; TimeDst 0,2,3,1,2,60 America/Bahia Timezone -3:00 America/Bahia_Banderas Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 America/Barbados Timezone -4:00 America/Belem Timezone -3:00 America/Belize Timezone -6:00 America/Blanc-Sablon Timezone -4:00 America/Boa_Vista Timezone -4:00 America/Bogota Timezone -5:00 America/Boise Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Buenos_Aires Timezone -3:00 America/Cambridge_Bay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Campo_Grande Timezone -4:00 America/Cancun Timezone -5:00 America/Caracas Timezone -4:00 America/Catamarca Timezone -3:00 America/Cayenne Timezone -3:00 America/Cayman Timezone -5:00 America/Chicago Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Chihuahua Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-420; TimeDst 0,1,4,1,2,-360 America/Coral_Harbour Timezone -5:00 America/Cordoba Timezone -3:00 America/Costa_Rica Timezone -6:00 America/Creston Timezone -7:00 America/Cuiaba Timezone -4:00 America/Curacao Timezone -4:00 America/Danmarkshavn Timezone +0:00 America/Dawson Timezone -7:00 America/Dawson_Creek Timezone -7:00 America/Denver Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Detroit Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Dominica Timezone -4:00 America/Edmonton Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Eirunepe Timezone -5:00 America/El_Salvador Timezone -6:00 America/Ensenada Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Fort_Nelson Timezone -7:00 America/Fort_Wayne Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Fortaleza Timezone -3:00 America/Glace_Bay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Godthab This timezone uses a DST start/end rule that Tasmota does not support. America/Goose_Bay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Grand_Turk Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Grenada Timezone -4:00 America/Guadeloupe Timezone -4:00 America/Guatemala Timezone -6:00 America/Guayaquil Timezone -5:00 America/Guyana Timezone -4:00 America/Halifax Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Havana Backlog0 Timezone 99; TimeStd 0,1,11,1,1,-300; TimeDst 0,2,3,1,0,-240 America/Hermosillo Timezone -7:00 America/Indiana/Indianapolis Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Knox Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Indiana/Marengo Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Petersburg Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Tell_City Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Indiana/Vevay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Vincennes Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Winamac Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indianapolis Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Inuvik Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Iqaluit Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Jamaica Timezone -5:00 America/Jujuy Timezone -3:00 America/Juneau Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Kentucky/Louisville Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Kentucky/Monticello Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Knox_IN Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Kralendijk Timezone -4:00 America/La_Paz Timezone -4:00 America/Lima Timezone -5:00 America/Los_Angeles Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Louisville Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Lower_Princes Timezone -4:00 America/Maceio Timezone -3:00 America/Managua Timezone -6:00 America/Manaus Timezone -4:00 America/Marigot Timezone -4:00 America/Martinique Timezone -4:00 America/Matamoros Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Mazatlan Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-420; TimeDst 0,1,4,1,2,-360 America/Mendoza Timezone -3:00 America/Menominee Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Merida Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 America/Metlakatla Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Mexico_City Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 America/Miquelon Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-180; TimeDst 0,2,3,1,2,-120 America/Moncton Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Monterrey Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 America/Montevideo Timezone -3:00 America/Montreal Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Montserrat Timezone -4:00 America/Nassau Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/New_York Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Nipigon Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Nome Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Noronha Timezone -2:00 America/North_Dakota/Beulah Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/North_Dakota/Center Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/North_Dakota/New_Salem Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Nuuk This timezone uses a DST start/end rule that Tasmota does not support. America/Ojinaga Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Panama Timezone -5:00 America/Pangnirtung Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Paramaribo Timezone -3:00 America/Phoenix Timezone -7:00 America/Port-au-Prince Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Port_of_Spain Timezone -4:00 America/Porto_Acre Timezone -5:00 America/Porto_Velho Timezone -4:00 America/Puerto_Rico Timezone -4:00 America/Punta_Arenas Timezone -3:00 America/Rainy_River Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Rankin_Inlet Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Recife Timezone -3:00 America/Regina Timezone -6:00 America/Resolute Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Rio_Branco Timezone -5:00 America/Rosario Timezone -3:00 America/Santa_Isabel Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Santarem Timezone -3:00 America/Santiago This timezone uses a DST start/end rule that Tasmota does not support. America/Santo_Domingo Timezone -4:00 America/Sao_Paulo Timezone -3:00 America/Scoresbysund Backlog0 Timezone 99; TimeStd 0,0,10,1,1,-60; TimeDst 0,0,3,1,0,0 America/Shiprock Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Sitka Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/St_Barthelemy Timezone -4:00 America/St_Johns Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-30.0; TimeDst 0,2,3,1,2,30.0 America/St_Kitts Timezone -4:00 America/St_Lucia Timezone -4:00 America/St_Thomas Timezone -4:00 America/St_Vincent Timezone -4:00 America/Swift_Current Timezone -6:00 America/Tegucigalpa Timezone -6:00 America/Thule Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Thunder_Bay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Tijuana Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Toronto Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Tortola Timezone -4:00 America/Vancouver Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Virgin Timezone -4:00 America/Whitehorse Timezone -7:00 America/Winnipeg Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Yakutat Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Yellowknife Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 Antarctica/Casey Timezone +11:00 Antarctica/Davis Timezone +7:00 Antarctica/DumontDUrville Timezone +10:00 Antarctica/Macquarie Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Antarctica/Mawson Timezone +5:00 Antarctica/McMurdo Backlog0 Timezone 99; TimeStd 1,1,4,1,3,720; TimeDst 1,0,9,1,2,780 Antarctica/Palmer Timezone -3:00 Antarctica/Rothera Timezone -3:00 Antarctica/South_Pole Backlog0 Timezone 99; TimeStd 1,1,4,1,3,720; TimeDst 1,0,9,1,2,780 Antarctica/Syowa Timezone +3:00 Antarctica/Troll Backlog0 Timezone 99; TimeStd 0,0,10,1,3,0; TimeDst 0,0,3,1,1,120 Antarctica/Vostok Timezone +6:00 Arctic/Longyearbyen Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Asia/Aden Timezone +3:00 Asia/Almaty Timezone +6:00 Asia/Amman This timezone uses a DST start/end rule that Tasmota does not support. Asia/Anadyr Timezone +12:00 Asia/Aqtau Timezone +5:00 Asia/Aqtobe Timezone +5:00 Asia/Ashgabat Timezone +5:00 Asia/Ashkhabad Timezone +5:00 Asia/Atyrau Timezone +5:00 Asia/Baghdad Timezone +3:00 Asia/Bahrain Timezone +3:00 Asia/Baku Timezone +4:00 Asia/Bangkok Timezone +7:00 Asia/Barnaul Timezone +7:00 Asia/Beirut Backlog0 Timezone 99; TimeStd 0,0,10,1,0,120; TimeDst 0,0,3,1,0,180 Asia/Bishkek Timezone +6:00 Asia/Brunei Timezone +8:00 Asia/Calcutta Timezone +5:30 Asia/Chita Timezone +9:00 Asia/Choibalsan Timezone +8:00 Asia/Chongqing Timezone +8:00 Asia/Chungking Timezone +8:00 Asia/Colombo Timezone +5:30 Asia/Dacca Timezone +6:00 Asia/Damascus Backlog0 Timezone 99; TimeStd 0,0,10,6,0,120; TimeDst 0,0,3,6,0,180 Asia/Dhaka Timezone +6:00 Asia/Dili Timezone +9:00 Asia/Dubai Timezone +4:00 Asia/Dushanbe Timezone +5:00 Asia/Famagusta Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Asia/Gaza This timezone uses a DST start/end rule that Tasmota does not support. Asia/Harbin Timezone +8:00 Asia/Hebron This timezone uses a DST start/end rule that Tasmota does not support. Asia/Ho_Chi_Minh Timezone +7:00 Asia/Hong_Kong Timezone +8:00 Asia/Hovd Timezone +7:00 Asia/Irkutsk Timezone +8:00 Asia/Istanbul Timezone +3:00 Asia/Jakarta Timezone +7:00 Asia/Jayapura Timezone +9:00 Asia/Jerusalem This timezone uses a DST start/end rule that Tasmota does not support. Asia/Kabul Timezone +4:30 Asia/Kamchatka Timezone +12:00 Asia/Karachi Timezone +5:00 Asia/Kashgar Timezone +6:00 Asia/Kathmandu Timezone +5:45 Asia/Katmandu Timezone +5:45 Asia/Khandyga Timezone +9:00 Asia/Kolkata Timezone +5:30 Asia/Krasnoyarsk Timezone +7:00 Asia/Kuala_Lumpur Timezone +8:00 Asia/Kuching Timezone +8:00 Asia/Kuwait Timezone +3:00 Asia/Macao Timezone +8:00 Asia/Macau Timezone +8:00 Asia/Magadan Timezone +11:00 Asia/Makassar Timezone +8:00 Asia/Manila Timezone +8:00 Asia/Muscat Timezone +4:00 Asia/Nicosia Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Asia/Novokuznetsk Timezone +7:00 Asia/Novosibirsk Timezone +7:00 Asia/Omsk Timezone +6:00 Asia/Oral Timezone +5:00 Asia/Phnom_Penh Timezone +7:00 Asia/Pontianak Timezone +7:00 Asia/Pyongyang Timezone +9:00 Asia/Qatar Timezone +3:00 Asia/Qostanay Timezone +6:00 Asia/Qyzylorda Timezone +5:00 Asia/Rangoon Timezone +6:30 Asia/Riyadh Timezone +3:00 Asia/Saigon Timezone +7:00 Asia/Sakhalin Timezone +11:00 Asia/Samarkand Timezone +5:00 Asia/Seoul Timezone +9:00 Asia/Shanghai Timezone +8:00 Asia/Singapore Timezone +8:00 Asia/Srednekolymsk Timezone +11:00 Asia/Taipei Timezone +8:00 Asia/Tashkent Timezone +5:00 Asia/Tbilisi Timezone +4:00 Asia/Tehran Timezone +3:30 Asia/Tel_Aviv This timezone uses a DST start/end rule that Tasmota does not support. Asia/Thimbu Timezone +6:00 Asia/Thimphu Timezone +6:00 Asia/Tokyo Timezone +9:00 Asia/Tomsk Timezone +7:00 Asia/Ujung_Pandang Timezone +8:00 Asia/Ulaanbaatar Timezone +8:00 Asia/Ulan_Bator Timezone +8:00 Asia/Urumqi Timezone +6:00 Asia/Ust-Nera Timezone +10:00 Asia/Vientiane Timezone +7:00 Asia/Vladivostok Timezone +10:00 Asia/Yakutsk Timezone +9:00 Asia/Yangon Timezone +6:30 Asia/Yekaterinburg Timezone +5:00 Asia/Yerevan Timezone +4:00 Atlantic/Azores Backlog0 Timezone 99; TimeStd 0,0,10,1,1,-60; TimeDst 0,0,3,1,0,0 Atlantic/Bermuda Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 Atlantic/Canary Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Atlantic/Cape_Verde Timezone -1:00 Atlantic/Faeroe Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Atlantic/Faroe Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Atlantic/Jan_Mayen Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Atlantic/Madeira Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Atlantic/Reykjavik Timezone +0:00 Atlantic/South_Georgia Timezone -2:00 Atlantic/St_Helena Timezone +0:00 Atlantic/Stanley Timezone -3:00 Australia/ACT Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Adelaide Backlog0 Timezone 99; TimeStd 1,1,4,1,3,570.0; TimeDst 1,1,10,1,2,630.0 Australia/Brisbane Timezone +10:00 Australia/Broken_Hill Backlog0 Timezone 99; TimeStd 1,1,4,1,3,570.0; TimeDst 1,1,10,1,2,630.0 Australia/Canberra Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Currie Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Darwin Timezone +9:30 Australia/Eucla Timezone +8:45 Australia/Hobart Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/LHI Backlog0 Timezone 99; TimeStd 1,1,4,1,2,630.0; TimeDst 1,1,10,1,2,660 Australia/Lindeman Timezone +10:00 Australia/Lord_Howe Backlog0 Timezone 99; TimeStd 1,1,4,1,2,630.0; TimeDst 1,1,10,1,2,660 Australia/Melbourne Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/NSW Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/North Timezone +9:30 Australia/Perth Timezone +8:00 Australia/Queensland Timezone +10:00 Australia/South Backlog0 Timezone 99; TimeStd 1,1,4,1,3,570.0; TimeDst 1,1,10,1,2,630.0 Australia/Sydney Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Tasmania Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Victoria Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/West Timezone +8:00 Australia/Yancowinna Backlog0 Timezone 99; TimeStd 1,1,4,1,3,570.0; TimeDst 1,1,10,1,2,630.0 Brazil/Acre Timezone -5:00 Brazil/DeNoronha Timezone -2:00 Brazil/East Timezone -3:00 Brazil/West Timezone -4:00 CET Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 CST6CDT Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 Canada/Atlantic Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 Canada/Central Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 Canada/Eastern Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 Canada/Mountain Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 Canada/Newfoundland Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-30.0; TimeDst 0,2,3,1,2,30.0 Canada/Pacific Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 Canada/Saskatchewan Timezone -6:00 Canada/Yukon Timezone -7:00 Chile/Continental This timezone uses a DST start/end rule that Tasmota does not support. Chile/EasterIsland Backlog0 Timezone 99; TimeStd 1,1,4,7,22,-360; TimeDst 1,1,9,7,22,-300 Cuba Backlog0 Timezone 99; TimeStd 0,1,11,1,1,-300; TimeDst 0,2,3,1,0,-240 EET Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 EST Timezone -5:00 EST5EDT Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 Egypt Timezone +2:00 Eire Backlog0 Timezone 99; TimeStd 1,0,3,1,1,60; TimeDst 1,0,10,1,2,120 Etc/GMT Timezone +0:00 Etc/GMT+0 Timezone +0:00 Etc/GMT+1 Timezone -1:00 Etc/GMT+10 Timezone -10:00 Etc/GMT+11 Timezone -11:00 Etc/GMT+12 Timezone -12:00 Etc/GMT+2 Timezone -2:00 Etc/GMT+3 Timezone -3:00 Etc/GMT+4 Timezone -4:00 Etc/GMT+5 Timezone -5:00 Etc/GMT+6 Timezone -6:00 Etc/GMT+7 Timezone -7:00 Etc/GMT+8 Timezone -8:00 Etc/GMT+9 Timezone -9:00 Etc/GMT-0 Timezone +0:00 Etc/GMT-1 Timezone +1:00 Etc/GMT-10 Timezone +10:00 Etc/GMT-11 Timezone +11:00 Etc/GMT-12 Timezone +12:00 Etc/GMT-13 Timezone +13:00 Etc/GMT-14 This timezone has a UTC offset outside the range Tasmota supports. Etc/GMT-2 Timezone +2:00 Etc/GMT-3 Timezone +3:00 Etc/GMT-4 Timezone +4:00 Etc/GMT-5 Timezone +5:00 Etc/GMT-6 Timezone +6:00 Etc/GMT-7 Timezone +7:00 Etc/GMT-8 Timezone +8:00 Etc/GMT-9 Timezone +9:00 Etc/GMT0 Timezone +0:00 Etc/Greenwich Timezone +0:00 Etc/UCT Timezone +0:00 Etc/UTC Timezone +0:00 Etc/Universal Timezone +0:00 Etc/Zulu Timezone +0:00 Europe/Amsterdam Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Andorra Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Astrakhan Timezone +4:00 Europe/Athens Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Belfast Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Belgrade Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Berlin Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Bratislava Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Brussels Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Bucharest Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Budapest Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Busingen Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Chisinau Backlog0 Timezone 99; TimeStd 0,0,10,1,3,120; TimeDst 0,0,3,1,2,180 Europe/Copenhagen Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Dublin Backlog0 Timezone 99; TimeStd 1,0,3,1,1,60; TimeDst 1,0,10,1,2,120 Europe/Gibraltar Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Guernsey Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Helsinki Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Isle_of_Man Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Istanbul Timezone +3:00 Europe/Jersey Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Kaliningrad Timezone +2:00 Europe/Kiev Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Kirov Timezone +3:00 Europe/Kyiv Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Lisbon Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Ljubljana Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/London Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Luxembourg Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Madrid Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Malta Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Mariehamn Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Minsk Timezone +3:00 Europe/Monaco Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Moscow Timezone +3:00 Europe/Nicosia Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Oslo Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Paris Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Podgorica Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Prague Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Riga Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Rome Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Samara Timezone +4:00 Europe/San_Marino Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Sarajevo Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Saratov Timezone +4:00 Europe/Simferopol Timezone +3:00 Europe/Skopje Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Sofia Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Stockholm Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Tallinn Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Tirane Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Tiraspol Backlog0 Timezone 99; TimeStd 0,0,10,1,3,120; TimeDst 0,0,3,1,2,180 Europe/Ulyanovsk Timezone +4:00 Europe/Uzhgorod Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Vaduz Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Vatican Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Vienna Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Vilnius Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Volgograd Timezone +3:00 Europe/Warsaw Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Zagreb Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Zaporozhye Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Zurich Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Factory Timezone +0:00 GB Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 GB-Eire Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 GMT Timezone +0:00 GMT+0 Timezone +0:00 GMT-0 Timezone +0:00 GMT0 Timezone +0:00 Greenwich Timezone +0:00 HST Timezone +0:00 Hongkong Timezone +8:00 Iceland Timezone +0:00 Indian/Antananarivo Timezone +3:00 Indian/Chagos Timezone +6:00 Indian/Christmas Timezone +7:00 Indian/Cocos Timezone +6:30 Indian/Comoro Timezone +3:00 Indian/Kerguelen Timezone +5:00 Indian/Mahe Timezone +4:00 Indian/Maldives Timezone +5:00 Indian/Mauritius Timezone +4:00 Indian/Mayotte Timezone +3:00 Indian/Reunion Timezone +4:00 Iran Timezone +3:30 Israel This timezone uses a DST start/end rule that Tasmota does not support. Jamaica Timezone -5:00 Japan Timezone +9:00 Kwajalein Timezone +12:00 Libya Timezone +2:00 MET Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 MST Timezone -7:00 MST7MDT Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 Mexico/BajaNorte Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 Mexico/BajaSur Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-420; TimeDst 0,1,4,1,2,-360 Mexico/General Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 NZ Backlog0 Timezone 99; TimeStd 1,1,4,1,3,720; TimeDst 1,0,9,1,2,780 NZ-CHAT This timezone has a UTC offset outside the range Tasmota supports. Navajo Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 PRC Timezone +8:00 PST8PDT Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 Pacific/Apia Timezone +13:00 Pacific/Auckland Backlog0 Timezone 99; TimeStd 1,1,4,1,3,720; TimeDst 1,0,9,1,2,780 Pacific/Bougainville Timezone +11:00 Pacific/Chatham This timezone has a UTC offset outside the range Tasmota supports. Pacific/Chuuk Timezone +10:00 Pacific/Easter Backlog0 Timezone 99; TimeStd 1,1,4,7,22,-360; TimeDst 1,1,9,7,22,-300 Pacific/Efate Timezone +11:00 Pacific/Enderbury Timezone +13:00 Pacific/Fakaofo Timezone +13:00 Pacific/Fiji This timezone uses a DST start/end rule that Tasmota does not support. Pacific/Funafuti Timezone +12:00 Pacific/Galapagos Timezone -6:00 Pacific/Gambier Timezone -9:00 Pacific/Guadalcanal Timezone +11:00 Pacific/Guam Timezone +10:00 Pacific/Honolulu Timezone +0:00 Pacific/Johnston Timezone +0:00 Pacific/Kanton Timezone +13:00 Pacific/Kiritimati This timezone has a UTC offset outside the range Tasmota supports. Pacific/Kosrae Timezone +11:00 Pacific/Kwajalein Timezone +12:00 Pacific/Majuro Timezone +12:00 Pacific/Marquesas Timezone -9:30 Pacific/Midway Timezone -1:00 Pacific/Nauru Timezone +12:00 Pacific/Niue Timezone -11:00 Pacific/Norfolk Backlog0 Timezone 99; TimeStd 1,1,4,1,3,660; TimeDst 1,1,10,1,2,720 Pacific/Noumea Timezone +11:00 Pacific/Pago_Pago Timezone -1:00 Pacific/Palau Timezone +9:00 Pacific/Pitcairn Timezone -8:00 Pacific/Pohnpei Timezone +11:00 Pacific/Ponape Timezone +11:00 Pacific/Port_Moresby Timezone +10:00 Pacific/Rarotonga Timezone -10:00 Pacific/Saipan Timezone +10:00 Pacific/Samoa Timezone -1:00 Pacific/Tahiti Timezone -10:00 Pacific/Tarawa Timezone +12:00 Pacific/Tongatapu Timezone +13:00 Pacific/Truk Timezone +10:00 Pacific/Wake Timezone +12:00 Pacific/Wallis Timezone +12:00 Pacific/Yap Timezone +10:00 Poland Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Portugal Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 ROC Timezone +8:00 ROK Timezone +9:00 Singapore Timezone +8:00 Turkey Timezone +3:00 UCT Timezone +0:00 US/Alaska Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 US/Aleutian Backlog0 Timezone 99; TimeStd 0,1,11,1,2,0; TimeDst 0,2,3,1,2,60 US/Arizona Timezone -7:00 US/Central Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 US/East-Indiana Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 US/Eastern Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 US/Hawaii Timezone +0:00 US/Indiana-Starke Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 US/Michigan Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 US/Mountain Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 US/Pacific Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 US/Samoa Timezone -1:00 UTC Timezone +0:00 Universal Timezone +0:00 W-SU Timezone +3:00 WET Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Zulu Timezone +0:00 This table was generated from the IANA Time Zone Database , version 2022b .","title":"Timezone table"},{"location":"Commands/timezone_table/#tasmota-timezone-table","text":"Use this table to look up the correct Timezone , TimeStd , and TimeDst commands to configure a Tasmota device for your local timezone. Timezone Commands Africa/Abidjan Timezone +0:00 Africa/Accra Timezone +0:00 Africa/Addis_Ababa Timezone +3:00 Africa/Algiers Timezone +1:00 Africa/Asmara Timezone +3:00 Africa/Asmera Timezone +3:00 Africa/Bamako Timezone +0:00 Africa/Bangui Timezone +1:00 Africa/Banjul Timezone +0:00 Africa/Bissau Timezone +0:00 Africa/Blantyre Timezone +2:00 Africa/Brazzaville Timezone +1:00 Africa/Bujumbura Timezone +2:00 Africa/Cairo Timezone +2:00 Africa/Casablanca Timezone +1:00 Africa/Ceuta Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Africa/Conakry Timezone +0:00 Africa/Dakar Timezone +0:00 Africa/Dar_es_Salaam Timezone +3:00 Africa/Djibouti Timezone +3:00 Africa/Douala Timezone +1:00 Africa/El_Aaiun Timezone +1:00 Africa/Freetown Timezone +0:00 Africa/Gaborone Timezone +2:00 Africa/Harare Timezone +2:00 Africa/Johannesburg Timezone +2:00 Africa/Juba Timezone +2:00 Africa/Kampala Timezone +3:00 Africa/Khartoum Timezone +2:00 Africa/Kigali Timezone +2:00 Africa/Kinshasa Timezone +1:00 Africa/Lagos Timezone +1:00 Africa/Libreville Timezone +1:00 Africa/Lome Timezone +0:00 Africa/Luanda Timezone +1:00 Africa/Lubumbashi Timezone +2:00 Africa/Lusaka Timezone +2:00 Africa/Malabo Timezone +1:00 Africa/Maputo Timezone +2:00 Africa/Maseru Timezone +2:00 Africa/Mbabane Timezone +2:00 Africa/Mogadishu Timezone +3:00 Africa/Monrovia Timezone +0:00 Africa/Nairobi Timezone +3:00 Africa/Ndjamena Timezone +1:00 Africa/Niamey Timezone +1:00 Africa/Nouakchott Timezone +0:00 Africa/Ouagadougou Timezone +0:00 Africa/Porto-Novo Timezone +1:00 Africa/Sao_Tome Timezone +0:00 Africa/Timbuktu Timezone +0:00 Africa/Tripoli Timezone +2:00 Africa/Tunis Timezone +1:00 Africa/Windhoek Timezone +2:00 America/Adak Backlog0 Timezone 99; TimeStd 0,1,11,1,2,0; TimeDst 0,2,3,1,2,60 America/Anchorage Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Anguilla Timezone -4:00 America/Antigua Timezone -4:00 America/Araguaina Timezone -3:00 America/Argentina/Buenos_Aires Timezone -3:00 America/Argentina/Catamarca Timezone -3:00 America/Argentina/ComodRivadavia Timezone -3:00 America/Argentina/Cordoba Timezone -3:00 America/Argentina/Jujuy Timezone -3:00 America/Argentina/La_Rioja Timezone -3:00 America/Argentina/Mendoza Timezone -3:00 America/Argentina/Rio_Gallegos Timezone -3:00 America/Argentina/Salta Timezone -3:00 America/Argentina/San_Juan Timezone -3:00 America/Argentina/San_Luis Timezone -3:00 America/Argentina/Tucuman Timezone -3:00 America/Argentina/Ushuaia Timezone -3:00 America/Aruba Timezone -4:00 America/Asuncion Backlog0 Timezone 99; TimeStd 1,4,3,1,0,-240; TimeDst 1,1,10,1,0,-180 America/Atikokan Timezone -5:00 America/Atka Backlog0 Timezone 99; TimeStd 0,1,11,1,2,0; TimeDst 0,2,3,1,2,60 America/Bahia Timezone -3:00 America/Bahia_Banderas Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 America/Barbados Timezone -4:00 America/Belem Timezone -3:00 America/Belize Timezone -6:00 America/Blanc-Sablon Timezone -4:00 America/Boa_Vista Timezone -4:00 America/Bogota Timezone -5:00 America/Boise Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Buenos_Aires Timezone -3:00 America/Cambridge_Bay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Campo_Grande Timezone -4:00 America/Cancun Timezone -5:00 America/Caracas Timezone -4:00 America/Catamarca Timezone -3:00 America/Cayenne Timezone -3:00 America/Cayman Timezone -5:00 America/Chicago Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Chihuahua Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-420; TimeDst 0,1,4,1,2,-360 America/Coral_Harbour Timezone -5:00 America/Cordoba Timezone -3:00 America/Costa_Rica Timezone -6:00 America/Creston Timezone -7:00 America/Cuiaba Timezone -4:00 America/Curacao Timezone -4:00 America/Danmarkshavn Timezone +0:00 America/Dawson Timezone -7:00 America/Dawson_Creek Timezone -7:00 America/Denver Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Detroit Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Dominica Timezone -4:00 America/Edmonton Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Eirunepe Timezone -5:00 America/El_Salvador Timezone -6:00 America/Ensenada Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Fort_Nelson Timezone -7:00 America/Fort_Wayne Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Fortaleza Timezone -3:00 America/Glace_Bay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Godthab This timezone uses a DST start/end rule that Tasmota does not support. America/Goose_Bay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Grand_Turk Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Grenada Timezone -4:00 America/Guadeloupe Timezone -4:00 America/Guatemala Timezone -6:00 America/Guayaquil Timezone -5:00 America/Guyana Timezone -4:00 America/Halifax Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Havana Backlog0 Timezone 99; TimeStd 0,1,11,1,1,-300; TimeDst 0,2,3,1,0,-240 America/Hermosillo Timezone -7:00 America/Indiana/Indianapolis Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Knox Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Indiana/Marengo Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Petersburg Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Tell_City Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Indiana/Vevay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Vincennes Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indiana/Winamac Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Indianapolis Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Inuvik Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Iqaluit Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Jamaica Timezone -5:00 America/Jujuy Timezone -3:00 America/Juneau Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Kentucky/Louisville Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Kentucky/Monticello Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Knox_IN Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Kralendijk Timezone -4:00 America/La_Paz Timezone -4:00 America/Lima Timezone -5:00 America/Los_Angeles Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Louisville Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Lower_Princes Timezone -4:00 America/Maceio Timezone -3:00 America/Managua Timezone -6:00 America/Manaus Timezone -4:00 America/Marigot Timezone -4:00 America/Martinique Timezone -4:00 America/Matamoros Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Mazatlan Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-420; TimeDst 0,1,4,1,2,-360 America/Mendoza Timezone -3:00 America/Menominee Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Merida Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 America/Metlakatla Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Mexico_City Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 America/Miquelon Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-180; TimeDst 0,2,3,1,2,-120 America/Moncton Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Monterrey Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 America/Montevideo Timezone -3:00 America/Montreal Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Montserrat Timezone -4:00 America/Nassau Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/New_York Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Nipigon Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Nome Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Noronha Timezone -2:00 America/North_Dakota/Beulah Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/North_Dakota/Center Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/North_Dakota/New_Salem Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Nuuk This timezone uses a DST start/end rule that Tasmota does not support. America/Ojinaga Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Panama Timezone -5:00 America/Pangnirtung Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Paramaribo Timezone -3:00 America/Phoenix Timezone -7:00 America/Port-au-Prince Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Port_of_Spain Timezone -4:00 America/Porto_Acre Timezone -5:00 America/Porto_Velho Timezone -4:00 America/Puerto_Rico Timezone -4:00 America/Punta_Arenas Timezone -3:00 America/Rainy_River Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Rankin_Inlet Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Recife Timezone -3:00 America/Regina Timezone -6:00 America/Resolute Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Rio_Branco Timezone -5:00 America/Rosario Timezone -3:00 America/Santa_Isabel Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Santarem Timezone -3:00 America/Santiago This timezone uses a DST start/end rule that Tasmota does not support. America/Santo_Domingo Timezone -4:00 America/Sao_Paulo Timezone -3:00 America/Scoresbysund Backlog0 Timezone 99; TimeStd 0,0,10,1,1,-60; TimeDst 0,0,3,1,0,0 America/Shiprock Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 America/Sitka Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/St_Barthelemy Timezone -4:00 America/St_Johns Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-30.0; TimeDst 0,2,3,1,2,30.0 America/St_Kitts Timezone -4:00 America/St_Lucia Timezone -4:00 America/St_Thomas Timezone -4:00 America/St_Vincent Timezone -4:00 America/Swift_Current Timezone -6:00 America/Tegucigalpa Timezone -6:00 America/Thule Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 America/Thunder_Bay Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Tijuana Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Toronto Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 America/Tortola Timezone -4:00 America/Vancouver Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 America/Virgin Timezone -4:00 America/Whitehorse Timezone -7:00 America/Winnipeg Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 America/Yakutat Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 America/Yellowknife Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 Antarctica/Casey Timezone +11:00 Antarctica/Davis Timezone +7:00 Antarctica/DumontDUrville Timezone +10:00 Antarctica/Macquarie Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Antarctica/Mawson Timezone +5:00 Antarctica/McMurdo Backlog0 Timezone 99; TimeStd 1,1,4,1,3,720; TimeDst 1,0,9,1,2,780 Antarctica/Palmer Timezone -3:00 Antarctica/Rothera Timezone -3:00 Antarctica/South_Pole Backlog0 Timezone 99; TimeStd 1,1,4,1,3,720; TimeDst 1,0,9,1,2,780 Antarctica/Syowa Timezone +3:00 Antarctica/Troll Backlog0 Timezone 99; TimeStd 0,0,10,1,3,0; TimeDst 0,0,3,1,1,120 Antarctica/Vostok Timezone +6:00 Arctic/Longyearbyen Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Asia/Aden Timezone +3:00 Asia/Almaty Timezone +6:00 Asia/Amman This timezone uses a DST start/end rule that Tasmota does not support. Asia/Anadyr Timezone +12:00 Asia/Aqtau Timezone +5:00 Asia/Aqtobe Timezone +5:00 Asia/Ashgabat Timezone +5:00 Asia/Ashkhabad Timezone +5:00 Asia/Atyrau Timezone +5:00 Asia/Baghdad Timezone +3:00 Asia/Bahrain Timezone +3:00 Asia/Baku Timezone +4:00 Asia/Bangkok Timezone +7:00 Asia/Barnaul Timezone +7:00 Asia/Beirut Backlog0 Timezone 99; TimeStd 0,0,10,1,0,120; TimeDst 0,0,3,1,0,180 Asia/Bishkek Timezone +6:00 Asia/Brunei Timezone +8:00 Asia/Calcutta Timezone +5:30 Asia/Chita Timezone +9:00 Asia/Choibalsan Timezone +8:00 Asia/Chongqing Timezone +8:00 Asia/Chungking Timezone +8:00 Asia/Colombo Timezone +5:30 Asia/Dacca Timezone +6:00 Asia/Damascus Backlog0 Timezone 99; TimeStd 0,0,10,6,0,120; TimeDst 0,0,3,6,0,180 Asia/Dhaka Timezone +6:00 Asia/Dili Timezone +9:00 Asia/Dubai Timezone +4:00 Asia/Dushanbe Timezone +5:00 Asia/Famagusta Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Asia/Gaza This timezone uses a DST start/end rule that Tasmota does not support. Asia/Harbin Timezone +8:00 Asia/Hebron This timezone uses a DST start/end rule that Tasmota does not support. Asia/Ho_Chi_Minh Timezone +7:00 Asia/Hong_Kong Timezone +8:00 Asia/Hovd Timezone +7:00 Asia/Irkutsk Timezone +8:00 Asia/Istanbul Timezone +3:00 Asia/Jakarta Timezone +7:00 Asia/Jayapura Timezone +9:00 Asia/Jerusalem This timezone uses a DST start/end rule that Tasmota does not support. Asia/Kabul Timezone +4:30 Asia/Kamchatka Timezone +12:00 Asia/Karachi Timezone +5:00 Asia/Kashgar Timezone +6:00 Asia/Kathmandu Timezone +5:45 Asia/Katmandu Timezone +5:45 Asia/Khandyga Timezone +9:00 Asia/Kolkata Timezone +5:30 Asia/Krasnoyarsk Timezone +7:00 Asia/Kuala_Lumpur Timezone +8:00 Asia/Kuching Timezone +8:00 Asia/Kuwait Timezone +3:00 Asia/Macao Timezone +8:00 Asia/Macau Timezone +8:00 Asia/Magadan Timezone +11:00 Asia/Makassar Timezone +8:00 Asia/Manila Timezone +8:00 Asia/Muscat Timezone +4:00 Asia/Nicosia Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Asia/Novokuznetsk Timezone +7:00 Asia/Novosibirsk Timezone +7:00 Asia/Omsk Timezone +6:00 Asia/Oral Timezone +5:00 Asia/Phnom_Penh Timezone +7:00 Asia/Pontianak Timezone +7:00 Asia/Pyongyang Timezone +9:00 Asia/Qatar Timezone +3:00 Asia/Qostanay Timezone +6:00 Asia/Qyzylorda Timezone +5:00 Asia/Rangoon Timezone +6:30 Asia/Riyadh Timezone +3:00 Asia/Saigon Timezone +7:00 Asia/Sakhalin Timezone +11:00 Asia/Samarkand Timezone +5:00 Asia/Seoul Timezone +9:00 Asia/Shanghai Timezone +8:00 Asia/Singapore Timezone +8:00 Asia/Srednekolymsk Timezone +11:00 Asia/Taipei Timezone +8:00 Asia/Tashkent Timezone +5:00 Asia/Tbilisi Timezone +4:00 Asia/Tehran Timezone +3:30 Asia/Tel_Aviv This timezone uses a DST start/end rule that Tasmota does not support. Asia/Thimbu Timezone +6:00 Asia/Thimphu Timezone +6:00 Asia/Tokyo Timezone +9:00 Asia/Tomsk Timezone +7:00 Asia/Ujung_Pandang Timezone +8:00 Asia/Ulaanbaatar Timezone +8:00 Asia/Ulan_Bator Timezone +8:00 Asia/Urumqi Timezone +6:00 Asia/Ust-Nera Timezone +10:00 Asia/Vientiane Timezone +7:00 Asia/Vladivostok Timezone +10:00 Asia/Yakutsk Timezone +9:00 Asia/Yangon Timezone +6:30 Asia/Yekaterinburg Timezone +5:00 Asia/Yerevan Timezone +4:00 Atlantic/Azores Backlog0 Timezone 99; TimeStd 0,0,10,1,1,-60; TimeDst 0,0,3,1,0,0 Atlantic/Bermuda Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 Atlantic/Canary Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Atlantic/Cape_Verde Timezone -1:00 Atlantic/Faeroe Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Atlantic/Faroe Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Atlantic/Jan_Mayen Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Atlantic/Madeira Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Atlantic/Reykjavik Timezone +0:00 Atlantic/South_Georgia Timezone -2:00 Atlantic/St_Helena Timezone +0:00 Atlantic/Stanley Timezone -3:00 Australia/ACT Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Adelaide Backlog0 Timezone 99; TimeStd 1,1,4,1,3,570.0; TimeDst 1,1,10,1,2,630.0 Australia/Brisbane Timezone +10:00 Australia/Broken_Hill Backlog0 Timezone 99; TimeStd 1,1,4,1,3,570.0; TimeDst 1,1,10,1,2,630.0 Australia/Canberra Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Currie Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Darwin Timezone +9:30 Australia/Eucla Timezone +8:45 Australia/Hobart Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/LHI Backlog0 Timezone 99; TimeStd 1,1,4,1,2,630.0; TimeDst 1,1,10,1,2,660 Australia/Lindeman Timezone +10:00 Australia/Lord_Howe Backlog0 Timezone 99; TimeStd 1,1,4,1,2,630.0; TimeDst 1,1,10,1,2,660 Australia/Melbourne Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/NSW Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/North Timezone +9:30 Australia/Perth Timezone +8:00 Australia/Queensland Timezone +10:00 Australia/South Backlog0 Timezone 99; TimeStd 1,1,4,1,3,570.0; TimeDst 1,1,10,1,2,630.0 Australia/Sydney Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Tasmania Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/Victoria Backlog0 Timezone 99; TimeStd 1,1,4,1,3,600; TimeDst 1,1,10,1,2,660 Australia/West Timezone +8:00 Australia/Yancowinna Backlog0 Timezone 99; TimeStd 1,1,4,1,3,570.0; TimeDst 1,1,10,1,2,630.0 Brazil/Acre Timezone -5:00 Brazil/DeNoronha Timezone -2:00 Brazil/East Timezone -3:00 Brazil/West Timezone -4:00 CET Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 CST6CDT Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 Canada/Atlantic Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-240; TimeDst 0,2,3,1,2,-180 Canada/Central Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 Canada/Eastern Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 Canada/Mountain Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 Canada/Newfoundland Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-30.0; TimeDst 0,2,3,1,2,30.0 Canada/Pacific Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 Canada/Saskatchewan Timezone -6:00 Canada/Yukon Timezone -7:00 Chile/Continental This timezone uses a DST start/end rule that Tasmota does not support. Chile/EasterIsland Backlog0 Timezone 99; TimeStd 1,1,4,7,22,-360; TimeDst 1,1,9,7,22,-300 Cuba Backlog0 Timezone 99; TimeStd 0,1,11,1,1,-300; TimeDst 0,2,3,1,0,-240 EET Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 EST Timezone -5:00 EST5EDT Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 Egypt Timezone +2:00 Eire Backlog0 Timezone 99; TimeStd 1,0,3,1,1,60; TimeDst 1,0,10,1,2,120 Etc/GMT Timezone +0:00 Etc/GMT+0 Timezone +0:00 Etc/GMT+1 Timezone -1:00 Etc/GMT+10 Timezone -10:00 Etc/GMT+11 Timezone -11:00 Etc/GMT+12 Timezone -12:00 Etc/GMT+2 Timezone -2:00 Etc/GMT+3 Timezone -3:00 Etc/GMT+4 Timezone -4:00 Etc/GMT+5 Timezone -5:00 Etc/GMT+6 Timezone -6:00 Etc/GMT+7 Timezone -7:00 Etc/GMT+8 Timezone -8:00 Etc/GMT+9 Timezone -9:00 Etc/GMT-0 Timezone +0:00 Etc/GMT-1 Timezone +1:00 Etc/GMT-10 Timezone +10:00 Etc/GMT-11 Timezone +11:00 Etc/GMT-12 Timezone +12:00 Etc/GMT-13 Timezone +13:00 Etc/GMT-14 This timezone has a UTC offset outside the range Tasmota supports. Etc/GMT-2 Timezone +2:00 Etc/GMT-3 Timezone +3:00 Etc/GMT-4 Timezone +4:00 Etc/GMT-5 Timezone +5:00 Etc/GMT-6 Timezone +6:00 Etc/GMT-7 Timezone +7:00 Etc/GMT-8 Timezone +8:00 Etc/GMT-9 Timezone +9:00 Etc/GMT0 Timezone +0:00 Etc/Greenwich Timezone +0:00 Etc/UCT Timezone +0:00 Etc/UTC Timezone +0:00 Etc/Universal Timezone +0:00 Etc/Zulu Timezone +0:00 Europe/Amsterdam Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Andorra Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Astrakhan Timezone +4:00 Europe/Athens Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Belfast Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Belgrade Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Berlin Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Bratislava Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Brussels Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Bucharest Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Budapest Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Busingen Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Chisinau Backlog0 Timezone 99; TimeStd 0,0,10,1,3,120; TimeDst 0,0,3,1,2,180 Europe/Copenhagen Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Dublin Backlog0 Timezone 99; TimeStd 1,0,3,1,1,60; TimeDst 1,0,10,1,2,120 Europe/Gibraltar Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Guernsey Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Helsinki Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Isle_of_Man Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Istanbul Timezone +3:00 Europe/Jersey Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Kaliningrad Timezone +2:00 Europe/Kiev Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Kirov Timezone +3:00 Europe/Kyiv Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Lisbon Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Ljubljana Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/London Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Europe/Luxembourg Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Madrid Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Malta Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Mariehamn Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Minsk Timezone +3:00 Europe/Monaco Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Moscow Timezone +3:00 Europe/Nicosia Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Oslo Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Paris Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Podgorica Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Prague Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Riga Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Rome Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Samara Timezone +4:00 Europe/San_Marino Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Sarajevo Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Saratov Timezone +4:00 Europe/Simferopol Timezone +3:00 Europe/Skopje Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Sofia Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Stockholm Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Tallinn Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Tirane Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Tiraspol Backlog0 Timezone 99; TimeStd 0,0,10,1,3,120; TimeDst 0,0,3,1,2,180 Europe/Ulyanovsk Timezone +4:00 Europe/Uzhgorod Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Vaduz Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Vatican Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Vienna Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Vilnius Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Volgograd Timezone +3:00 Europe/Warsaw Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Zagreb Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Europe/Zaporozhye Backlog0 Timezone 99; TimeStd 0,0,10,1,4,120; TimeDst 0,0,3,1,3,180 Europe/Zurich Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Factory Timezone +0:00 GB Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 GB-Eire Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 GMT Timezone +0:00 GMT+0 Timezone +0:00 GMT-0 Timezone +0:00 GMT0 Timezone +0:00 Greenwich Timezone +0:00 HST Timezone +0:00 Hongkong Timezone +8:00 Iceland Timezone +0:00 Indian/Antananarivo Timezone +3:00 Indian/Chagos Timezone +6:00 Indian/Christmas Timezone +7:00 Indian/Cocos Timezone +6:30 Indian/Comoro Timezone +3:00 Indian/Kerguelen Timezone +5:00 Indian/Mahe Timezone +4:00 Indian/Maldives Timezone +5:00 Indian/Mauritius Timezone +4:00 Indian/Mayotte Timezone +3:00 Indian/Reunion Timezone +4:00 Iran Timezone +3:30 Israel This timezone uses a DST start/end rule that Tasmota does not support. Jamaica Timezone -5:00 Japan Timezone +9:00 Kwajalein Timezone +12:00 Libya Timezone +2:00 MET Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 MST Timezone -7:00 MST7MDT Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 Mexico/BajaNorte Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 Mexico/BajaSur Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-420; TimeDst 0,1,4,1,2,-360 Mexico/General Backlog0 Timezone 99; TimeStd 0,0,10,1,2,-360; TimeDst 0,1,4,1,2,-300 NZ Backlog0 Timezone 99; TimeStd 1,1,4,1,3,720; TimeDst 1,0,9,1,2,780 NZ-CHAT This timezone has a UTC offset outside the range Tasmota supports. Navajo Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 PRC Timezone +8:00 PST8PDT Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 Pacific/Apia Timezone +13:00 Pacific/Auckland Backlog0 Timezone 99; TimeStd 1,1,4,1,3,720; TimeDst 1,0,9,1,2,780 Pacific/Bougainville Timezone +11:00 Pacific/Chatham This timezone has a UTC offset outside the range Tasmota supports. Pacific/Chuuk Timezone +10:00 Pacific/Easter Backlog0 Timezone 99; TimeStd 1,1,4,7,22,-360; TimeDst 1,1,9,7,22,-300 Pacific/Efate Timezone +11:00 Pacific/Enderbury Timezone +13:00 Pacific/Fakaofo Timezone +13:00 Pacific/Fiji This timezone uses a DST start/end rule that Tasmota does not support. Pacific/Funafuti Timezone +12:00 Pacific/Galapagos Timezone -6:00 Pacific/Gambier Timezone -9:00 Pacific/Guadalcanal Timezone +11:00 Pacific/Guam Timezone +10:00 Pacific/Honolulu Timezone +0:00 Pacific/Johnston Timezone +0:00 Pacific/Kanton Timezone +13:00 Pacific/Kiritimati This timezone has a UTC offset outside the range Tasmota supports. Pacific/Kosrae Timezone +11:00 Pacific/Kwajalein Timezone +12:00 Pacific/Majuro Timezone +12:00 Pacific/Marquesas Timezone -9:30 Pacific/Midway Timezone -1:00 Pacific/Nauru Timezone +12:00 Pacific/Niue Timezone -11:00 Pacific/Norfolk Backlog0 Timezone 99; TimeStd 1,1,4,1,3,660; TimeDst 1,1,10,1,2,720 Pacific/Noumea Timezone +11:00 Pacific/Pago_Pago Timezone -1:00 Pacific/Palau Timezone +9:00 Pacific/Pitcairn Timezone -8:00 Pacific/Pohnpei Timezone +11:00 Pacific/Ponape Timezone +11:00 Pacific/Port_Moresby Timezone +10:00 Pacific/Rarotonga Timezone -10:00 Pacific/Saipan Timezone +10:00 Pacific/Samoa Timezone -1:00 Pacific/Tahiti Timezone -10:00 Pacific/Tarawa Timezone +12:00 Pacific/Tongatapu Timezone +13:00 Pacific/Truk Timezone +10:00 Pacific/Wake Timezone +12:00 Pacific/Wallis Timezone +12:00 Pacific/Yap Timezone +10:00 Poland Backlog0 Timezone 99; TimeStd 0,0,10,1,3,60; TimeDst 0,0,3,1,2,120 Portugal Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 ROC Timezone +8:00 ROK Timezone +9:00 Singapore Timezone +8:00 Turkey Timezone +3:00 UCT Timezone +0:00 US/Alaska Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-540; TimeDst 0,2,3,1,2,-480 US/Aleutian Backlog0 Timezone 99; TimeStd 0,1,11,1,2,0; TimeDst 0,2,3,1,2,60 US/Arizona Timezone -7:00 US/Central Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 US/East-Indiana Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 US/Eastern Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 US/Hawaii Timezone +0:00 US/Indiana-Starke Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-360; TimeDst 0,2,3,1,2,-300 US/Michigan Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240 US/Mountain Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-420; TimeDst 0,2,3,1,2,-360 US/Pacific Backlog0 Timezone 99; TimeStd 0,1,11,1,2,-480; TimeDst 0,2,3,1,2,-420 US/Samoa Timezone -1:00 UTC Timezone +0:00 Universal Timezone +0:00 W-SU Timezone +3:00 WET Backlog0 Timezone 99; TimeStd 0,0,10,1,2,0; TimeDst 0,0,3,1,1,60 Zulu Timezone +0:00 This table was generated from the IANA Time Zone Database , version 2022b .","title":"Tasmota Timezone Table"},{"location":"changelogs/changelog-7.2/","text":"Version 7.2.0 Constance ~ Change Exception reporting removing exception details from Status 1 and consolidated in Status 12 if available Change HTTP CORS from command SetOption73 0/1 to Cors <cors_domain> allowing user control of specific CORS domain by Shantur Rathore (#7066) Change GUI Shutter button text to Up and Down Arrows based on PR by Xavier Muller (#7166) Change amount of supported DHT sensors from 3 to 4 by Xavier Muller (#7167) Change some Settings locations freeing up space for future single char allowing variable length text Change tasmota-basic.bin and FIRMWARE_BASIC to tasmota-lite.bin and FIRMWARE_LITE Fix flashing H801 led at boot by Stefan Hadinger (#7165, #649) Fix duplicated Backlog when using Event inside a Backlog by Adrian Scillato (#7178, #7147) Fix Gui Timer when using a negative zero offset of -00:00 by Peter Ooms (#7174) Fix DeepSleep in case there is no wifi by Stefan Bode (#7213) Fix Fade would ignore savedata 0 and store to flash anyways (#7262) Fix Arduino IDE compile error (#7277) Fix no AP on initial install (#7282) Add command SerialConfig 0..23 or SerialConfig 8N1 to select Serial Config based in PR by Luis Teixeira (#7108) Add command Sensor34 9 <weight code> to set minimum delta to trigger JSON message by @tobox (#7188) Add rule var %topic% by Adrian Scillato (#5522) Add rule triggers tele-wifi1#xxx by Adrian Scillato (#7093) Add SML bus decoder syntax support for byte order by Gerhard Mutz (#7112) Add experimental support for stepper motor shutter control by Stefan Bode Add optional USE_MQTT_TLS to tasmota-minimal.bin by Bohdan Kmit (#7115) Add save call stack in RTC memory in case of crash, command Status 12 to dump the stack by Stefan Hadinger Add Home Assistant force update by Frederico Leoni (#7140, #7074) Add Wifi Signal Strength in dBm in addition to RSSI Wifi Experience by Andreas Schultz (#7145) Add Yaw, Pitch and Roll support for MPU6050 by Philip Barclay (#7058) Add reporting of raw weight to JSON from HX711 to overcome auto-tare functionality by @tobox (#7171) Add Zigbee support for Xiaomi Aqara Vibration Sensor and Presence Sensor by Stefan Hadinger Add Shutter functions ramp up/down and MQTT reporting by Stefan Bode Add fallback support from version 8.x Add restriction if fallback firmware is incompatible with settings resulting in unreachable device Add support for DHT12 Temperature and Humidity sensor by Stefan Oskamp","title":"Changelog 7.2"},{"location":"changelogs/changelog-7.2/#version-720-constance","text":"Change Exception reporting removing exception details from Status 1 and consolidated in Status 12 if available Change HTTP CORS from command SetOption73 0/1 to Cors <cors_domain> allowing user control of specific CORS domain by Shantur Rathore (#7066) Change GUI Shutter button text to Up and Down Arrows based on PR by Xavier Muller (#7166) Change amount of supported DHT sensors from 3 to 4 by Xavier Muller (#7167) Change some Settings locations freeing up space for future single char allowing variable length text Change tasmota-basic.bin and FIRMWARE_BASIC to tasmota-lite.bin and FIRMWARE_LITE Fix flashing H801 led at boot by Stefan Hadinger (#7165, #649) Fix duplicated Backlog when using Event inside a Backlog by Adrian Scillato (#7178, #7147) Fix Gui Timer when using a negative zero offset of -00:00 by Peter Ooms (#7174) Fix DeepSleep in case there is no wifi by Stefan Bode (#7213) Fix Fade would ignore savedata 0 and store to flash anyways (#7262) Fix Arduino IDE compile error (#7277) Fix no AP on initial install (#7282) Add command SerialConfig 0..23 or SerialConfig 8N1 to select Serial Config based in PR by Luis Teixeira (#7108) Add command Sensor34 9 <weight code> to set minimum delta to trigger JSON message by @tobox (#7188) Add rule var %topic% by Adrian Scillato (#5522) Add rule triggers tele-wifi1#xxx by Adrian Scillato (#7093) Add SML bus decoder syntax support for byte order by Gerhard Mutz (#7112) Add experimental support for stepper motor shutter control by Stefan Bode Add optional USE_MQTT_TLS to tasmota-minimal.bin by Bohdan Kmit (#7115) Add save call stack in RTC memory in case of crash, command Status 12 to dump the stack by Stefan Hadinger Add Home Assistant force update by Frederico Leoni (#7140, #7074) Add Wifi Signal Strength in dBm in addition to RSSI Wifi Experience by Andreas Schultz (#7145) Add Yaw, Pitch and Roll support for MPU6050 by Philip Barclay (#7058) Add reporting of raw weight to JSON from HX711 to overcome auto-tare functionality by @tobox (#7171) Add Zigbee support for Xiaomi Aqara Vibration Sensor and Presence Sensor by Stefan Hadinger Add Shutter functions ramp up/down and MQTT reporting by Stefan Bode Add fallback support from version 8.x Add restriction if fallback firmware is incompatible with settings resulting in unreachable device Add support for DHT12 Temperature and Humidity sensor by Stefan Oskamp","title":"Version 7.2.0 Constance"},{"location":"changelogs/changelog-8.1/","text":"Version 8.1.0 Doris ~ Change Settings text handling allowing variable length text within a total text pool of 699 characters Change Smoother Fade using 100Hz instead of 20Hz animation (#7179) Change number of rule Var s and Mem s from 5 to 16 (#4933) Change number of FriendlyName s from 4 to 8 Add commands WebButton1 until WebButton16 to support user defined GUI button text (#7166) Add support for max 150 characters in most command parameter strings (#3686, #4754) Add support for GPS as NTP server by Christian Baars and Adrian Scillato Add support for AdcParam parameters to control ADC0 Moisture formula by Federico Leoni (#7309) Add Zigbee coalesce sensor attributes into a single message Add Zigbee better support for Xiaomi Double Switch and Xiaomi Vibration sensor Add Deepsleep start delay based on Teleperiod if Teleperiod differs from 10 or 300","title":"Changelog 8.1"},{"location":"changelogs/changelog-8.1/#version-810-doris","text":"Change Settings text handling allowing variable length text within a total text pool of 699 characters Change Smoother Fade using 100Hz instead of 20Hz animation (#7179) Change number of rule Var s and Mem s from 5 to 16 (#4933) Change number of FriendlyName s from 4 to 8 Add commands WebButton1 until WebButton16 to support user defined GUI button text (#7166) Add support for max 150 characters in most command parameter strings (#3686, #4754) Add support for GPS as NTP server by Christian Baars and Adrian Scillato Add support for AdcParam parameters to control ADC0 Moisture formula by Federico Leoni (#7309) Add Zigbee coalesce sensor attributes into a single message Add Zigbee better support for Xiaomi Double Switch and Xiaomi Vibration sensor Add Deepsleep start delay based on Teleperiod if Teleperiod differs from 10 or 300","title":"Version 8.1.0 Doris"},{"location":"changelogs/changelog-8.2/","text":"Version 8.2.0 Elliot ~ Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Changelog 8.2"},{"location":"changelogs/changelog-8.2/#version-820-elliot","text":"Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Version 8.2.0 Elliot"},{"location":"devices/","text":"Visit Tasmota Supported Devices Repository for a complete list of devices working with Tasmota. Devices listed here are the ones existing as modules in Tasmota.","title":"Index"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/","text":"Products ~ WiFi-Socket-Smart-Power-Strip at aliexpress AKA: SA-P402A BY-V1.1. 180823 Wifi Smart Power Strip 4 EU Outlets Plug with 4 USBCharging Port at aliexpress also at Amazon.de as AOFO ZLD-44EU-W Koogeek Wifi Smart USB Power Strip Socket at aliexpress AKA: 0710033644644 / KLOE4 Woox R4028 EU Smart Power Strip with 3 EU Plug and 4 USB charging Ports Opening ~ To open take a very small screwdrive to pull out the six feets. Don't remove the rubber plates, it won't help. Flashing ~ You'll have to connect GPIO0 manually, the switch is connected to GPIO1. It marked the pin in the picture. Because the TYWE2S has 2mm pitch, I made a little adapter to 2,54mm pitch. Then it can easy soldered to the first four pins. From left to right 3,3V, Gnd, Rx, Tx. Configuration ~ Configure the USB-Charger as number five, then the next socket as number one and so on. This is the configuration: For the other model (Koogeek and AOFO) the GPIO connections are a bit different: LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO12 Socket 4: GPIO13 USB: GPIO14 For the model Woox R4028 the GPIO connections are a bit different ( only 3 EU Plugs): LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO13 USB: GPIO14","title":"4CH Wifi Socket with USB Charger SA P402A"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/#products","text":"WiFi-Socket-Smart-Power-Strip at aliexpress AKA: SA-P402A BY-V1.1. 180823 Wifi Smart Power Strip 4 EU Outlets Plug with 4 USBCharging Port at aliexpress also at Amazon.de as AOFO ZLD-44EU-W Koogeek Wifi Smart USB Power Strip Socket at aliexpress AKA: 0710033644644 / KLOE4 Woox R4028 EU Smart Power Strip with 3 EU Plug and 4 USB charging Ports","title":"Products"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/#opening","text":"To open take a very small screwdrive to pull out the six feets. Don't remove the rubber plates, it won't help.","title":"Opening"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/#flashing","text":"You'll have to connect GPIO0 manually, the switch is connected to GPIO1. It marked the pin in the picture. Because the TYWE2S has 2mm pitch, I made a little adapter to 2,54mm pitch. Then it can easy soldered to the first four pins. From left to right 3,3V, Gnd, Rx, Tx.","title":"Flashing"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A/#configuration","text":"Configure the USB-Charger as number five, then the next socket as number one and so on. This is the configuration: For the other model (Koogeek and AOFO) the GPIO connections are a bit different: LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO12 Socket 4: GPIO13 USB: GPIO14 For the model Woox R4028 the GPIO connections are a bit different ( only 3 EU Plugs): LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO13 USB: GPIO14","title":"Configuration"},{"location":"devices/Arilux-LC02/","text":"This device is a RGBW led controller and need a different setup against the ex Arilux LC01 You can configure it as a \"generic module\" And set the GPIO as follow: Red: * D1 GPIO5 = 33 PWM1 Blue: * D6 GPIO12 = 35 PWM3 White: * D7 GPIO13 = 36 PWM4 Green: * D5 GPIO14 = 34 PWM2 Learn more about Arilux devices","title":"Arilux LC02"},{"location":"devices/Arilux-LC04/","text":"Arilux AL-LC04 ~ (WIFI Smart RGBW Controller With 24-key IR Remote, Working Voltage: DC 9-12V, Output Current: RGBW, 4*4A) These devices can be configured as \"generic module\" with this GPIO configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO12 = [39] PWM3 (R) GPIO14 = [37] PWM1 (B) GPIO13 = [40] PWM4 (W) [Only for RGBW-Stripe] A later version has been found to use the following configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO13 = [39] PWM3 (R) GPIO12 = [37] PWM1 (B) GPIO15 = [40] PWM4 (W) [Only for RGBW-Stripe] Note: as of #5523 IRCodes are now 64 bits. Copy this Code to your console to use the 24 Button IR Remote rule1 on IrReceived#Data=0x00FFB04F do power1 on endon on IrReceived#Data=0x00FFF807 do power1 off endon on IrReceived#Data=0x00FF906F do dimmer + endon on IrReceived#Data=0x00FFB847 do dimmer - endon on IrReceived#Data=0x00FFB24D do scheme 0 endon on IrReceived#Data=0x00FF00FF do scheme 4 endon on IrReceived#Data=0x00FF58A7 do scheme 2 endon on IrReceived#Data=0x00FF30CF do scheme 3 endon rule2 on IrReceived#Data=0x00FF9867 do color2 #FF0000 endon on IrReceived#Data=0x00FFE817 do color2 #470D00 endon on IrReceived#Data=0x00FF02FD do color2 #381600 endon on IrReceived#Data=0x00FF50AF do color2 #331E00 endon on IrReceived#Data=0x00FF38C7 do color2 #332800 endon on IrReceived#Data=0x00FFD827 do color2 #00FF00 endon on IrReceived#Data=0x00FF48B7 do color2 #00330A endon on IrReceived#Data=0x00FF32CD do color2 #003314 endon on IrReceived#Data=0x00FF7887 do color2 #00331E endon rule3 on IrReceived#Data=0x00FF28D7 do color2 #003328 endon on IrReceived#Data=0x00FF8877 do color2 #0000FF endon on IrReceived#Data=0x00FF6897 do color2 #0A0033 endon on IrReceived#Data=0x00FF20DF do color2 #140033 endon on IrReceived#Data=0x00FF708F do color2 #140033 endon on IrReceived#Data=0x00FFF00F do color2 #280033 endon on IrReceived#Data=0x00FFA857 do color2 #FFFFFF endon and then activate the rules Backlog rule1 1; rule2 1; rule3 1 Learn more about Arilux devices","title":"Arilux AL-LC04"},{"location":"devices/Arilux-LC04/#arilux-al-lc04","text":"(WIFI Smart RGBW Controller With 24-key IR Remote, Working Voltage: DC 9-12V, Output Current: RGBW, 4*4A) These devices can be configured as \"generic module\" with this GPIO configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO12 = [39] PWM3 (R) GPIO14 = [37] PWM1 (B) GPIO13 = [40] PWM4 (W) [Only for RGBW-Stripe] A later version has been found to use the following configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO13 = [39] PWM3 (R) GPIO12 = [37] PWM1 (B) GPIO15 = [40] PWM4 (W) [Only for RGBW-Stripe] Note: as of #5523 IRCodes are now 64 bits. Copy this Code to your console to use the 24 Button IR Remote rule1 on IrReceived#Data=0x00FFB04F do power1 on endon on IrReceived#Data=0x00FFF807 do power1 off endon on IrReceived#Data=0x00FF906F do dimmer + endon on IrReceived#Data=0x00FFB847 do dimmer - endon on IrReceived#Data=0x00FFB24D do scheme 0 endon on IrReceived#Data=0x00FF00FF do scheme 4 endon on IrReceived#Data=0x00FF58A7 do scheme 2 endon on IrReceived#Data=0x00FF30CF do scheme 3 endon rule2 on IrReceived#Data=0x00FF9867 do color2 #FF0000 endon on IrReceived#Data=0x00FFE817 do color2 #470D00 endon on IrReceived#Data=0x00FF02FD do color2 #381600 endon on IrReceived#Data=0x00FF50AF do color2 #331E00 endon on IrReceived#Data=0x00FF38C7 do color2 #332800 endon on IrReceived#Data=0x00FFD827 do color2 #00FF00 endon on IrReceived#Data=0x00FF48B7 do color2 #00330A endon on IrReceived#Data=0x00FF32CD do color2 #003314 endon on IrReceived#Data=0x00FF7887 do color2 #00331E endon rule3 on IrReceived#Data=0x00FF28D7 do color2 #003328 endon on IrReceived#Data=0x00FF8877 do color2 #0000FF endon on IrReceived#Data=0x00FF6897 do color2 #0A0033 endon on IrReceived#Data=0x00FF20DF do color2 #140033 endon on IrReceived#Data=0x00FF708F do color2 #140033 endon on IrReceived#Data=0x00FFF00F do color2 #280033 endon on IrReceived#Data=0x00FFA857 do color2 #FFFFFF endon and then activate the rules Backlog rule1 1; rule2 1; rule3 1 Learn more about Arilux devices","title":"Arilux AL-LC04"},{"location":"devices/Armtronix-Dimmers/","text":"There is a small company making dimmers in about the same formfactor as a sonoff dual and single. These Single and Dual dimmer boards have open source firmware. Supported since version 6.4.0 as ARMTR Dimmer (56) Hardware ~ The dimmers contain an ESP8266 for the wifi connection and an Atmega328 which monitors the mains frequency and dimm the lights using a triac and phase controlled dimming. Communication between the two is done using the serial port at 115200 baud. The dimmers contain extra connections (pin headers) for a 10K potentiometer. When this one is connected you get 10 step dimming of the lights which overrides the tasmota dimm level. This feature also works when the Tasmota firmware is non-functional, so it is nice as a fail safe feature. The setting of the potentiometer is fed back to the Tasmota firmware, so when the potentiometer dimmer is turned and the Tasmota setting overridden, the value in the Tasmota channel is representable of the dimmer value. WARNINGS ~ Phase dimming is not for all lights. Most incandescent bulbs will work, but for LED and CCFL bulbs you will need the special dimmable versions of these lights. The large Blue/Yellow Swedish furniture store has some nice ones. Because these dimmers come in a small package, they lack a bit on the safety and interference side. A good idea would be to add a 1A fuse in the AC line and a R/C Snubber on the output. I also read somewhere that they work less well on 110VAC but this could probably be solved using a firmware update. The ESP8266 and Atmega are isolated from Mains. The used 220v-5V converter is the tried and tested HiLink 5V 0.6A PM01, but without the case. Software ~ For now, to use these dimmers you need to take it apart and flash new firmware to the ESP8266 and the Atmega328p using the Arduino IDE. The whole process is quite well documented for the single and dual dimmers. But you do need a USB to serial bridge, at best one with the DTR and RTS signals broken out as well. The software can be found in two Github repositories, for the single and dual dimmer. The Armtronix dimmer can be used in the Tasmota firmware by uncommenting the line #define USE_ARMTRONIX_DIMMERS in my_user_config.h and setting the module to ARMTR Dimmer. The Dual dimmer has a dual color led, which for now shows the wifi status of the Tasmota firmware. But this can be changed in the Tasmota firmware.","title":"Armtronix Dimmers"},{"location":"devices/Armtronix-Dimmers/#hardware","text":"The dimmers contain an ESP8266 for the wifi connection and an Atmega328 which monitors the mains frequency and dimm the lights using a triac and phase controlled dimming. Communication between the two is done using the serial port at 115200 baud. The dimmers contain extra connections (pin headers) for a 10K potentiometer. When this one is connected you get 10 step dimming of the lights which overrides the tasmota dimm level. This feature also works when the Tasmota firmware is non-functional, so it is nice as a fail safe feature. The setting of the potentiometer is fed back to the Tasmota firmware, so when the potentiometer dimmer is turned and the Tasmota setting overridden, the value in the Tasmota channel is representable of the dimmer value.","title":"Hardware"},{"location":"devices/Armtronix-Dimmers/#warnings","text":"Phase dimming is not for all lights. Most incandescent bulbs will work, but for LED and CCFL bulbs you will need the special dimmable versions of these lights. The large Blue/Yellow Swedish furniture store has some nice ones. Because these dimmers come in a small package, they lack a bit on the safety and interference side. A good idea would be to add a 1A fuse in the AC line and a R/C Snubber on the output. I also read somewhere that they work less well on 110VAC but this could probably be solved using a firmware update. The ESP8266 and Atmega are isolated from Mains. The used 220v-5V converter is the tried and tested HiLink 5V 0.6A PM01, but without the case.","title":"WARNINGS"},{"location":"devices/Armtronix-Dimmers/#software","text":"For now, to use these dimmers you need to take it apart and flash new firmware to the ESP8266 and the Atmega328p using the Arduino IDE. The whole process is quite well documented for the single and dual dimmers. But you do need a USB to serial bridge, at best one with the DTR and RTS signals broken out as well. The software can be found in two Github repositories, for the single and dual dimmer. The Armtronix dimmer can be used in the Tasmota firmware by uncommenting the line #define USE_ARMTRONIX_DIMMERS in my_user_config.h and setting the module to ARMTR Dimmer. The Dual dimmer has a dual color led, which for now shows the wifi status of the Tasmota firmware. But this can be changed in the Tasmota firmware.","title":"Software"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/","text":"Product Page: https://www.amazon.co.uk/gp/product/B07GJ26TCQ Serial Connection ~ Please see the Hardware Preparation page for general instructions. MAKE SURE YOU DON'T HAVE IT PLUGGED IN WHEN DOING ANY OF THIS INCLUDING FLASHING - YOU HAVE BEEN WARNED. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Overview ~ The UK version of the BW SHP works perfectly as module number 45 (BlitzWolf SHP) but is challenging to flash with Tasmota firmware for two reasons: The case is glued; this is relatively easy to overcome as you can insert a very thin screwdriver into the case then simply slide it all the way around the perimeter to free off the glue. A much bigger issue is that the programming pins for the esp8266 are underneath the PCB very close to the case, so there's no way to get to them easily. This is the biggest challenge to installing Tasmota. There are three choices here: Open the case, unsolder the main PCB from the live and neutral pins. This is very difficult to do without deforming the plastic protection on the pins themselves and needs a powerful soldering iron. Open the case, bend the main PCB up from the case. I've done one this way and it's possible, but not ideal as the copper live and neutral bars could crack from fatigue. In either of these two methods, you also have to glue the case back together before the plug is safe to use, otherwise if you try and pull it out of a socket the cover simply comes off, exposing all the mains potentials. Make a slot in the bottom of the case, exposing the programming pins. This is my recommended way of doing it because it doesn't risk damaging the case or having it come apart from improper gluing, nor does it potentially fatigue the power pins or deform their safety plastic. However it does leave a big hole in the bottom of the case! That said, the hole is only accessible when the plug is not in a socket and you can always cover it with more plastic later. Holes in the base method ~ If you want to go for method 3 ie hole in the base, this is where they should be. There's a better picture of this area of the PCB further down this page on a version I removed from its case. Opening the case ~ If you really feel a need to open the case - not recommended - get something very thin and fairly strong, push it into the base and pry a little until it goes in 3-4 millimetres. Then slowly rotate the plug with the wedge held in the opening so you end up pushing the top of the case away from the base all the way around. Once you're done, this is what you'll find inside. Gently pull the white shutter mechanism upwards and off the copper pins - it comes away very smoothly and easily but be careful to hold upright so the little spring doesn't pop out and disappear. To get at the programming pins you then either have to desolder the live and neutral from the PCB and lift the whole thing off - strongly recommend you don't do this as you will almost certainly deform the plastic protecting the pins - or you will need to bend the PCB gently upwards so you can get at the underside. If you do that it will look like this..... It's then pretty easy to flash using the pin connections I've annotated on the drawing - make sure you power it from low voltage though - DON'T EVER CONNECT TO THE MAINS TO FLASH OR WHEN CASE IS OPEN. Once done, bend the PCB back into place, pop the white shutter assembly back on top and put the two case halves together with strong glue. MAKE SURE THE GLUE IS WELL HELD AS OTHERWISE WHEN YOU PULL THE PLUG OUT OF A SOCKET THE TOP COULD COME OFF, EXPOSING ALL THE LIVE CONNECTIONS. This is why I DON'T recommend opening the case to flash the firmware but instead suggest cutting a slot in the base and cover it afterwards.","title":"BlitzWolf BW SHP4 UK Version"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. MAKE SURE YOU DON'T HAVE IT PLUGGED IN WHEN DOING ANY OF THIS INCLUDING FLASHING - YOU HAVE BEEN WARNED. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK.","title":"Serial Connection"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/#overview","text":"The UK version of the BW SHP works perfectly as module number 45 (BlitzWolf SHP) but is challenging to flash with Tasmota firmware for two reasons: The case is glued; this is relatively easy to overcome as you can insert a very thin screwdriver into the case then simply slide it all the way around the perimeter to free off the glue. A much bigger issue is that the programming pins for the esp8266 are underneath the PCB very close to the case, so there's no way to get to them easily. This is the biggest challenge to installing Tasmota. There are three choices here: Open the case, unsolder the main PCB from the live and neutral pins. This is very difficult to do without deforming the plastic protection on the pins themselves and needs a powerful soldering iron. Open the case, bend the main PCB up from the case. I've done one this way and it's possible, but not ideal as the copper live and neutral bars could crack from fatigue. In either of these two methods, you also have to glue the case back together before the plug is safe to use, otherwise if you try and pull it out of a socket the cover simply comes off, exposing all the mains potentials. Make a slot in the bottom of the case, exposing the programming pins. This is my recommended way of doing it because it doesn't risk damaging the case or having it come apart from improper gluing, nor does it potentially fatigue the power pins or deform their safety plastic. However it does leave a big hole in the bottom of the case! That said, the hole is only accessible when the plug is not in a socket and you can always cover it with more plastic later.","title":"Overview"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/#holes-in-the-base-method","text":"If you want to go for method 3 ie hole in the base, this is where they should be. There's a better picture of this area of the PCB further down this page on a version I removed from its case.","title":"Holes in the base method"},{"location":"devices/BlitzWolf-BW-SHP4-UK-Version/#opening-the-case","text":"If you really feel a need to open the case - not recommended - get something very thin and fairly strong, push it into the base and pry a little until it goes in 3-4 millimetres. Then slowly rotate the plug with the wedge held in the opening so you end up pushing the top of the case away from the base all the way around. Once you're done, this is what you'll find inside. Gently pull the white shutter mechanism upwards and off the copper pins - it comes away very smoothly and easily but be careful to hold upright so the little spring doesn't pop out and disappear. To get at the programming pins you then either have to desolder the live and neutral from the PCB and lift the whole thing off - strongly recommend you don't do this as you will almost certainly deform the plastic protecting the pins - or you will need to bend the PCB gently upwards so you can get at the underside. If you do that it will look like this..... It's then pretty easy to flash using the pin connections I've annotated on the drawing - make sure you power it from low voltage though - DON'T EVER CONNECT TO THE MAINS TO FLASH OR WHEN CASE IS OPEN. Once done, bend the PCB back into place, pop the white shutter assembly back on top and put the two case halves together with strong glue. MAKE SURE THE GLUE IS WELL HELD AS OTHERWISE WHEN YOU PULL THE PLUG OUT OF A SOCKET THE TOP COULD COME OFF, EXPOSING ALL THE LIVE CONNECTIONS. This is why I DON'T recommend opening the case to flash the firmware but instead suggest cutting a slot in the base and cover it afterwards.","title":"Opening the case"},{"location":"devices/BlitzWolf-SHP2/","text":"The BlitzWolf BW-SHP2, HomeCube SP1, and Teckin SP22 are basically the same device barring the branding. September 2019 - Recent versions of the Teckin SP22 have been redesigned with a Tuya WR2 Wi-Fi module based on the Realtek RTL8710BN. Since these are not ESP82xx based, Tasmota will not function on this newer version of the device. Product Page: - BlitzWolf BW-SHP2 - Gosund-SP1 OTA install ~ October 2019 - As far as the newer firmware versions and shipments are delivered, the devices possibly won't work with this method. Try it at your own discretion. Since SHP2 is one of those Tuya based devices this OTA Tasmota installation method works just fine: https://github.com/ct-Open-Source/tuya-convert The Tuya-convert has a built in Tasmota v6.5.0 basic(but you can define any firmware during the install), remember, that basic version doesn't come with homeassistant auto discovery support, but Tasmota OTA works as expected. This method does't need any wiring. Serial Connection ~ Please see the Hardware Preparation page for general instructions. Step 1. ~ Be sure it is NOT plugged in! Remove the 4 triangle screws. Triangular 2.3mm Screwdriver required (a Torx T6 works well too)! Step 2. ~ Solder cables to the ESP Pins Step 3. ~ For version 2.3 and 2.4, see: devices/Gosund-SP1 . Connect serial adapter and make a shortwire between Pin IO0 and GND during startup. (For entering flashmode) RX and TX must be crossed. Step 4. ~ Flash Tasmota OpenHab configuration ~ sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=Power_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\" Home Assistant configuration ~ configuration.yaml switch: - platform: mqtt name: \"Blitzwolf\" state_topic: \"stat/blitzwolf/POWER\" command_topic: \"cmnd/blitzwolf/POWER\" payload_on: \"ON\" payload_off: \"OFF\" retain: false sensor: - platform: mqtt name: \"Blitzwolf Energy Today\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Energy Yesterday\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Energy Total\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Power\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement: \"W\" - platform: mqtt name: \"Blitzwolf Voltage\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement: \"V\" - platform: mqtt name: \"Blitzwolf Power Factor\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Factor\"] }}' Attention ~ There is a newer hardware revision (v2.3) which is supported too. Use latest release. See also devices/Gosund-SP1","title":"BlitzWolf SHP2"},{"location":"devices/BlitzWolf-SHP2/#ota-install","text":"October 2019 - As far as the newer firmware versions and shipments are delivered, the devices possibly won't work with this method. Try it at your own discretion. Since SHP2 is one of those Tuya based devices this OTA Tasmota installation method works just fine: https://github.com/ct-Open-Source/tuya-convert The Tuya-convert has a built in Tasmota v6.5.0 basic(but you can define any firmware during the install), remember, that basic version doesn't come with homeassistant auto discovery support, but Tasmota OTA works as expected. This method does't need any wiring.","title":"OTA install"},{"location":"devices/BlitzWolf-SHP2/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP2/#step-1","text":"Be sure it is NOT plugged in! Remove the 4 triangle screws. Triangular 2.3mm Screwdriver required (a Torx T6 works well too)!","title":"Step 1."},{"location":"devices/BlitzWolf-SHP2/#step-2","text":"Solder cables to the ESP Pins","title":"Step 2."},{"location":"devices/BlitzWolf-SHP2/#step-3","text":"For version 2.3 and 2.4, see: devices/Gosund-SP1 . Connect serial adapter and make a shortwire between Pin IO0 and GND during startup. (For entering flashmode) RX and TX must be crossed.","title":"Step 3."},{"location":"devices/BlitzWolf-SHP2/#step-4","text":"Flash Tasmota","title":"Step 4."},{"location":"devices/BlitzWolf-SHP2/#openhab-configuration","text":"sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=Power_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\"","title":"OpenHab configuration"},{"location":"devices/BlitzWolf-SHP2/#home-assistant-configuration","text":"configuration.yaml switch: - platform: mqtt name: \"Blitzwolf\" state_topic: \"stat/blitzwolf/POWER\" command_topic: \"cmnd/blitzwolf/POWER\" payload_on: \"ON\" payload_off: \"OFF\" retain: false sensor: - platform: mqtt name: \"Blitzwolf Energy Today\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Energy Yesterday\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Energy Total\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Power\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement: \"W\" - platform: mqtt name: \"Blitzwolf Voltage\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement: \"V\" - platform: mqtt name: \"Blitzwolf Power Factor\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Home Assistant configuration"},{"location":"devices/BlitzWolf-SHP2/#attention","text":"There is a newer hardware revision (v2.3) which is supported too. Use latest release. See also devices/Gosund-SP1","title":"Attention"},{"location":"devices/BlitzWolf-SHP6/","text":"The BlitzWolf BW-SHP6, Gosund SP111, and the Nous A1 are basically the same device, barring the branding. Product page: - BlitzWolf\u00ae BW-SHP6 - 2300W EU WIFI Smart Socket - Gosund SP111 - Nous A1 Device needs exact calibration with a load >=60 Watt to gain good results! For further infos see Issue #4727 Serial Connection ~ Please see the Hardware Preparation page for general instructions. There are currently at least two versions of this device. The (newer) Version has exposed contacts with holes for all connections necessary to flash tasmota, while the old requires soldering of cables to some points. For the older Version: Step 1 ~ Disconnect device from power source! Step 2 ~ Remove one screw on the back of the device. PH1 screwdriver required. Step 3 ~ Undo 2 screws. PH1 screwdriver required. Disconnect antenna. Step 4 ~ Carefully remove PCB from casing for easier soldering. * Don't stress antenna cable too much. * Don't lose metal tube. Step 5 ~ Solder cables to the ESP Pins. SHP6 10A model: SHP6 15A model: If you do not want to solder you can try using crocodile clips and manually push a jumper cable first to IO0 (enter flash mode while booting, i.e. connect IO0 to ground) and then during flashing push a jumper to TX. Just be careful to not cause any short-circuit with the clips on the other side of the pads. Crocodile clips Step 6 ~ Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode). Step 7 ~ Erase flash to avoid issues with dropping WiFi connection. Example using esptool: esptool.py --port COM3 erase_flash Step 8 ~ Flash Tasmota. Step 9 ~ Select the correct configuration under Configuration -> Configure Module or apply correct template: SHP6 10A model SHP6 15A model As an alternative for steps 3 to 5: ~ The following programming adapter could be an option, which requires no soldering or significant disassembly on the SHP-6. It significantly reduces the effort of reflashing multiple SHP-6 units. Thingiverse link For Version 2 for steps 3 to 5: ~ The new Version has exposed pads with holes for Ground, Reset, TX, RX, Vcc 3.3.V and GPIO0. YOu can use small jumper cables to directly connect a programmer, so no further disassembly is required. NOTE: If Tasmotizer or esptool timeouts, can't find your socket and nothing seems working, before tearing your hair out try swapping TX and RX connections on your serial adapter, i.e. TX on board connect to RX on adapter and similarly RX on board to TX on adapter. NOTE2: GPIO0 can stay connected to GND always. For version 2 (alternative layout) ~ In case that device is not booting in flash mode - then your pinout is different - assume that GPIO0 is Reset pin, and put it to ground before powering on device. Other photos ~ Power monitoring calibration ~ Approach the calibration using the Method 2. If not satisfied with the results, you could mod the SMD direct measure resistor or mitigate this using a Tasmota set of rules (values valid only for the 10A model): Rule1 ON energy#power<=100 DO Currentcal 2500 BREAK ON energy#power<=500 DO Currentcal 2635 BREAK ON energy#power<=1000 DO Currentcal 2788 BREAK ON energy#power<=1500 DO Currentcal 2942 BREAK ON energy#power<=2000 DO Currentcal 3095 BREAK ON energy#power<=2500 DO Currentcal 3249 BREAK ON energy#power>2500 DO Currentcal 3402 BREAK Rule1 1 Take the CurrentCal values above as a first approach and should be corrected through the Tasmota Method 2 calibration procedure: [[devices/Power-Monitoring-Calibration]] Home Assistant configuration ~ switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"BlitzWolf SHP6"},{"location":"devices/BlitzWolf-SHP6/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. There are currently at least two versions of this device. The (newer) Version has exposed contacts with holes for all connections necessary to flash tasmota, while the old requires soldering of cables to some points. For the older Version:","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP6/#step-1","text":"Disconnect device from power source!","title":"Step 1"},{"location":"devices/BlitzWolf-SHP6/#step-2","text":"Remove one screw on the back of the device. PH1 screwdriver required.","title":"Step 2"},{"location":"devices/BlitzWolf-SHP6/#step-3","text":"Undo 2 screws. PH1 screwdriver required. Disconnect antenna.","title":"Step 3"},{"location":"devices/BlitzWolf-SHP6/#step-4","text":"Carefully remove PCB from casing for easier soldering. * Don't stress antenna cable too much. * Don't lose metal tube.","title":"Step 4"},{"location":"devices/BlitzWolf-SHP6/#step-5","text":"Solder cables to the ESP Pins. SHP6 10A model: SHP6 15A model: If you do not want to solder you can try using crocodile clips and manually push a jumper cable first to IO0 (enter flash mode while booting, i.e. connect IO0 to ground) and then during flashing push a jumper to TX. Just be careful to not cause any short-circuit with the clips on the other side of the pads. Crocodile clips","title":"Step 5"},{"location":"devices/BlitzWolf-SHP6/#step-6","text":"Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode).","title":"Step 6"},{"location":"devices/BlitzWolf-SHP6/#step-7","text":"Erase flash to avoid issues with dropping WiFi connection. Example using esptool: esptool.py --port COM3 erase_flash","title":"Step 7"},{"location":"devices/BlitzWolf-SHP6/#step-8","text":"Flash Tasmota.","title":"Step 8"},{"location":"devices/BlitzWolf-SHP6/#step-9","text":"Select the correct configuration under Configuration -> Configure Module or apply correct template: SHP6 10A model SHP6 15A model","title":"Step 9"},{"location":"devices/BlitzWolf-SHP6/#as-an-alternative-for-steps-3-to-5","text":"The following programming adapter could be an option, which requires no soldering or significant disassembly on the SHP-6. It significantly reduces the effort of reflashing multiple SHP-6 units. Thingiverse link","title":"As an alternative for steps 3 to 5:"},{"location":"devices/BlitzWolf-SHP6/#for-version-2-for-steps-3-to-5","text":"The new Version has exposed pads with holes for Ground, Reset, TX, RX, Vcc 3.3.V and GPIO0. YOu can use small jumper cables to directly connect a programmer, so no further disassembly is required. NOTE: If Tasmotizer or esptool timeouts, can't find your socket and nothing seems working, before tearing your hair out try swapping TX and RX connections on your serial adapter, i.e. TX on board connect to RX on adapter and similarly RX on board to TX on adapter. NOTE2: GPIO0 can stay connected to GND always.","title":"For Version 2 for steps 3 to 5:"},{"location":"devices/BlitzWolf-SHP6/#for-version-2-alternative-layout","text":"In case that device is not booting in flash mode - then your pinout is different - assume that GPIO0 is Reset pin, and put it to ground before powering on device.","title":"For version 2 (alternative layout)"},{"location":"devices/BlitzWolf-SHP6/#other-photos","text":"","title":"Other photos"},{"location":"devices/BlitzWolf-SHP6/#power-monitoring-calibration","text":"Approach the calibration using the Method 2. If not satisfied with the results, you could mod the SMD direct measure resistor or mitigate this using a Tasmota set of rules (values valid only for the 10A model): Rule1 ON energy#power<=100 DO Currentcal 2500 BREAK ON energy#power<=500 DO Currentcal 2635 BREAK ON energy#power<=1000 DO Currentcal 2788 BREAK ON energy#power<=1500 DO Currentcal 2942 BREAK ON energy#power<=2000 DO Currentcal 3095 BREAK ON energy#power<=2500 DO Currentcal 3249 BREAK ON energy#power>2500 DO Currentcal 3402 BREAK Rule1 1 Take the CurrentCal values above as a first approach and should be corrected through the Tasmota Method 2 calibration procedure: [[devices/Power-Monitoring-Calibration]]","title":"Power monitoring calibration"},{"location":"devices/BlitzWolf-SHP6/#home-assistant-configuration","text":"switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Home Assistant configuration"},{"location":"devices/BlitzWolf-SHP7/","text":"Serial Connection ~ Please see the Hardware Preparation page for general instructions. Step 1 ~ Disconnect device from power source! Step 2 ~ Remove the two stickers on the front. Step 3 ~ Undo 2 screws. PH1 screwdriver required. Step 4 ~ Remove back with screwdriver Step 4 ~ Undo 2 screws at the back. PH1 screwdriver required. Step 5 ~ Remove PCB from casing for easier soldering. Step 6 ~ Solder cables to the ESP pins. Because GND is hard to solder/access, I recommend to use the other side for GND: Result: Step 7 ~ Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode). Step 8 ~ Flash Tasmota. Step 9 ~ Setup Tasmota (wifi settings). Go to Configuration -> Configure Other and enter this template: {\"NAME\":\"SHP7 v2\",\"GPIO\":[18,158,56,131,134,132,0,0,17,57,21,0,22],\"FLAG\":0,\"BASE\":45} (I had to use v2 from https://templates.blakadder.com/blitzwolf_SHP7.html) Done !","title":"BlitzWolf SHP7"},{"location":"devices/BlitzWolf-SHP7/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP7/#step-1","text":"Disconnect device from power source!","title":"Step 1"},{"location":"devices/BlitzWolf-SHP7/#step-2","text":"Remove the two stickers on the front.","title":"Step 2"},{"location":"devices/BlitzWolf-SHP7/#step-3","text":"Undo 2 screws. PH1 screwdriver required.","title":"Step 3"},{"location":"devices/BlitzWolf-SHP7/#step-4","text":"Remove back with screwdriver","title":"Step 4"},{"location":"devices/BlitzWolf-SHP7/#step-4_1","text":"Undo 2 screws at the back. PH1 screwdriver required.","title":"Step 4"},{"location":"devices/BlitzWolf-SHP7/#step-5","text":"Remove PCB from casing for easier soldering.","title":"Step 5"},{"location":"devices/BlitzWolf-SHP7/#step-6","text":"Solder cables to the ESP pins. Because GND is hard to solder/access, I recommend to use the other side for GND: Result:","title":"Step 6"},{"location":"devices/BlitzWolf-SHP7/#step-7","text":"Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode).","title":"Step 7"},{"location":"devices/BlitzWolf-SHP7/#step-8","text":"Flash Tasmota.","title":"Step 8"},{"location":"devices/BlitzWolf-SHP7/#step-9","text":"Setup Tasmota (wifi settings). Go to Configuration -> Configure Other and enter this template: {\"NAME\":\"SHP7 v2\",\"GPIO\":[18,158,56,131,134,132,0,0,17,57,21,0,22],\"FLAG\":0,\"BASE\":45} (I had to use v2 from https://templates.blakadder.com/blitzwolf_SHP7.html) Done !","title":"Step 9"},{"location":"devices/Burnett-BN-K01/","text":"The Burnett Smart Socket. ~ Introduction ~ The Burnett Smart Socket BN-K01 is a smart socket that is small in size. The body is only 58mm * 48mm 34mm which can fit into smaller places. It is equipped with an ESP8285 which makes it possible to flash sonoff-tasmota. However, * you need to manually wire the Tx and Rx from the chip for flashing**. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code. What is it? ~ As the other Sonoff's do, this smart socket uses EWeLink app to control. It\u2019s pretty well made and there is a shutter to close off the live socket holes when a plug is removed. Besides, it is pretty cheap in Taobao (it costs no more than USD 6). \ufffc Disassembly ~ * WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * There are no screws. And unfortunately it is precisely glued, so to disassemble you need to find a thin yet strong tool to pull it open. \ufffcInside there is a main board with most of the components on the top. The Wi-Fi and control comes from a small daughter board, soldered on the left of the main board.\ufffc Unfortunately I cannot tear down the plastic around the main board, so I don't have a clear look for the back of the daughter board. Hookup ~ Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the daughter board. For flashing you need to solder the VCC and GND from the back. As shown in the picture, the GND is the top right pad while the VCC is the bottom left pad. While unfortunately, the Rx and Tx is not connected, so you have to wire directly to the ESP8285. It can be very hard if you are not familiar with soldering. The GPIO0 is connected to the button so no wiring is needed. Building Firmware ~ The process for building the firmware for the Burnett BN-K01 is basically the same as for the Sonoff with a few additional changes. You need to set the board to \"Generic ESP8285 Module\" The crystal frequency is 26MHz. Flash the Firmware ~ Hold the button when you connect the VCC and GND to make the ESP8285 boot into flash mode. After it boots, you no longer need to hold it. Configure ~ After you flashed and booted the Burnett BN-K01, just set config it as Sonoff S2x, then it will work.","title":"The Burnett Smart Socket."},{"location":"devices/Burnett-BN-K01/#the-burnett-smart-socket","text":"","title":"The Burnett Smart Socket."},{"location":"devices/Burnett-BN-K01/#introduction","text":"The Burnett Smart Socket BN-K01 is a smart socket that is small in size. The body is only 58mm * 48mm 34mm which can fit into smaller places. It is equipped with an ESP8285 which makes it possible to flash sonoff-tasmota. However, * you need to manually wire the Tx and Rx from the chip for flashing**. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code.","title":"Introduction"},{"location":"devices/Burnett-BN-K01/#what-is-it","text":"As the other Sonoff's do, this smart socket uses EWeLink app to control. It\u2019s pretty well made and there is a shutter to close off the live socket holes when a plug is removed. Besides, it is pretty cheap in Taobao (it costs no more than USD 6). \ufffc","title":"What is it?"},{"location":"devices/Burnett-BN-K01/#disassembly","text":"* WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * There are no screws. And unfortunately it is precisely glued, so to disassemble you need to find a thin yet strong tool to pull it open. \ufffcInside there is a main board with most of the components on the top. The Wi-Fi and control comes from a small daughter board, soldered on the left of the main board.\ufffc Unfortunately I cannot tear down the plastic around the main board, so I don't have a clear look for the back of the daughter board.","title":"Disassembly"},{"location":"devices/Burnett-BN-K01/#hookup","text":"Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the daughter board. For flashing you need to solder the VCC and GND from the back. As shown in the picture, the GND is the top right pad while the VCC is the bottom left pad. While unfortunately, the Rx and Tx is not connected, so you have to wire directly to the ESP8285. It can be very hard if you are not familiar with soldering. The GPIO0 is connected to the button so no wiring is needed.","title":"Hookup"},{"location":"devices/Burnett-BN-K01/#building-firmware","text":"The process for building the firmware for the Burnett BN-K01 is basically the same as for the Sonoff with a few additional changes. You need to set the board to \"Generic ESP8285 Module\" The crystal frequency is 26MHz.","title":"Building Firmware"},{"location":"devices/Burnett-BN-K01/#flash-the-firmware","text":"Hold the button when you connect the VCC and GND to make the ESP8285 boot into flash mode. After it boots, you no longer need to hold it.","title":"Flash the Firmware"},{"location":"devices/Burnett-BN-K01/#configure","text":"After you flashed and booted the Burnett BN-K01, just set config it as Sonoff S2x, then it will work.","title":"Configure"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/","text":"CE Smart Home - LA-WF3 Wifi Plug (TYWE2S) ~ Simple and compact Wifi Plug, based in ESP8266, internal module Tuya TYWE2S esptool log: Wifi module is an: TYWE2S: Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded. Model purchased: https://www.costco.ca/Wi-Fi-Smart-Plug%2C-2-pack.product.100417575.html 24.99 CAD$ Product ~ Flashing ~ GPIO0 Needs to be grounded in order to get into flashing mode. 1. erase_flash 2. flash tasmota_minimal 3. flash tasmota_full Module Configuration ~","title":"CE Smart Home   LA WF3 Wifi Plug"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/#ce-smart-home-la-wf3-wifi-plug-tywe2s","text":"Simple and compact Wifi Plug, based in ESP8266, internal module Tuya TYWE2S esptool log: Wifi module is an: TYWE2S: Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded. Model purchased: https://www.costco.ca/Wi-Fi-Smart-Plug%2C-2-pack.product.100417575.html 24.99 CAD$","title":"CE Smart Home - LA-WF3 Wifi Plug (TYWE2S)"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/#product","text":"","title":"Product"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/#flashing","text":"GPIO0 Needs to be grounded in order to get into flashing mode. 1. erase_flash 2. flash tasmota_minimal 3. flash tasmota_full","title":"Flashing"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug/#module-configuration","text":"","title":"Module Configuration"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/","text":"Device Template ~ {\"NAME\":\"CE Power Stake\",\"GPIO\":[255,255,255,255,56,57,255,255,21,17,255,255,255],\"FLAG\":0,\"BASE\":18} Connection ~ This 6-outlet outdoor garden power stake is controlled by a standard ESP-12 chip connected to a single relay, meaning that all 6 outlets are on or off simultaneously. It also has a mains switch, a manual relay trigger button, and an LED indicator. Programmer Power Stake 3V3 VCC TX RX RX TX GND GND The button is not connected to D0 , so you will need to shunt D0 / GPIO0 to GND to enable programming mode. You may need to briefly shunt RESET to GND in order to initiate connections to the device. Internal Device Image ~ [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_esp12s.jpg|alt=PowerStake Pinout]] Generic Module Config ~ [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_tasmota_config.jpg|alt=Generic Module Config]] Additional Information ~ This device was found at Costco, and in fact appears to be made for Costco (see image below). The regular price was $13.97 USD, but was on sale for Christmas for $9.99 USD. [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_front.jpg|alt=PowerStake Box Front]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_rear.jpg|alt=PowerStake Box Rear]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side1.jpg|alt=PowerStake Box Side 1]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side2.jpg|alt=PowerStake Box Side 2]] [[https://github.com/untergeek/shared_images/blob/master/devices/esp12-pinout.png|alt=ESP12]]","title":"CE Smart Home\u2122 Garden Power Stake"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#device-template","text":"{\"NAME\":\"CE Power Stake\",\"GPIO\":[255,255,255,255,56,57,255,255,21,17,255,255,255],\"FLAG\":0,\"BASE\":18}","title":"Device Template"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#connection","text":"This 6-outlet outdoor garden power stake is controlled by a standard ESP-12 chip connected to a single relay, meaning that all 6 outlets are on or off simultaneously. It also has a mains switch, a manual relay trigger button, and an LED indicator. Programmer Power Stake 3V3 VCC TX RX RX TX GND GND The button is not connected to D0 , so you will need to shunt D0 / GPIO0 to GND to enable programming mode. You may need to briefly shunt RESET to GND in order to initiate connections to the device.","title":"Connection"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#internal-device-image","text":"[[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_esp12s.jpg|alt=PowerStake Pinout]]","title":"Internal Device Image"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#generic-module-config","text":"[[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_tasmota_config.jpg|alt=Generic Module Config]]","title":"Generic Module Config"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#additional-information","text":"This device was found at Costco, and in fact appears to be made for Costco (see image below). The regular price was $13.97 USD, but was on sale for Christmas for $9.99 USD. [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_front.jpg|alt=PowerStake Box Front]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_rear.jpg|alt=PowerStake Box Rear]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side1.jpg|alt=PowerStake Box Side 1]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side2.jpg|alt=PowerStake Box Side 2]] [[https://github.com/untergeek/shared_images/blob/master/devices/esp12-pinout.png|alt=ESP12]]","title":"Additional Information"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/","text":"General ~ These CNSKOU / CNSANKOU wall switches (Chinese Sonoff clones) are sold on AliExpress and have a neutral design. They come in 1, 2 and 3 circuits and are easily mounted replacing your old wall switches. It measures 118mm wide by 72mm high, irrespective of the number of buttons, although it is also available in 86x86mm. The tempered glass front plate is available in white, black and gold colors. Despite it being advertised as a 'US' device, it will handle 90-250V AC input at 50/60Hz and is said to switch up to 10A per circuit. The same design is also available for use with a RF-remote, or as a traditional wall switch. There is a backlight indicator behind each button, which subtly shows green when the circuit is live and red when it is not. When physically pushing the button, there is an audio feedback. See here to view a video of the audio feedback. The one interesting for Tasmota is of course the WiFi version, which connects to 2.4GHz networks, up to 802.11n. The switch comes pre-loaded with ITEAD software and works well with the EWeLink app. Inside ~ When opening the package, easily done by turning a screwdriver under the two plastic lips at the lower side of the switch, the first thing we see are the capacitive touch sensors mounted on the back of the low-voltage board. The low-voltage board is connected through a 14-pin connector to the mains board, and contains an ESP8285 , piezo buzzer (should you wish to remove that audio feedback!) and a number of additional components. The ESP8285 is of course compatible with the ESP8266 albeit with only 1MB flash storage. The mains-voltage board contains the mains connection points, a TI ULN2003A relay driver and 1-3 relays and a tiny little board containing a power supply for the low-voltage bits. Flashing ~ The most interesting part is of course how we flash this device with Tasmota. To do this, do not connect the device to mains power and carefully remove the low-voltage board as this is all you'll need. Notice the 4 connection points just above the ESP8285, which is where you'll connect (from square pad up) 3v3, RX, TX and GND. I found that normal DuPont jumper wires provide a secure enough connection, but you may wish to solder on a few header pins. In order to get the ESP8285 into programming mode, you'll also need to connect GPIO0 to GND. There is no easily accessible connection point for GPIO0 and no buttons are provided on the board. I found the easiest way is to just use a normal jumper cable and manually hold it up against pin 10 (GPIO0) for a few seconds while the power is connected to the chip. Pin 10 is the second pin of the 'pin 9-16' row, on the right hand side of the chip in the image above. Use the usual method for flashing, undoubtedly documented better elsewhere than I ever could. Once Tasmota was up and running, I used the Sonoff T1 US module type.","title":"CNSKOU   CNSANKOU wall switches"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#general","text":"These CNSKOU / CNSANKOU wall switches (Chinese Sonoff clones) are sold on AliExpress and have a neutral design. They come in 1, 2 and 3 circuits and are easily mounted replacing your old wall switches. It measures 118mm wide by 72mm high, irrespective of the number of buttons, although it is also available in 86x86mm. The tempered glass front plate is available in white, black and gold colors. Despite it being advertised as a 'US' device, it will handle 90-250V AC input at 50/60Hz and is said to switch up to 10A per circuit. The same design is also available for use with a RF-remote, or as a traditional wall switch. There is a backlight indicator behind each button, which subtly shows green when the circuit is live and red when it is not. When physically pushing the button, there is an audio feedback. See here to view a video of the audio feedback. The one interesting for Tasmota is of course the WiFi version, which connects to 2.4GHz networks, up to 802.11n. The switch comes pre-loaded with ITEAD software and works well with the EWeLink app.","title":"General"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#inside","text":"When opening the package, easily done by turning a screwdriver under the two plastic lips at the lower side of the switch, the first thing we see are the capacitive touch sensors mounted on the back of the low-voltage board. The low-voltage board is connected through a 14-pin connector to the mains board, and contains an ESP8285 , piezo buzzer (should you wish to remove that audio feedback!) and a number of additional components. The ESP8285 is of course compatible with the ESP8266 albeit with only 1MB flash storage. The mains-voltage board contains the mains connection points, a TI ULN2003A relay driver and 1-3 relays and a tiny little board containing a power supply for the low-voltage bits.","title":"Inside"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#flashing","text":"The most interesting part is of course how we flash this device with Tasmota. To do this, do not connect the device to mains power and carefully remove the low-voltage board as this is all you'll need. Notice the 4 connection points just above the ESP8285, which is where you'll connect (from square pad up) 3v3, RX, TX and GND. I found that normal DuPont jumper wires provide a secure enough connection, but you may wish to solder on a few header pins. In order to get the ESP8285 into programming mode, you'll also need to connect GPIO0 to GND. There is no easily accessible connection point for GPIO0 and no buttons are provided on the board. I found the easiest way is to just use a normal jumper cable and manually hold it up against pin 10 (GPIO0) for a few seconds while the power is connected to the chip. Pin 10 is the second pin of the 'pin 9-16' row, on the right hand side of the chip in the image above. Use the usual method for flashing, undoubtedly documented better elsewhere than I ever could. Once Tasmota was up and running, I used the Sonoff T1 US module type.","title":"Flashing"},{"location":"devices/CSL-aplic-WDP-303075/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND For flashing you need to connect GPIO0 to GND Additional Information ~ Hardware details ~ ESP8266 - on TYWE2S Module HLW8012 - Power Monitor Chip SRU 5VDC SDA - Relais GPIO0 ~ You need to solder a wire to the test-point on the TYWE2S Module to be able to enter the flashmode. The Resest Pin has no function for that purpose. Device Images ~ GPIO Config ~ Power Monitoring will not work with that configuration... wait for software update in case you want to use it UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for CSL Aplic WDP 303075 Power Socket with Energy Monitoring (#3991, #3996))","title":"CSL aplic WDP 303075"},{"location":"devices/CSL-aplic-WDP-303075/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND For flashing you need to connect GPIO0 to GND","title":"Connection"},{"location":"devices/CSL-aplic-WDP-303075/#additional-information","text":"","title":"Additional Information"},{"location":"devices/CSL-aplic-WDP-303075/#hardware-details","text":"ESP8266 - on TYWE2S Module HLW8012 - Power Monitor Chip SRU 5VDC SDA - Relais","title":"Hardware details"},{"location":"devices/CSL-aplic-WDP-303075/#gpio0","text":"You need to solder a wire to the test-point on the TYWE2S Module to be able to enter the flashmode. The Resest Pin has no function for that purpose.","title":"GPIO0"},{"location":"devices/CSL-aplic-WDP-303075/#device-images","text":"","title":"Device Images"},{"location":"devices/CSL-aplic-WDP-303075/#gpio-config","text":"Power Monitoring will not work with that configuration... wait for software update in case you want to use it UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for CSL Aplic WDP 303075 Power Socket with Energy Monitoring (#3991, #3996))","title":"GPIO Config"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/","text":"General: ~ Nice size and form factor - can be used as Sonoff Basic R2 There seems to be no unique name for the device in the market. The one I ordered for testing Tasmota was packaged by brand / model Canwing CW-001 . Let's use this naming for all similar devices. Operating the device under the original firmware by use of eWeLink-App shows \"Coolkit 0185\" as brand / model supported by ESP8285 . Source of supply was \"ebay.de\", seller \"globewin\", ordered 2019-01-12 for a price of 6,89 Euro , received in 14 calendar days. Additionally by name \u201eASHATA Intelligente WLAN Schalter\u201c this device is proposed by \"amazon.de\", seller \"Richer-R123\" for a price of 9,39 Euro. Aliexpress: Wi-Fi Smart Switch 5A Features of original device / firmware: ~ Remote control domestic appliances - a phone with 2.4G WiFi can remote control all domestic appliances through phone app. 1000W large power - adopting a 1000 W power to make operation powerful. Suitable for higher than Android 4.0. Flame retardant ABS shell ensures the safety. PCB equipped with serial standard interface (4 pins RX, TX, GND, Vcc / 3.3 V) and button / momentary switch dedicated to GPIO0. Specification: ~ Product type: WiFi Switch Module Wireless standard: WIFI 2.4 GHz IEEE 802.11 b/g/n Remote control mode: eWeLink phone app for Android/iOS or Tasmota Chip ESP 8266 / 8285 Maximum power: 1000 W / 5 A Package size: approx. 57 * 41 * 21 mm / 2.4 * 1.6 * 1.1 in Package weight: 35 g / 1.2 oz Package List: ~ 1 x WiFi Switch Controller 1 x User Manual (see end of this page) Photos of the case: ~ Photos of the PCB: ~ Magic moment \u2013 eWeLink slips away \u2013 Tasmota appears: ~ Result: ~ \u2003 Original users manual for eWeLink: ~","title":"Canwing CW001 WiFi Smart Switch"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#general","text":"Nice size and form factor - can be used as Sonoff Basic R2 There seems to be no unique name for the device in the market. The one I ordered for testing Tasmota was packaged by brand / model Canwing CW-001 . Let's use this naming for all similar devices. Operating the device under the original firmware by use of eWeLink-App shows \"Coolkit 0185\" as brand / model supported by ESP8285 . Source of supply was \"ebay.de\", seller \"globewin\", ordered 2019-01-12 for a price of 6,89 Euro , received in 14 calendar days. Additionally by name \u201eASHATA Intelligente WLAN Schalter\u201c this device is proposed by \"amazon.de\", seller \"Richer-R123\" for a price of 9,39 Euro. Aliexpress: Wi-Fi Smart Switch 5A","title":"General:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#features-of-original-device-firmware","text":"Remote control domestic appliances - a phone with 2.4G WiFi can remote control all domestic appliances through phone app. 1000W large power - adopting a 1000 W power to make operation powerful. Suitable for higher than Android 4.0. Flame retardant ABS shell ensures the safety. PCB equipped with serial standard interface (4 pins RX, TX, GND, Vcc / 3.3 V) and button / momentary switch dedicated to GPIO0.","title":"Features of original device / firmware:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#specification","text":"Product type: WiFi Switch Module Wireless standard: WIFI 2.4 GHz IEEE 802.11 b/g/n Remote control mode: eWeLink phone app for Android/iOS or Tasmota Chip ESP 8266 / 8285 Maximum power: 1000 W / 5 A Package size: approx. 57 * 41 * 21 mm / 2.4 * 1.6 * 1.1 in Package weight: 35 g / 1.2 oz","title":"Specification:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#package-list","text":"1 x WiFi Switch Controller 1 x User Manual (see end of this page)","title":"Package List:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#photos-of-the-case","text":"","title":"Photos of the case:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#photos-of-the-pcb","text":"","title":"Photos of the PCB:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#magic-moment-ewelink-slips-away-tasmota-appears","text":"","title":"Magic moment \u2013 eWeLink slips away \u2013 Tasmota appears:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#result","text":"","title":"Result:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#original-users-manual-for-ewelink","text":"","title":"Original users manual for eWeLink:"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #343 . Device Images ~ I'll try to upload the images later. Generic Module Config ~","title":"Century Aoke   Festnight (Sonoff Basic clone)"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#additional-information","text":"SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #343 .","title":"Additional Information"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#device-images","text":"I'll try to upload the images later.","title":"Device Images"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#generic-module-config","text":"","title":"Generic Module Config"},{"location":"devices/Digoo-DG-SP202/","text":"","title":"Digoo DG SP202"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/","text":"A generic touch dimmer flashed with Tasmota . On AliExpress you can buy a wifi dimmer for mains voltage (110 or 220V) It's a brandles dimmer, but can be found here: AliExpress page It comes in a couple of forms, but sinds I live in Holland, I chose the EU style, single gang, 220V, White edition. It has a glass front plate with 3 proximity/touch switches (On/Off, dimm up & dimm down) and a wifi indicator LED. The inside houses 2 PCB's; a power board and a control board: The control board: There are two main chips on board: An ESP8266 and a Nuvoton n76e003at20 The Nuvoton will do the switch side of it all, the ESP communication. The mains board: For flashing, we only need the control board. Solder small wires to the pads as marked on the picture: 3.3V GND RX TX Sw (gpio0) Solder 'Res1' to GND Note that the silkscreen on this board has TX and RX wrong. Now use a USB to serial adapter to connect the wires. Use a 3.3V board, NOT 5V, this will destroy the ESP chip on the board! Connect: GND to GND 3.3V to 3.3V RX to RX (due to the fact the silkscreen is wrong, otherwise, RX connects to TX and vice versa) TX to TX SW to GND -- only during power up, to put the ESP in programming mode. From here the upload is the same as for all other Tasmota devices. See the upload page for detailed info. Note: sonoff basic and classic variants do not support the serial bridge. To get this working you should use the standard tasmota.bin - NOT basic or classic. After the upload was successful, unplug the device from the serial adapter. You can now desolder all the connections you have made earlier. Also remove the wire between RES1 and GND. Then plug the board back in its housing. Be careful with the connector on the underside of the board. Line up the pins with te header and lightly press it in its place. Connecting to mains installation: ~ WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire. First connection ~ When you first power up the dimmer switch, it comes up in AccessPoint mode. Follow the instructions here Set correct module type ~ Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dim the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Dimmer switch with Nuvoton chip"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#connecting-to-mains-installation","text":"WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire.","title":"Connecting to mains installation:"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#first-connection","text":"When you first power up the dimmer switch, it comes up in AccessPoint mode. Follow the instructions here","title":"First connection"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#set-correct-module-type","text":"Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dim the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Set correct module type"},{"location":"devices/ERC309-Kinetic-Switch/","text":"Discussed here Configuration ~ Configure as a Tuya Dimmer (54) (support as a BASE module was introduced in 6.2.1.16). GPIO13 - Tuya Rx (108) GPIO15 - Tuya Tx (107) Template: {\"NAME\":\"Kinetic Switch\",\"GPIO\":[255,255,255,255,255,255,0,0,255,108,255,107,255],\"FLAG\":0,\"BASE\":54} Module Flashing ~ This device uses a Tuya TYWE3S Wi-Fi PCB module. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Two options: Remove the ESP PCB by desoldering. This makes it easier to get to the pins of the TYWE3S board. No PCB desoldering. You will have to connect the RESET pin of the MCU chip to GND. This requires a soldering iron with a thin tip. Product Link","title":"ERC309 Kinetic Switch"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/","text":"Disclaimer ~ DANGER OF ELECTROCUTION You must de-solder ESP8266 pins from the PCB in order to flash Tasmota! You can't flash Tasmota over firmware from ex-store.de At the moment I can see no way to flash minimal.bin over the original firmware. How flash on assembled PCB Line TX and RX is directly wired from the dimmer to the MCU. Cut this 2 lines. For example desolder pin2 and pin3 from MCU. Solder cable on GPIO0, TX, RX (ESP8266) VCC and GND (See description on pcb). Connect cables with your USB adapter. Before you flash firmware connect the module with 230V (Solderpads \"230V IN\" and \"NULL\") since some USB adapters do not have enough power. Das Modul sollte nur geflasht werden wenn es sich nicht auf der Leiterplatte befindet! Die Firmware \"Tasmota\" kann nicht \u00fcber die Firmware von ex-store.de geflasht werden (OTA) Versuchen Sie es trotzdem ist das Modul unbrauchbar und muss ausgebaut werden und neu geflasht werden. Aufspielen der Tasmota Firmware mit dem Modul auf der Platine Die Leitungen TX und RX sind direkt mit der Dimm-MCU verdrahtet. Diese Leitungen m\u00fcssen getrennt werden. Zum Beispiel Pin2 und Pin3 von der MCU abl\u00f6ten (hochbiegen). L\u00f6ten Sie Kabel an GPIO0, TX, RX (ESP8266), VCC und GND (siehe Beschreibung auf der Platine). Verbinden Sie diese Kabel mit Ihrem USB Adapter. Bevor Sie die Firmware flashen, muss das Modul mit 230V (L\u00f6tpads \"230V IN\" und \"NULL\") verbunden werden. Einige USB-Adapter haben nicht gen\u00fcgend Strom um die Platine zu versorgen. 230V sind f\u00fcr Lebewesen Lebensgef\u00e4hrlich. Ein Stromschlag kann unter anderem Ihren Herzrythmus st\u00f6ren und zum Tode f\u00fchren. Dessen sollten Sie sich bewust sein wenn Sie an diesem Modul arbeiten. Schematic ~ Menu ~ Example setup with DHT22 ~ DHT wiring VCC - header VCC Ground - header GND Data line - to GPIO14","title":"EXS 2 Channel Wifi Dimmer V4"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#disclaimer","text":"DANGER OF ELECTROCUTION You must de-solder ESP8266 pins from the PCB in order to flash Tasmota! You can't flash Tasmota over firmware from ex-store.de At the moment I can see no way to flash minimal.bin over the original firmware. How flash on assembled PCB Line TX and RX is directly wired from the dimmer to the MCU. Cut this 2 lines. For example desolder pin2 and pin3 from MCU. Solder cable on GPIO0, TX, RX (ESP8266) VCC and GND (See description on pcb). Connect cables with your USB adapter. Before you flash firmware connect the module with 230V (Solderpads \"230V IN\" and \"NULL\") since some USB adapters do not have enough power. Das Modul sollte nur geflasht werden wenn es sich nicht auf der Leiterplatte befindet! Die Firmware \"Tasmota\" kann nicht \u00fcber die Firmware von ex-store.de geflasht werden (OTA) Versuchen Sie es trotzdem ist das Modul unbrauchbar und muss ausgebaut werden und neu geflasht werden. Aufspielen der Tasmota Firmware mit dem Modul auf der Platine Die Leitungen TX und RX sind direkt mit der Dimm-MCU verdrahtet. Diese Leitungen m\u00fcssen getrennt werden. Zum Beispiel Pin2 und Pin3 von der MCU abl\u00f6ten (hochbiegen). L\u00f6ten Sie Kabel an GPIO0, TX, RX (ESP8266), VCC und GND (siehe Beschreibung auf der Platine). Verbinden Sie diese Kabel mit Ihrem USB Adapter. Bevor Sie die Firmware flashen, muss das Modul mit 230V (L\u00f6tpads \"230V IN\" und \"NULL\") verbunden werden. Einige USB-Adapter haben nicht gen\u00fcgend Strom um die Platine zu versorgen. 230V sind f\u00fcr Lebewesen Lebensgef\u00e4hrlich. Ein Stromschlag kann unter anderem Ihren Herzrythmus st\u00f6ren und zum Tode f\u00fchren. Dessen sollten Sie sich bewust sein wenn Sie an diesem Modul arbeiten.","title":"Disclaimer"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#schematic","text":"","title":"Schematic"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#menu","text":"","title":"Menu"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#example-setup-with-dht22","text":"DHT wiring VCC - header VCC Ground - header GND Data line - to GPIO14","title":"Example setup with DHT22"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/","text":"Flush Wifi Moduls with latching Relays ~ V3.1 Relay ~ V5.0 Relay ~ V5.0 Relay (PCB Backside) ~ Pinouts: ~ V3.1 GPIO00 Module Pin 8 GPIO01 UART0_TXD Pin 2 GPIO02 Module Pin 7 GPIO03 UART0_RXD Pin 3 GPIO04 Module Pin 10 GPIO05 Module Pin 9 GPIO12 Relay1 (High = off) GPIO13 Relay1 (High = on ) V5.0 GPIO00 Module Pin 4 GPIO02 Module Pin 3 GPIO04 Module Pin 2 GPIO05 Module Pin 1 GPIO12 Relay1 ( High = Off) GPIO13 Relay1 ( High = On) GPIO14 Relay2 ( High = Off) GPIO15 LED1 GPIO16 Relay2 ( High = On) Serial Connection ~ The only way to flashing the moduls you must soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB have no serial pinout connector. For connecting the ground (GND) on a V5.0 Modul you can use one of the 2 GND pinout connectors from the PCB. For flashing the moduls enable the flashmode of the ESP, connect PIN4 (GPIO00) to GND. !!! Don't flashing the modul when it connected to the main power. You brick the device and your computer or USB Port. Use only a 3.3V USB Adapter for flashing!!! Notes ~ For use the V5.0 Modul with the \"EXS Relay(s)\" profile you must change the \"Module parameters\" (see picture below) Now you see in device setup The output pins of the V5.0 are reversed on the PCB. You must use \"out1\" for Relay2 and \"out2\" for Relay1 !!! This is the only way for support both Moduls with Tasmota. (thanks for this Note to Theo Arends)","title":"EXS Relay V3.1 & V5.1"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#flush-wifi-moduls-with-latching-relays","text":"","title":"Flush Wifi Moduls with latching Relays"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v31-relay","text":"","title":"V3.1 Relay"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v50-relay","text":"","title":"V5.0 Relay"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v50-relay-pcb-backside","text":"","title":"V5.0 Relay (PCB Backside)"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#pinouts","text":"V3.1 GPIO00 Module Pin 8 GPIO01 UART0_TXD Pin 2 GPIO02 Module Pin 7 GPIO03 UART0_RXD Pin 3 GPIO04 Module Pin 10 GPIO05 Module Pin 9 GPIO12 Relay1 (High = off) GPIO13 Relay1 (High = on ) V5.0 GPIO00 Module Pin 4 GPIO02 Module Pin 3 GPIO04 Module Pin 2 GPIO05 Module Pin 1 GPIO12 Relay1 ( High = Off) GPIO13 Relay1 ( High = On) GPIO14 Relay2 ( High = Off) GPIO15 LED1 GPIO16 Relay2 ( High = On)","title":"Pinouts:"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#serial-connection","text":"The only way to flashing the moduls you must soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB have no serial pinout connector. For connecting the ground (GND) on a V5.0 Modul you can use one of the 2 GND pinout connectors from the PCB. For flashing the moduls enable the flashmode of the ESP, connect PIN4 (GPIO00) to GND. !!! Don't flashing the modul when it connected to the main power. You brick the device and your computer or USB Port. Use only a 3.3V USB Adapter for flashing!!!","title":"Serial Connection"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#notes","text":"For use the V5.0 Modul with the \"EXS Relay(s)\" profile you must change the \"Module parameters\" (see picture below) Now you see in device setup The output pins of the V5.0 are reversed on the PCB. You must use \"out1\" for Relay2 and \"out2\" for Relay1 !!! This is the only way for support both Moduls with Tasmota. (thanks for this Note to Theo Arends)","title":"Notes"},{"location":"devices/Etekcity-Smart-WiFi-Light-Switch-ESWL01/","text":"Generic Config\\ GPIO5 Led1\\ GPIO13 Relay1\\ GPIO14 Switch1\\ Execute switchmode1 3 in console. To put unit into flashing mode, short GPIO0 with GND","title":"Etekcity Smart WiFi Light Switch ESWL01"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/","text":"Geekcreit \"Sonoff\" 2 Channel Relay Bare PCB version: https://www.aliexpress.com/item/Sonoff-2CH-AC85-250V-Wireless-Switch-Timer-Smart-Wifi-Switch-Universal-Automation-Module-Remote-Control-for/32948157608.html Version with enclosure: https://www.banggood.com/Geekcreit-2-Channel-AC-85V-250V-APP-Remote-Control-WIFI-Wireless-Switch-Socket-For-Smart-Home-p-1114958.html?rmmds=search&cur_warehouse=CN The Geekcreit/\"Sonoff\" 2CH is based on the ESP8285 via the Itead PSF-B04. It is very similar to 4CH DIY, so this wiki page is based on the page for that device. More info here: https://github.com/arendst/Tasmota/issues/1970 Serial Connection ~ Geekcreit/\"Sonoff\" 2CH ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Unless you have a very steady hand soldering will be required for the TX and RX on the ESP chip. Programming the Geekcreit/\"Sonoff\" 2CH is easy. The bottom left on-board-button is connected to GPIO0 and as with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to hold this button when booting the device for flashing. Module parameters ~ Enable GPIO9 & GPIO10 ~ To use GPIO9 and GPIO10 of the ESP8285, open the console and enter => \"SetOption51 on\". Restart the module. Assign inputs and outputs ~ * Note: * The third button on this device is not connected to a GPIO. Instead it is used to cycle through some relay modes that are supported by the two external ICs. Only one of these modes works with Tasmota, so it is necessary to continue to press this button 3 until the relays can be controlled from the toggle buttons in the Tasmota web UI. Module Type => Generic (18) GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 13 => LED 1 (52) Restart the module.","title":"Geekcreit Sonoff 2 Channel Relay"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#serial-connection","text":"","title":"Serial Connection"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#geekcreitsonoff-2ch","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Unless you have a very steady hand soldering will be required for the TX and RX on the ESP chip. Programming the Geekcreit/\"Sonoff\" 2CH is easy. The bottom left on-board-button is connected to GPIO0 and as with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to hold this button when booting the device for flashing.","title":"Geekcreit/\"Sonoff\" 2CH"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#module-parameters","text":"","title":"Module parameters"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#enable-gpio9-gpio10","text":"To use GPIO9 and GPIO10 of the ESP8285, open the console and enter => \"SetOption51 on\". Restart the module.","title":"Enable GPIO9 &amp; GPIO10"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay/#assign-inputs-and-outputs","text":"* Note: * The third button on this device is not connected to a GPIO. Instead it is used to cycle through some relay modes that are supported by the two external ICs. Only one of these modes works with Tasmota, so it is necessary to continue to press this button 3 until the relays can be controlled from the toggle buttons in the Tasmota web UI. Module Type => Generic (18) GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 13 => LED 1 (52) Restart the module.","title":"Assign inputs and outputs"},{"location":"devices/Gosund-SP1/","text":"Purchase There are several clones of this device -- use the Teckin device: Gosund SP1 (Version 2.3 and 2.4) To configure select Gosund SP1 v23 (55) or console command Module 55 BlitzWolf SHP2 (Version 2.3 and 2.4) Watch out: SP1 devices sold nowadays do not always contain a ESP8266. Variants are around with a W701 cpu, which is incompatible with Tasmota!! ~ Calibration ~ If you have another (better) volt and power meter, this procedure should increase the precision. Use an incandescent bulb or an iron. In the web UI Console, enter the (correct) readings using the following commands: Backlog VoltageSet <voltage>; CurrentSet <current>; PowerSet <wattage> Details ~ Rx and Tx are inverted on this picture! More pictures","title":"Gosund SP1"},{"location":"devices/Gosund-SP1/#watch-out-sp1-devices-sold-nowadays-do-not-always-contain-a-esp8266-variants-are-around-with-a-w701-cpu-which-is-incompatible-with-tasmota","text":"","title":"Watch out: SP1 devices sold nowadays do not always contain a ESP8266. Variants are around with a W701 cpu, which is incompatible with Tasmota!!"},{"location":"devices/Gosund-SP1/#calibration","text":"If you have another (better) volt and power meter, this procedure should increase the precision. Use an incandescent bulb or an iron. In the web UI Console, enter the (correct) readings using the following commands: Backlog VoltageSet <voltage>; CurrentSet <current>; PowerSet <wattage>","title":"Calibration"},{"location":"devices/Gosund-SP1/#details","text":"Rx and Tx are inverted on this picture! More pictures","title":"Details"},{"location":"devices/H801/","text":"It's not entirely clear where these devices come from originally, but they are available from AliExpress and eBay. AliExpress: https://www.aliexpress.com/wholesale?catId=0&SearchText=H801 eBay: https://www.ebay.co.uk/sch/items/?_nkw=h801 Hardware ~ The chip used on this board is the ESP8266EX . 5 PWM outputs are connected to DTU35N06 MOSFETs to drive the 5 output channels (RGB + W1 + W2). Function ESP Pin Channel R GPIO 15 PWM1 G GPIO 13 PWM2 B GPIO 12 PWM3 W1 GPIO 14 PWM4 W2 GPIO 04 PWM5 LED D1(red) GPIO 05 LED D2 (green) GPIO 01 Serial Connection ~ Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The unpopulated serial header (3V3, RX, TX, GND) are available in the middle of the PCB, right next to J3. Note: the RX and TX pins are labelled from the terminal's perspective, not from the perspective of the ESP chip. This means you should connect the RX and TX pins from your computer's UART to the RX and TX pins on the board respectively, not crossing them over! To place the board into flashing mode, you will need to short J3. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware. First Boot ~ Most boards supported by the Tasmota firmware use GPIO 1 for serial TX. The H801, as shown in the image above, uses GPIO 2. As the serial RX is still the same as for other boards, it is possible for Tasmota to read from the serial connection but anything written will not be sent to your terminal. Blindly type the following command to set Tasmota to the H801 module type, and it will automatically switch to using GPIO 2 for serial TX allowing setup to proceed: module 20 See #2155 for more details. Please be aware that some of the H801 modules were sold with only 512kB of flash. You can check whether yours is affected by using esptool, with the flash_id command. If you only have 512kB of flash, you can still build your own firmware, but will have to remove components that you do not need, in order to reduce the size of the firmware binary. You will also have to use a linker script for the smaller flash. For an example, see this issue Known Issue ~ While powering up there is a short but bright light flash emitted from the strip.","title":"H801"},{"location":"devices/H801/#hardware","text":"The chip used on this board is the ESP8266EX . 5 PWM outputs are connected to DTU35N06 MOSFETs to drive the 5 output channels (RGB + W1 + W2). Function ESP Pin Channel R GPIO 15 PWM1 G GPIO 13 PWM2 B GPIO 12 PWM3 W1 GPIO 14 PWM4 W2 GPIO 04 PWM5 LED D1(red) GPIO 05 LED D2 (green) GPIO 01","title":"Hardware"},{"location":"devices/H801/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The unpopulated serial header (3V3, RX, TX, GND) are available in the middle of the PCB, right next to J3. Note: the RX and TX pins are labelled from the terminal's perspective, not from the perspective of the ESP chip. This means you should connect the RX and TX pins from your computer's UART to the RX and TX pins on the board respectively, not crossing them over! To place the board into flashing mode, you will need to short J3. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Serial Connection"},{"location":"devices/H801/#first-boot","text":"Most boards supported by the Tasmota firmware use GPIO 1 for serial TX. The H801, as shown in the image above, uses GPIO 2. As the serial RX is still the same as for other boards, it is possible for Tasmota to read from the serial connection but anything written will not be sent to your terminal. Blindly type the following command to set Tasmota to the H801 module type, and it will automatically switch to using GPIO 2 for serial TX allowing setup to proceed: module 20 See #2155 for more details. Please be aware that some of the H801 modules were sold with only 512kB of flash. You can check whether yours is affected by using esptool, with the flash_id command. If you only have 512kB of flash, you can still build your own firmware, but will have to remove components that you do not need, in order to reduce the size of the firmware binary. You will also have to use a linker script for the smaller flash. For an example, see this issue","title":"First Boot"},{"location":"devices/H801/#known-issue","text":"While powering up there is a short but bright light flash emitted from the strip.","title":"Known Issue"},{"location":"devices/Home-Awesome-Breathing-Light-Smart-Plug-Mini-TMRLIFE-%5B2-PACK%5D-WiFi-Smart-Plug/","text":"TMRLife Plug https://smile.amazon.com/gp/product/B0786L8TC1/ref=oh_aui_search_asin_title?ie=UTF8&psc=1 Home Awesome Plug https://smile.amazon.com/gp/product/B07HH29XNS/ref=ppx_yo_dt_b_asin_title_o02__o00_s00?ie=UTF8&psc=1 These are the same device. Easily flashed with OTA GPIO is as follows Io0=pwm1 Io2=pwm2 Io5=pwm3 Io13=button1n Io15=relay1 These make great night lights","title":"Home Awesome Breathing Light Smart Plug Mini TMRLIFE [2 PACK] WiFi Smart Plug"},{"location":"devices/Hompie-SWS1/","text":"Very cheap outlet with USB-charger functionality (supposed to deliver 2A, have to test this though) and real 16A relay: Device Images 3.3V, GND and GPI00 are accessible on the main board. The used TYWE3S board unfortunately does not have easily reachable solderpads for TX/RX, but I managed to solder with a normal 60W iron between main board and TYWE3S board: Works perfectly with Tasmota 6.2.1 and the same configuration like SM-PW701E Socket Board: TYWE3S","title":"Hompie SWS1"},{"location":"devices/HuaFan-Smart-Socket/","text":"The Huafan Wi-Fi Wireless Smart Socket/Plug. ~ Introduction ~ The HuaFan Wireless Wifi Smart Plug/Socket is a useful bit of kit that allows you to introduce home automation without getting into any mains re-wiring. As an added bonus, the device also provides energy monitoring functions (voltage, current, power) in much the same way as the Sonoff Pow module does. As you may have guessed, its 'smarts' come from an embedded ESP8266, which makes it a potential target for the excellent sonoff-tasmota code. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code. What is it? ~ This smart socket comes with its own iPhone/Android App and is controllable from the HF Smart cloud service. As well as allowing on/off control, the plug/socket also measures current, voltage and power. It\u2019s pretty well made but almost certainly doesn\u2019t meet the full British electrical standards, as it doesn\u2019t have a shutter to close off the live socket holes when a plug is removed. This a rather a shame and would not be too tricky to implement and would only marginally increase the cost of these pretty cheap (~\u00a3UK 10) units. The provided software/service all seemed rather closed and proprietary and not able to talk to other stuff. So something had to change! The Name ~ I'm mostly calling this a 'Smart Socket' but it also is called a 'Smart Plug' in some places. As it's got both, I guess both are right. \ufffc Disassembly ~ * WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * There are no screws; to disassemble you need to prise it open on each side. \ufffcInside there is a main board with most of the components on the reverse. The Wi-Fi and control comes from a small daughter board, soldered to the main board.\ufffc There\u2019s not a lot to see on the top apart from the mains relay, the button and the red/blue LEDs that illuminate it.\ufffc The main item of interest on the top is the daughter board. This has our trusty ESP8266EX and a 8Mbit SPI flash memory. You can also see the 40MHz crystal - more on this later\u2026 \ufffc The reverse of the daughter board is pretty bare - only the Vcc (3.3V) and GND are marked. In this view you can also see the red and blue LEDs and the push button. In its original configuration the red LED normally is set to the same state as the relay and the blue LED provides information on the state of connectivity. Another warning... What is marked as GND IS NOT GROUNDED , it\u2019s not even floating, GND IS CONNECTED TO THE NEUTRAL LINE OF THE MAINS . Do not connect any equipment or yourself to the board whilst it is plugged onto a mains socket - EVEN IF THAT SOCKET APPEARS TO BE SWITCHED OFF. Neutral is not 0V or Ground and should be treated as live (just in case it really is). Always completely disconnect your programming / serial interface before plugging the device into a mains socket. You need a hefty soldering iron to unsolder the board from the plug pins and on the reverse you see the main circuitry. Next door to the AMS1117 3.3V regulator for the ESP is a HLW8012 chip that does the current/voltage/power measurement. Conveniently, this is the same chip that's used in the Sonoff Pow module, so all the code to drive it is already in place. Below the two ICs is R12 it's R002 i.e. a 2mOhm resistor. This may be different to the one in the Sonoff, so expect to use different calibration settings. Hookup ~ Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the main board. \ufffc For programming you need to unplug the unit for any mains and make connections to GND, Vcc and Rx. That\u2019s 1, 2 and 4 on the back of the daughter board, counting from the right. The connection for Tx should have been on the back of the daughter board (all the circuit board tracks are in place on the daughter board). However, for some reason they didn\u2019t populate R5 (or removed it after programming) so the Tx signal does not appear on the rear of the board like it was clearly designed to do. Instead you have two options, either re-instate R5 with a very small piece of wire (or a teeny resistor if you have one) or solder a wire directly to the resistor pad/chip pin. As the connection should be temporary (subsequent flashes will be Over the Air) I initially went for the simpler but more fragile direct connection, mechanically secured with some insulating tape. If you do prefer to solder a small wire across R5 then you will need to cut the small links on the main board around pad 5, as the designers of the main board have connected this pad to the GND plane with two small links, one at the end and to the left side of the pad. Again, all this is on the top of the main board, you don\u2019t need to go delving underneath. On the front of the daughter board there is the GPIO0 pin (pad number 4, reading from the left). This needs to be manually connected to ground and then the power applied to the ESP8266 to put it in programming mode. You can solder something onto this, as shown, or pick it up where it connects to the blue LED with a small clip probe. Daughter board pinout ~ Viewed from above the main board Front Back GPIO14 - HLW8012 P pulse 1 |B| 1 0V (marked GND) GPIO12 - HLW8012 I/V pulse 2 |O| 2 3.3V (marked VCC) GPIO13 - HLW8012 I/V select 3 |A| 3 GPIO05 - Relay- GPIO00 - Blue LED- 4 |R| 4 GPIO03 (U0RxD) - Red LED- GPIO04 - Button- 5 |D| 5 Initially GND but ready for GPIO01 (U0TxD) Hookup - Solder Free Option ~ Adding to the great guide above ... So if soldering isn't your bag, there are a few connection points that you can get at with clip probes. There is a +5V and GND contact on the left side of the board and the right LED legs give access to the ESP's GPIO0 and RXD. The tricky bit is the ESP's TXD line which, as stated before, is only accessible on the daughter board via the chip's pin or an smd pad above and to the right. @jwrw, I am in awe of anyone that can solder onto this pad! As an alternative, try connecting an alligator clip to a sewing pin 8) to make a probe and holding it in place with your finger during firmware programming (hey, it only has to work once as from then on you use OTA). Powering via the pcb contacts requires more current than my FTDI was able to source so a seperate 5V power supply is required (a Raspberry Pi can provide the +5V/GND via it's GPIO header if you haven't got a dedicated power supply at hand). Building Firmware ~ The process for building the firmware for the HuaFan is basically the same as for the Sonoff but with a few additional steps. Firstly, make sure that you have installed release 5.5.0 of Tasmota or later and that you have completed all of the standard preparation tasks mentioned in the Wiki. Next, you should ensure that you have installed version 2.4.0-rc1 or later of ESP8266/Arduino core that includes support for the 40MHz crystal used by the HuaFan. Installation instructions can be found here but are essentially as follows: - Start Arduino and open Preferences window. - Swap the existing link for the stable ESP8266/Arduino core release with https://github.com/esp8266/Arduino/releases/download/2.4.0-rc1/package_esp8266com_index.json in Additional Board Manager URLs field.. - Open Boards Manager from Tools > Board menu and update esp8266 platform (check that it is using the RC version). Lastly, you need to edit the boards.txt file to allow selection of the 40MHz Crystal via the Arduino IDE Tools menu. Add the following lines into the section for the \"Generic ESP8266 Module\" and immediately after the \"generic.menu.CpuFrequency\" items: generic.menu.CrystalFreq.26=26 MHz` generic.menu.CrystalFreq.40=40 MHz` generic.menu.CrystalFreq.40.build.extra_flags=-DF_CRYSTAL=40000000","title":"The Huafan Wi-Fi Wireless Smart Socket/Plug."},{"location":"devices/HuaFan-Smart-Socket/#the-huafan-wi-fi-wireless-smart-socketplug","text":"","title":"The Huafan Wi-Fi Wireless Smart Socket/Plug."},{"location":"devices/HuaFan-Smart-Socket/#introduction","text":"The HuaFan Wireless Wifi Smart Plug/Socket is a useful bit of kit that allows you to introduce home automation without getting into any mains re-wiring. As an added bonus, the device also provides energy monitoring functions (voltage, current, power) in much the same way as the Sonoff Pow module does. As you may have guessed, its 'smarts' come from an embedded ESP8266, which makes it a potential target for the excellent sonoff-tasmota code. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code.","title":"Introduction"},{"location":"devices/HuaFan-Smart-Socket/#what-is-it","text":"This smart socket comes with its own iPhone/Android App and is controllable from the HF Smart cloud service. As well as allowing on/off control, the plug/socket also measures current, voltage and power. It\u2019s pretty well made but almost certainly doesn\u2019t meet the full British electrical standards, as it doesn\u2019t have a shutter to close off the live socket holes when a plug is removed. This a rather a shame and would not be too tricky to implement and would only marginally increase the cost of these pretty cheap (~\u00a3UK 10) units. The provided software/service all seemed rather closed and proprietary and not able to talk to other stuff. So something had to change!","title":"What is it?"},{"location":"devices/HuaFan-Smart-Socket/#the-name","text":"I'm mostly calling this a 'Smart Socket' but it also is called a 'Smart Plug' in some places. As it's got both, I guess both are right. \ufffc","title":"The Name"},{"location":"devices/HuaFan-Smart-Socket/#disassembly","text":"* WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * There are no screws; to disassemble you need to prise it open on each side. \ufffcInside there is a main board with most of the components on the reverse. The Wi-Fi and control comes from a small daughter board, soldered to the main board.\ufffc There\u2019s not a lot to see on the top apart from the mains relay, the button and the red/blue LEDs that illuminate it.\ufffc The main item of interest on the top is the daughter board. This has our trusty ESP8266EX and a 8Mbit SPI flash memory. You can also see the 40MHz crystal - more on this later\u2026 \ufffc The reverse of the daughter board is pretty bare - only the Vcc (3.3V) and GND are marked. In this view you can also see the red and blue LEDs and the push button. In its original configuration the red LED normally is set to the same state as the relay and the blue LED provides information on the state of connectivity. Another warning... What is marked as GND IS NOT GROUNDED , it\u2019s not even floating, GND IS CONNECTED TO THE NEUTRAL LINE OF THE MAINS . Do not connect any equipment or yourself to the board whilst it is plugged onto a mains socket - EVEN IF THAT SOCKET APPEARS TO BE SWITCHED OFF. Neutral is not 0V or Ground and should be treated as live (just in case it really is). Always completely disconnect your programming / serial interface before plugging the device into a mains socket. You need a hefty soldering iron to unsolder the board from the plug pins and on the reverse you see the main circuitry. Next door to the AMS1117 3.3V regulator for the ESP is a HLW8012 chip that does the current/voltage/power measurement. Conveniently, this is the same chip that's used in the Sonoff Pow module, so all the code to drive it is already in place. Below the two ICs is R12 it's R002 i.e. a 2mOhm resistor. This may be different to the one in the Sonoff, so expect to use different calibration settings.","title":"Disassembly"},{"location":"devices/HuaFan-Smart-Socket/#hookup","text":"Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the main board. \ufffc For programming you need to unplug the unit for any mains and make connections to GND, Vcc and Rx. That\u2019s 1, 2 and 4 on the back of the daughter board, counting from the right. The connection for Tx should have been on the back of the daughter board (all the circuit board tracks are in place on the daughter board). However, for some reason they didn\u2019t populate R5 (or removed it after programming) so the Tx signal does not appear on the rear of the board like it was clearly designed to do. Instead you have two options, either re-instate R5 with a very small piece of wire (or a teeny resistor if you have one) or solder a wire directly to the resistor pad/chip pin. As the connection should be temporary (subsequent flashes will be Over the Air) I initially went for the simpler but more fragile direct connection, mechanically secured with some insulating tape. If you do prefer to solder a small wire across R5 then you will need to cut the small links on the main board around pad 5, as the designers of the main board have connected this pad to the GND plane with two small links, one at the end and to the left side of the pad. Again, all this is on the top of the main board, you don\u2019t need to go delving underneath. On the front of the daughter board there is the GPIO0 pin (pad number 4, reading from the left). This needs to be manually connected to ground and then the power applied to the ESP8266 to put it in programming mode. You can solder something onto this, as shown, or pick it up where it connects to the blue LED with a small clip probe.","title":"Hookup"},{"location":"devices/HuaFan-Smart-Socket/#daughter-board-pinout","text":"Viewed from above the main board Front Back GPIO14 - HLW8012 P pulse 1 |B| 1 0V (marked GND) GPIO12 - HLW8012 I/V pulse 2 |O| 2 3.3V (marked VCC) GPIO13 - HLW8012 I/V select 3 |A| 3 GPIO05 - Relay- GPIO00 - Blue LED- 4 |R| 4 GPIO03 (U0RxD) - Red LED- GPIO04 - Button- 5 |D| 5 Initially GND but ready for GPIO01 (U0TxD)","title":"Daughter board pinout"},{"location":"devices/HuaFan-Smart-Socket/#hookup-solder-free-option","text":"Adding to the great guide above ... So if soldering isn't your bag, there are a few connection points that you can get at with clip probes. There is a +5V and GND contact on the left side of the board and the right LED legs give access to the ESP's GPIO0 and RXD. The tricky bit is the ESP's TXD line which, as stated before, is only accessible on the daughter board via the chip's pin or an smd pad above and to the right. @jwrw, I am in awe of anyone that can solder onto this pad! As an alternative, try connecting an alligator clip to a sewing pin 8) to make a probe and holding it in place with your finger during firmware programming (hey, it only has to work once as from then on you use OTA). Powering via the pcb contacts requires more current than my FTDI was able to source so a seperate 5V power supply is required (a Raspberry Pi can provide the +5V/GND via it's GPIO header if you haven't got a dedicated power supply at hand).","title":"Hookup - Solder Free Option"},{"location":"devices/HuaFan-Smart-Socket/#building-firmware","text":"The process for building the firmware for the HuaFan is basically the same as for the Sonoff but with a few additional steps. Firstly, make sure that you have installed release 5.5.0 of Tasmota or later and that you have completed all of the standard preparation tasks mentioned in the Wiki. Next, you should ensure that you have installed version 2.4.0-rc1 or later of ESP8266/Arduino core that includes support for the 40MHz crystal used by the HuaFan. Installation instructions can be found here but are essentially as follows: - Start Arduino and open Preferences window. - Swap the existing link for the stable ESP8266/Arduino core release with https://github.com/esp8266/Arduino/releases/download/2.4.0-rc1/package_esp8266com_index.json in Additional Board Manager URLs field.. - Open Boards Manager from Tools > Board menu and update esp8266 platform (check that it is using the RC version). Lastly, you need to edit the boards.txt file to allow selection of the 40MHz Crystal via the Arduino IDE Tools menu. Add the following lines into the section for the \"Generic ESP8266 Module\" and immediately after the \"generic.menu.CpuFrequency\" items: generic.menu.CrystalFreq.26=26 MHz` generic.menu.CrystalFreq.40=40 MHz` generic.menu.CrystalFreq.40.build.extra_flags=-DF_CRYSTAL=40000000","title":"Building Firmware"},{"location":"devices/Hyleton-313-Smart-Plug/","text":"Intro ~ Recently I bought a very nice and compact Smart Plug (UK variant) from Aliexpress - a Hyleton 313 . This was in fact the smallest smart plug device with UK plug I've ever seen - it is no bigger than an average USB/phone charger: Another good thing is that it is built around a ESP8266 module, which gives us the possibility to change its firmware and install Tasmota. Open the case ~ There are no visible screws, however it is not that difficult to open the case using some sharp plastic or metal pry tool and a heat gun (or hair dryer on max setting also works - hold on each side for about 20-30 seconds). Heat the edge of the plug a bit, then work your way slowly and pry from the middle of side with the button, slowly moving the tool towards the corners. Alternatively if you don't have a heat gun or hair dryer you can use a pry tool or something else thin to slowly \"saw\" away at the middle of the side with the button until you are through (about 2-3mm) . With or without a heat gun/hair drier it can be quite tough - be careful and keep your fingers away from the tool you are using! Once you have got through the layer of adhesive you can lever the case open to dislodge the adhesive on the other sides. Be careful not to accidentally knock off the PCB supports in each corner as these are crucial to safety. Once the case is open, the top side of the PCB will be exposed: The WiFi module is soldered vertically to the main PCB and sits right next to the relay. In order to get access to its pins, remove the screw from the centre of the PCB. After that the bottom plastic plate, which holds the three mains connector prongs, can be moved a bit to the side without desoldering anything (it is attached with short cables to the PCB, but cables' length is just enough to move it out of the way of the WiFi module's pins). Here's a view of the bottom side of the PCB: You can see the product labels (product code, date and board revision), as well as the UL number. WiFi module pins ~ Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14 Serial Connection ~ For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 : Pin Function 11 Rx 12 Tx 13 Vdd 14 Ground In this picture Yellow is Tx, Orange is Ground, Grey is Rx and White is Vdd: Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. See devices/Esptool for details of how to flash the firmware when in firmware upload mode. Once you have flashed the firmware, leave the jumpers soldered to the pins and unplug & reinsert your USB-to-serial adapter - this will reset the unit and provide voltage to the ESP8266 which will then boot the new Tasmota firmware - you'll see a Wifi network called \"sonof-xxxx\" if it has flashed successfully worked (if you do not see the wifi, the flashing process might not have worked correctly and you'll need to try again). If you see the wifi network come up ok, you can de-solder the jumpers and reassemble the unit. Reassembly ~ Screw the PCB back to the housing, and place the PCB back into the other half of the socket. Apply a small 1mm bead of super glue around the edges and firmly clip the two halves back together again, and hold firmly for about 30 seconds to allow the glue to cure. Dangerous Failure Mode To Avoid ~ When reassembling the plug, be extremely careful to ensure that the resistor next to the PCB screw is not leaning towards the earth (top) pin! It is very easy to slightly bend it towards the earth pin when unscrewing. If the resistor is too close to the earth pin, the plastic shield for the earth pin on the upper-half of the case will press the resistor down onto the earth pin and when a plug is inserted it can short-out and trigger a small explosion: This will kill the socket, and maybe you too. Take extreme caution - mains electricity is dangerous. If you cannot neatly clip everything back into place (i.e. the two halves of the shell don't neatly sit together again, or there is a springiness) then you may have caught the resistor. If you accidentally broke off the PCB standoffs when opening the case, this is harder to detect (as the PCB may be pushed further down than usual) so be especially careful. Double & triple check. If you've done everything right you should have a fairly clean looking plug still with just a small amount of cosmetic scratches on the bottom side of the unit where you used the pry tool. Configuration ~ Enroll your plug back onto your wifi as usual for Tasmota (i.e. join the wifi network started by the plug, give it your wifi details, then restart it). Once Tasmota 's WebUI configuration interface is loaded in the browser, you need to configure the template type: Go to \"Configuration\" Go to \"Configure template\" Create a new template that looks like this one and save it: Once you have saved the template: Wait for the device to restart Go to \"Configuration\" Go to \"Configure module\" Select the new template you just created and save. Note on LEDs ~ Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). Additional Details ~ If you want to read a detailed project log that uses this plug, you can do so at GitHub Blog page , although some of the information is now out of date.","title":"Hyleton 313 Smart Plug"},{"location":"devices/Hyleton-313-Smart-Plug/#intro","text":"Recently I bought a very nice and compact Smart Plug (UK variant) from Aliexpress - a Hyleton 313 . This was in fact the smallest smart plug device with UK plug I've ever seen - it is no bigger than an average USB/phone charger: Another good thing is that it is built around a ESP8266 module, which gives us the possibility to change its firmware and install Tasmota.","title":"Intro"},{"location":"devices/Hyleton-313-Smart-Plug/#open-the-case","text":"There are no visible screws, however it is not that difficult to open the case using some sharp plastic or metal pry tool and a heat gun (or hair dryer on max setting also works - hold on each side for about 20-30 seconds). Heat the edge of the plug a bit, then work your way slowly and pry from the middle of side with the button, slowly moving the tool towards the corners. Alternatively if you don't have a heat gun or hair dryer you can use a pry tool or something else thin to slowly \"saw\" away at the middle of the side with the button until you are through (about 2-3mm) . With or without a heat gun/hair drier it can be quite tough - be careful and keep your fingers away from the tool you are using! Once you have got through the layer of adhesive you can lever the case open to dislodge the adhesive on the other sides. Be careful not to accidentally knock off the PCB supports in each corner as these are crucial to safety. Once the case is open, the top side of the PCB will be exposed: The WiFi module is soldered vertically to the main PCB and sits right next to the relay. In order to get access to its pins, remove the screw from the centre of the PCB. After that the bottom plastic plate, which holds the three mains connector prongs, can be moved a bit to the side without desoldering anything (it is attached with short cables to the PCB, but cables' length is just enough to move it out of the way of the WiFi module's pins). Here's a view of the bottom side of the PCB: You can see the product labels (product code, date and board revision), as well as the UL number.","title":"Open the case"},{"location":"devices/Hyleton-313-Smart-Plug/#wifi-module-pins","text":"Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14","title":"WiFi module pins"},{"location":"devices/Hyleton-313-Smart-Plug/#serial-connection","text":"For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 : Pin Function 11 Rx 12 Tx 13 Vdd 14 Ground In this picture Yellow is Tx, Orange is Ground, Grey is Rx and White is Vdd: Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. See devices/Esptool for details of how to flash the firmware when in firmware upload mode. Once you have flashed the firmware, leave the jumpers soldered to the pins and unplug & reinsert your USB-to-serial adapter - this will reset the unit and provide voltage to the ESP8266 which will then boot the new Tasmota firmware - you'll see a Wifi network called \"sonof-xxxx\" if it has flashed successfully worked (if you do not see the wifi, the flashing process might not have worked correctly and you'll need to try again). If you see the wifi network come up ok, you can de-solder the jumpers and reassemble the unit.","title":"Serial Connection"},{"location":"devices/Hyleton-313-Smart-Plug/#reassembly","text":"Screw the PCB back to the housing, and place the PCB back into the other half of the socket. Apply a small 1mm bead of super glue around the edges and firmly clip the two halves back together again, and hold firmly for about 30 seconds to allow the glue to cure.","title":"Reassembly"},{"location":"devices/Hyleton-313-Smart-Plug/#dangerous-failure-mode-to-avoid","text":"When reassembling the plug, be extremely careful to ensure that the resistor next to the PCB screw is not leaning towards the earth (top) pin! It is very easy to slightly bend it towards the earth pin when unscrewing. If the resistor is too close to the earth pin, the plastic shield for the earth pin on the upper-half of the case will press the resistor down onto the earth pin and when a plug is inserted it can short-out and trigger a small explosion: This will kill the socket, and maybe you too. Take extreme caution - mains electricity is dangerous. If you cannot neatly clip everything back into place (i.e. the two halves of the shell don't neatly sit together again, or there is a springiness) then you may have caught the resistor. If you accidentally broke off the PCB standoffs when opening the case, this is harder to detect (as the PCB may be pushed further down than usual) so be especially careful. Double & triple check. If you've done everything right you should have a fairly clean looking plug still with just a small amount of cosmetic scratches on the bottom side of the unit where you used the pry tool.","title":"Dangerous Failure Mode To Avoid"},{"location":"devices/Hyleton-313-Smart-Plug/#configuration","text":"Enroll your plug back onto your wifi as usual for Tasmota (i.e. join the wifi network started by the plug, give it your wifi details, then restart it). Once Tasmota 's WebUI configuration interface is loaded in the browser, you need to configure the template type: Go to \"Configuration\" Go to \"Configure template\" Create a new template that looks like this one and save it: Once you have saved the template: Wait for the device to restart Go to \"Configuration\" Go to \"Configure module\" Select the new template you just created and save.","title":"Configuration"},{"location":"devices/Hyleton-313-Smart-Plug/#note-on-leds","text":"Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ).","title":"Note on LEDs"},{"location":"devices/Hyleton-313-Smart-Plug/#additional-details","text":"If you want to read a detailed project log that uses this plug, you can do so at GitHub Blog page , although some of the information is now out of date.","title":"Additional Details"},{"location":"devices/KMC-70008-light-switch/","text":"Shopping Depending on the version of the firmware shipped on the device, you may be able to flash it using the Tuya-Convert OTA flashing tool . This tutorial shows how that tool works. If the OTA flash method does not work, you will have to solder leads to flash the device. Except for GPIO0, the programming pins are not broken out on the PCB. The module has the usual ESP-12 pin layout, so carefully solder right to the chip's pins. The device button is connected to GPIO0. You do not need to solder onto GPIO0. Just hold the button down when booting the device to get it into flash mode. Once you get the device flashed, set up the Wi-Fi configuration and connect to the device using a browser using its IP address. To keep the device from constantly rebooting, the first configuration step you should perform is to set the module type to Generic (18). Configuration: * Digiblur's Tasmota forked firmware * Generic (18) * GPIO0: Button1 * GPIO13: Led1i * GPIO14: Relay1 When the blue LED on GPIO 13 is set to LED1i the white light shines when the relay is off and the blue light illuminates then the relay is on. Further configuration and setup may be required as the blue LED constantly flashes.","title":"KMC 70008 light switch"},{"location":"devices/KS-602S-Switch/","text":"These Wi-Fi Smart Light Switches are essentially a sonoff basic in a decora wall switch. GPIO Map ~ GPIO 0 - Button1 - Button GPIO 12 - Relay1 - Red LED and Relay GPIO 13 - Led1 (not Led1i like the Sonoff Basic) Green LED * As of May 2019 there may be a modified version. This is the pinout. * * GPIO 0 - Button1 - Button * GPIO 14 - Relay1 - Relay * GPIO 16 - Led1/Led1i - Red LED * I couldn't find the green LED but it exists. Product Links ~ Amazon Link of KULED Branded Switches Unboxing ~ Some revisions of the switch have the header marked GND, RXD, TXD, 3V3. Some revisions do not. It has been reported that some boxes have mixed revisions. If you are ever in doubt, double check with a meter to determine your pins. Flashing process and hardware revision without the labels can be seen on the following video link . RXD is connected to Transmit on your programmer TXD is connected to Receive on your programmer Ground and 3.3vdc to power unit during flash. You do not need to solder a header to flash the board, an empty 4 pin header connected to 4 dupont jumper wires held into the empty header location works fine with a little pressure to ensure connectivity. Hold the button(GPIO0) and plug in programmer. Note for newer / touch button devices (as of March 2021): If you have the newer version without a physical switch, you will not be able to hold down a button to ender programming mode! The only way to enter programming mode is to physically short GPIO0 and GND (a picture of the GPIO0 location is here: https://raw.githubusercontent.com/tasmota/docs/master/docs/_media/gpio0.png ). Make the connection, plug in the device, let go of the connection, and you should be in programming mode. Device works perfectly as a Sonoff Basic but the LED will be backwards as designed. The Red LED is hardwired to the relay and the green is controllable over GPIO pins. If you wish to change the functionality to have the green LED when the device is off, you can utilize or change the template to a generic device type and map the suggested names except you will choose Led1 instead of Led1i.","title":"KS 602S Switch"},{"location":"devices/KS-602S-Switch/#gpio-map","text":"GPIO 0 - Button1 - Button GPIO 12 - Relay1 - Red LED and Relay GPIO 13 - Led1 (not Led1i like the Sonoff Basic) Green LED * As of May 2019 there may be a modified version. This is the pinout. * * GPIO 0 - Button1 - Button * GPIO 14 - Relay1 - Relay * GPIO 16 - Led1/Led1i - Red LED * I couldn't find the green LED but it exists.","title":"GPIO Map"},{"location":"devices/KS-602S-Switch/#product-links","text":"Amazon Link of KULED Branded Switches","title":"Product Links"},{"location":"devices/KS-602S-Switch/#unboxing","text":"Some revisions of the switch have the header marked GND, RXD, TXD, 3V3. Some revisions do not. It has been reported that some boxes have mixed revisions. If you are ever in doubt, double check with a meter to determine your pins. Flashing process and hardware revision without the labels can be seen on the following video link . RXD is connected to Transmit on your programmer TXD is connected to Receive on your programmer Ground and 3.3vdc to power unit during flash. You do not need to solder a header to flash the board, an empty 4 pin header connected to 4 dupont jumper wires held into the empty header location works fine with a little pressure to ensure connectivity. Hold the button(GPIO0) and plug in programmer. Note for newer / touch button devices (as of March 2021): If you have the newer version without a physical switch, you will not be able to hold down a button to ender programming mode! The only way to enter programming mode is to physically short GPIO0 and GND (a picture of the GPIO0 location is here: https://raw.githubusercontent.com/tasmota/docs/master/docs/_media/gpio0.png ). Make the connection, plug in the device, let go of the connection, and you should be in programming mode. Device works perfectly as a Sonoff Basic but the LED will be backwards as designed. The Red LED is hardwired to the relay and the green is controllable over GPIO pins. If you wish to change the functionality to have the green LED when the device is off, you can utilize or change the template to a generic device type and map the suggested names except you will choose Led1 instead of Led1i.","title":"Unboxing"},{"location":"devices/Kesen-KS-604S/","text":"This Tuya Wi-Fi module ESP8266 based device has a really attractive form factor and functionality (in-wall, single gang, dual outlet, USB port, each individually controllable). This device can be most easily flashed using using Tuya-Convert . Others have reported that flashing this device by attaching leads to the serial interface requires disassembling and unsoldering the internal AC components to get access to the needed contacts, however an AliBaba device was successfully flashed by connecting to the four terminals at the bottom of the back circuit board (3v3, Tx, Rx, G) and connecting pin D3 in block J7 to ground while booting and during the flashing process. Shopping ~ Amazon Alibaba (10 minimum) Configuration ~ It appears that there are different versions of the KS-604S. The device that @DavinKD flashed (likely purchased from Amazon in early to mid March 2019) has a different GPIO configuration than devices purchased from Alibaba in late March. Rear Amazon Device ~ {\"NAME\":\"KS-604S\",\"GPIO\":[255,255,56,255,255,17,255,255,22,21,255,255,18],\"FLAG\":1,\"BASE\":18} GPIO Function Configuration 2 Device Status (Green) LED1i (56) 5 Top Button Button1 (17) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 16 Bottom Button Button2 (18) The USB port on this variant is not switchable. Alibaba Device ~ {\"NAME\":\"KS-604S\",\"GPIO\":[158,255,255,17,56,18,255,255,22,21,57,23,255],\"FLAG\":0,\"BASE\":18} GPIO Function Configuration 0 Device Status (Green) LEDLinki (158) 3 Top Button Button1 (17) 4 Top LED (Orange) LED1i (56) 5 Bottom Button Button2 (18) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 14 Bottom LED (Orange) LED2i (57) 15 USB Port Relay3 (23) This configuration requires the LedLinki Component (introduced in 6.5.0.12) to associate the GPIO to the status LED indicator. In order for the LED power indicators to follow the state of each receptacle relay, LedState must be set to show the power state on the LEDs. Select the desired power on state for the device's relays using PowerOnState and/or a System#Boot triggered rule. This device also requires SetOption63 (introduced in 6.5.0.9) in order to disable relay power feedback state scanning at restart. The following Console statements define the necessary settings and rules as described above. Backlog SerialLog 0; PowerOnState 0; SetOption63 1; LEDState 1 Rule1 ON System#Boot DO Power3 On ENDON # Turn the USB port on Rule1 1","title":"Kesen KS 604S"},{"location":"devices/Kesen-KS-604S/#shopping","text":"Amazon Alibaba (10 minimum)","title":"Shopping"},{"location":"devices/Kesen-KS-604S/#configuration","text":"It appears that there are different versions of the KS-604S. The device that @DavinKD flashed (likely purchased from Amazon in early to mid March 2019) has a different GPIO configuration than devices purchased from Alibaba in late March. Rear","title":"Configuration"},{"location":"devices/Kesen-KS-604S/#amazon-device","text":"{\"NAME\":\"KS-604S\",\"GPIO\":[255,255,56,255,255,17,255,255,22,21,255,255,18],\"FLAG\":1,\"BASE\":18} GPIO Function Configuration 2 Device Status (Green) LED1i (56) 5 Top Button Button1 (17) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 16 Bottom Button Button2 (18) The USB port on this variant is not switchable.","title":"Amazon Device"},{"location":"devices/Kesen-KS-604S/#alibaba-device","text":"{\"NAME\":\"KS-604S\",\"GPIO\":[158,255,255,17,56,18,255,255,22,21,57,23,255],\"FLAG\":0,\"BASE\":18} GPIO Function Configuration 0 Device Status (Green) LEDLinki (158) 3 Top Button Button1 (17) 4 Top LED (Orange) LED1i (56) 5 Bottom Button Button2 (18) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 14 Bottom LED (Orange) LED2i (57) 15 USB Port Relay3 (23) This configuration requires the LedLinki Component (introduced in 6.5.0.12) to associate the GPIO to the status LED indicator. In order for the LED power indicators to follow the state of each receptacle relay, LedState must be set to show the power state on the LEDs. Select the desired power on state for the device's relays using PowerOnState and/or a System#Boot triggered rule. This device also requires SetOption63 (introduced in 6.5.0.9) in order to disable relay power feedback state scanning at restart. The following Console statements define the necessary settings and rules as described above. Backlog SerialLog 0; PowerOnState 0; SetOption63 1; LEDState 1 Rule1 ON System#Boot DO Power3 On ENDON # Turn the USB port on Rule1 1","title":"Alibaba Device"},{"location":"devices/KingArt/","text":"KingArt-N1 - Touch Light Light Switch ~ This is a relatively cheap Premium glass fronted touch panel, looks clean and minimal when installed too. Table Of Contents: * Device Features * * Breakdown * * Capacitive Touch IC * Re-Programming * * Tools * * Setup * * Programming Mode * Reference Device Features ~ ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Confirmed 10A/250VAC mains relay -- Image: The 1 Gang Touch Panel, featuring the glass front (protective plastic film still on) Breakdown ~ Whats in the package... This looks like a reasonably simple setup. Removing the front glass panel you have access to the main control PCB. This holds the ESP8285 micro-controller and accompanying guff. I've worked through mapping most of the pins of interest - notes are in the images below. The control board runs off a 5V fed from the Power-Relay board at the read of the unit - a 3v3 reg is the control board for all the logic. The back of the control board has the touch controller and the 8way header to the Power-Relay board. There are only touch pads on the back of the control board as a means to interface with the microcontroller. There is no SonOff type programming header arrangement. , see Re-Programming . Control and Interface PCB Sorry for the horrible pics.. will replace Some Application-Interesting Pin Allocations *Trace for the King Art Switch with 2 (Touch-)Button is confirmed - works well with this Parameters The Power-Relay board is reasonably simple as well. This board, being a 1-gang switch, only has a single relay - but the PCB is set out for 3 (again, see images for trace and pin notes ). Power-Relay PCB Capacitive Touch IC ~ This board uses a dedicated capacitive touch control IC. Something interesting, that this IC manages touch switching as well a red and blue touch status LEDs for each of the touch pads that it services as the buttons. The IC illuminates a diffuser block over a 'button', indicating: * Blue : when Idle - button state is 'OFF' * Red+Blue : when Active - button state is 'ON' The TW8001 is also linked to a red error indicator led on the front of the Control Board - it is co-located above the EPS8285 microcontroller's Blue status indicator. This appears to be used by the Touch IC to indicate its own state information * eg, if the touch is held for +30s the touch shows an error state (red LED) and resets - useful if you replace the front panel and it needs to recalibrate. With regard to interfacing with the microcontroller, this device seems function with GPIO-friendly pin state for the capacitive button state reporting. Here is the only information I have been able to find on this device at the time of this investigation : TechWave - TW8001 . It does have much (or: any) in way of public datasheets. If anyone finds a datasheet please link it here! Re-Programming ~ Tools ~ You shall need something in way of the following: (or whatever works for you, this is just my setup) * A USB-TTL adapter (TTL, 3V3.. something also with a 3V3 source) * Some leads * A soldering iron (solder, bits.. etc) - I'm going to assume you know how/what to do with this. Setup ~ (This is my setup) USB-TTL | Lead | Board 3V3 Red 3v3 TXD White RX RXD Grey TX GND Black GND NNB : DO NOT USE or CONNECT THE 5V ever.. Programming Mode ~ Before you can program the board you have to start the ESP8285 micro in Programming Mode. This is important. Remember we soldered the blue lead to the board at (SW) - you will use this to force the micro to the required mode on startup. (you can only do this on startup) Entering Programming Mode: * Remove power from the board * Short the blue lead (SW) to ground (use a ground pad on the board or on your programmer) * NOW: Apply power. You can remove the short to ground after a second or two. So, Are we in Programming Mode? ... ~ Test Failed - try again If the board has its factory firmware installed still it usually flashes the status LED on startup.. (ie: not in programming mode) Test Success If you have successfully put the micro into programming mode the ONLY the blue status illumination of the touch pad will be ON. -> Now you can access and upload to the device using your preferred tool (Atom IDE, ESPtool, Arduino.. etc) Remember that the flashing mode MUST BE DOUT as it is for ALL devices on which Tasmota is flashed! Reference ~ https://github.com/EphemeralPersistence/Sonoff-Tasmota/wiki","title":"KingArt-N1 - Touch Light Light Switch"},{"location":"devices/KingArt/#kingart-n1-touch-light-light-switch","text":"This is a relatively cheap Premium glass fronted touch panel, looks clean and minimal when installed too. Table Of Contents: * Device Features * * Breakdown * * Capacitive Touch IC * Re-Programming * * Tools * * Setup * * Programming Mode * Reference","title":"KingArt-N1 - Touch Light Light Switch"},{"location":"devices/KingArt/#device-features","text":"ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Confirmed 10A/250VAC mains relay -- Image: The 1 Gang Touch Panel, featuring the glass front (protective plastic film still on)","title":"Device Features"},{"location":"devices/KingArt/#breakdown","text":"Whats in the package... This looks like a reasonably simple setup. Removing the front glass panel you have access to the main control PCB. This holds the ESP8285 micro-controller and accompanying guff. I've worked through mapping most of the pins of interest - notes are in the images below. The control board runs off a 5V fed from the Power-Relay board at the read of the unit - a 3v3 reg is the control board for all the logic. The back of the control board has the touch controller and the 8way header to the Power-Relay board. There are only touch pads on the back of the control board as a means to interface with the microcontroller. There is no SonOff type programming header arrangement. , see Re-Programming . Control and Interface PCB Sorry for the horrible pics.. will replace Some Application-Interesting Pin Allocations *Trace for the King Art Switch with 2 (Touch-)Button is confirmed - works well with this Parameters The Power-Relay board is reasonably simple as well. This board, being a 1-gang switch, only has a single relay - but the PCB is set out for 3 (again, see images for trace and pin notes ). Power-Relay PCB","title":"Breakdown"},{"location":"devices/KingArt/#capacitive-touch-ic","text":"This board uses a dedicated capacitive touch control IC. Something interesting, that this IC manages touch switching as well a red and blue touch status LEDs for each of the touch pads that it services as the buttons. The IC illuminates a diffuser block over a 'button', indicating: * Blue : when Idle - button state is 'OFF' * Red+Blue : when Active - button state is 'ON' The TW8001 is also linked to a red error indicator led on the front of the Control Board - it is co-located above the EPS8285 microcontroller's Blue status indicator. This appears to be used by the Touch IC to indicate its own state information * eg, if the touch is held for +30s the touch shows an error state (red LED) and resets - useful if you replace the front panel and it needs to recalibrate. With regard to interfacing with the microcontroller, this device seems function with GPIO-friendly pin state for the capacitive button state reporting. Here is the only information I have been able to find on this device at the time of this investigation : TechWave - TW8001 . It does have much (or: any) in way of public datasheets. If anyone finds a datasheet please link it here!","title":"Capacitive Touch IC"},{"location":"devices/KingArt/#re-programming","text":"","title":"Re-Programming"},{"location":"devices/KingArt/#tools","text":"You shall need something in way of the following: (or whatever works for you, this is just my setup) * A USB-TTL adapter (TTL, 3V3.. something also with a 3V3 source) * Some leads * A soldering iron (solder, bits.. etc) - I'm going to assume you know how/what to do with this.","title":"Tools"},{"location":"devices/KingArt/#setup","text":"(This is my setup) USB-TTL | Lead | Board 3V3 Red 3v3 TXD White RX RXD Grey TX GND Black GND NNB : DO NOT USE or CONNECT THE 5V ever..","title":"Setup"},{"location":"devices/KingArt/#programming-mode","text":"Before you can program the board you have to start the ESP8285 micro in Programming Mode. This is important. Remember we soldered the blue lead to the board at (SW) - you will use this to force the micro to the required mode on startup. (you can only do this on startup) Entering Programming Mode: * Remove power from the board * Short the blue lead (SW) to ground (use a ground pad on the board or on your programmer) * NOW: Apply power. You can remove the short to ground after a second or two.","title":"Programming Mode"},{"location":"devices/KingArt/#reference","text":"https://github.com/EphemeralPersistence/Sonoff-Tasmota/wiki","title":"Reference"},{"location":"devices/KingArts-touch-Dimmer/","text":"On AliExpress you can buy a wifi dimmer for mains voltage (110 or 220V) It's a brandles dimmer, but can be found here: AliExpress page It comes in a couple of forms, but sinds I live in Holland, I chose the EU style, single gang, 220V, White edition. It has a glass front plate with 3 proximity/touch switches (On/Off, dimm up & dimm down) and a wifi indicator LED. The inside houses 2 PCB's; a power board and a control board: The control board: There are two main chips on board: An ESP8266 and a Nuvoton n76e003at20 The Nuvoton will do the switch side of it all, the ESP communication. The mains board: For flashing, we only need the control board. Solder small wires to the pads as marked on the picture: 3.3V GND RX TX Sw (gpio0) Solder 'Res1' to GND Note that the silkscreen on this board has TX and RX wrong. Now use a USB to serial adapter to connect the wires. Use a 3.3V board, NOT 5V, this will destroy the ESP chip on the board! Connect: GND to GND 3.3V to 3.3V RX to RX (due to the fact the silkscreen is wrong, otherwise, RX connects to TX and vice versa) TX to TX SW to GND -- only durning power up, to put the ESP in programming mode. From here the upload is the same as for all other Tasmota devices. See the upload page for detailed info. After the upload was successful, unplug the device from the serial adapter. You can now desolder all the connections you have made earlier. Also remove the wire between RES1 and GND. Then plug the board back in its housing. Be careful with the connector on the underside of the board. Line up the pins with te header and lightly press it in its place. Connecting to mains installation: ~ WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire. First connection ~ When you first power up the dimmer switch, it comes up in AccesPoint mode. Follow the instructions here Set correct module type ~ Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dimm the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"KingArts touch Dimmer"},{"location":"devices/KingArts-touch-Dimmer/#connecting-to-mains-installation","text":"WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire.","title":"Connecting to mains installation:"},{"location":"devices/KingArts-touch-Dimmer/#first-connection","text":"When you first power up the dimmer switch, it comes up in AccesPoint mode. Follow the instructions here","title":"First connection"},{"location":"devices/KingArts-touch-Dimmer/#set-correct-module-type","text":"Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dimm the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Set correct module type"},{"location":"devices/Kohree-VHP560-Smart-Light-Compatible%2C-RGBCW-Wi-Fi-LED-Bulb-A19/","text":"Kohree VHP560 Smart Light - A19 RGBCW Wi-Fi LED Bulb Easily flashed OTA using Tuya-Convert (OTA flashable as of Sept. 29, 2019, recent purchase). GPIO4 = PWM1 GPIO5 = PWM5 GPIO12 = PWM2 GPIO13 = PWM4 GPIO14 = PWM3","title":"Kohree VHP560 Smart Light Compatible, RGBCW Wi Fi LED Bulb A19"},{"location":"devices/LC-Technology-WiFi-Relay/","text":"LC Technology WiFi Relay - Single Relay ~ The LC Technology relay devices use GPIO1 and GPIO3 for the serial communications used to control the relays. You do not need to specify these in the template. SerialSend uses these standard serial communications GPIO by default. In order to use LC Technology WiFi Relay for 1 relay version: Set module to Generic (18) (in module configuration and click save) Set D3 GPIO0 as Relay1 (21) (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon Enable the rule (type rule1 1 in the Tasmota console) Note: If you use LC Technology v1.2 and this rule does not work, try to use 115200 baudrate Note: If that doesn't work for you, you may find that using Power1#Boot as the event to trigger the baud rate setting (instead of System#Boot ) works, as it did for me. So the alternate rule is: on Power1#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon LC Technology WiFi Relay - Dual Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600) ~ To configure an LC Technology ESP8266 Relay X2, use the following settings... Set module to Generic (in module configuration and click save) Set GPIO0 and GPIO2 as Relay1 and Relay 2 (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the Tasmota console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Enable the rule (type rule1 1 in the Tasmota console) LC Technology WiFi Relay - Quad Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600) ~ Note: The template provided below did not work on an ESP-01 running Tasmota 8.1.0. It was necessary to manually enter the template in the Configure Template menu. In configuration open Configure Other paste this template and select activate {\"NAME\":\"LC Technology 4CH Relay\",\"GPIO\":[52,255,17,255,255,255,255,255,21,22,23,24,255],\"FLAG\":0,\"BASE\":18} Open Configure Module and set GPIO0, GPIO2, GPIO4 and GPIO5 as Relay1, Relay2, Relay3 and Relay4. Click Save. Disable SerialLog (type seriallog 0 in the Tasmota console) Enter this command in console (configure the 1st rule) Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Enable the rule (type rule1 1 in the Tasmota console) If your relay is still not switching, check the LED on the board. If LED D5 is on (blue on my board, the middle LED) then the controller is in Mode 2. By pressing S2 while power up you can change back to Mode 1. After that the LED D7 is on ( red in my case) an the device works like a charm. Be carefull when you press S1 you change the mode again! LC Technology WiFi Relay X2 with Nuvoton N76E003AT20 ~ Note: This version of the board has the Nuvoton N76E003AT20 as its host microcontroller instead of STC15F104W. This device requires a special configuration for it to start listening to serial commands. Use the following device template, configureable in Configure Other : {\"NAME\":\"LC-ESP01-2R-5V\",\"GPIO\":[0,148,0,149,0,0,0,0,21,22,0,0,0],\"FLAG\":0,\"BASE\":18} Add the following rules: on System#Boot do Backlog Baudrate 115200 endon on SerialReceived#Data=41542B5253540D0A do SerialSend5 5749464920434f4e4e45435445440a5749464920474f542049500a41542b4349504d55583d310a41542b4349505345525645523d312c383038300a41542b43495053544f3d333630 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Here's what the above code does line per line: Sets the serial baud rate to 115200 (this seems to be the default for the Nuvoton LCTech Relay) This sends a certain stream of serial messages (in hex) below after receiving AT+RST (41542B5253540D0A in hex) from the NUVOTON devices. This message seems to make the NUVOTON enter listening mode. The long stream of hex messages for sending is equivalent to the ff. key in ASCII: WIFI CONNECTED WIFI GOT IP AT+CIPMUX=1 AT+CIPSERVER=1,8080 AT+CIPSTO=360 * The PowerX#State=xxx... messages are triggers to send serial messages to the NUVOTON chip. Do not forget to enable the rule. After the device receives the bypass key, it wouldn't immediately respond to commands. The ESP has to wait for the following return messages echoed back to Serial first: AT+CIPMUX=1 AT+CIPSERVER=1,8080 AT+CIPSTO=360 After these messages are sent back by Nuvoton to the ESP, the green LED beside the green LED will start blinking once a second. From here you can verify that the relay indeed starts to receive commands from the ESP. ## LC Technology WiFi Relay X4 with Nuvoton N76E003AT20 Note: This version of the board has the Nuvoton N76E003AT20 as its host microcontroller instead of STC15F104W. Becareful, not working with Nuvoton MS51FB9AE. (Not sure why this 'be careful' comment is here, the following did work on LC x4 board with Nuvoton MS51FB9AE rec'd Jan 2021, and Tasmota 9.2.0 If the board LEDs are not solid red + 1 sec green blink, press button S2 when powering up board. If buttons are pressed and solid blue is shown, it will not work.) Same special configuration than with X2 relay version with Nuvoton N76E003AT20. Use the following device template, configureable in `Configure Other`: {\"NAME\":\"LC-ESP01-4R-12V\",\"GPIO\":[0,148,0,149,0,0,0,0,21,22,23,24,0],\"FLAG\":0,\"BASE\":18} Add the following rules: Rule1 on System#Boot do Backlog Baudrate 115200 endon on SerialReceived#Data=41542B5253540D0A do SerialSend5 5749464920434f4e4e45435445440a5749464920474f542049500a41542b4349504d55583d310a41542b4349505345525645523d312c383038300a41542b43495053544f3d333630 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Rule1 1 Activate the rules: Rule1 1 * Open Configure Module and set GPIO0, GPIO2, GPIO4 and GPIO5 as Relay1, Relay2, Relay3 and Relay4. Click Save. * Disable SerialLog (type seriallog 0 in the Tasmota console) Beware of counterfeit modules ~ If your board just continuously flashes its led when powered on and no esp-01 is entered, the onboard STC15F104W needs to be programmed! For more details ( link ) Additionally, once programmed, you may also have to remove r4. Some issues exist where r3 and r4 are swapped, but just removing r4 works. ESP-01S 5V Relay Module V1.0 Relay ~ This board will not boot unless R2 is removed or the easier hardware fix below is carried out. A template is available ([here] (https://templates.blakadder.com/ESP-01S-Relay-v1.html)) Easier hardware fix ~ This is an easier fix for the ESP-01S relay v1.0 board, which does not require pcb cuts or resistor desoldering, just a 10K resistor soldered as in image: this mod prevents the relay flicker, and connects ch_pd, too How to use with up to 12V power supply ~ LC Technology WiFi Relay use CJT1117B linear regulator which support input power up to 12V. It is ok for ESP-01 and N76E003, but not for relay. Relay connected without any voltage regulator to input power directly. The easier way to replace existing relay. Part number for 12V relay is SRD-12VDC-SLC. You can use similar analogs for 6V and 9V.","title":"LC Technology WiFi Relay"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-single-relay","text":"The LC Technology relay devices use GPIO1 and GPIO3 for the serial communications used to control the relays. You do not need to specify these in the template. SerialSend uses these standard serial communications GPIO by default. In order to use LC Technology WiFi Relay for 1 relay version: Set module to Generic (18) (in module configuration and click save) Set D3 GPIO0 as Relay1 (21) (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon Enable the rule (type rule1 1 in the Tasmota console) Note: If you use LC Technology v1.2 and this rule does not work, try to use 115200 baudrate Note: If that doesn't work for you, you may find that using Power1#Boot as the event to trigger the baud rate setting (instead of System#Boot ) works, as it did for me. So the alternate rule is: on Power1#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon","title":"LC Technology WiFi Relay - Single Relay"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-dual-relay-note-older-versions-of-this-board-used-a-baud-rate-of-9600-so-if-115200-doesnt-work-try-9600","text":"To configure an LC Technology ESP8266 Relay X2, use the following settings... Set module to Generic (in module configuration and click save) Set GPIO0 and GPIO2 as Relay1 and Relay 2 (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the Tasmota console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Enable the rule (type rule1 1 in the Tasmota console)","title":"LC Technology WiFi Relay - Dual Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600)"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-quad-relay-note-older-versions-of-this-board-used-a-baud-rate-of-9600-so-if-115200-doesnt-work-try-9600","text":"Note: The template provided below did not work on an ESP-01 running Tasmota 8.1.0. It was necessary to manually enter the template in the Configure Template menu. In configuration open Configure Other paste this template and select activate {\"NAME\":\"LC Technology 4CH Relay\",\"GPIO\":[52,255,17,255,255,255,255,255,21,22,23,24,255],\"FLAG\":0,\"BASE\":18} Open Configure Module and set GPIO0, GPIO2, GPIO4 and GPIO5 as Relay1, Relay2, Relay3 and Relay4. Click Save. Disable SerialLog (type seriallog 0 in the Tasmota console) Enter this command in console (configure the 1st rule) Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Enable the rule (type rule1 1 in the Tasmota console) If your relay is still not switching, check the LED on the board. If LED D5 is on (blue on my board, the middle LED) then the controller is in Mode 2. By pressing S2 while power up you can change back to Mode 1. After that the LED D7 is on ( red in my case) an the device works like a charm. Be carefull when you press S1 you change the mode again!","title":"LC Technology WiFi Relay - Quad Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600)"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-x2-with-nuvoton-n76e003at20","text":"Note: This version of the board has the Nuvoton N76E003AT20 as its host microcontroller instead of STC15F104W. This device requires a special configuration for it to start listening to serial commands. Use the following device template, configureable in Configure Other : {\"NAME\":\"LC-ESP01-2R-5V\",\"GPIO\":[0,148,0,149,0,0,0,0,21,22,0,0,0],\"FLAG\":0,\"BASE\":18} Add the following rules: on System#Boot do Backlog Baudrate 115200 endon on SerialReceived#Data=41542B5253540D0A do SerialSend5 5749464920434f4e4e45435445440a5749464920474f542049500a41542b4349504d55583d310a41542b4349505345525645523d312c383038300a41542b43495053544f3d333630 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Here's what the above code does line per line: Sets the serial baud rate to 115200 (this seems to be the default for the Nuvoton LCTech Relay) This sends a certain stream of serial messages (in hex) below after receiving AT+RST (41542B5253540D0A in hex) from the NUVOTON devices. This message seems to make the NUVOTON enter listening mode. The long stream of hex messages for sending is equivalent to the ff. key in ASCII: WIFI CONNECTED WIFI GOT IP AT+CIPMUX=1 AT+CIPSERVER=1,8080 AT+CIPSTO=360 * The PowerX#State=xxx... messages are triggers to send serial messages to the NUVOTON chip. Do not forget to enable the rule. After the device receives the bypass key, it wouldn't immediately respond to commands. The ESP has to wait for the following return messages echoed back to Serial first: AT+CIPMUX=1 AT+CIPSERVER=1,8080 AT+CIPSTO=360 After these messages are sent back by Nuvoton to the ESP, the green LED beside the green LED will start blinking once a second. From here you can verify that the relay indeed starts to receive commands from the ESP. ## LC Technology WiFi Relay X4 with Nuvoton N76E003AT20 Note: This version of the board has the Nuvoton N76E003AT20 as its host microcontroller instead of STC15F104W. Becareful, not working with Nuvoton MS51FB9AE. (Not sure why this 'be careful' comment is here, the following did work on LC x4 board with Nuvoton MS51FB9AE rec'd Jan 2021, and Tasmota 9.2.0 If the board LEDs are not solid red + 1 sec green blink, press button S2 when powering up board. If buttons are pressed and solid blue is shown, it will not work.) Same special configuration than with X2 relay version with Nuvoton N76E003AT20. Use the following device template, configureable in `Configure Other`: {\"NAME\":\"LC-ESP01-4R-12V\",\"GPIO\":[0,148,0,149,0,0,0,0,21,22,23,24,0],\"FLAG\":0,\"BASE\":18} Add the following rules: Rule1 on System#Boot do Backlog Baudrate 115200 endon on SerialReceived#Data=41542B5253540D0A do SerialSend5 5749464920434f4e4e45435445440a5749464920474f542049500a41542b4349504d55583d310a41542b4349505345525645523d312c383038300a41542b43495053544f3d333630 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Rule1 1 Activate the rules: Rule1 1 * Open Configure Module and set GPIO0, GPIO2, GPIO4 and GPIO5 as Relay1, Relay2, Relay3 and Relay4. Click Save. * Disable SerialLog (type seriallog 0 in the Tasmota console)","title":"LC Technology WiFi Relay X2 with Nuvoton N76E003AT20"},{"location":"devices/LC-Technology-WiFi-Relay/#beware-of-counterfeit-modules","text":"If your board just continuously flashes its led when powered on and no esp-01 is entered, the onboard STC15F104W needs to be programmed! For more details ( link ) Additionally, once programmed, you may also have to remove r4. Some issues exist where r3 and r4 are swapped, but just removing r4 works.","title":"Beware of counterfeit modules"},{"location":"devices/LC-Technology-WiFi-Relay/#esp-01s-5v-relay-module-v10-relay","text":"This board will not boot unless R2 is removed or the easier hardware fix below is carried out. A template is available ([here] (https://templates.blakadder.com/ESP-01S-Relay-v1.html))","title":"ESP-01S 5V Relay Module V1.0 Relay"},{"location":"devices/LC-Technology-WiFi-Relay/#easier-hardware-fix","text":"This is an easier fix for the ESP-01S relay v1.0 board, which does not require pcb cuts or resistor desoldering, just a 10K resistor soldered as in image: this mod prevents the relay flicker, and connects ch_pd, too","title":"Easier hardware fix"},{"location":"devices/LC-Technology-WiFi-Relay/#how-to-use-with-up-to-12v-power-supply","text":"LC Technology WiFi Relay use CJT1117B linear regulator which support input power up to 12V. It is ok for ESP-01 and N76E003, but not for relay. Relay connected without any voltage regulator to input power directly. The easier way to replace existing relay. Part number for 12V relay is SRD-12VDC-SLC. You can use similar analogs for 6V and 9V.","title":"How to use with up to 12V power supply"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/","text":"Simple somewhat compact WiFi controllable EU plug socket. Sold in the Netherlands by Action. Product ~ Internals ~ Inside the device is a Tuya TYWE2S. This device can be flashed using a software OTA hack using tuya-convert Flashing ~ Simply connect the (clearly labeled) 3v3, GND, TX, RX pins of the TYWE2S to the appropriate pins on your serial adapter and connect IO0 to GND to enter flashing mode. With the device connected and in flashing mode, create a backup of the factory firmware, erase the flash, and flash a tasmota firmware approximately as follows: esptool.py read_flash 0x000000 0x100000 image1M.bin esptool.py erase_flash esptool.py write_flash -fs 1MB -fm dout 0x0 tasmota-lite.bin` Configuration ~ \u26a0\ufe0f Warning! While the below configuration is correct and working, configuring a button on GPIO14 will make the device reset itself to the default Tasmota configuration after a number of seconds.","title":"LSC Smart Connect Smart Power Plug"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#product","text":"","title":"Product"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#internals","text":"Inside the device is a Tuya TYWE2S. This device can be flashed using a software OTA hack using tuya-convert","title":"Internals"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#flashing","text":"Simply connect the (clearly labeled) 3v3, GND, TX, RX pins of the TYWE2S to the appropriate pins on your serial adapter and connect IO0 to GND to enter flashing mode. With the device connected and in flashing mode, create a backup of the factory firmware, erase the flash, and flash a tasmota firmware approximately as follows: esptool.py read_flash 0x000000 0x100000 image1M.bin esptool.py erase_flash esptool.py write_flash -fs 1MB -fm dout 0x0 tasmota-lite.bin`","title":"Flashing"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#configuration","text":"\u26a0\ufe0f Warning! While the below configuration is correct and working, configuring a button on GPIO14 will make the device reset itself to the default Tasmota configuration after a number of seconds.","title":"Configuration"},{"location":"devices/LeFun-SK2-Smart-Power-Strip/","text":"The LeFun SK2 has 4 mains power and 4 USB ports. Each mains power is independently controlled and the USB group is controllable via a solid state relay. The ESP8266 module inside is likely a TYWE3S by Tuya but I didn't open the case and use the tuya-convert tool to flash.","title":"LeFun SK2 Smart Power Strip"},{"location":"devices/Lingan-SWA1/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ More Infos can be found here: Lingan SWA1 Plug in Wi-Fi Socket with MQTT (ESP8266) . Device Images ~ GPIO Config ~","title":"Lingan SWA1"},{"location":"devices/Lingan-SWA1/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/Lingan-SWA1/#additional-information","text":"More Infos can be found here: Lingan SWA1 Plug in Wi-Fi Socket with MQTT (ESP8266) .","title":"Additional Information"},{"location":"devices/Lingan-SWA1/#device-images","text":"","title":"Device Images"},{"location":"devices/Lingan-SWA1/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/Luminea-ZX-2844-675/","text":"Luminea ZX-2844-* ~ also known as: * XS-RGBW-LedControl-V2.0.2 * JCD XS-RGBW sold by PEARL and amazon (i know know if they are available outside D-A-CH) * https://www.pearl.de/a-ZX2844-3103.shtml * https://www.amazon.de/Luminea-Zubeh%C3%B6r-Smarthome-LED-Strips-WLAN-Controller-spritzwassergesch%C3%BCtzt/dp/B074T11793 Hardware ~ There is a ESP8266EX sitting on the backside. 4 PWM outputs are connected to drive the 4 output channels (RGB + W). Red is on GPIO14 Green is on GPIO12 Blue is on GPIO5 White is on GPIO13 The pushbutton is GPIO13. Assign it to Button1 for local on/off control. You can configure it as a \"generic module\" And set the GPIO as follow: Function ESP Pin Channel R GPIO 14 PWM1 G GPIO 12 PWM2 B GPIO 5 PWM3 W GPIO 0 PWM4 PushButton GPIO 13 Button1 There is an second version with a green PCB and different pinout: Function ESP Pin Channel R GPIO 4 PWM1 G GPIO 12 PWM2 B GPIO 14 PWM3 W GPIO 5 PWM4 PushButton GPIO 0 Button1 Serial Connection ~ See the Hardware Preparation page for general instructions. The serial header (3.3V, RXD, TXD, GND) as well as GPIO0, GPIO2 and RESET (IO0, IO2, RST) are populated as test pads on the frontside of the PCB. You can easily add some solder to fix the wires during the flash process. To place the board into flashing mode, you will need to short IO0 to GND. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Luminea ZX-2844-*"},{"location":"devices/Luminea-ZX-2844-675/#luminea-zx-2844-","text":"also known as: * XS-RGBW-LedControl-V2.0.2 * JCD XS-RGBW sold by PEARL and amazon (i know know if they are available outside D-A-CH) * https://www.pearl.de/a-ZX2844-3103.shtml * https://www.amazon.de/Luminea-Zubeh%C3%B6r-Smarthome-LED-Strips-WLAN-Controller-spritzwassergesch%C3%BCtzt/dp/B074T11793","title":"Luminea ZX-2844-*"},{"location":"devices/Luminea-ZX-2844-675/#hardware","text":"There is a ESP8266EX sitting on the backside. 4 PWM outputs are connected to drive the 4 output channels (RGB + W). Red is on GPIO14 Green is on GPIO12 Blue is on GPIO5 White is on GPIO13 The pushbutton is GPIO13. Assign it to Button1 for local on/off control. You can configure it as a \"generic module\" And set the GPIO as follow: Function ESP Pin Channel R GPIO 14 PWM1 G GPIO 12 PWM2 B GPIO 5 PWM3 W GPIO 0 PWM4 PushButton GPIO 13 Button1 There is an second version with a green PCB and different pinout: Function ESP Pin Channel R GPIO 4 PWM1 G GPIO 12 PWM2 B GPIO 14 PWM3 W GPIO 5 PWM4 PushButton GPIO 0 Button1","title":"Hardware"},{"location":"devices/Luminea-ZX-2844-675/#serial-connection","text":"See the Hardware Preparation page for general instructions. The serial header (3.3V, RXD, TXD, GND) as well as GPIO0, GPIO2 and RESET (IO0, IO2, RST) are populated as test pads on the frontside of the PCB. You can easily add some solder to fix the wires during the flash process. To place the board into flashing mode, you will need to short IO0 to GND. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Serial Connection"},{"location":"devices/MagicHome-LED-strip-controller/","text":"MagicHome LED controllers (aka Flux-Led, aka Arilux AL-LC01) ~ Shopping Board is essentially a ESP-12S (or ESP-2M) with necessary voltage converters, little bit of flash, 3 or 4 MOSFETs to drive LED strip (depending on the model), connector for LED strip and optional IR receiver. Warning There are new versions of these boards that use an incompatible module, Tasmota cannot be flashed on them! Before anything, make sure your board has a compatible chip. Module is powered by 12V that is used to power LED strip as well. RGB models are declared as 144W, RGBW models as 192W. Module comes in (at least) 3 variants: - LC01: RGB, - LC02: RGBW and - LC03: RGB with IR receiver. - LC04: RGBW with IR receiver. - LC05: RGB with Screw-Headers. - LC06: RGBW/WW with Screw-Headers A different version of this controller with an ESP8285 is documented here The new models comes with the BL602 (RISC-V) and still incompatible as the issue Serial Connection ~ Board has RX, TX, GND and GPIO00 pads exposed on the bottom side of the PCB. You need to solder temporary wires those pads. You need to power the board while keeping it connected to the programmer. With all Sonoff boards that work with AC, this is a big no-no that will fry your programmer, your Sonoff and might even get you killed. In this case, you'd be dealing with 12V, so the only thing that matters is to connect the GND of your programmer to GND of the board before you supply the 12V. Not doing so might fry your board and/or programmer, but would definitely not hurt you. Steps used: 1. Connect your programmer to a breadboard and notice the locations of GND, TX and RX columns. 1. Open the MagicHome controller box and expose bottom side of PCB 1. Solder 4 jumper wires to 4 exposed pads. 1. FIRST connect GND to your programmer (and make sure they are connected well!) 1. Connect RX from the MagicHome to TX on the programmer. TX from the board goes to RX on the programmer. 1. Connect GPIO00 to GND (best to use same column on the breadboard) 1. Connect the 12V power supply to MagicHome. As GPIO00 is connected to GND, board will go into flash mode. Disconnect GPIO00 after few seconds. 1. Upload Tasmota like it would be any other board. 1. Once upload is complete, disconnect power from the MagicHome controller 1. Disconnect RX and TX and then only then GND. GND gets disconnected LAST. You can then connect the power back to the board and Tasmota should be running on it. Once you verify that board is up and you can access it over the Web, you can unsolder temporary wires and update subsequent firmware versions using OTA. Configuration ~ Some GPIO are preconfigured with the board: - GPIO05 - (PWM2) Green color on the led strip, first pin from the GND - GPIO14 - (PWM1) Red color on the LED strip, second pin from the GND - GPIO12 - (PWM3) Blue color on the LED strip, third pin from the GND For instructions to setup the 24 Button Remote visit the AL-LC04 device page Check this for Board Version 2.3 : #1867 Due to variants, you can configure: - GPIO04 - on non-IR boards, it's an open pin you can use for Onewire, button or something else. It might have pull-down resistor and/or bypass capacitor, so please take that into consideration. On IR-enabled boards, IR receiver is connected to this pin, so you can use IRRecv as functionality. - GPIO13 - This pin is not used on RGB board (so you'll leave it as \"None\"), but on RGBW, it's driving another channel (cold white or warm white) for LED strip. Variant without Rx/Tx pads: ~ - Using the IRrecv (IR Remote) feature ~ If you have a variant with an IR Remote (as per the opening picture), you can use the new rule command to make the remote buttons change the light levels. For example, this rule allows me to turn it on and off, change the brightness, and turn it on to full white: rule1 on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color #000000ff endon Full Set of rules for IR remote ~ Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. rule1 on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color 12 endon on IrReceived#Data=0xFF9867 do color 1 endon on IrReceived#Data=0xFFD827 do color 2 endon on IrReceived#Data=0xFF8877 do color 3 endon on IrReceived#Data=0xFF28D7 do color #007FFF endon on IrReceived#Data=0xFF38C7 do color 4 endon rule2 on IrReceived#Data=0xFFE817 do color #FF3F00 endon on IrReceived#Data=0xFF48B7 do color #00FF3F endon on IrReceived#Data=0xFF6897 do color #3F00FF endon on IrReceived#Data=0xFF02FD do color 4 endon on IrReceived#Data=0xFF32CD do color #00FFBF endon on IrReceived#Data=0xFF20DF do color #7F00FF endon on IrReceived#Data=0xFF50AF do color #FF7F00 endon on IrReceived#Data=0xFF7887 do color #00BFFF endon on IrReceived#Data=0xFF708F do color #FF00FF endon on IrReceived#Data=0xFFF00F do color #FF003F endon rule3 on IrReceived#Data=0xFF00FF do scheme 4 endon on IrReceived#Data=0xFF58A7 do scheme 3 endon on IrReceived#Data=0xFF30CF do scheme 2 endon on IrReceived#Data=0xFFB24D do backlog BlinkCount 600; Power 3 endon After setting the rules you need to activate them with the following: rule1 1 rule2 1 rule3 1 The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do what ever you want. See here for more details: devices/Rules","title":"MagicHome LED strip controller"},{"location":"devices/MagicHome-LED-strip-controller/#magichome-led-controllers-aka-flux-led-aka-arilux-al-lc01","text":"Shopping Board is essentially a ESP-12S (or ESP-2M) with necessary voltage converters, little bit of flash, 3 or 4 MOSFETs to drive LED strip (depending on the model), connector for LED strip and optional IR receiver. Warning There are new versions of these boards that use an incompatible module, Tasmota cannot be flashed on them! Before anything, make sure your board has a compatible chip. Module is powered by 12V that is used to power LED strip as well. RGB models are declared as 144W, RGBW models as 192W. Module comes in (at least) 3 variants: - LC01: RGB, - LC02: RGBW and - LC03: RGB with IR receiver. - LC04: RGBW with IR receiver. - LC05: RGB with Screw-Headers. - LC06: RGBW/WW with Screw-Headers A different version of this controller with an ESP8285 is documented here The new models comes with the BL602 (RISC-V) and still incompatible as the issue","title":"MagicHome LED controllers (aka Flux-Led, aka Arilux AL-LC01)"},{"location":"devices/MagicHome-LED-strip-controller/#serial-connection","text":"Board has RX, TX, GND and GPIO00 pads exposed on the bottom side of the PCB. You need to solder temporary wires those pads. You need to power the board while keeping it connected to the programmer. With all Sonoff boards that work with AC, this is a big no-no that will fry your programmer, your Sonoff and might even get you killed. In this case, you'd be dealing with 12V, so the only thing that matters is to connect the GND of your programmer to GND of the board before you supply the 12V. Not doing so might fry your board and/or programmer, but would definitely not hurt you. Steps used: 1. Connect your programmer to a breadboard and notice the locations of GND, TX and RX columns. 1. Open the MagicHome controller box and expose bottom side of PCB 1. Solder 4 jumper wires to 4 exposed pads. 1. FIRST connect GND to your programmer (and make sure they are connected well!) 1. Connect RX from the MagicHome to TX on the programmer. TX from the board goes to RX on the programmer. 1. Connect GPIO00 to GND (best to use same column on the breadboard) 1. Connect the 12V power supply to MagicHome. As GPIO00 is connected to GND, board will go into flash mode. Disconnect GPIO00 after few seconds. 1. Upload Tasmota like it would be any other board. 1. Once upload is complete, disconnect power from the MagicHome controller 1. Disconnect RX and TX and then only then GND. GND gets disconnected LAST. You can then connect the power back to the board and Tasmota should be running on it. Once you verify that board is up and you can access it over the Web, you can unsolder temporary wires and update subsequent firmware versions using OTA.","title":"Serial Connection"},{"location":"devices/MagicHome-LED-strip-controller/#configuration","text":"Some GPIO are preconfigured with the board: - GPIO05 - (PWM2) Green color on the led strip, first pin from the GND - GPIO14 - (PWM1) Red color on the LED strip, second pin from the GND - GPIO12 - (PWM3) Blue color on the LED strip, third pin from the GND For instructions to setup the 24 Button Remote visit the AL-LC04 device page Check this for Board Version 2.3 : #1867 Due to variants, you can configure: - GPIO04 - on non-IR boards, it's an open pin you can use for Onewire, button or something else. It might have pull-down resistor and/or bypass capacitor, so please take that into consideration. On IR-enabled boards, IR receiver is connected to this pin, so you can use IRRecv as functionality. - GPIO13 - This pin is not used on RGB board (so you'll leave it as \"None\"), but on RGBW, it's driving another channel (cold white or warm white) for LED strip.","title":"Configuration"},{"location":"devices/MagicHome-LED-strip-controller/#variant-without-rxtx-pads","text":"-","title":"Variant without Rx/Tx pads:"},{"location":"devices/MagicHome-LED-strip-controller/#using-the-irrecv-ir-remote-feature","text":"If you have a variant with an IR Remote (as per the opening picture), you can use the new rule command to make the remote buttons change the light levels. For example, this rule allows me to turn it on and off, change the brightness, and turn it on to full white: rule1 on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color #000000ff endon","title":"Using the IRrecv (IR Remote) feature"},{"location":"devices/MagicHome-LED-strip-controller/#full-set-of-rules-for-ir-remote","text":"Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. rule1 on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color 12 endon on IrReceived#Data=0xFF9867 do color 1 endon on IrReceived#Data=0xFFD827 do color 2 endon on IrReceived#Data=0xFF8877 do color 3 endon on IrReceived#Data=0xFF28D7 do color #007FFF endon on IrReceived#Data=0xFF38C7 do color 4 endon rule2 on IrReceived#Data=0xFFE817 do color #FF3F00 endon on IrReceived#Data=0xFF48B7 do color #00FF3F endon on IrReceived#Data=0xFF6897 do color #3F00FF endon on IrReceived#Data=0xFF02FD do color 4 endon on IrReceived#Data=0xFF32CD do color #00FFBF endon on IrReceived#Data=0xFF20DF do color #7F00FF endon on IrReceived#Data=0xFF50AF do color #FF7F00 endon on IrReceived#Data=0xFF7887 do color #00BFFF endon on IrReceived#Data=0xFF708F do color #FF00FF endon on IrReceived#Data=0xFFF00F do color #FF003F endon rule3 on IrReceived#Data=0xFF00FF do scheme 4 endon on IrReceived#Data=0xFF58A7 do scheme 3 endon on IrReceived#Data=0xFF30CF do scheme 2 endon on IrReceived#Data=0xFFB24D do backlog BlinkCount 600; Power 3 endon After setting the rules you need to activate them with the following: rule1 1 rule2 1 rule3 1 The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do what ever you want. See here for more details: devices/Rules","title":"Full Set of rules for IR remote"},{"location":"devices/MagicHome-with-ESP8285/","text":"Yet another MagicHome RGB controller. I specifically had this one . Aside from it going 9-28V, there are no other external model numbers etc, however opening it up revealed a very different configuration inside, using an ESP8285 chip directly on the board. (Right click and view the original image to see the full size image for all images below) Identifying this board ~ Looking closely you can see it's an ESP8285, on the main board, it has the part number: ZJ-WFMN-A V1.1 , ZJ-WFMN-B V1.1 , ZJ-WFMN-C V1.1 , or ZJ-WFMN-D V1.0 Arilux devices ~ The devices are similar to the Arilux devices. Here is an overview: Model Color Support Voltages (sometimes) Remote PCB part number Link LC01 RGB 5-28V None ZJ-WFMN-A V1.1 [Banggood][LC01-banggood] LC02 RGBW 9-12V (5-28V) None ZJ-WFMN-B V1.1 [Banggood][LC02-banggood] LC03 RGB 5-28V IR ZJ-WFMN-A V1.1 [Banggood][LC03-banggood] LC04 RGBW 9-12V (5-28V) IR ZJ-WFMN-A V1.1 [Banggood][LC04-banggood] LC08 RGBWW/RGBWC 5-28V None [Banggood][LC08-banggood] LC09 RGB 5-28V RF [Banggood][LC09-banggood] LC10 RGBW 9-28V RF [Banggood][LC10-banggood] LC11 RGBWW/RGBWC 9-28V RF ZJ-WFMN-D V1.0 [Banggood][LC11-banggood] Flashing ~ I found that on the back it has pads to solder to so you can flash it. The IO0 port is GPIO0 that needs to be pulled to ground when powered on for flashing (as per all ESP devices). I soldered cables to each of these. Note that some are very close to other pads, so be careful. If you want to avoid soldering, also pogo pins work well with the pads. Template configuration ~ Arilux LC01 (ZJ-WFMN-A V1.1) Automatic configuration: Field Value Function Module type 37 Arilux LC01 Module type Manual configuration: Field Value Function Module type 18 Generic Module type GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC02 (ZJ-WFMN-B V1.1) Field Value Function Module type 18 Generic Module type GPIO5 38 PWM2 GREEN GPIO12 39 PWM3 BLUE GPIO13 40 PWM4 WHITE GPIO14 37 PWM1 RED Arilux LC03 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC04 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote (optional, view console for debugging!) GPIO5 38 PWM2 BLUE GPIO12 37 PWM1 RED GPIO13 39 PWM3 GREEN GPIO15 40 PWM4 WHITE Arilux LC11 (ZJ-WFMN-D V1.0) Field Value Function Module type 18 Generic Module type GPIO4 147 ALux IrRcv GPIO5 40 PWM4 COLD WHITE GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE GPIO14 37 PWM1 RED GPIO15 41 PWM5 WARM WHITE GPIO16 159 ALux IrSel With all that done, one of the critical things I needed to do so I could set the colors was to run the command to set SetOption15 1 . After that it is possible to test the lights functionality, e.g. with the command Color #ff0000ff . RF control ~ If you have an RF variant, you will want to configure the GPIOs like this: { \"MagicHome RF\", // Magic Home RF (ESP8266) - (Arilux LC10) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (optional) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_ARIRFRCV, // GPIO04 RF receiver input (New Tasmota ALux IrRcv 147) GPIO_PWM2, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM3, // GPIO12 RGB LED Blue GPIO_PWM4, // GPIO13 RGBW LED White GPIO_PWM1, // GPIO14 RGB LED Red GPIO_LED2_INV, // GPIO15 RF receiver control (New Tasmota ALuxIrSel 159) 0, 0 }, Tasmota template '{\"NAME\":\"MagicHome RGBW RF\",\"GPIO\":[0,0,56,0,147,38,0,0,39,40,37,159,0],\"FLAG\":0,\"BASE\":18}' or like this: { \"MagicHome RF\", // Magic Home RF (ESP8285) - (IRrecv) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (not soldered) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_IRRECV, // GPIO04 IR receiver input GPIO_PWM1, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM2, // GPIO12 RGB LED Blue GPIO_PWM3, // GPIO13 RGBW LED White 0, 0, 0 }, After choosing the correct module type in your Tasmota configuration, press a key on the remote after boot for the device to learn your code. No need for the below rules for the RF varient Full Set of rules for IR remote ~ Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. Rule1 On IrReceived#Data=0x00FF906F Do Dimmer + EndOn On IrReceived#Data=0x00FF9867 Do Color2 1 EndOn On IrReceived#Data=0x00FFE817 Do HSBColor1 13 EndOn On IrReceived#Data=0x00FF02FD Do HSBColor1 23 EndOn On IrReceived#Data=0x00FF50AF Do HSBColor1 33 EndOn On IrReceived#Data=0x00FF38C7 Do HSBColor1 43 EndOn On IrReceived#Data=0x00FFB847 Do Dimmer - EndOn On IrReceived#Data=0x00FFD827 Do Color2 2 EndOn On IrReceived#Data=0x00FF48B7 Do HSBColor1 140 EndOn On IrReceived#Data=0x00FF32CD Do HSBColor1 160 EndOn Rule2 On IrReceived#Data=0x00FF7887 Do HSBColor1 180 EndOn On IrReceived#Data=0x00FF28D7 Do HSBColor1 200 EndOn On IrReceived#Data=0x00FFF807 Do Power 0 EndOn On IrReceived#Data=0x00FF8877 Do Color2 3 EndOn On IrReceived#Data=0x00FF6897 Do HSBColor1 260 EndOn On IrReceived#Data=0x00FF20DF Do HSBColor1 280 EndOn On IrReceived#Data=0x00FF708F Do HSBColor1 300 EndOn On IrReceived#Data=0x00FFF00F Do HSBColor1 320 EndOn Rule3 On IrReceived#Data=0x00FFB04F Do Power 1 EndOn On IrReceived#Data=0x00FFA857 Do Color2 12 EndOn On IrReceived#Data=0x00FFB24D Do Backlog Power 0; WakeupDuration 1; Dimmer 100; Wakeup EndOn On IrReceived#Data=0x00FF00FF Do Backlog Power 0; WakeupDuration 5; Wakeup EndOn On IrReceived#Data=0x00FF58A7 Do Backlog Scheme 2; Speed 1 EndOn On IrReceived#Data=0x00FF30CF Do Backlog Scheme 3; Speed 5 EndOn A Google Sheets Document to edit the desired actions and create the three needed rules is linked here . Don't forget to activate the rules Backlog Rule1 1; Rule2 1; Rule3 1 The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do whatever you want using Rules . LC01-banggood LC02-banggood LC03-banggood LC04-banggood LC08-banggood LC09-banggood LC10-banggood LC11-banggood","title":"MagicHome with ESP8285"},{"location":"devices/MagicHome-with-ESP8285/#identifying-this-board","text":"Looking closely you can see it's an ESP8285, on the main board, it has the part number: ZJ-WFMN-A V1.1 , ZJ-WFMN-B V1.1 , ZJ-WFMN-C V1.1 , or ZJ-WFMN-D V1.0","title":"Identifying this board"},{"location":"devices/MagicHome-with-ESP8285/#arilux-devices","text":"The devices are similar to the Arilux devices. Here is an overview: Model Color Support Voltages (sometimes) Remote PCB part number Link LC01 RGB 5-28V None ZJ-WFMN-A V1.1 [Banggood][LC01-banggood] LC02 RGBW 9-12V (5-28V) None ZJ-WFMN-B V1.1 [Banggood][LC02-banggood] LC03 RGB 5-28V IR ZJ-WFMN-A V1.1 [Banggood][LC03-banggood] LC04 RGBW 9-12V (5-28V) IR ZJ-WFMN-A V1.1 [Banggood][LC04-banggood] LC08 RGBWW/RGBWC 5-28V None [Banggood][LC08-banggood] LC09 RGB 5-28V RF [Banggood][LC09-banggood] LC10 RGBW 9-28V RF [Banggood][LC10-banggood] LC11 RGBWW/RGBWC 9-28V RF ZJ-WFMN-D V1.0 [Banggood][LC11-banggood]","title":"Arilux devices"},{"location":"devices/MagicHome-with-ESP8285/#flashing","text":"I found that on the back it has pads to solder to so you can flash it. The IO0 port is GPIO0 that needs to be pulled to ground when powered on for flashing (as per all ESP devices). I soldered cables to each of these. Note that some are very close to other pads, so be careful. If you want to avoid soldering, also pogo pins work well with the pads.","title":"Flashing"},{"location":"devices/MagicHome-with-ESP8285/#template-configuration","text":"Arilux LC01 (ZJ-WFMN-A V1.1) Automatic configuration: Field Value Function Module type 37 Arilux LC01 Module type Manual configuration: Field Value Function Module type 18 Generic Module type GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC02 (ZJ-WFMN-B V1.1) Field Value Function Module type 18 Generic Module type GPIO5 38 PWM2 GREEN GPIO12 39 PWM3 BLUE GPIO13 40 PWM4 WHITE GPIO14 37 PWM1 RED Arilux LC03 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC04 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote (optional, view console for debugging!) GPIO5 38 PWM2 BLUE GPIO12 37 PWM1 RED GPIO13 39 PWM3 GREEN GPIO15 40 PWM4 WHITE Arilux LC11 (ZJ-WFMN-D V1.0) Field Value Function Module type 18 Generic Module type GPIO4 147 ALux IrRcv GPIO5 40 PWM4 COLD WHITE GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE GPIO14 37 PWM1 RED GPIO15 41 PWM5 WARM WHITE GPIO16 159 ALux IrSel With all that done, one of the critical things I needed to do so I could set the colors was to run the command to set SetOption15 1 . After that it is possible to test the lights functionality, e.g. with the command Color #ff0000ff .","title":"Template configuration"},{"location":"devices/MagicHome-with-ESP8285/#rf-control","text":"If you have an RF variant, you will want to configure the GPIOs like this: { \"MagicHome RF\", // Magic Home RF (ESP8266) - (Arilux LC10) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (optional) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_ARIRFRCV, // GPIO04 RF receiver input (New Tasmota ALux IrRcv 147) GPIO_PWM2, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM3, // GPIO12 RGB LED Blue GPIO_PWM4, // GPIO13 RGBW LED White GPIO_PWM1, // GPIO14 RGB LED Red GPIO_LED2_INV, // GPIO15 RF receiver control (New Tasmota ALuxIrSel 159) 0, 0 }, Tasmota template '{\"NAME\":\"MagicHome RGBW RF\",\"GPIO\":[0,0,56,0,147,38,0,0,39,40,37,159,0],\"FLAG\":0,\"BASE\":18}' or like this: { \"MagicHome RF\", // Magic Home RF (ESP8285) - (IRrecv) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (not soldered) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_IRRECV, // GPIO04 IR receiver input GPIO_PWM1, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM2, // GPIO12 RGB LED Blue GPIO_PWM3, // GPIO13 RGBW LED White 0, 0, 0 }, After choosing the correct module type in your Tasmota configuration, press a key on the remote after boot for the device to learn your code. No need for the below rules for the RF varient","title":"RF control"},{"location":"devices/MagicHome-with-ESP8285/#full-set-of-rules-for-ir-remote","text":"Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. Rule1 On IrReceived#Data=0x00FF906F Do Dimmer + EndOn On IrReceived#Data=0x00FF9867 Do Color2 1 EndOn On IrReceived#Data=0x00FFE817 Do HSBColor1 13 EndOn On IrReceived#Data=0x00FF02FD Do HSBColor1 23 EndOn On IrReceived#Data=0x00FF50AF Do HSBColor1 33 EndOn On IrReceived#Data=0x00FF38C7 Do HSBColor1 43 EndOn On IrReceived#Data=0x00FFB847 Do Dimmer - EndOn On IrReceived#Data=0x00FFD827 Do Color2 2 EndOn On IrReceived#Data=0x00FF48B7 Do HSBColor1 140 EndOn On IrReceived#Data=0x00FF32CD Do HSBColor1 160 EndOn Rule2 On IrReceived#Data=0x00FF7887 Do HSBColor1 180 EndOn On IrReceived#Data=0x00FF28D7 Do HSBColor1 200 EndOn On IrReceived#Data=0x00FFF807 Do Power 0 EndOn On IrReceived#Data=0x00FF8877 Do Color2 3 EndOn On IrReceived#Data=0x00FF6897 Do HSBColor1 260 EndOn On IrReceived#Data=0x00FF20DF Do HSBColor1 280 EndOn On IrReceived#Data=0x00FF708F Do HSBColor1 300 EndOn On IrReceived#Data=0x00FFF00F Do HSBColor1 320 EndOn Rule3 On IrReceived#Data=0x00FFB04F Do Power 1 EndOn On IrReceived#Data=0x00FFA857 Do Color2 12 EndOn On IrReceived#Data=0x00FFB24D Do Backlog Power 0; WakeupDuration 1; Dimmer 100; Wakeup EndOn On IrReceived#Data=0x00FF00FF Do Backlog Power 0; WakeupDuration 5; Wakeup EndOn On IrReceived#Data=0x00FF58A7 Do Backlog Scheme 2; Speed 1 EndOn On IrReceived#Data=0x00FF30CF Do Backlog Scheme 3; Speed 5 EndOn A Google Sheets Document to edit the desired actions and create the three needed rules is linked here . Don't forget to activate the rules Backlog Rule1 1; Rule2 1; Rule3 1 The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do whatever you want using Rules . LC01-banggood LC02-banggood LC03-banggood LC04-banggood LC08-banggood LC09-banggood LC10-banggood LC11-banggood","title":"Full Set of rules for IR remote"},{"location":"devices/Martin-Jerry-MJ-S01/","text":"The chip inside is a Tuya TYWE3S which is based on the ESP8266. Template GPIO Pin Selection 4 D2 Led1i (56) 5 D1 Led2i (57) 12 D6 Relay1 (21) 13 D7 Button1 (17) All other component assignments should be set to None (0)","title":"Martin Jerry MJ S01"},{"location":"devices/Martin-Jerry-MJ-SD01/","text":"This model sells for about $20 on Amazon . Info on the Tuya ~ The chip inside is a Tuya TYWE3S. It replicates the capabilities of an ESP8266 plus some other functionality. NOTE: THE RIGHT SIDE IS THE BACK OF THE BOARD. RST IS ON THE TOP LEFT OF THE LEFT PICTURE, AS WELL AS THE TOP LEFT OF THE PICTURE BELOW. Here\u2019s a picture of the chip inside the switch: Pin 1 is labeled M1 in the silkscreen of the switch board. Here\u2019s the back, I desoldered it with my Quick 861DW: On the other side of the board is an apparent test/programming header labeled CN1: From top to bottom on CN1 above, they are: Pin Signal CN1-1 TXD CN1-2 RXD CN1-3 GPIO2 CN1-4 GPIO0 CN1-5 GROUND CN1-6 VCC See Tasmota Hardware Prep for more details I removed all the crappy lead-free solder and put on a little strip of female pin header: Now I can easily hook it all up to the breadboard! I erased the firmware using the instructions using a Raspberry Pi 3 Model B. I couldn\u2019t get the board into programming mode by grounding the reset pin through the breadboard, so I just held the UP1 button while connecting 3V3 and it worked fine. There\u2019s another 4-wire connector that goes to the AC board. The wires are as follows: Wire Description Black 3.3v consistent, probably to power the other side Purple Variable voltage tied to dimmer. Low to high it\u2019s: 360mV, 680mV, 1.32V, 1.94V, 2.57V, 3.20V White GPIO16 Red Ground The other side features an STC15W404AS chip. This is the closest information sheet I\u2019ve found so far. It\u2019s likely there\u2019s an ADC receiver on the other side receiving our variable voltage on the purple wire above and converting that to the AC dimmer signal. When probing with the oscilloscope I noticed a 3.3v 1Khz square wave on GPIO13. It turns out this is the PWM that controls the output of the purple wire. This is done using the positive duty cycle of the wave. Here\u2019s a state table: Setting Duty 1 (Min Setting) 20% Duty 2 40% Duty 3 60% Duty 4 80% Duty 5 (Max Setting) 100% Duty, constant 3.3v We should be able to generate this same wave with whatever duty cycle we want in Tasmota to get much better dimming resolution than the default firmware provides. The buttons are tied as follows: Button Description UP1 GPIO0 to GROUND when pushed DOWN1 TXD to GROUND when pushed ON/OFF 3.3v to GPIO15 when pushed RESET Wired through an LED and resistor to GPIO16, also goes to white wire (RESET for the STC?), ties to GROUND The LEDs are wired as follows: LED Description LED1 Passthrough to RESET, GPIO16, see above. LED2 GPIO14 LED3 GPIO12 LED4 GPIO5 LED5 RXD FADE ON: Makes the PWM movements smooth DIMMER +/-: Moves dimmer up and down SPEED 3: Slows down fade a little SETOPTION15 1: Sets DIMMER mode rather than PWM Now that you can have rules set on dimmer actions, changing the LEDs with dimmer settings should be easy. I tried to do this before that existed, and it wasn't possible.","title":"Martin Jerry MJ SD01"},{"location":"devices/Martin-Jerry-MJ-SD01/#info-on-the-tuya","text":"The chip inside is a Tuya TYWE3S. It replicates the capabilities of an ESP8266 plus some other functionality. NOTE: THE RIGHT SIDE IS THE BACK OF THE BOARD. RST IS ON THE TOP LEFT OF THE LEFT PICTURE, AS WELL AS THE TOP LEFT OF THE PICTURE BELOW. Here\u2019s a picture of the chip inside the switch: Pin 1 is labeled M1 in the silkscreen of the switch board. Here\u2019s the back, I desoldered it with my Quick 861DW: On the other side of the board is an apparent test/programming header labeled CN1: From top to bottom on CN1 above, they are: Pin Signal CN1-1 TXD CN1-2 RXD CN1-3 GPIO2 CN1-4 GPIO0 CN1-5 GROUND CN1-6 VCC See Tasmota Hardware Prep for more details I removed all the crappy lead-free solder and put on a little strip of female pin header: Now I can easily hook it all up to the breadboard! I erased the firmware using the instructions using a Raspberry Pi 3 Model B. I couldn\u2019t get the board into programming mode by grounding the reset pin through the breadboard, so I just held the UP1 button while connecting 3V3 and it worked fine. There\u2019s another 4-wire connector that goes to the AC board. The wires are as follows: Wire Description Black 3.3v consistent, probably to power the other side Purple Variable voltage tied to dimmer. Low to high it\u2019s: 360mV, 680mV, 1.32V, 1.94V, 2.57V, 3.20V White GPIO16 Red Ground The other side features an STC15W404AS chip. This is the closest information sheet I\u2019ve found so far. It\u2019s likely there\u2019s an ADC receiver on the other side receiving our variable voltage on the purple wire above and converting that to the AC dimmer signal. When probing with the oscilloscope I noticed a 3.3v 1Khz square wave on GPIO13. It turns out this is the PWM that controls the output of the purple wire. This is done using the positive duty cycle of the wave. Here\u2019s a state table: Setting Duty 1 (Min Setting) 20% Duty 2 40% Duty 3 60% Duty 4 80% Duty 5 (Max Setting) 100% Duty, constant 3.3v We should be able to generate this same wave with whatever duty cycle we want in Tasmota to get much better dimming resolution than the default firmware provides. The buttons are tied as follows: Button Description UP1 GPIO0 to GROUND when pushed DOWN1 TXD to GROUND when pushed ON/OFF 3.3v to GPIO15 when pushed RESET Wired through an LED and resistor to GPIO16, also goes to white wire (RESET for the STC?), ties to GROUND The LEDs are wired as follows: LED Description LED1 Passthrough to RESET, GPIO16, see above. LED2 GPIO14 LED3 GPIO12 LED4 GPIO5 LED5 RXD FADE ON: Makes the PWM movements smooth DIMMER +/-: Moves dimmer up and down SPEED 3: Slows down fade a little SETOPTION15 1: Sets DIMMER mode rather than PWM Now that you can have rules set on dimmer actions, changing the LEDs with dimmer settings should be easy. I tried to do this before that existed, and it wasn't possible.","title":"Info on the Tuya"},{"location":"devices/Mirabella-Genio-Bulb/","text":"Mirabella Genio Bulb ~ Mirabella have released a few smart bulbs. Here is a bit of a guide on how to flash them with Tasmota. There are two ways: Over the Air (OTA) or via Serial. Flashing Over the Air ~ Flashing over the air requires running a linux shell script called tuya-convert and hence requires a computer (I used a Raspberry PI 3) with a wifi adaptor that supports AP mode. There are options if you run Windows to use either a virtual machine (it is reported that KALI Linux running on VMWare has worked) or potentially a live usb (I haven't tested it). Follow this procedure . To get the bulb into config mode, have the bulb on for at least 10 seconds, then cycle it off and on 3 times via a physical light switch. The bulb should flash rapidly when its in config mode. Tasmota v6.4.1 basic build is included as part of the tuya-convert script. It will open an WiFi access point named sonoff-XXX on the bulb once flashed correctly. Flashing via Serial ~ Flashing via Serial requires disassembling the bulb and soldiering wires to the board. Note: modifying these bulbs is dangerous if you do not understand what you are doing, please do so at your own risk! Mirabella Bulbs Disassembling bulb ~ The 2 main outer parts of the bulb are stuck together with high temp silicone or something similar. Squeeze the outer of the bulb (the bit that looks like glass) as near to the join as possible, you can use a tool like a spudger or something if that helps to break the seal, being careful not to damage any internal parts or cut yourself! Once the outer (fake glass) is removed you will see this: Carefully cut / scrape away as much of the sealent on the outer edge of the round circut board then using some needle nose pliers and your spudger pry the round board out. If you are really good at soldering and have a fine tip on your iron you could possibly skip this step and jump straight to the next one. B22 ~ Stand the bulb up and de-solder the 2 pads, and straighten the wires to remove the board. E27 ~ Using a sharp strong blade carefully pry out the small terminal on the end of the bulb then straighten the wire in side This will allow you to pull the board out a little and get enough angle on it to make soldering easier. You should now have these parts (E27 bulb will be still partly assembled): B22 ~ E27 ~ (with wires added) Connect FTDI ~ Connect your FTDI up to these pins: Flash with your preferred method I use this one (remember to connect GPIO0 to GND when plugging in your FTDI this will force the ESP into firmware write mode, you may need to try it a couple of times. Module Settings ~ Once flashed I use termite (or you could use any serial command tool) to send my settings: Note: Change these to match your environment Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; module 38;topic bulb1; FriendlyName Bulb1 Or set manually from the web interface: Dimmable warm white or cool white bulbs ~ Tunable warm/cool white bulbs ~ I based these settings on the RGBW settings. I would have thought PWM1-3 were redundant, but have only had it work with all of these assigned as per below. The bulb is then tunable, with a brightness slider and a cool/warm slider. Module type => Generic D2 GPIO4 => PWM1 (37) D1 GPIO5 => PWM4 (40) D6 GPIO12 => PWM2\ufffc (38) D7 GPIO13 => PWM5 (41) D5 GPIO14 => PWM3\ufffc (39) RGBW colour bulbs ~ Module type = Generic D2 GPIO4 = PWM1 37 = Red D6 GPIO12 = PWM2 38 = Green D5 GPIO14 = PWM3 39 = Blue D1 GPIO5 = PWM4 = White RGBW colour bulbs (12w version) ~ Newer versions operate under the SM2135 chipset. This can be confirmed when disassembled by inspecting the pins which connect the main board up to the LED board. They will be marked SDA1, CLK alongside the two other pins for the 12v and ground rails. These newer globes will require the following settings: * Module type = Generic * D5 GPIO14 = SM2135DAT (2) * D1 GPIO5 = SM2135CLK Re-assembly ~ Re-assembly procedure is the reverse of the disassemble procedure!","title":"Mirabella Genio Bulb"},{"location":"devices/Mirabella-Genio-Bulb/#mirabella-genio-bulb","text":"Mirabella have released a few smart bulbs. Here is a bit of a guide on how to flash them with Tasmota. There are two ways: Over the Air (OTA) or via Serial.","title":"Mirabella Genio Bulb"},{"location":"devices/Mirabella-Genio-Bulb/#flashing-over-the-air","text":"Flashing over the air requires running a linux shell script called tuya-convert and hence requires a computer (I used a Raspberry PI 3) with a wifi adaptor that supports AP mode. There are options if you run Windows to use either a virtual machine (it is reported that KALI Linux running on VMWare has worked) or potentially a live usb (I haven't tested it). Follow this procedure . To get the bulb into config mode, have the bulb on for at least 10 seconds, then cycle it off and on 3 times via a physical light switch. The bulb should flash rapidly when its in config mode. Tasmota v6.4.1 basic build is included as part of the tuya-convert script. It will open an WiFi access point named sonoff-XXX on the bulb once flashed correctly.","title":"Flashing Over the Air"},{"location":"devices/Mirabella-Genio-Bulb/#flashing-via-serial","text":"Flashing via Serial requires disassembling the bulb and soldiering wires to the board. Note: modifying these bulbs is dangerous if you do not understand what you are doing, please do so at your own risk! Mirabella Bulbs","title":"Flashing via Serial"},{"location":"devices/Mirabella-Genio-Bulb/#disassembling-bulb","text":"The 2 main outer parts of the bulb are stuck together with high temp silicone or something similar. Squeeze the outer of the bulb (the bit that looks like glass) as near to the join as possible, you can use a tool like a spudger or something if that helps to break the seal, being careful not to damage any internal parts or cut yourself! Once the outer (fake glass) is removed you will see this: Carefully cut / scrape away as much of the sealent on the outer edge of the round circut board then using some needle nose pliers and your spudger pry the round board out. If you are really good at soldering and have a fine tip on your iron you could possibly skip this step and jump straight to the next one.","title":"Disassembling bulb"},{"location":"devices/Mirabella-Genio-Bulb/#connect-ftdi","text":"Connect your FTDI up to these pins: Flash with your preferred method I use this one (remember to connect GPIO0 to GND when plugging in your FTDI this will force the ESP into firmware write mode, you may need to try it a couple of times.","title":"Connect FTDI"},{"location":"devices/Mirabella-Genio-Bulb/#module-settings","text":"Once flashed I use termite (or you could use any serial command tool) to send my settings: Note: Change these to match your environment Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; module 38;topic bulb1; FriendlyName Bulb1 Or set manually from the web interface:","title":"Module Settings"},{"location":"devices/Mirabella-Genio-Bulb/#dimmable-warm-white-or-cool-white-bulbs","text":"","title":"Dimmable warm white or cool white bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#tunable-warmcool-white-bulbs","text":"I based these settings on the RGBW settings. I would have thought PWM1-3 were redundant, but have only had it work with all of these assigned as per below. The bulb is then tunable, with a brightness slider and a cool/warm slider. Module type => Generic D2 GPIO4 => PWM1 (37) D1 GPIO5 => PWM4 (40) D6 GPIO12 => PWM2\ufffc (38) D7 GPIO13 => PWM5 (41) D5 GPIO14 => PWM3\ufffc (39)","title":"Tunable warm/cool white bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#rgbw-colour-bulbs","text":"Module type = Generic D2 GPIO4 = PWM1 37 = Red D6 GPIO12 = PWM2 38 = Green D5 GPIO14 = PWM3 39 = Blue D1 GPIO5 = PWM4 = White","title":"RGBW colour bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#rgbw-colour-bulbs-12w-version","text":"Newer versions operate under the SM2135 chipset. This can be confirmed when disassembled by inspecting the pins which connect the main board up to the LED board. They will be marked SDA1, CLK alongside the two other pins for the 12v and ground rails. These newer globes will require the following settings: * Module type = Generic * D5 GPIO14 = SM2135DAT (2) * D1 GPIO5 = SM2135CLK","title":"RGBW colour bulbs (12w version)"},{"location":"devices/Mirabella-Genio-Bulb/#re-assembly","text":"Re-assembly procedure is the reverse of the disassemble procedure!","title":"Re-assembly"},{"location":"devices/Mirabella-Genio-Smart-Plug/","text":"Mirabella Genio Smart Plug ~ This is a simple smart plug with the addition of a USB port, as far as I can see the USB port is 'always on' and is not access this from the ESP module. Opening up the device was easy, 2 screws then a small amount of gentle prying exposed the components, 2 more screws had it fully deconstructed. The ESP module is mounted on a pcb with all of the required pins exposed. I was able to flash by connecting GPIO0 to GND while connecting my Serial Adaptor and flashing as per any other ESP device Use the string below from the console of the device to configure everything (replace required data with your own SSID, Password, MQTT Settings etc.): Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17;topic genio1; FriendlyName Genio1 my prefered flashing method Once flashed, the config should look like:","title":"Mirabella Genio Smart Plug"},{"location":"devices/Mirabella-Genio-Smart-Plug/#mirabella-genio-smart-plug","text":"This is a simple smart plug with the addition of a USB port, as far as I can see the USB port is 'always on' and is not access this from the ESP module. Opening up the device was easy, 2 screws then a small amount of gentle prying exposed the components, 2 more screws had it fully deconstructed. The ESP module is mounted on a pcb with all of the required pins exposed. I was able to flash by connecting GPIO0 to GND while connecting my Serial Adaptor and flashing as per any other ESP device Use the string below from the console of the device to configure everything (replace required data with your own SSID, Password, MQTT Settings etc.): Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17;topic genio1; FriendlyName Genio1 my prefered flashing method Once flashed, the config should look like:","title":"Mirabella Genio Smart Plug"},{"location":"devices/Modify-KaKu-to-WKaKu-Power-Socket/","text":"The Dutch Klik Aan Klik Uit PAR-1000 434MHz Power socket might suffer from Capacitor degeneration. In effect the power needed to engage the relay is too low. Replacing the Yellow Capacitor often solves the problem. I have several of these lying around and they can be used very well with sonoff functionality. As the sonoff PCA is a bit too large I decided to design my own PCA using kicad. During Proof of Concept I used 5V power supplies from itead. After three units were built one crashed caused by debris on the PS PCA resulting in an AC short which in turn blew the large resistor. As the selected Songle relay has the control leads close to the AC leads I also changed the relay. I decided to select the HiLink 5V power supply as it was also favourable on other sites. The relay now has the same connections as the one used in sonoff. The parts used are: = HiLink 5V power supply HLK-PM01 (aliexpress) = 5V to 3V3 step down (aliexpress) = 5V relay OJE-SH-105DM (ebay) = ESP12-F (aliexpress) = Capacitors and led from kaku PCA = 2 x 1k and 1 x 10k Resistors The image on the right shows how I mounted the ESP12-F vertically. Notice the 10k resistor from GPIO15 to the board. The firmware used is sonoff without modification!","title":"Modify KaKu to WKaKu Power Socket"},{"location":"devices/NEO-COOLCAM-NAS-WR01W/","text":"I got NEO and managed install tasmota on it. https://www.amazon.de/dp/B07KJGHXCQ * IMPORTANT: * I checked PCB and it is not solid for long use and high power. All contact are very cheap, also there is no POW. I can recommend user other SmartPlug AISIRER, AVATAR (see on tasmota main page), 2 euro difference, but much more solid + onboard POW. All details are into Espurna page https://github.com/xoseperez/espurna/wiki/Hardware-NEO-COOLCAM-NAS-WR01W","title":"NEO COOLCAM NAS WR01W"},{"location":"devices/Nedis-WIFIP310FWT/","text":"ATTENTION! Verifying/updating this currently. This setup is not 100% accurate. 20190327 Template: {\"NAME\":\"Nedis WIFIP310\",\"GPIO\":[0,56,0,17,22,21,0,0,0,23,24,0,0],\"FLAG\":1,\"BASE\":18} Description: 3 port AC outlets (European Schucko Type F) + 4 USB power outlets Power input: 16 A - 230 VAC Max. Power: 3680 W Power output: USB: 5 VDC /2.4 A each Product page - Swedish Product page - English","title":"Nedis WIFIP310FWT"},{"location":"devices/Novostella-B22-RGB-LED-Colour-WiFi-Smart-Bulb/","text":"Novostella B22 RGB LED Colour WiFi Smart Bulb https://www.amazon.co.uk/gp/product/B07DN4NLKM?ref_=oh_aui_search_asin_title&psc=1&pldnSite=1 Easily flashed OTA. GPIO is as follows. GPIO4 = PWM1 GPIO5 = PWM5 GPIO12 = PWM2 GPIO13 = PWM4 GPIO14 = PWM3","title":"Novostella B22 RGB LED Colour WiFi Smart Bulb"},{"location":"devices/OBI-Socket-2/","text":"OBI Socket 2 ~ Supported since version 6.4.1.8 as OBI Socket 2 (61) Another cheap socket from the German Hardware Store, based on ESP-WROOM-02 with 2MB Flash. Smaller form factor as the first OBI Socket. \u26a0\ufe0f\ufe0f Special Attention \u26a0\ufe0f\ufe0f ~ DO NOT try to flash the module when it is connected to mains AC power. You WILL brick or destroy the device and your computer or USB Port and get electrocutes! Use only a 3.3V USB adapter for flashing DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The OBI Socket 2 has no transformer to isolate the mains voltage. The entire circuit is at mains-level voltage! Only use the device as designed. One way to flash the module is soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB has no serial pinout connector. For flashing the module enable the flash mode of the ESP, connect GPIO 0 to GND. Another way to flash is soldering 4 wires to the bottom side of the PCB as described on https://github.com/mattzzw/obi_socket/wiki/OBI-socket. If you follow that approach of powering the socket with 5V (which enables the relay coil allowing for acoustic feedback) you need to make sure to nevertheless use 3V3 for the actual serial interface to the module!!! This happens to work out very nicely with the popular cheap CH340 USB to Serial TTL adapters which come with a jumper to select between 5V and 3.3V. Setting the adapter to 3.3V by putting the jumper on the 3V3 and VCC pins leaves the 5V pin free. That pin is directly connected to the USB port. So you can just connect the four wires from the socket to the four free pins of the CH340 adapter :-) If you want the green Wi-Fi LED to work, please use version 6.4.1.8+. You can either use \"Obi Socket 2 Type (61)\" (with default behaviour \"Wi-Fi LED = off\" when connected) or use \"Generic (18)\" for manually override. See issue 4567 for details. PCB serial pinouts ~ PCB serial pinouts (back) ~ ( Note: Same PCB as OBI Socket IP44 (Black) )","title":"OBI Socket 2"},{"location":"devices/OBI-Socket-2/#obi-socket-2","text":"Supported since version 6.4.1.8 as OBI Socket 2 (61) Another cheap socket from the German Hardware Store, based on ESP-WROOM-02 with 2MB Flash. Smaller form factor as the first OBI Socket.","title":"OBI Socket 2"},{"location":"devices/OBI-Socket-2/#special-attention","text":"DO NOT try to flash the module when it is connected to mains AC power. You WILL brick or destroy the device and your computer or USB Port and get electrocutes! Use only a 3.3V USB adapter for flashing DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The OBI Socket 2 has no transformer to isolate the mains voltage. The entire circuit is at mains-level voltage! Only use the device as designed. One way to flash the module is soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB has no serial pinout connector. For flashing the module enable the flash mode of the ESP, connect GPIO 0 to GND. Another way to flash is soldering 4 wires to the bottom side of the PCB as described on https://github.com/mattzzw/obi_socket/wiki/OBI-socket. If you follow that approach of powering the socket with 5V (which enables the relay coil allowing for acoustic feedback) you need to make sure to nevertheless use 3V3 for the actual serial interface to the module!!! This happens to work out very nicely with the popular cheap CH340 USB to Serial TTL adapters which come with a jumper to select between 5V and 3.3V. Setting the adapter to 3.3V by putting the jumper on the 3V3 and VCC pins leaves the 5V pin free. That pin is directly connected to the USB port. So you can just connect the four wires from the socket to the four free pins of the CH340 adapter :-) If you want the green Wi-Fi LED to work, please use version 6.4.1.8+. You can either use \"Obi Socket 2 Type (61)\" (with default behaviour \"Wi-Fi LED = off\" when connected) or use \"Generic (18)\" for manually override. See issue 4567 for details.","title":"\u26a0\ufe0f\ufe0f  Special Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/OBI-Socket-2/#pcb-serial-pinouts","text":"","title":"PCB serial pinouts"},{"location":"devices/OBI-Socket-2/#pcb-serial-pinouts-back","text":"( Note: Same PCB as OBI Socket IP44 (Black) )","title":"PCB serial pinouts (back)"},{"location":"devices/OBI-WiFi-Socket-IP44/","text":"Overview ~ This WiFi socket is a cheap outdoor alternative to the popular low-cost indoor WiFi socket \"Wifi Stecker Schuko Wei\u00df\" from the German Diy-warehouse OBI. It is equipped with a ESP-WROOM-02 module. Sadly, there is no programming pin header and it can be kind of tricky to get the module into programming state (see below). You'll need some soldering skills to attach the programming wires. Where to buy ~ The Outdoor Wifi Socket is only available in the OBI Diy-Warehouse. It's \"official name\" is \"Wifi Stecker Schuko Schwarz\". It can also be bought in the OBI online-store Open the socket ~ Opening the socket is kind of difficult. The case is held together by two Tri-Wing screws, two tiny cross-head/PH screws, some sealing grease in the screw holes and some glue. First, you can remove the sealing grease out of the screw holes by using a matching drill. Drill out the sealing grease by turning it by hand, until you reach the screw head. After this, you can use the matching screw driver. The eventually remaining sealing grease will move aside. Tipp: Afterwards use normal cross screws to close the casing. After this its getting tricky: use a stable knife or a flat screw driver to carefully crack up the two halfs of the case. In any case, try to NOT cut up your hands! Connection ~ For convenient access to the programming pins, you can solder jump wires to the corresponding pads of the WROOM module. After successfully reprogramming the module, you can fold the wires into the socket in case of further tinkering. ( Note: Same PCB as OBI Socket 2 ! ) Entering programming mode ~ Connect GPIO0 to GND before connecting power to enable flash mode! GPIO Config ~","title":"OBI WiFi Socket IP44"},{"location":"devices/OBI-WiFi-Socket-IP44/#overview","text":"This WiFi socket is a cheap outdoor alternative to the popular low-cost indoor WiFi socket \"Wifi Stecker Schuko Wei\u00df\" from the German Diy-warehouse OBI. It is equipped with a ESP-WROOM-02 module. Sadly, there is no programming pin header and it can be kind of tricky to get the module into programming state (see below). You'll need some soldering skills to attach the programming wires.","title":"Overview"},{"location":"devices/OBI-WiFi-Socket-IP44/#where-to-buy","text":"The Outdoor Wifi Socket is only available in the OBI Diy-Warehouse. It's \"official name\" is \"Wifi Stecker Schuko Schwarz\". It can also be bought in the OBI online-store","title":"Where to buy"},{"location":"devices/OBI-WiFi-Socket-IP44/#open-the-socket","text":"Opening the socket is kind of difficult. The case is held together by two Tri-Wing screws, two tiny cross-head/PH screws, some sealing grease in the screw holes and some glue. First, you can remove the sealing grease out of the screw holes by using a matching drill. Drill out the sealing grease by turning it by hand, until you reach the screw head. After this, you can use the matching screw driver. The eventually remaining sealing grease will move aside. Tipp: Afterwards use normal cross screws to close the casing. After this its getting tricky: use a stable knife or a flat screw driver to carefully crack up the two halfs of the case. In any case, try to NOT cut up your hands!","title":"Open the socket"},{"location":"devices/OBI-WiFi-Socket-IP44/#connection","text":"For convenient access to the programming pins, you can solder jump wires to the corresponding pads of the WROOM module. After successfully reprogramming the module, you can fold the wires into the socket in case of further tinkering. ( Note: Same PCB as OBI Socket 2 ! )","title":"Connection"},{"location":"devices/OBI-WiFi-Socket-IP44/#entering-programming-mode","text":"Connect GPIO0 to GND before connecting power to enable flash mode!","title":"Entering programming mode"},{"location":"devices/OBI-WiFi-Socket-IP44/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/OBI-Wifi-Socket/","text":"Where to buy ~ As shown in the name the Wifi Socket is only available in the OBI Diy-Warehouse. It can also be bought in the OBI online-store Open the socket ~ Opening the socket is kind of difficult. If you have one of the Tri-Wing screwdrivers it is much more easier. If you haven't got use a normal head screwdriver. Be careful not damaging your hand with it. Tipp: Afterwards use normal cross screws to close the casing. Connection ~ ESP Programmer VCC 3V3 TX RX RX TX GND GND Connect GPIO0 to GND before connecting power to enable flash mode! Additional Information ~ A low pulse on GPIO12 switches the relay on, a low pulse on GPIO5 switches it off. I have solved the 'pulse issue' by setting GPIO12 to always 0 (as LED) and works fine. More Infos can be found here: #1988 . Initial Configuration ~ In the default configuration GPIO0 (which is also used to enable flash-mode) is setup as a Button. To enable AP-Mode and setup the correct GPIOs as described below, You can short GPIO0 to GND 4 times as if it was a button (see [[Button-usage]]) Using this method allows you to flash a precompiled binary Device Images ~ (images from https://github.com/martin-ger/ESP8266-WiFi-Socket) GPIO Config ~ UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for OBI Power Socket (#1988, #3944)) ** Beginning 6.3.0, no need to choose type 18 anymore, use type 51 Obi Socket *","title":"OBI Wifi Socket"},{"location":"devices/OBI-Wifi-Socket/#where-to-buy","text":"As shown in the name the Wifi Socket is only available in the OBI Diy-Warehouse. It can also be bought in the OBI online-store","title":"Where to buy"},{"location":"devices/OBI-Wifi-Socket/#open-the-socket","text":"Opening the socket is kind of difficult. If you have one of the Tri-Wing screwdrivers it is much more easier. If you haven't got use a normal head screwdriver. Be careful not damaging your hand with it. Tipp: Afterwards use normal cross screws to close the casing.","title":"Open the socket"},{"location":"devices/OBI-Wifi-Socket/#connection","text":"ESP Programmer VCC 3V3 TX RX RX TX GND GND Connect GPIO0 to GND before connecting power to enable flash mode!","title":"Connection"},{"location":"devices/OBI-Wifi-Socket/#additional-information","text":"A low pulse on GPIO12 switches the relay on, a low pulse on GPIO5 switches it off. I have solved the 'pulse issue' by setting GPIO12 to always 0 (as LED) and works fine. More Infos can be found here: #1988 .","title":"Additional Information"},{"location":"devices/OBI-Wifi-Socket/#initial-configuration","text":"In the default configuration GPIO0 (which is also used to enable flash-mode) is setup as a Button. To enable AP-Mode and setup the correct GPIOs as described below, You can short GPIO0 to GND 4 times as if it was a button (see [[Button-usage]]) Using this method allows you to flash a precompiled binary","title":"Initial Configuration"},{"location":"devices/OBI-Wifi-Socket/#device-images","text":"(images from https://github.com/martin-ger/ESP8266-WiFi-Socket)","title":"Device Images"},{"location":"devices/OBI-Wifi-Socket/#gpio-config","text":"UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for OBI Power Socket (#1988, #3944)) ** Beginning 6.3.0, no need to choose type 18 anymore, use type 51 Obi Socket *","title":"GPIO Config"},{"location":"devices/Oittm-Smart-Plug/","text":"Oittm Smart Plug ~ Oittm provides a relatively cheap Wifi smart plug with an ESP8266, too. To enable the flash mode of the ESP connect GPIO 0 to GND. The wires have to be soldered directly onto the ESP chip itself, it won't work otherwise. Opening the device ~ Remove the small plastics caps on the back and unscrew the first two screws and then again the next ones PCB layout ~ !!Make sure to flash with 3.3V and disconnect the power plug from the power outlet before!! Web configuration ~ If you want the blue LED instead of the red one, use Led2i ~","title":"Oittm Smart Plug"},{"location":"devices/Oittm-Smart-Plug/#oittm-smart-plug","text":"Oittm provides a relatively cheap Wifi smart plug with an ESP8266, too. To enable the flash mode of the ESP connect GPIO 0 to GND. The wires have to be soldered directly onto the ESP chip itself, it won't work otherwise.","title":"Oittm Smart Plug"},{"location":"devices/Oittm-Smart-Plug/#opening-the-device","text":"Remove the small plastics caps on the back and unscrew the first two screws and then again the next ones","title":"Opening the device"},{"location":"devices/Oittm-Smart-Plug/#pcb-layout","text":"!!Make sure to flash with 3.3V and disconnect the power plug from the power outlet before!!","title":"PCB layout"},{"location":"devices/Oittm-Smart-Plug/#web-configuration","text":"","title":"Web configuration"},{"location":"devices/Other-Devices/","text":"This page is here for archival purposes. For new devices use Tasmota Supported Devices Repository ! New submissions here will not be approved. ~ Relays/Sonoff Basic Clones ~ WL-SW01_10 WiFi Smart Switch - Sonoff Basic in a different form factor Canwing CW001 5A LC Technology WiFi Relay EXS Relay V3.1 & V5.1 Ledunia and NodeMcu Plugs/Sockets ~ Lingan SWA1 Hyleton 313 Smart Plug Teckin SP23 LA-WF3 Wifi Plug (Tuya TYWE2S) - Costco No-Brand Smart Plug with Tuya-based ESP8266MOD and ESP-12F modules WiOn 50055 Indoor Wi-Fi Switch With USB (support for relay and switch only - no power monitoring yet. See status here #82 .) SM-SO301 4 mains Power Strip with 4 USB ports LeFun SK2 Smart Power Strip with 4 Mains + 4 USB meross MSS425 Smart Power Strip Gosund SP1 SWB1 Wi-Fi Smart Power Strip Kesen KS-604S Dual Outlet Oittm Smart Plug Mirabella Genio Smart Plug CE Smart Home\u2122 Garden Power Stake 4CH-Wifi-Socket-with-USB-Charger (Tuya TYWE2S) Anoopsyche JH-G01B1 RGB Smart Socket with Power Monitor 16A EU Supernight Dual Wifi Plug TMRLife Plug or Home Awesome Plug SmartPlug AISIRER, AVATAR with POW SmartPlug NEO COOLCAM NAS WR01W Slitinto NX SP202 Wall Switches/Dimmers ~ KS-602 based switches like GresaTek, Jesiya, NewRice, Lyasi etc Smart Light Switch - SS118-01K1 KMC 70008 Light Switch KS-602S Smart Wifi Light Switch Xenon SM-SW102-2 two-relay light switch Martin Jerry MJ-SD01 Smart Dimmer KingArt N1 - Other Sonoff T1 clone, flash works also on KingArt N2 (2 gangs) KingArt Dimmer Same as above, but a dimmer Lights/LED Controllers ~ SP108E LED strip controller WS03 LED Controller Luminea-ZX-2844-675 Mirabella Genio Smart Bulb Kohree VHP560 Smart Light Compatible, RGBCW Wi-Fi LED Bulb A19 Novostella B22 RGBW Smart Light Xiaomi Mi Desk Lamp Out of production devices ~ ITead Motor Clockwise/ Anticlockwise Running WiFi Wireless Switch PowStro - Sonoff Basic clone SmartHome - Sonoff Basic clone YUNTONG Smart - Sonoff Basic clone CSL (aplic WDP 303075) SM-PW701E Socket Board: (Tuya TYWE3S) WK30 (Tuya TYWE3S) Hompie-SWS1 (Tuya TYWE3S) Burnett BN K01 Smart Socket CNSKOU / CNSANKOU wall switches - Chinese Sonoff T1 clones","title":"Other Devices"},{"location":"devices/Other-Devices/#this-page-is-here-for-archival-purposes-for-new-devices-use-tasmota-supported-devices-repository-new-submissions-here-will-not-be-approved","text":"","title":"This page is here for archival purposes. For new devices use Tasmota Supported Devices Repository! New submissions here will not be approved."},{"location":"devices/Other-Devices/#relayssonoff-basic-clones","text":"WL-SW01_10 WiFi Smart Switch - Sonoff Basic in a different form factor Canwing CW001 5A LC Technology WiFi Relay EXS Relay V3.1 & V5.1 Ledunia and NodeMcu","title":"Relays/Sonoff Basic Clones"},{"location":"devices/Other-Devices/#plugssockets","text":"Lingan SWA1 Hyleton 313 Smart Plug Teckin SP23 LA-WF3 Wifi Plug (Tuya TYWE2S) - Costco No-Brand Smart Plug with Tuya-based ESP8266MOD and ESP-12F modules WiOn 50055 Indoor Wi-Fi Switch With USB (support for relay and switch only - no power monitoring yet. See status here #82 .) SM-SO301 4 mains Power Strip with 4 USB ports LeFun SK2 Smart Power Strip with 4 Mains + 4 USB meross MSS425 Smart Power Strip Gosund SP1 SWB1 Wi-Fi Smart Power Strip Kesen KS-604S Dual Outlet Oittm Smart Plug Mirabella Genio Smart Plug CE Smart Home\u2122 Garden Power Stake 4CH-Wifi-Socket-with-USB-Charger (Tuya TYWE2S) Anoopsyche JH-G01B1 RGB Smart Socket with Power Monitor 16A EU Supernight Dual Wifi Plug TMRLife Plug or Home Awesome Plug SmartPlug AISIRER, AVATAR with POW SmartPlug NEO COOLCAM NAS WR01W Slitinto NX SP202","title":"Plugs/Sockets"},{"location":"devices/Other-Devices/#wall-switchesdimmers","text":"KS-602 based switches like GresaTek, Jesiya, NewRice, Lyasi etc Smart Light Switch - SS118-01K1 KMC 70008 Light Switch KS-602S Smart Wifi Light Switch Xenon SM-SW102-2 two-relay light switch Martin Jerry MJ-SD01 Smart Dimmer KingArt N1 - Other Sonoff T1 clone, flash works also on KingArt N2 (2 gangs) KingArt Dimmer Same as above, but a dimmer","title":"Wall Switches/Dimmers"},{"location":"devices/Other-Devices/#lightsled-controllers","text":"SP108E LED strip controller WS03 LED Controller Luminea-ZX-2844-675 Mirabella Genio Smart Bulb Kohree VHP560 Smart Light Compatible, RGBCW Wi-Fi LED Bulb A19 Novostella B22 RGBW Smart Light Xiaomi Mi Desk Lamp","title":"Lights/LED Controllers"},{"location":"devices/Other-Devices/#out-of-production-devices","text":"ITead Motor Clockwise/ Anticlockwise Running WiFi Wireless Switch PowStro - Sonoff Basic clone SmartHome - Sonoff Basic clone YUNTONG Smart - Sonoff Basic clone CSL (aplic WDP 303075) SM-PW701E Socket Board: (Tuya TYWE3S) WK30 (Tuya TYWE3S) Hompie-SWS1 (Tuya TYWE3S) Burnett BN K01 Smart Socket CNSKOU / CNSANKOU wall switches - Chinese Sonoff T1 clones","title":"Out of production devices"},{"location":"devices/PS-16-DZ-Dimmer/","text":"PS-16-DZ Dimmer ~ The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ. Pics ~ Opened it up, found a ESP8285 and a Nuvoton N76E003. Flash and GPIO pins ~ Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND Communication between ESP8285 and N76E003 ~ It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266: Send from ESP8266 AT+UPDATE=\"sequence\":\"1528335040032\",\"switch\":\"on\" Receive from MCU AT+RESULT=\"sequence\":1528335040032\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn off the switch from ESP8266: Send from ESP8266 AT+UPDATE=\"sequence\":\"1528335118327\",\"switch\":\"off\" Receive from MCU AT+RESULT=\"sequence\":1528335118327\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Change brightness to 44 from ESP8266: Send from ESP8266: AT+UPDATE=\"sequence\":\"1528335181502\",\"bright\":44 Receive from MCU AT+RESULT=\"sequence\":1528335181502\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn on the switch with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn off the switch with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"off\",\"bright\":44 Send from ESP8266: AT+SEND=ok Change the brightness to 52 with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":52 Send from ESP8266: AT+SEND=ok Holding the middle button on faceplate to reset the device: Received from MCU AT+SETTING=enterESPTOUCH Send from ESP8266: AT+SETTING=enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"PS-16-DZ Dimmer"},{"location":"devices/PS-16-DZ-Dimmer/#ps-16-dz-dimmer","text":"The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ.","title":"PS-16-DZ Dimmer"},{"location":"devices/PS-16-DZ-Dimmer/#pics","text":"Opened it up, found a ESP8285 and a Nuvoton N76E003.","title":"Pics"},{"location":"devices/PS-16-DZ-Dimmer/#flash-and-gpio-pins","text":"Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND","title":"Flash and GPIO pins"},{"location":"devices/PS-16-DZ-Dimmer/#communication-between-esp8285-and-n76e003","text":"It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266: Send from ESP8266 AT+UPDATE=\"sequence\":\"1528335040032\",\"switch\":\"on\" Receive from MCU AT+RESULT=\"sequence\":1528335040032\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn off the switch from ESP8266: Send from ESP8266 AT+UPDATE=\"sequence\":\"1528335118327\",\"switch\":\"off\" Receive from MCU AT+RESULT=\"sequence\":1528335118327\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Change brightness to 44 from ESP8266: Send from ESP8266: AT+UPDATE=\"sequence\":\"1528335181502\",\"bright\":44 Receive from MCU AT+RESULT=\"sequence\":1528335181502\" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn on the switch with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":44 Send from ESP8266: AT+SEND=ok Turn off the switch with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"off\",\"bright\":44 Send from ESP8266: AT+SEND=ok Change the brightness to 52 with faceplate button: Received from MCU AT+UPDATE=\"switch\":\"on\",\"bright\":52 Send from ESP8266: AT+SEND=ok Holding the middle button on faceplate to reset the device: Received from MCU AT+SETTING=enterESPTOUCH Send from ESP8266: AT+SETTING=enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"Communication between ESP8285 and N76E003"},{"location":"devices/PowStro/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ PowStro are fake Sonoff Basic, but they still work with Tasmota. More Infos can be found here: #1419 . Device Images ~ GPIO Config ~","title":"PowStro"},{"location":"devices/PowStro/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/PowStro/#additional-information","text":"PowStro are fake Sonoff Basic, but they still work with Tasmota. More Infos can be found here: #1419 .","title":"Additional Information"},{"location":"devices/PowStro/#device-images","text":"","title":"Device Images"},{"location":"devices/PowStro/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/RGB-Smart-Plug-16A/","text":"* Aliexpress: Lonsonho Wifi Smart Socket Power Monitor EU 2 Pin * Aliexpress: RGB Smart Plug * amazon.de: Smart Steckdose, Wechsellicht 16A, WLAN Steckdose Wifi Stecker fernbedienbar, Stromverbrauch messen, funktioniert mit Alexa [Echo, Echo Dot] und Google Home, 4 Packs OTA flashing ~ DEVICE IS DIFFICULT TO DISASSEMBLE SO ANY ERRORS WITH FLASHING OR CONFIGURATION CAN EASILY BRICK IT. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Device case is glued so recommended way to flash it is using tuya-convert This method worked for 3 devices that were shipped before December 2019, never paired with Tuya apps and never powered on near open WiFi APs. So they had no chance to download Tuya-Convert updates. It may not work for devices with newer firmware. Prerequisites ~ You'll need a Linux device with both WiFi capable of running in AP mode and ethernet connection Clone/download tuya-convert Run install_prereq.sh Ubuntu only ~ On Ubuntu, it's also necessary to temporary disable WiFi from Network Manager and stop/disable systemd-resolved. Edit /etc/NetworkManager/NetworkManager.conf and add [keyfile] unmanaged-devices=interface-name:wlp2s0 Replace wlp2s0 with your WiFi interface name if neccessary. Then run sudo systemctl restart network-manager.service sudo systemctl disable systemd-resolved.service sudo systemctl stop systemd-resolved.service Don't forget to undo everything after flashing, DNS and WiFi won't work otherwise. Start flashing ~ Run start_flash.sh and follow the instructions Connect any WiFi device to vtrust-flash AP when it asks to and make sure that it gets an IP address. If it doesn't stop and check logs in scripts folder for clues Connect socket to mains and long-press the button to enter pairing mode Tasmota is included with tuya-convert, follow script's instruction to flash it After flashing device should reboot and you should see Tasmota's WiFi AP (Sonoff-xxx). Run stop_flash.sh to shutdown vtrust-flash AP on a machine you used for OTA. Configuration ~ Connect to Tasmota's AP It's extremely important to enter correct WiFi configuration. Button is not on GPIO0 so won't do anything for default Sonoff Basic device profile. It's recommended to temporary enter second WiFi with something easy like SSID: TEST Password: testtest so you could start that AP and re-configure the device if there are any issues with main WiFi connection. After it reboots and successfully connects to WiFi configure it as Blizwolf SHP module Now button and relay should work. Red and Blue LEDs will be used as status LEDs. RGB Light ~ Use this template to configure the device: {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} For older versions: Complete RGB support requires building slightly custom Tasmota. Edit sonoff/sonoff_template.h and replace \"BlitzWolf SHP\" configuration with the following: { \"BlitzWolf SHP\", // BlitzWolf BW-SHP2 and BW-SHP6 (ESP8285 - BL0937 or HJL-01 Energy Monitoring) // https://www.banggood.com/BlitzWolf-BW-SHP2-Smart-WIFI-Socket-EU-Plug-220V-16A-Work-with-Amazon-Alexa-Google-Assistant-p-1292899.html // https://www.amazon.de/Steckdose-Homecube-intelligente-Verbrauchsanzeige-funktioniert/dp/B076Q2LKHG/ref=sr_1_fkmr0_1 // https://www.amazon.de/Intelligente-Stromverbrauch-Fernsteurung-Schaltbare-Energieklasse/dp/B076WZQS4S/ref=sr_1_1 // https://www.aliexpress.com/store/product/BlitzWolf-BW-SHP6-EU-Plug-Metering-Version-WIFI-Smart-Socket-220V-240V-10A-Work-with-Amazon/1965360_32945504669.html GPIO_USER, // GPIO00 Red Led (1 = On, 0 = Off) GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_USER, // GPIO02 Blue Led (1 = On, 0 = Off) GPIO_USER, // GPIO03 Serial TXD and Optional sensor GPIO_USER, // GPIO04 GPIO_HJL_CF, // GPIO05 BL0937 or HJL-01 CF power 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 BL0937 or HJL-01 Sel output (0 = Voltage) GPIO_KEY1, // GPIO13 Button GPIO_NRG_CF1, // GPIO14 BL0937 or HJL-01 CF1 current / voltage GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }, Make sure that you don't have wrong WiFi configuration in user_config_override.h. Build and OTA flash it to the device using Tasmota. After it reboots configure as following: [[https://raw.githubusercontent.com/wiki/Astr0/Sonoff-Tasmota/images/lonsonho16a/config.png|Configuration]] RGB and dimming should work now. Disassembling the device ~ This is not recommended. Do it only if you have to or just buy a new one. The device is hard to open and may be damaged. Components inside may have mains charge and electrocute you even if powered off. Do it at your own risk. One of my devices had a hardware issue - constantly losing WiFi, rebooted when wiggled in power socket, rebooted every few seconds on 1250W load, sometimes just hanged and not responded even to the button. Since it wasn't usable at all I tried to fix it. The reason was broken steel input pole inside(what?? how?? WTF??) that was making weak contact, couldn't fix it reliably. Unbend earth connections on the bottom to make them straight. Use a sharp knife to slice through glue between RGB ring and the case. Requires quite a lot of force and time. RGB ring may break in places where glue is stronger than the plastic. Use a screwdriver to pry the case open. Remove button cap Desolder output connections, try not to melt any plastic. Remove support plastic with a screwdriver, it's held to the PCB by two clips. Desolder input poles. This is tricky since there's a lot of solder. I've removed as much of it as possible with desoldering pump, then melted the solder and rotated the poles with pliers while it cooled. Poles are made of steel and steel don't accept solder well. Remove the PCB by lifting it up. It's glued to the case on the bottom by the relay and held tight with input poles so it requires some force. Also, it's not easy to grab the PCB. I've used dip removing tweezers, holding PCB by holes for the earth connectors. I figured out the pinout for flashing the device: Before assembling it back remove as much solder as possible from input and output pole pads. The device fits together very tight, so everything should be perfectly in place. Don't forget to glue the case back. Alternative to disasselmy: Drilling two holes. ~ _With all this information at hand it is also possible to drill two simple holes into the case to get to the necesarry contact pads. I recommend a 6mm drill, carfully drill trough the case at he center of the ledge from the high power side opposite the power button. See pictures. Now you can solder on a few temporary flash cables. Don't forget to pull IO0 to GND to get into flash mode. Few observations: * It has ESP8266EX with FM25F08 8Mbit flash. The module has lots of connections, some of them have only pads without tracks on the main board. High chances to find RX and TX there. Obviously, there should be VCC and GND to power up the module. * Uses HJL-01 with a shunt for power monitoring, so every mains power track that looks like it should be covered with solder but is not, probably should be covered with solder :) * It has 4 RGB LEDs. GPIO00-Red, GPIO02-Blue, GPIO04-Green * AFE BPD-SS-105DM 16A 250VAC relay * 16A SMD fuse for mains input * Something that's probably another fuse marked F1 for low-voltage circuitry power * Low-voltage part is not galvanically insulated from mains * There's \"QC Passed\" sticker on the relay","title":"RGB Smart Plug 16A"},{"location":"devices/RGB-Smart-Plug-16A/#ota-flashing","text":"DEVICE IS DIFFICULT TO DISASSEMBLE SO ANY ERRORS WITH FLASHING OR CONFIGURATION CAN EASILY BRICK IT. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Device case is glued so recommended way to flash it is using tuya-convert This method worked for 3 devices that were shipped before December 2019, never paired with Tuya apps and never powered on near open WiFi APs. So they had no chance to download Tuya-Convert updates. It may not work for devices with newer firmware.","title":"OTA flashing"},{"location":"devices/RGB-Smart-Plug-16A/#prerequisites","text":"You'll need a Linux device with both WiFi capable of running in AP mode and ethernet connection Clone/download tuya-convert Run install_prereq.sh","title":"Prerequisites"},{"location":"devices/RGB-Smart-Plug-16A/#start-flashing","text":"Run start_flash.sh and follow the instructions Connect any WiFi device to vtrust-flash AP when it asks to and make sure that it gets an IP address. If it doesn't stop and check logs in scripts folder for clues Connect socket to mains and long-press the button to enter pairing mode Tasmota is included with tuya-convert, follow script's instruction to flash it After flashing device should reboot and you should see Tasmota's WiFi AP (Sonoff-xxx). Run stop_flash.sh to shutdown vtrust-flash AP on a machine you used for OTA.","title":"Start flashing"},{"location":"devices/RGB-Smart-Plug-16A/#configuration","text":"Connect to Tasmota's AP It's extremely important to enter correct WiFi configuration. Button is not on GPIO0 so won't do anything for default Sonoff Basic device profile. It's recommended to temporary enter second WiFi with something easy like SSID: TEST Password: testtest so you could start that AP and re-configure the device if there are any issues with main WiFi connection. After it reboots and successfully connects to WiFi configure it as Blizwolf SHP module Now button and relay should work. Red and Blue LEDs will be used as status LEDs.","title":"Configuration"},{"location":"devices/RGB-Smart-Plug-16A/#rgb-light","text":"Use this template to configure the device: {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} For older versions: Complete RGB support requires building slightly custom Tasmota. Edit sonoff/sonoff_template.h and replace \"BlitzWolf SHP\" configuration with the following: { \"BlitzWolf SHP\", // BlitzWolf BW-SHP2 and BW-SHP6 (ESP8285 - BL0937 or HJL-01 Energy Monitoring) // https://www.banggood.com/BlitzWolf-BW-SHP2-Smart-WIFI-Socket-EU-Plug-220V-16A-Work-with-Amazon-Alexa-Google-Assistant-p-1292899.html // https://www.amazon.de/Steckdose-Homecube-intelligente-Verbrauchsanzeige-funktioniert/dp/B076Q2LKHG/ref=sr_1_fkmr0_1 // https://www.amazon.de/Intelligente-Stromverbrauch-Fernsteurung-Schaltbare-Energieklasse/dp/B076WZQS4S/ref=sr_1_1 // https://www.aliexpress.com/store/product/BlitzWolf-BW-SHP6-EU-Plug-Metering-Version-WIFI-Smart-Socket-220V-240V-10A-Work-with-Amazon/1965360_32945504669.html GPIO_USER, // GPIO00 Red Led (1 = On, 0 = Off) GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_USER, // GPIO02 Blue Led (1 = On, 0 = Off) GPIO_USER, // GPIO03 Serial TXD and Optional sensor GPIO_USER, // GPIO04 GPIO_HJL_CF, // GPIO05 BL0937 or HJL-01 CF power 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 BL0937 or HJL-01 Sel output (0 = Voltage) GPIO_KEY1, // GPIO13 Button GPIO_NRG_CF1, // GPIO14 BL0937 or HJL-01 CF1 current / voltage GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }, Make sure that you don't have wrong WiFi configuration in user_config_override.h. Build and OTA flash it to the device using Tasmota. After it reboots configure as following: [[https://raw.githubusercontent.com/wiki/Astr0/Sonoff-Tasmota/images/lonsonho16a/config.png|Configuration]] RGB and dimming should work now.","title":"RGB Light"},{"location":"devices/RGB-Smart-Plug-16A/#disassembling-the-device","text":"This is not recommended. Do it only if you have to or just buy a new one. The device is hard to open and may be damaged. Components inside may have mains charge and electrocute you even if powered off. Do it at your own risk. One of my devices had a hardware issue - constantly losing WiFi, rebooted when wiggled in power socket, rebooted every few seconds on 1250W load, sometimes just hanged and not responded even to the button. Since it wasn't usable at all I tried to fix it. The reason was broken steel input pole inside(what?? how?? WTF??) that was making weak contact, couldn't fix it reliably. Unbend earth connections on the bottom to make them straight. Use a sharp knife to slice through glue between RGB ring and the case. Requires quite a lot of force and time. RGB ring may break in places where glue is stronger than the plastic. Use a screwdriver to pry the case open. Remove button cap Desolder output connections, try not to melt any plastic. Remove support plastic with a screwdriver, it's held to the PCB by two clips. Desolder input poles. This is tricky since there's a lot of solder. I've removed as much of it as possible with desoldering pump, then melted the solder and rotated the poles with pliers while it cooled. Poles are made of steel and steel don't accept solder well. Remove the PCB by lifting it up. It's glued to the case on the bottom by the relay and held tight with input poles so it requires some force. Also, it's not easy to grab the PCB. I've used dip removing tweezers, holding PCB by holes for the earth connectors. I figured out the pinout for flashing the device: Before assembling it back remove as much solder as possible from input and output pole pads. The device fits together very tight, so everything should be perfectly in place. Don't forget to glue the case back.","title":"Disassembling the device"},{"location":"devices/RGB-Smart-Plug-16A/#alternative-to-disasselmy-drilling-two-holes","text":"_With all this information at hand it is also possible to drill two simple holes into the case to get to the necesarry contact pads. I recommend a 6mm drill, carfully drill trough the case at he center of the ledge from the high power side opposite the power button. See pictures. Now you can solder on a few temporary flash cables. Don't forget to pull IO0 to GND to get into flash mode. Few observations: * It has ESP8266EX with FM25F08 8Mbit flash. The module has lots of connections, some of them have only pads without tracks on the main board. High chances to find RX and TX there. Obviously, there should be VCC and GND to power up the module. * Uses HJL-01 with a shunt for power monitoring, so every mains power track that looks like it should be covered with solder but is not, probably should be covered with solder :) * It has 4 RGB LEDs. GPIO00-Red, GPIO02-Blue, GPIO04-Green * AFE BPD-SS-105DM 16A 250VAC relay * 16A SMD fuse for mains input * Something that's probably another fuse marked F1 for low-voltage circuitry power * Low-voltage part is not galvanically insulated from mains * There's \"QC Passed\" sticker on the relay","title":"Alternative to disasselmy: Drilling two holes."},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/","text":"Model ~ There's no brand on this one, I got it for 11\u20ac on ebay as \"Wifi Smart Sans Fil T\u00e9l\u00e9commande Prise de Courant Pour T\u00e9l\u00e9phone Prise EU Plug\" from this seller . Flashing ~ As chipset is a TYWE2S , you'll have to connect GPIO0 (marked IO0) manually to the ground. There's better images than mines here and here on the wiki. Configuration ~ GPIO5: Relay1 (21) GPIO12: Led1 (52) GPIO14: Button1 (17)","title":"S1 Series   Wifi Socket S120 (EU model) chipset TYWE2S"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#model","text":"There's no brand on this one, I got it for 11\u20ac on ebay as \"Wifi Smart Sans Fil T\u00e9l\u00e9commande Prise de Courant Pour T\u00e9l\u00e9phone Prise EU Plug\" from this seller .","title":"Model"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#flashing","text":"As chipset is a TYWE2S , you'll have to connect GPIO0 (marked IO0) manually to the ground. There's better images than mines here and here on the wiki.","title":"Flashing"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#configuration","text":"GPIO5: Relay1 (21) GPIO12: Led1 (52) GPIO14: Button1 (17)","title":"Configuration"},{"location":"devices/SK03-Outdoor-Smart-Plug/","text":"SK03 Outdoor Smart Plug which can be found as different brand names on Amazon. The ESP8266 module inside is a TYWE3S by Tuya. The power monitoring is a HLW8012 much like the original Sonoff POW and other power monitoring modules. Pull the four rubber pads off the bottom to expose the screws and the unit opens up. Unscrew the small screws from the board and it comes out of the case. The relay is close to the soldering points on the Tuya module but it can be done if you are careful. GPIO0 is the button on the underside so you do not need to solder to that point, just hold the button during boot for your flashing process like you would with a Sonoff Basic. digiblurDIY did a livestream showing this device, soldering and flashing process (split in two videos): https://www.youtube.com/watch?v=C5_BqptJA_w and https://www.youtube.com/watch?v=ca7P9TR9r68 As of firmware 6.3.0.11, the SK03 is available for use in the module configuration. Information regarding the standard soldering and pinouts for the TYWE3S module: { \"SK03 Outdoor\", // Outdoor smart plug with power monitoring HLW8012 chip - https://www.amazon.com/gp/product/B07CG7MBPV GPIO_KEY1, // GPIO00 Button 0, 0, 0, GPIO_HLW_CF, // GPIO04 HLW8012 CF power GPIO_NRG_CF1, // GPIO05 HLW8012 CF1 current / voltage 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 HLW8012 CF Sel output (0 = Voltage) GPIO_LED2_INV, // GPIO13 Red Led (0 = On, 1 = Off) GPIO_LED1_INV, // GPIO14 Blue Led (0 = On, 1 = Off) GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }","title":"SK03 Outdoor Smart Plug"},{"location":"devices/SM-SO301/","text":"SM-SO301 with an FCC ID of 2AJ5F-SM-SO3015 has 4 mains power and 4 USB ports. Each mains power is independently controlled and the USB group is controllable via a solid state relay. The ESP8266 module inside is a TYWE3S by Tuya. Model purchased SM-SO301 (it seems to change on Amazon and other places, search for the model#). Other resellers may sell the same unit with various mains voltages/plug types. Also sold under the Vivitar name model HA-1007-ACD (US version). There is also an HA-1007-AU (AUS version). Product ~ Flashing and Configuration Pictures ~ Hold/Attach the GPIO0 wire/pin to ground during initial boot to flash. (TX pin to RX pin and RX pin to TX pin on USB flash adapter)","title":"SM SO301"},{"location":"devices/SM-SO301/#product","text":"","title":"Product"},{"location":"devices/SM-SO301/#flashing-and-configuration-pictures","text":"Hold/Attach the GPIO0 wire/pin to ground during initial boot to flash. (TX pin to RX pin and RX pin to TX pin on USB flash adapter)","title":"Flashing and Configuration Pictures"},{"location":"devices/SP108E-HardwareAnalysis/","text":"So far I analyzed it is equipped with these chips: ESP-12F STM32F-030C8T (Cortex M0) Winbond 25Q32 (EEPROM) 74HC245 XL1509 3.3E1 (Step down regulator) RX/TX of STM is connected to ESP. 74HC245 buffers the outputs ESP is connected to the STM RX/TX pins. No other connections seen. We can assume there is some firmware in the STM that does the low level connection to the LEDs. Question is how does the ESP communicate with the STM and what exactly does the STM at all. But we can mod the hardware so the ESP can talk to the LEDs. I made some pictures with phone and microscope. PCB Open the housing, see the red marks for the holders) RX/TX connection ESP to STM STM32F0 EEPROM Pins lead to the STM32F0 (Firmware flash? Debug?) ESP-12 and its pins Buffer chip 74HC245 Traces on bottom side from STM to HC245 (actually R3 and R4) Known differences to the 2nd gen The following picture shows the pcb of the 2nd generation of the SP108E. The ESP12F was replaced to a proprietary ESP8285 pcb. Fortunately the pinout is printed on the back of the pcb so we can use it to connect the cables for flashing. As the pcb were already soldered out for taking the following picture it was flashed in this unmounted state. It should work as well while the ESP is soldered. Pay attention to the information below. The STM32F0 was replaced through a Geehy APM32F030C8T6 ARM-Cortex M0 microcontroller. At least the reset pin is at the same place. So the hardware modification of the first gen can also be applied. For the hardware mod to make it working without the STM32F0/Geehy, there are several ways: 1. Cut traces and add wires ~ We need to break one of the traces on the bottom of the PCB. Then connect GPIO4 of ESP-12 with R4. Also RX/TX connection between STM32F0 and ESP-12 need to be broken up. 2. Hold STM32F0 in reset ~ This is the simpler method, no cuts on the PCB required, just two additional wires. - NRST of STM32F0 to GND - IO4 of ESP-12 to R4 See here for details. Flashing prohibited (not anymore with a cut in the PCB) ~ Major problem is that IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. This is for the older rev of the PCB and showing the same physical device seen in my very first posts a few years ago. After removing the ESP-12, the trace was visible and now it is easy to see where to cut the PCB. See the \"cut here\" in blue letters. I also sketched the VCC-trace in red. After the cut cut you can connect the IO0 to GND for reflashing. Later you need to connect back to VCC.","title":"SP108E HardwareAnalysis"},{"location":"devices/SP108E-HardwareAnalysis/#1-cut-traces-and-add-wires","text":"We need to break one of the traces on the bottom of the PCB. Then connect GPIO4 of ESP-12 with R4. Also RX/TX connection between STM32F0 and ESP-12 need to be broken up.","title":"1. Cut traces and add wires"},{"location":"devices/SP108E-HardwareAnalysis/#2-hold-stm32f0-in-reset","text":"This is the simpler method, no cuts on the PCB required, just two additional wires. - NRST of STM32F0 to GND - IO4 of ESP-12 to R4 See here for details.","title":"2. Hold STM32F0 in reset"},{"location":"devices/SP108E-HardwareAnalysis/#flashing-prohibited-not-anymore-with-a-cut-in-the-pcb","text":"Major problem is that IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. This is for the older rev of the PCB and showing the same physical device seen in my very first posts a few years ago. After removing the ESP-12, the trace was visible and now it is easy to see where to cut the PCB. See the \"cut here\" in blue letters. I also sketched the VCC-trace in red. After the cut cut you can connect the IO0 to GND for reflashing. Later you need to connect back to VCC.","title":"Flashing prohibited (not anymore with a cut in the PCB)"},{"location":"devices/SP108E-HardwareMod/","text":"SP108e (1st gen) Below is correct, but IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. Will check for some OTA mode that can be used. With just two additional wires we can use Tasmota with the SP108E. Analysis of the hardware The trick is to hold the STM32F0 controller in reset. Then we do not need to cut any traces on the PCB because all pins of the STM32F0 are inputs. Another warning: I did not yet proof it actually works, this is work in progress. Wire 1 - NRST (pin 7) of STM32F0 to GND Wire 2 - IO4 of ESP-12 to R4 SP108E (2nd gen) With the new hardware version of the SP108E a new microcontroller (Geehy APM32F030C8T6) comes to control the WS2812 leds. It seems to be pin compatible at least for the part of its reset pin. As the data sheet reveals the NRST is also located to pin 7. The Espressif chip was replaced as well. It has a different pinout and cannot be flashed as the usual ESP12S or similar. See Analysis of the hardware page for more details on it. The picture below shows the necessary hardware modifications to run tasmota for the 2nd gen. Wire 1 NRST (pin 7) of Geehy APM32 to GND Wire 2 IO4 of ESP8285 to R4 (DAT)","title":"SP108E HardwareMod"},{"location":"devices/SP108E-LED-strip-controller/","text":"This is a controller for the WS2812 and similar LED chips (stripes). Prize is 13..15\u20ac at ebay. It uses another controller (STM32F0) to control CLK and Data lines to the LEDs tripes. Warning: Construction zone. To run Tasmota on it, we need to modify the hardware. See here for details. Currently not working, see HardwareMod for details: \"Other than that, the normal flash instruction for Tasmota do apply.\" SP108E (1st Gen) SP108E (2nd Gen) New generation of the WS2812 controller. A modification of the hardware is also necessary. See page for SP108E-HardwareMod from above. Working","title":"SP108E LED strip controller"},{"location":"devices/SWB1-Smart-Power-Strip/","text":"Product ~ SWB1 Wi-Fi smart power strip with 4 main ports. Each port can be controlled manually FCCID: 2AJK8-SWB1 This is a new device not using the Tuya PCB but is a esp8266ex based and works great with Tasmota The product can be purchased on amazon.ca (could be found on other amazon sites) Inside ~ Inside PCB The chip used WT8266-S1. The specs can be found on wireless-tags.com JTAG ~ Pins used. You can choose one of 3 GND to your liking. the RESET(RST) pin is also marked for those that use that pin to reset the chip while flashing TASMOTA CONFIGURATION ~","title":"SWB1 Smart Power Strip"},{"location":"devices/SWB1-Smart-Power-Strip/#product","text":"SWB1 Wi-Fi smart power strip with 4 main ports. Each port can be controlled manually FCCID: 2AJK8-SWB1 This is a new device not using the Tuya PCB but is a esp8266ex based and works great with Tasmota The product can be purchased on amazon.ca (could be found on other amazon sites)","title":"Product"},{"location":"devices/SWB1-Smart-Power-Strip/#inside","text":"Inside PCB The chip used WT8266-S1. The specs can be found on wireless-tags.com","title":"Inside"},{"location":"devices/SWB1-Smart-Power-Strip/#jtag","text":"Pins used. You can choose one of 3 GND to your liking. the RESET(RST) pin is also marked for those that use that pin to reset the chip while flashing","title":"JTAG"},{"location":"devices/SWB1-Smart-Power-Strip/#tasmota-configuration","text":"","title":"TASMOTA CONFIGURATION"},{"location":"devices/Shelly-1/","text":"The Shelly 1 is supported in Tasmota from version 6.2.1.7 Allterco Shelly 1 Product Page Allterco Shelly 1 Shop Flashing ~ There are two options to get tasmota onto your shelly: 1) OTA update with an intermediate firmware (preferred - can be done in an already installed state) 2) The common way using a serial adapter. DO NOT DO THIS WHEN CONNECTED TO AC MAINS! OTA Update ~ Follow the guide from this repository: https://github.com/yaourdt/mgos-to-tasmota \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. There is possibility to attach DS18B20 or other sensors BUT only using Digital Voltage Isolator For example the company sells Temperature Sensor AddOn for Shelly 1/1PM with DS18B20. This should not fool you, never ever attach any sensor directly to the GPIOs - this expansion board uses TexasInstruments ISO7221 for voltage isolation. More information and Tasmota support for the extension board at https://github.com/arendst/Tasmota/issues/7469. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! An ESP8266 with 2MB flash single relay device 42mm \"round\" in size. Serial Connection ~ Shelly1 comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A serial-to-USB adapter is needed as well as a reliable 3.3V source with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. Flash mode ~ To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at Hardware Preparation . \u26a0\ufe0f\ufe0fWARNING\u26a0\ufe0f\ufe0f ~ Please note what version of the Shelly 1 you have (V1, V2 or V3). The V2 user guide is incorrect . The mains connections are as shown in the image above for all versions of the switch. The labels on the V2 switches are WRONG! Video tutorial by digiblurDIY ~ Video tutorial by BurnsHA ~","title":"Shelly 1"},{"location":"devices/Shelly-1/#flashing","text":"There are two options to get tasmota onto your shelly: 1) OTA update with an intermediate firmware (preferred - can be done in an already installed state) 2) The common way using a serial adapter. DO NOT DO THIS WHEN CONNECTED TO AC MAINS!","title":"Flashing"},{"location":"devices/Shelly-1/#ota-update","text":"Follow the guide from this repository: https://github.com/yaourdt/mgos-to-tasmota","title":"OTA Update"},{"location":"devices/Shelly-1/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. There is possibility to attach DS18B20 or other sensors BUT only using Digital Voltage Isolator For example the company sells Temperature Sensor AddOn for Shelly 1/1PM with DS18B20. This should not fool you, never ever attach any sensor directly to the GPIOs - this expansion board uses TexasInstruments ISO7221 for voltage isolation. More information and Tasmota support for the extension board at https://github.com/arendst/Tasmota/issues/7469. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! An ESP8266 with 2MB flash single relay device 42mm \"round\" in size.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1/#serial-connection","text":"Shelly1 comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A serial-to-USB adapter is needed as well as a reliable 3.3V source with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper.","title":"Serial Connection"},{"location":"devices/Shelly-1/#flash-mode","text":"To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at Hardware Preparation .","title":"Flash mode"},{"location":"devices/Shelly-1/#warning","text":"Please note what version of the Shelly 1 you have (V1, V2 or V3). The V2 user guide is incorrect . The mains connections are as shown in the image above for all versions of the switch. The labels on the V2 switches are WRONG!","title":"\u26a0\ufe0f\ufe0fWARNING\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1/#video-tutorial-by-digiblurdiy","text":"","title":"Video tutorial by digiblurDIY"},{"location":"devices/Shelly-1/#video-tutorial-by-burnsha","text":"","title":"Video tutorial by BurnsHA"},{"location":"devices/Shelly-1PM/","text":"The Shelly 1PM is supported from Tasmota 6.5.0.10 using a template. Allterco Shelly 1PM Product Page Allterco Shelly 1PM Shop \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. An ESP8266 with 2MB flash single relay device 42mm \"round\" in size. Serial Flashing ~ Shelly 1PM comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout. Template ~ {\"NAME\":\"Shelly 1PM\",\"GPIO\":[56,0,0,0,82,134,0,0,0,0,0,21,0],\"FLAG\":2,\"BASE\":18} Calibration ~ Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the Energy Monitoring chip is a serial interface which can take over a second to complete.","title":"Shelly 1PM"},{"location":"devices/Shelly-1PM/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. An ESP8266 with 2MB flash single relay device 42mm \"round\" in size.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1PM/#serial-flashing","text":"Shelly 1PM comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout.","title":"Serial Flashing"},{"location":"devices/Shelly-1PM/#template","text":"{\"NAME\":\"Shelly 1PM\",\"GPIO\":[56,0,0,0,82,134,0,0,0,0,0,21,0],\"FLAG\":2,\"BASE\":18}","title":"Template"},{"location":"devices/Shelly-1PM/#calibration","text":"Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the Energy Monitoring chip is a serial interface which can take over a second to complete.","title":"Calibration"},{"location":"devices/Shelly-2.5/","text":"The Shelly 2.5 is supported from Tasmota 6.5.0.8 using a template. Allterco Shelly 2.5 Product Page Allterco Shelly 2.5 Shop Shelly 2.5 Initial issue \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Shelly 2.5 ~ [!WARNING] Warning (April 10, 2019): This appears to affect a percentage of their entire first run production. Check your device before powering it on. An ESP8266 with 2MB flash dual relay device with Energy Monitoring. Slightly smaller than the original Shelly 2. Serial Connection ~ The Shelly 2.5 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped 24 AWG Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths. Otherwise you could simply buy an adapter that converts Dupont to 1.27mm raster at tindie Template ~ Tasmota 6.5.0.8 and higher supports Shelly 2.5 GPIO Component 0 LED1i 2 Button1 4 Relay1 5 Switch2n 12 I2C SDA 13 Switch1n 14 I2C SCL 15 Relay2 16 ADE7953 IRQ A0 Internal Temperature {\"NAME\":\"Shelly 2.5\",\"GPIO\":[56,0,17,0,21,83,0,0,6,82,5,22,156],\"FLAG\":2,\"BASE\":18} Energy metering is done by a ADE7953 chip connected via I2C and IRQ on GPIO16. If you connect momentary switches, use the following template: {\"NAME\":\"Shelly 2.5 (buttons)\",\"GPIO\":[56,0,19,0,21,127,0,0,6,126,5,22,156],\"FLAG\":2,\"BASE\":18} Button1 and Button2 are assigned to the SW1 and SW2 external inputs. Button3 is the button on the back of the device next to the pin header and you can optionally assign the behaviour you want using rules. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time. If you want to see Voltage and Frequency also when the relays are off, use SetOption21 1 Flash mode ~ To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode . Calibration ~ Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the energy monitoring chip is a serial interface which can take over a second to complete. Use rules to control shutter endpoints ~ As the Shelly 2.5 contains energy monitoring you can use rules to power off the shutter when too much current is drawn at the end point. This rule will power off both directions when the current becomes greater than 600mA. Before you activate the rule, let your shutter move and pay attention to the current value in the WebGUI. Note your value and add 0.050 to your value. After that, you change the value for the rule. Eg.: Your Value = 0.520 + 0.050 = 0.570 energy#current[X]>0.570 rule1 on energy#current[2]>0.600 do shutterstop endon on energy#current[1]>0.600 do shutterstop endon rule1 1 rule1 5 Use Shelly 2.5 device for Blinds and Shutters ~ Further Information: Blinds and Shutters Ghost switching ~ The Shelly 2.5 inputs appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value can be set up to 1000 milliseconds. Some issues were reported for this topic - search query Overheating ~ Due to the built-in temperature sensor, it is possible to switch off the relays when a certain temperature is exceeded. The limit for the original Shelly firmware seems to be around 95 \u00b0 C. Source The ambient temperature according to the manufacturer is between - 40 \u00b0 C up to 40 \u00b0 C Even at temperatures within this range, a significantly higher temperature can occur when installed behind switches or in walls. There are reports that temperature-related shutdowns occur at high loads. A standby temperature between 30-60 \u00b0 C seems normal. An overtemperature threshold is implemented in the Tasmota firmware. Note It is set to 90 \u00b0 C This can be changed via SetOption42 . [!WARNING]It is absolutely not recommended to increase the limit.","title":"Shelly 2.5"},{"location":"devices/Shelly-2.5/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-2.5/#shelly-25","text":"[!WARNING] Warning (April 10, 2019): This appears to affect a percentage of their entire first run production. Check your device before powering it on. An ESP8266 with 2MB flash dual relay device with Energy Monitoring. Slightly smaller than the original Shelly 2.","title":"Shelly 2.5"},{"location":"devices/Shelly-2.5/#serial-connection","text":"The Shelly 2.5 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped 24 AWG Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths. Otherwise you could simply buy an adapter that converts Dupont to 1.27mm raster at tindie","title":"Serial Connection"},{"location":"devices/Shelly-2.5/#template","text":"Tasmota 6.5.0.8 and higher supports Shelly 2.5 GPIO Component 0 LED1i 2 Button1 4 Relay1 5 Switch2n 12 I2C SDA 13 Switch1n 14 I2C SCL 15 Relay2 16 ADE7953 IRQ A0 Internal Temperature {\"NAME\":\"Shelly 2.5\",\"GPIO\":[56,0,17,0,21,83,0,0,6,82,5,22,156],\"FLAG\":2,\"BASE\":18} Energy metering is done by a ADE7953 chip connected via I2C and IRQ on GPIO16. If you connect momentary switches, use the following template: {\"NAME\":\"Shelly 2.5 (buttons)\",\"GPIO\":[56,0,19,0,21,127,0,0,6,126,5,22,156],\"FLAG\":2,\"BASE\":18} Button1 and Button2 are assigned to the SW1 and SW2 external inputs. Button3 is the button on the back of the device next to the pin header and you can optionally assign the behaviour you want using rules. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time. If you want to see Voltage and Frequency also when the relays are off, use SetOption21 1","title":"Template"},{"location":"devices/Shelly-2.5/#flash-mode","text":"To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode .","title":"Flash mode"},{"location":"devices/Shelly-2.5/#calibration","text":"Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the energy monitoring chip is a serial interface which can take over a second to complete.","title":"Calibration"},{"location":"devices/Shelly-2.5/#use-rules-to-control-shutter-endpoints","text":"As the Shelly 2.5 contains energy monitoring you can use rules to power off the shutter when too much current is drawn at the end point. This rule will power off both directions when the current becomes greater than 600mA. Before you activate the rule, let your shutter move and pay attention to the current value in the WebGUI. Note your value and add 0.050 to your value. After that, you change the value for the rule. Eg.: Your Value = 0.520 + 0.050 = 0.570 energy#current[X]>0.570 rule1 on energy#current[2]>0.600 do shutterstop endon on energy#current[1]>0.600 do shutterstop endon rule1 1 rule1 5","title":"Use rules to control shutter endpoints"},{"location":"devices/Shelly-2.5/#use-shelly-25-device-for-blinds-and-shutters","text":"Further Information: Blinds and Shutters","title":"Use Shelly 2.5 device for Blinds and Shutters"},{"location":"devices/Shelly-2.5/#ghost-switching","text":"The Shelly 2.5 inputs appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value can be set up to 1000 milliseconds. Some issues were reported for this topic - search query","title":"Ghost switching"},{"location":"devices/Shelly-2.5/#overheating","text":"Due to the built-in temperature sensor, it is possible to switch off the relays when a certain temperature is exceeded. The limit for the original Shelly firmware seems to be around 95 \u00b0 C. Source The ambient temperature according to the manufacturer is between - 40 \u00b0 C up to 40 \u00b0 C Even at temperatures within this range, a significantly higher temperature can occur when installed behind switches or in walls. There are reports that temperature-related shutdowns occur at high loads. A standby temperature between 30-60 \u00b0 C seems normal. An overtemperature threshold is implemented in the Tasmota firmware. Note It is set to 90 \u00b0 C This can be changed via SetOption42 . [!WARNING]It is absolutely not recommended to increase the limit.","title":"Overheating"},{"location":"devices/Shelly-2/","text":"Shelly 2 is discontinued and replaced by Shelly 2.5 The Shelly 2 is fully supported in Tasmota from version 6.2.1.7 \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! Shelly 2 ~ An ESP8266 with 2MB flash dual relay device with Energy Monitoring the size of round 45mm. Templates as of v6.4.1.17 ~ The inbuilt template equals the following: {\"NAME\":\"Shelly 2\",\"GPIO\":[0,135,0,136,21,22,0,0,9,0,10,137,0],\"FLAG\":0,\"BASE\":47} An alternative template without switch pull-up is: {\"NAME\":\"Shelly 2n\",\"GPIO\":[0,135,0,136,21,22,0,0,82,0,83,137,0],\"FLAG\":0,\"BASE\":47} Pullup or no pullup ~ The shelly 2 inputs may or may not need pullups for SW1 and SW2 to work correctly. Default state is pullups enabled. To disable pullups either use command SetOption62 1 or select the option from the GUI. Refer to the following issue: https://github.com/arendst/Tasmota/issues/4841","title":"Shelly 2"},{"location":"devices/Shelly-2/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly!","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-2/#shelly-2","text":"An ESP8266 with 2MB flash dual relay device with Energy Monitoring the size of round 45mm.","title":"Shelly 2"},{"location":"devices/Shelly-2/#templates-as-of-v64117","text":"The inbuilt template equals the following: {\"NAME\":\"Shelly 2\",\"GPIO\":[0,135,0,136,21,22,0,0,9,0,10,137,0],\"FLAG\":0,\"BASE\":47} An alternative template without switch pull-up is: {\"NAME\":\"Shelly 2n\",\"GPIO\":[0,135,0,136,21,22,0,0,82,0,83,137,0],\"FLAG\":0,\"BASE\":47}","title":"Templates as of v6.4.1.17"},{"location":"devices/Shelly-2/#pullup-or-no-pullup","text":"The shelly 2 inputs may or may not need pullups for SW1 and SW2 to work correctly. Default state is pullups enabled. To disable pullups either use command SetOption62 1 or select the option from the GUI. Refer to the following issue: https://github.com/arendst/Tasmota/issues/4841","title":"Pullup or no pullup"},{"location":"devices/Shelly-RGBW2/","text":"The Shelly RGBW2 is supported by using a template. Allterco Shelly RGBW2 Product Page Allterco Shelly RGBW2 Shop \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) There is no galvanic isolation between the DC Inputs and the GPIOs. Do not connect AC/DC power and the serial connection at the same time! Only use a Shelly as designed. Shelly RGBW2 ~ An ESP8266 with 2MB flash LED Controller. - Support any 12v or 24v White, RGB, RGBW led strips and 12/24v led bulbs, with up to 288W combined power - Support 4 ways PWM, applied to control 4 colors LED(R/G/B/W), meet a requirement for colored lights, color temperature lights, and general lights - A separate 12V/24V power supply unit is required. - 12V => 144W combined / 45W p. Channel - 24V => 288W combined / 90W p. Channel Serial Connection ~ The Shelly RGBW2 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths. Template ~ GPIO Component 0 None 1 None 2 LEDLink 3 None 4 PWM4 5 USER 9 None 10 None 12 PWM1 13 Button1 14 PWM3 15 PWM2 16 None A0 OpAmp Current Monitor Template: {\"NAME\":\"ShellyRGBW2\",\"GPIO\":[0,0,157,0,40,89,0,0,37,17,39,38,0],\"FLAG\":7,\"BASE\":18} Energy metering is done by a LM321 OpAmp (1mOhm Shunt lowside) via ADC0 . If you want to use a push button, you should take a look at the Button & Switches. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time. Flash mode ~ To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode . Calibration ~ After successfully flashing Tasmota and selecting the template for the Shelly RGBW2, you can start configuring the power consumption. Disconnect the GPIOs and connect the Shelly RGBW to its future power supply. Set ADC0 to Analog in the template settings . Save this setting. After restarting, you will find the acutal ADC Value of the analog input in the main menu. There should be no light on at this time. Make a note of this value. Its the baseValue. In the template settings, set ADC0 to CT-POWER and save the settings. Use the AdcParam command: AdcParam 7, baseValue, Multiplcator, Voltage in the webconsole. For a 12VDC PowerSupply and a baseValue of 407 this lines looks like this: AdcParam 7, 407, 3282, 0.012 If there are no lights on, the Main Menu should show only the Voltage but no consumption. Connect a light source with a current consumption known to you. Or measure the current with a multimeter. Compare the displayed values in the menu and those of your meter. Please note that the measurement of the Shelly RGBW2 is very inaccurate due to its electrical construction. Tip In case the values do not fit at all, you have to perform a recalibration. Set the ADC0 input back to analog. Note the base value when the light is switched off. Switch on the light and note the displayed analog value (comparison value) and the current value displayed by your meter (real value). Calculate: (ComparisonValue-baseValue)*100/realValue = Multiplicator Example BaseValue 407, ComparisonValue 455, realValue=1.5A (455-407)*100/1,5 = 3200 Set the ADC0 input back to CT-Power and start at 4. of the previous list. Using the attached AC switch adapter ~ As described in AC Frequency Detection Switch section, the adapter sends pulses (by shorting red wire to GND), when AC voltage is present between the two black wires. Shelly RGBW2 has an on-board pull-up resistor to 3.3V, therefore to make it work set GPIO5 to Switch_n mode, then use command like SwitchDebounce 69 to enable pulse detection. Use rules to control both switches ~ If SetOption37 is set to 128 the RGB and White is splited. To switch both RGB and W on/off with the connected hardware switch, you can use this Rule: rule1 on power1#state do power2 %value% endon rule1 1 Ghost switching ~ The inputs on Shelly devices appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value can be set up to 1000 milliseconds. Some issues were reported for this topic - search query Light setup ~ Please read: Lights . PCB images ~","title":"Shelly RGBW2"},{"location":"devices/Shelly-RGBW2/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) There is no galvanic isolation between the DC Inputs and the GPIOs. Do not connect AC/DC power and the serial connection at the same time! Only use a Shelly as designed.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-RGBW2/#shelly-rgbw2","text":"An ESP8266 with 2MB flash LED Controller. - Support any 12v or 24v White, RGB, RGBW led strips and 12/24v led bulbs, with up to 288W combined power - Support 4 ways PWM, applied to control 4 colors LED(R/G/B/W), meet a requirement for colored lights, color temperature lights, and general lights - A separate 12V/24V power supply unit is required. - 12V => 144W combined / 45W p. Channel - 24V => 288W combined / 90W p. Channel","title":"Shelly RGBW2"},{"location":"devices/Shelly-RGBW2/#serial-connection","text":"The Shelly RGBW2 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths.","title":"Serial Connection"},{"location":"devices/Shelly-RGBW2/#template","text":"GPIO Component 0 None 1 None 2 LEDLink 3 None 4 PWM4 5 USER 9 None 10 None 12 PWM1 13 Button1 14 PWM3 15 PWM2 16 None A0 OpAmp Current Monitor Template: {\"NAME\":\"ShellyRGBW2\",\"GPIO\":[0,0,157,0,40,89,0,0,37,17,39,38,0],\"FLAG\":7,\"BASE\":18} Energy metering is done by a LM321 OpAmp (1mOhm Shunt lowside) via ADC0 . If you want to use a push button, you should take a look at the Button & Switches. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time.","title":"Template"},{"location":"devices/Shelly-RGBW2/#flash-mode","text":"To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode .","title":"Flash mode"},{"location":"devices/Shelly-RGBW2/#calibration","text":"After successfully flashing Tasmota and selecting the template for the Shelly RGBW2, you can start configuring the power consumption. Disconnect the GPIOs and connect the Shelly RGBW to its future power supply. Set ADC0 to Analog in the template settings . Save this setting. After restarting, you will find the acutal ADC Value of the analog input in the main menu. There should be no light on at this time. Make a note of this value. Its the baseValue. In the template settings, set ADC0 to CT-POWER and save the settings. Use the AdcParam command: AdcParam 7, baseValue, Multiplcator, Voltage in the webconsole. For a 12VDC PowerSupply and a baseValue of 407 this lines looks like this: AdcParam 7, 407, 3282, 0.012 If there are no lights on, the Main Menu should show only the Voltage but no consumption. Connect a light source with a current consumption known to you. Or measure the current with a multimeter. Compare the displayed values in the menu and those of your meter. Please note that the measurement of the Shelly RGBW2 is very inaccurate due to its electrical construction. Tip In case the values do not fit at all, you have to perform a recalibration. Set the ADC0 input back to analog. Note the base value when the light is switched off. Switch on the light and note the displayed analog value (comparison value) and the current value displayed by your meter (real value). Calculate: (ComparisonValue-baseValue)*100/realValue = Multiplicator Example BaseValue 407, ComparisonValue 455, realValue=1.5A (455-407)*100/1,5 = 3200 Set the ADC0 input back to CT-Power and start at 4. of the previous list.","title":"Calibration"},{"location":"devices/Shelly-RGBW2/#using-the-attached-ac-switch-adapter","text":"As described in AC Frequency Detection Switch section, the adapter sends pulses (by shorting red wire to GND), when AC voltage is present between the two black wires. Shelly RGBW2 has an on-board pull-up resistor to 3.3V, therefore to make it work set GPIO5 to Switch_n mode, then use command like SwitchDebounce 69 to enable pulse detection.","title":"Using the attached AC switch adapter"},{"location":"devices/Shelly-RGBW2/#use-rules-to-control-both-switches","text":"If SetOption37 is set to 128 the RGB and White is splited. To switch both RGB and W on/off with the connected hardware switch, you can use this Rule: rule1 on power1#state do power2 %value% endon rule1 1","title":"Use rules to control both switches"},{"location":"devices/Shelly-RGBW2/#ghost-switching","text":"The inputs on Shelly devices appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value can be set up to 1000 milliseconds. Some issues were reported for this topic - search query","title":"Ghost switching"},{"location":"devices/Shelly-RGBW2/#light-setup","text":"Please read: Lights .","title":"Light setup"},{"location":"devices/Shelly-RGBW2/#pcb-images","text":"","title":"PCB images"},{"location":"devices/Slitinto-NX-SP202/","text":"indirectly supported as configuration of Digoo NX-SP202 seems to work fine Device can switch 2 individual plugs. It has a builtin metering sensor which measures power consumption of the sum of both. My 2 devices I bought at Amazon have ROHS and CE signs and are officially valid for a maximum of 16A. You can buy it at Amazon According to the template configuration the device seems to be compatible with Digoo NX-SP202 Configuration ~ Currently Slitinto is not present as separate module but DIGOO NX-SP202 seems to work. I had to adjust voltage and current with the following commands in the console * command VoltageSet 233 // measured with a multimeter * command CurrentSet 171 // known milliampere of my reference (here lightbulb of 40watts) This calibration is potentially individual for every device so I would suggest to calibrate it with a known power consuming device like a good old light bulb where the wattage is well known. Flashing ~ Disassembly ~ The device has no screws but disassembling as not needed as you can flash it OTA using tuya-convert. Nevertheless one user described a method to \"crack\" it using a rubber hammer and then glue it together again with no visible defects. Pinout ~ Not known. Procedure ~ Here is described how to crack the device but also how to flash it OTA. Miscellaneous ~ I use metering capable devices to observe the power consumption and execute rule based behaviour on base of the consumption values. i.e.: if the power consumption is lower than 10W for 30min (checked every 60 seconds) then switch off. My script for this looks like this: * rule1 on Energy#Power>10 do backlog ruletimer1 1800; ruletimer2 60; rule1 off; endon * rule2 on rules#timer=1 do power2 off endon * rule3 on rules#timer=2 do rule1 on endon * rule1 on * rule2 on * rule3 on","title":"Slitinto NX SP202"},{"location":"devices/Slitinto-NX-SP202/#configuration","text":"Currently Slitinto is not present as separate module but DIGOO NX-SP202 seems to work. I had to adjust voltage and current with the following commands in the console * command VoltageSet 233 // measured with a multimeter * command CurrentSet 171 // known milliampere of my reference (here lightbulb of 40watts) This calibration is potentially individual for every device so I would suggest to calibrate it with a known power consuming device like a good old light bulb where the wattage is well known.","title":"Configuration"},{"location":"devices/Slitinto-NX-SP202/#flashing","text":"","title":"Flashing"},{"location":"devices/Slitinto-NX-SP202/#disassembly","text":"The device has no screws but disassembling as not needed as you can flash it OTA using tuya-convert. Nevertheless one user described a method to \"crack\" it using a rubber hammer and then glue it together again with no visible defects.","title":"Disassembly"},{"location":"devices/Slitinto-NX-SP202/#pinout","text":"Not known.","title":"Pinout"},{"location":"devices/Slitinto-NX-SP202/#procedure","text":"Here is described how to crack the device but also how to flash it OTA.","title":"Procedure"},{"location":"devices/Slitinto-NX-SP202/#miscellaneous","text":"I use metering capable devices to observe the power consumption and execute rule based behaviour on base of the consumption values. i.e.: if the power consumption is lower than 10W for 30min (checked every 60 seconds) then switch off. My script for this looks like this: * rule1 on Energy#Power>10 do backlog ruletimer1 1800; ruletimer2 60; rule1 off; endon * rule2 on rules#timer=1 do power2 off endon * rule3 on rules#timer=2 do rule1 on endon * rule1 on * rule2 on * rule3 on","title":"Miscellaneous"},{"location":"devices/Smart-Light-Switch--SS118-01K1/","text":"Generic Smart Light Switch from Amazon TYWE3S Model - In Canada ESP8266-S1 Model - August 2019 Product ~ Pins ~ Module Configuration ~ New Version - August 2019 Product ~ Pins ~ Module Configuration ~ GPIO Tasmota Component Device Function 0 LedLink (157) Red LED 2 Button1 (17) Button 12 LED1i (56) Green LED 15 Relay1 (21) Relay","title":"Smart Light Switch  SS118 01K1"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#product","text":"","title":"Product"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#pins","text":"","title":"Pins"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#module-configuration","text":"New Version - August 2019","title":"Module Configuration"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#product_1","text":"","title":"Product"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#pins_1","text":"","title":"Pins"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#module-configuration_1","text":"GPIO Tasmota Component Device Function 0 LedLink (157) Red LED 2 Button1 (17) Button 12 LED1i (56) Green LED 15 Relay1 (21) Relay","title":"Module Configuration"},{"location":"devices/SmartHome/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #1474 . Device Images ~ Generic Module Config ~ ESP Module ~ The module being used in this device is the esp8266-s3","title":"SmartHome"},{"location":"devices/SmartHome/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/SmartHome/#additional-information","text":"SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #1474 .","title":"Additional Information"},{"location":"devices/SmartHome/#device-images","text":"","title":"Device Images"},{"location":"devices/SmartHome/#generic-module-config","text":"","title":"Generic Module Config"},{"location":"devices/SmartHome/#esp-module","text":"The module being used in this device is the esp8266-s3","title":"ESP Module"},{"location":"devices/SmartPlug-with-POW/","text":"Smart Plugs from Amazon with same internal parts: - AISIRER - AVATAR Device: ~ solid design with 16A Relays 8 MB memory chip 2 LEDs POW function (unfortunately did not test yet, need help) very small size, easy to disassemble no need to disassemble PCBs test mode works with 5 or 3.3 V (relays also works) Disassemble * take off the lead with 2 screws * put small cross screwdriver inside 220V plug connector, there are 2 screws * free the antenna from plastic (no need to disconnect) * pull of PCB from the case Important build flags. * in Platformio for Tasmota flag change from 1MB to 8MB is needed, otherwise flash fails. build_flags = ${esp82xx_defaults.build_flags} -Wl,-Teagle.flash.8m.ld * in Arduino IDE: board selected - \"Node MCU 1.0\", standard Found how some of PINS are linked to main PCB and are easy to connect for flashing PCB Flashing: ~ I've decided to use 5V - there is a painted pad on the PCB, clean it and attach 5V (see image) * Connect GPIO0 to GND * Connect RX, TX * Connect 5V and GND * Connect USB to PC, start flashing Tasmota WEB config (Generic) * GPIO0 - Led1i * GPIO2 - Led2i * GPIO5 - HLW8012 CF * GPIO12 - HLWBLSELi * GPIO13 - Button1 * GPIO14 - HLWBL CF1 * GPIO15- Relais1 webconfig IMPORTANT: in order to have an accurate measurement of Voltage/Current/Power, you have to calibrate the internal meter with a well know load (like lamp or hair dryer) using this detailed procedure . Update from my side ~ I managed to flash two Aisirer plugs using pre-compiled tasmota.binaries, since my plugs had only 1M flash. I used 3.3V connected directly to the ESP board. I had some trouble with WLAN connectivity which caused the relays to pulse, so I switched to 2.3.0 core, which seems default again since a few releases. This runs quite well. Configure as BlitzWolf SHP(45) Module and also the power measurement is working. Update from nos86 ~ I have updated the guide in order to interface Tasmota with the power meter inside smart plug (tested only on AISIRER) and added the link for the power monitoring calibration","title":"SmartPlug with POW"},{"location":"devices/SmartPlug-with-POW/#device","text":"solid design with 16A Relays 8 MB memory chip 2 LEDs POW function (unfortunately did not test yet, need help) very small size, easy to disassemble no need to disassemble PCBs test mode works with 5 or 3.3 V (relays also works) Disassemble * take off the lead with 2 screws * put small cross screwdriver inside 220V plug connector, there are 2 screws * free the antenna from plastic (no need to disconnect) * pull of PCB from the case Important build flags. * in Platformio for Tasmota flag change from 1MB to 8MB is needed, otherwise flash fails. build_flags = ${esp82xx_defaults.build_flags} -Wl,-Teagle.flash.8m.ld * in Arduino IDE: board selected - \"Node MCU 1.0\", standard Found how some of PINS are linked to main PCB and are easy to connect for flashing PCB","title":"Device:"},{"location":"devices/SmartPlug-with-POW/#flashing","text":"I've decided to use 5V - there is a painted pad on the PCB, clean it and attach 5V (see image) * Connect GPIO0 to GND * Connect RX, TX * Connect 5V and GND * Connect USB to PC, start flashing Tasmota WEB config (Generic) * GPIO0 - Led1i * GPIO2 - Led2i * GPIO5 - HLW8012 CF * GPIO12 - HLWBLSELi * GPIO13 - Button1 * GPIO14 - HLWBL CF1 * GPIO15- Relais1 webconfig IMPORTANT: in order to have an accurate measurement of Voltage/Current/Power, you have to calibrate the internal meter with a well know load (like lamp or hair dryer) using this detailed procedure .","title":"Flashing:"},{"location":"devices/SmartPlug-with-POW/#update-from-my-side","text":"I managed to flash two Aisirer plugs using pre-compiled tasmota.binaries, since my plugs had only 1M flash. I used 3.3V connected directly to the ESP board. I had some trouble with WLAN connectivity which caused the relays to pulse, so I switched to 2.3.0 core, which seems default again since a few releases. This runs quite well. Configure as BlitzWolf SHP(45) Module and also the power measurement is working.","title":"Update from my side"},{"location":"devices/SmartPlug-with-POW/#update-from-nos86","text":"I have updated the guide in order to interface Tasmota with the power meter inside smart plug (tested only on AISIRER) and added the link for the power monitoring calibration","title":"Update from nos86"},{"location":"devices/Sonoff-4CH-DIY/","text":"Sonoff 4CH DIY Itead Shop: https://www.itead.cc/psf-b85.html Itead Wiki: https://www.itead.cc/wiki/PSF-B85 The Sonoff 4CH DIY is based on the ESP8285. Serial Connection ~ Sonoff 4CH DIY ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Programming the Sonoff 4CH DIY is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as KEY 1) are available on the header. A simple jumper between GND and KEY 1 while programming will do. Module parameters ~ Type ~ Module Type => Generic (18) Restart the module. GPIO9 & GPIO10 ~ To use GPIO9 and GPIO10 of the ESP8285, open the consol and enter => \"SetOption51 on\". Restart the module. Assign inputs and outputs ~ GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 4 => relay 3 (23) GPIO 15 => relay 4 (24) GPIO 13 => LED 1 (52)","title":"Sonoff 4CH DIY"},{"location":"devices/Sonoff-4CH-DIY/#serial-connection","text":"","title":"Serial Connection"},{"location":"devices/Sonoff-4CH-DIY/#sonoff-4ch-diy","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Programming the Sonoff 4CH DIY is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as KEY 1) are available on the header. A simple jumper between GND and KEY 1 while programming will do.","title":"Sonoff 4CH DIY"},{"location":"devices/Sonoff-4CH-DIY/#module-parameters","text":"","title":"Module parameters"},{"location":"devices/Sonoff-4CH-DIY/#type","text":"Module Type => Generic (18) Restart the module.","title":"Type"},{"location":"devices/Sonoff-4CH-DIY/#gpio9-gpio10","text":"To use GPIO9 and GPIO10 of the ESP8285, open the consol and enter => \"SetOption51 on\". Restart the module.","title":"GPIO9 &amp; GPIO10"},{"location":"devices/Sonoff-4CH-DIY/#assign-inputs-and-outputs","text":"GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 4 => relay 3 (23) GPIO 15 => relay 4 (24) GPIO 13 => LED 1 (52)","title":"Assign inputs and outputs"},{"location":"devices/Sonoff-4CH-Pro/","text":"Compared to the 4CH the main differences/improvements of the 4CH Pro are: Relays are isolated from mains and can each switch their own circuit (mains or low voltage). With stock firmware special modes are supported (stand-alone schedules, inching, interlocking). RF receiver (optional key fob or Sonoff RF Bridge 433 required). Dual microcontroller, both a ESP8285 and a STM32. Serial Flashing ~ Sonoff 4CH Pro ~ The \"FW/IO0\" button (Switch 1) is not directly connected to GPIO0 of the ESP module. A different method has to be used to program this board. To program the ESP chip disconnect power from the board, connect a cable from any Ground (GND) pin to the GPIO0 pin on the ESP (be careful not to touch any of the other pins). This is the second pin to the right on the top row of pins (see picture). While holding the pin connected power on the board. The board does not respond to any button pressed when in programming mode and LED 1, 2 and 3 are on (might differ per board). Use the ESP programming header as described in the picture to upload the firmware and follow regular programming procedure. Sonoff 4CH Pro R2 ~ On the R2 module the GPIO0 pin is broken out to a small pad to the right of the ESP package : If you have 4CH R2 v1.0 hardware, the GPIO0 is available as L1 switch - you don't need to solder additional cable to the PCB. Just push it during powering on for 3 seconds and release. Sonoff 4CH Pro R3 ~ R3 module has no any pad, so hold button 1 during powering for 3 seconds and release in order to put a chip in flashing mode. It is also possible to so use connect the pin of R21 on the board to the ground instead. If you like to use RF433 module is possible to direct connect SYN470R output to SDA (GPIO2), and then configure RF Receiver Solving Sonoff 4CH Pro programing issues ~ If you have problems to program the 4CH Pro, you might find below tips useful: * Use the ESP program header and ensure that the right port is set in the Arduino IDE. * TX/RX are printed correctly on the pro version => TX goes to RX PIN and RX to TX. * GPIO0 needs to be connected to ground the first 3 seconds during reboot (or longer)! If not you can not program it. * On 4CH Pro R2 try switch S6 to 0 before connecting power to enter flash mode. Reset to 1 (default) after finished flashing. If you use Windows7+, check in the device manager if the port is not added/removed all 2 seconds. If yes then your USB port does not deliver enough ampere. And/Or reduce upload speed to 57600 in Arduino IDE. Use an active USB HUB if your computer delivers not enough ampere External power source will stabilize the 4CH-pro and you can increase upload speed back to 115200. Using a Laptop instead of a Desktop Tower might also do the trick as Laptops have a battery to deliver more ampere. you can not flash it with tasmota-minimal.bin, you need to flash it with tasmota.bin ! Using esptool following commands might be usefull (you need to change com port) to clear: esptool.exe -cp COM6 -cb 115200 -ce -v to program: esptool.exe -cp COM6 -bm dout -cf tasmota.bin -v 4CH Pro DIPSwitch Configuration ~ Most special modes of the 4CH Pro are controlled by DIP switch panels on the board. Please refer to the back of the board or the Sonoff documentation for more details. For normal operation with Tasmota the following settings are recommended: S6: 1 K5: all 1 K6: all 0 (0 and 1 are printed onto the board next to the switch names) Changing these switches for operations like inching and interlocking are also supported with Tasmota. Official Sources ~ Itead Product Page Itead Shop Itead Wiki WARNING The Sonoff CH4 PRO is subject to radio frequency disturbances with random activation of the buttons. To eliminate interference due to the U7 (SYN470RU7 RF-433 module) you can cut the wire between U7 and U8 (MCU STM32f030c6). This line starts from pin 10 of U7, the part towards MCU can be soldered to ground (surrounding area). It is also possible to set the RF module (U7) in shutdown-mode by unsoldering or cutting pin 11.","title":"Sonoff 4CH Pro"},{"location":"devices/Sonoff-4CH-Pro/#serial-flashing","text":"","title":"Serial Flashing"},{"location":"devices/Sonoff-4CH-Pro/#sonoff-4ch-pro","text":"The \"FW/IO0\" button (Switch 1) is not directly connected to GPIO0 of the ESP module. A different method has to be used to program this board. To program the ESP chip disconnect power from the board, connect a cable from any Ground (GND) pin to the GPIO0 pin on the ESP (be careful not to touch any of the other pins). This is the second pin to the right on the top row of pins (see picture). While holding the pin connected power on the board. The board does not respond to any button pressed when in programming mode and LED 1, 2 and 3 are on (might differ per board). Use the ESP programming header as described in the picture to upload the firmware and follow regular programming procedure.","title":"Sonoff 4CH Pro"},{"location":"devices/Sonoff-4CH-Pro/#sonoff-4ch-pro-r2","text":"On the R2 module the GPIO0 pin is broken out to a small pad to the right of the ESP package : If you have 4CH R2 v1.0 hardware, the GPIO0 is available as L1 switch - you don't need to solder additional cable to the PCB. Just push it during powering on for 3 seconds and release.","title":"Sonoff 4CH Pro R2"},{"location":"devices/Sonoff-4CH-Pro/#sonoff-4ch-pro-r3","text":"R3 module has no any pad, so hold button 1 during powering for 3 seconds and release in order to put a chip in flashing mode. It is also possible to so use connect the pin of R21 on the board to the ground instead. If you like to use RF433 module is possible to direct connect SYN470R output to SDA (GPIO2), and then configure RF Receiver","title":"Sonoff 4CH Pro R3"},{"location":"devices/Sonoff-4CH-Pro/#solving-sonoff-4ch-pro-programing-issues","text":"If you have problems to program the 4CH Pro, you might find below tips useful: * Use the ESP program header and ensure that the right port is set in the Arduino IDE. * TX/RX are printed correctly on the pro version => TX goes to RX PIN and RX to TX. * GPIO0 needs to be connected to ground the first 3 seconds during reboot (or longer)! If not you can not program it. * On 4CH Pro R2 try switch S6 to 0 before connecting power to enter flash mode. Reset to 1 (default) after finished flashing. If you use Windows7+, check in the device manager if the port is not added/removed all 2 seconds. If yes then your USB port does not deliver enough ampere. And/Or reduce upload speed to 57600 in Arduino IDE. Use an active USB HUB if your computer delivers not enough ampere External power source will stabilize the 4CH-pro and you can increase upload speed back to 115200. Using a Laptop instead of a Desktop Tower might also do the trick as Laptops have a battery to deliver more ampere. you can not flash it with tasmota-minimal.bin, you need to flash it with tasmota.bin ! Using esptool following commands might be usefull (you need to change com port) to clear: esptool.exe -cp COM6 -cb 115200 -ce -v to program: esptool.exe -cp COM6 -bm dout -cf tasmota.bin -v","title":"Solving Sonoff 4CH Pro programing issues"},{"location":"devices/Sonoff-4CH-Pro/#4ch-pro-dipswitch-configuration","text":"Most special modes of the 4CH Pro are controlled by DIP switch panels on the board. Please refer to the back of the board or the Sonoff documentation for more details. For normal operation with Tasmota the following settings are recommended: S6: 1 K5: all 1 K6: all 0 (0 and 1 are printed onto the board next to the switch names) Changing these switches for operations like inching and interlocking are also supported with Tasmota.","title":"4CH Pro DIPSwitch Configuration"},{"location":"devices/Sonoff-4CH-Pro/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki WARNING The Sonoff CH4 PRO is subject to radio frequency disturbances with random activation of the buttons. To eliminate interference due to the U7 (SYN470RU7 RF-433 module) you can cut the wire between U7 and U8 (MCU STM32f030c6). This line starts from pin 10 of U7, the part towards MCU can be soldered to ground (surrounding area). It is also possible to set the RF module (U7) in shutdown-mode by unsoldering or cutting pin 11.","title":"Official Sources"},{"location":"devices/Sonoff-4CH/","text":"Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Sonoff 4CH and Sonoff 4CH R2 use the same configuration but have slightly different boards. Check which version you own before proceeding. Sonoff 4CH ~ Attention: The printed labels on the PCB for RX and TX may be incorrectly swapped as can be seen on the image. Regardless of the labels, the pin next to VCC33 is RX. The Sonoff 4CH features four hardware buttons. Button marked FW/IO0 is connected to GPIO0 and can be used to bring the module into flash mode. Sonoff 4CH R2 ~ Board is labelled Sonoff 4CH R2 V1.0. The RX and TX pins are correctly labelled on this PCB revision. The button labelled IO0 is connected to GPIO0 and can be used to bring the module into flash mode. Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff 4CH"},{"location":"devices/Sonoff-4CH/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Sonoff 4CH and Sonoff 4CH R2 use the same configuration but have slightly different boards. Check which version you own before proceeding.","title":"Serial Flashing"},{"location":"devices/Sonoff-4CH/#sonoff-4ch","text":"Attention: The printed labels on the PCB for RX and TX may be incorrectly swapped as can be seen on the image. Regardless of the labels, the pin next to VCC33 is RX. The Sonoff 4CH features four hardware buttons. Button marked FW/IO0 is connected to GPIO0 and can be used to bring the module into flash mode.","title":"Sonoff 4CH"},{"location":"devices/Sonoff-4CH/#sonoff-4ch-r2","text":"Board is labelled Sonoff 4CH R2 V1.0. The RX and TX pins are correctly labelled on this PCB revision. The button labelled IO0 is connected to GPIO0 and can be used to bring the module into flash mode.","title":"Sonoff 4CH R2"},{"location":"devices/Sonoff-4CH/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-B1-and-B1-R2/","text":"PAGE MOVED!","title":"Sonoff B1 and B1 R2"},{"location":"devices/Sonoff-B1/","text":"Sonoff B1 R2 is the replacement for Sonoff B1 and can be programmed the same way as the B1. See here for more background information. Serial Flashing ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. First pop up the top part of the bulb with controlled force. The PCB as shown in the image will become visible. The four serial pins (3V3, RX, TX, GND) as well as the GPIO0 signal line are available as test points and clearly marked. Solder wires to those or use pogo pins as you prefer. As with all modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. An additional GND pad is available in the middle of the PCB. NOTE: If experiencing trouble getting the B1 R2 into flash mode, try pulling GPIO to GND during power up and holding it for 20 to 25 seconds before release. LED HEX10 Color Codes ~ The Sonoff B1 uses a TEN charter HEX code for all colors. Colors tested with firmware 5.9.1 20171107: * 00000000A0 = WARM * 000000A000 = COOL * 0000A00000 = BLUE * FF14500000 = PURPLE * 551A8B0000 = DARK PURPLE * A300000000 = RED * 00ff000000 = GREEN Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-b1 Itead Shop: https://www.itead.cc/sonoff-b1.html Itead Wiki: (not available)","title":"Sonoff B1"},{"location":"devices/Sonoff-B1/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. First pop up the top part of the bulb with controlled force. The PCB as shown in the image will become visible. The four serial pins (3V3, RX, TX, GND) as well as the GPIO0 signal line are available as test points and clearly marked. Solder wires to those or use pogo pins as you prefer. As with all modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. An additional GND pad is available in the middle of the PCB. NOTE: If experiencing trouble getting the B1 R2 into flash mode, try pulling GPIO to GND during power up and holding it for 20 to 25 seconds before release.","title":"Serial Flashing"},{"location":"devices/Sonoff-B1/#led-hex10-color-codes","text":"The Sonoff B1 uses a TEN charter HEX code for all colors. Colors tested with firmware 5.9.1 20171107: * 00000000A0 = WARM * 000000A000 = COOL * 0000A00000 = BLUE * FF14500000 = PURPLE * 551A8B0000 = DARK PURPLE * A300000000 = RED * 00ff000000 = GREEN","title":"LED HEX10 Color Codes"},{"location":"devices/Sonoff-B1/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-b1 Itead Shop: https://www.itead.cc/sonoff-b1.html Itead Wiki: (not available)","title":"Official Sources"},{"location":"devices/Sonoff-Basic-and-BME280/","text":"This feature is included only in tasmota-sensors.bin \"BME280 sensor, an environmental sensor with temperature, barometric pressure and humidity\", see Datasheet. \"tasmota-sensors.bin is needed for this to work. tasmota.bin an tasmota-lite.bin do not include the necessary driver.\" Connect BME280 to Sonoff-Basic based on the GPIO locations ~ BME280-3.3V -> Sonoff-3.3V BME280-GND -> Sonoff-GND BME280-SCL -> Sonoff-TX BME280-SDA -> Sonoff-RX NOTE: YOU NEED TO DISABLE SERIAL LOG COMPLETELY TO ALLOW SENSORS ON TX/RX PINS On the Tasmota web interface go to Configuration->Configure Module and set","title":"Sonoff Basic and BME280"},{"location":"devices/Sonoff-Basic-and-BME280/#connect-bme280-to-sonoff-basic-based-on-the-gpio-locations","text":"BME280-3.3V -> Sonoff-3.3V BME280-GND -> Sonoff-GND BME280-SCL -> Sonoff-TX BME280-SDA -> Sonoff-RX NOTE: YOU NEED TO DISABLE SERIAL LOG COMPLETELY TO ALLOW SENSORS ON TX/RX PINS On the Tasmota web interface go to Configuration->Configure Module and set","title":"Connect BME280 to Sonoff-Basic based on the GPIO locations"},{"location":"devices/Sonoff-Basic/","text":"Sonoff Basic - the one that started it all! Serial Flashing ~ Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available in the middle of the PCB, right next to the on-board button. Newer versions of the Sonoff Basic device provide five pins below the button, ignore the pin furthest away from the Button (GPIO14 or I02) if available. The square pin right next to the button is the 3.3V line. For flashing the Sonoff Basic, hold the button while connecting the 3.3V power. The LED remains off until the flashing process is done and the board is rebooted. If your switch is powering up but is showing a solid-blink-reset pattern see this FAQ entry for advice . GPIO00 - BUTTON GPIO12 - RELAY GPIO13 - LED1 GPIO03 - RX PIN GPIO01 - TX PIN Sonoff Basic R3 ~ This is the board layout for the third design iteration of the Sonoff Basic. The Sonoff Basic R3 uses the ESP8285 chip. With this version, the mains power reverts to solder rails directly on the PCB. It also moves the Wi-Fi module to a separate PCB mounted on the main PCB. It makes access to the underside of the serial interface contacts quite difficult. This version of the device supports the new Itead DIY architecture which allows OTA firmware upload . The device was reviewed by DigiblurDIY in this video . The serial interface pins are broken out on the PCB making flashing using a serial adapter as well. Since the underside of the contacts is not easily reachable, use a solderless solution (i.e., friction) to maintain contact with the pins to flash the device. Sonoff Basic R2 ~ Around November 2018, Itead changed the layout of the Sonoff Basic ( issue #4515 ). The new board is labeled as Sonoff RF R2 POWER V1.0 . It is easily discerned from previous revisions since it uses wires instead of thick solder traces for mains power. The new version of the Sonoff Basic smart switch uses an ESP8285 SoC with the 1MB flash integrated into the same SoC chip. GPIO14 is no longer broken out to a contact on the PCB. Instead, GPIO02 (no pullup) is broken out. It is labeled as IO2 on the board. To use GPIO02, take care that it is not being pulled low when the device is booting . Otherwise, the device will not boot into its regular operational mode. Alternatively, you can use use GPIO03 (Rx) which does not have any boot function restrictions. However, both of these GPIO are pulled high momentarily after boot. This means that any connected device may \"blink\" when the Sonoff is powering up. Unlike GPIO03, the GPIO02 PCB contact is not prepared for a pin. You will need to solder your cable directly on the board. Be careful. Too high a temperature or long heating can damage the contact and its connectivity. You should also make sure that there is no tension on the cable. Affix the cable with a cable tie and perhaps some hot glue. GPIO02 as a user configurable input is implemented in the Sonoff Basic module (introduced in 6.3.0.15). If you use GPIO03, you must use a device template (rather than selecting the Sonoff Basic module), and also disable serial logging ( SerialLog 0 ). You can remove the thick wires from the PCB to use the screw connection on the output side for low voltage. Then add a screw terminal next to the relay for the LINE OUT. This keeps all high voltage on one side of the board Sonoff Basic R1 ~ This is the board layout for the first board version of the Sonoff Basic. (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) Usable GPIO: - GPIO14 is broken out on the PCB adjacent to the GND pin. - GPIO13 - You must remove the bi-colour LED - GPIO04 - You must solder wire to pin on ESP chip Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff Basic"},{"location":"devices/Sonoff-Basic/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available in the middle of the PCB, right next to the on-board button. Newer versions of the Sonoff Basic device provide five pins below the button, ignore the pin furthest away from the Button (GPIO14 or I02) if available. The square pin right next to the button is the 3.3V line. For flashing the Sonoff Basic, hold the button while connecting the 3.3V power. The LED remains off until the flashing process is done and the board is rebooted. If your switch is powering up but is showing a solid-blink-reset pattern see this FAQ entry for advice . GPIO00 - BUTTON GPIO12 - RELAY GPIO13 - LED1 GPIO03 - RX PIN GPIO01 - TX PIN","title":"Serial Flashing"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r3","text":"This is the board layout for the third design iteration of the Sonoff Basic. The Sonoff Basic R3 uses the ESP8285 chip. With this version, the mains power reverts to solder rails directly on the PCB. It also moves the Wi-Fi module to a separate PCB mounted on the main PCB. It makes access to the underside of the serial interface contacts quite difficult. This version of the device supports the new Itead DIY architecture which allows OTA firmware upload . The device was reviewed by DigiblurDIY in this video . The serial interface pins are broken out on the PCB making flashing using a serial adapter as well. Since the underside of the contacts is not easily reachable, use a solderless solution (i.e., friction) to maintain contact with the pins to flash the device.","title":"Sonoff Basic R3"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r2","text":"Around November 2018, Itead changed the layout of the Sonoff Basic ( issue #4515 ). The new board is labeled as Sonoff RF R2 POWER V1.0 . It is easily discerned from previous revisions since it uses wires instead of thick solder traces for mains power. The new version of the Sonoff Basic smart switch uses an ESP8285 SoC with the 1MB flash integrated into the same SoC chip. GPIO14 is no longer broken out to a contact on the PCB. Instead, GPIO02 (no pullup) is broken out. It is labeled as IO2 on the board. To use GPIO02, take care that it is not being pulled low when the device is booting . Otherwise, the device will not boot into its regular operational mode. Alternatively, you can use use GPIO03 (Rx) which does not have any boot function restrictions. However, both of these GPIO are pulled high momentarily after boot. This means that any connected device may \"blink\" when the Sonoff is powering up. Unlike GPIO03, the GPIO02 PCB contact is not prepared for a pin. You will need to solder your cable directly on the board. Be careful. Too high a temperature or long heating can damage the contact and its connectivity. You should also make sure that there is no tension on the cable. Affix the cable with a cable tie and perhaps some hot glue. GPIO02 as a user configurable input is implemented in the Sonoff Basic module (introduced in 6.3.0.15). If you use GPIO03, you must use a device template (rather than selecting the Sonoff Basic module), and also disable serial logging ( SerialLog 0 ). You can remove the thick wires from the PCB to use the screw connection on the output side for low voltage. Then add a screw terminal next to the relay for the LINE OUT. This keeps all high voltage on one side of the board","title":"Sonoff Basic R2"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r1","text":"This is the board layout for the first board version of the Sonoff Basic. (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) Usable GPIO: - GPIO14 is broken out on the PCB adjacent to the GND pin. - GPIO13 - You must remove the bi-colour LED - GPIO04 - You must solder wire to pin on ESP chip","title":"Sonoff Basic R1"},{"location":"devices/Sonoff-Basic/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-Dual-R2/","text":"Sonoff Dual R2 is the replacement for Sonoff Dual. Compared to the Dual the main differences/improvements for R2 are: * As the second microcontroller has been removed both relays are now controlled directly by an ESP8285 * The button is now directly connected to the ESP8285 * The header connector is now supported in Tasmota Serial Flashing (Sonoff Dual R2) ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. VCC, RX, TX and GND are available at the bottom left end of the PCB in the image below. Programming the Sonoff Dual R2 is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as BUTTON 0) are available on the second header. A simple jumper between GND and BUTTON 0 while powering on will do. For a video on how to flash the Sonoff Dual R2 with Tasmota, take a look here . Use external switches ~ The relays can be controlled by external push buttons or switches connected to the header at the designated positions. BUTTON 0 (on GPIO0) connected to GND controls Relay1 and BUTTON 1 (on GPIO9) connected to GND controls Relay2. See the image on the right how to configure this functionality in Tasmota as Switch1 and Switch2. NOTE Make sure not to use a switch that keeps the connection between GND and BUTTON 0 active while power is re-applied as the device will start in programming mode. Note 2: GPIO9 and 10 can be safely used with an external switch (even rebooting with the contacts closed), and configured as such using a template. GPIO9 is available in the header, and GPIO10 is the board's button (you only need to solder a wire to the GPIO10 side of the button, no need to remove it). Sonoff Dual ( not R2) ~ Serial Connection ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. For the v2.0 version of the board you need to cross-over the serial interface, see troubleshooting . Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by careful scratching it off. Restricted Button Functionality ~ Please be aware, that the button on the Sonoff Dual will initially not have any functionality! Other than on most Sonoff module the button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. You will need to configure wifi credentials connecting directly to the wifi AP your Dual will broadcast or configure the module firmware config beforehand via user_config_override.h . After configuring the device as a \"Sonoff Dual\", the button will regain normal functionality. GPIO Locations ~ GPIO4 => red, GPIO14 => orange Solving intermittent relay switch errors ~ Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual and 4 Channel Inching Relay Assy do use the standard SERIAL interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in user_config_override.h for all Sonoffs. Once in production it's wise to turn it off for all Sonoffs. For the Dual it is almost mandatory to turn it off. Execute command seriallog 0 once to turn all communication on the serial port off. If within 10 minutes no input is received serial communication is turned off too. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 . Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Sonoff Dual R2"},{"location":"devices/Sonoff-Dual-R2/#serial-flashing-sonoff-dual-r2","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. VCC, RX, TX and GND are available at the bottom left end of the PCB in the image below. Programming the Sonoff Dual R2 is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as BUTTON 0) are available on the second header. A simple jumper between GND and BUTTON 0 while powering on will do. For a video on how to flash the Sonoff Dual R2 with Tasmota, take a look here .","title":"Serial Flashing (Sonoff Dual R2)"},{"location":"devices/Sonoff-Dual-R2/#use-external-switches","text":"The relays can be controlled by external push buttons or switches connected to the header at the designated positions. BUTTON 0 (on GPIO0) connected to GND controls Relay1 and BUTTON 1 (on GPIO9) connected to GND controls Relay2. See the image on the right how to configure this functionality in Tasmota as Switch1 and Switch2. NOTE Make sure not to use a switch that keeps the connection between GND and BUTTON 0 active while power is re-applied as the device will start in programming mode. Note 2: GPIO9 and 10 can be safely used with an external switch (even rebooting with the contacts closed), and configured as such using a template. GPIO9 is available in the header, and GPIO10 is the board's button (you only need to solder a wire to the GPIO10 side of the button, no need to remove it).","title":"Use external switches"},{"location":"devices/Sonoff-Dual-R2/#sonoff-dual-not-r2","text":"","title":"Sonoff Dual (not R2)"},{"location":"devices/Sonoff-Dual-R2/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. For the v2.0 version of the board you need to cross-over the serial interface, see troubleshooting . Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by careful scratching it off.","title":"Serial Connection"},{"location":"devices/Sonoff-Dual-R2/#restricted-button-functionality","text":"Please be aware, that the button on the Sonoff Dual will initially not have any functionality! Other than on most Sonoff module the button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. You will need to configure wifi credentials connecting directly to the wifi AP your Dual will broadcast or configure the module firmware config beforehand via user_config_override.h . After configuring the device as a \"Sonoff Dual\", the button will regain normal functionality.","title":"Restricted Button Functionality"},{"location":"devices/Sonoff-Dual-R2/#gpio-locations","text":"GPIO4 => red, GPIO14 => orange","title":"GPIO Locations"},{"location":"devices/Sonoff-Dual-R2/#solving-intermittent-relay-switch-errors","text":"Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual and 4 Channel Inching Relay Assy do use the standard SERIAL interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in user_config_override.h for all Sonoffs. Once in production it's wise to turn it off for all Sonoffs. For the Dual it is almost mandatory to turn it off. Execute command seriallog 0 once to turn all communication on the serial port off. If within 10 minutes no input is received serial communication is turned off too. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 .","title":"Solving intermittent relay switch errors"},{"location":"devices/Sonoff-Dual-R2/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Official Sources"},{"location":"devices/Sonoff-Dual/","text":"Sonoff Dual has been obsoleted by Sonoff Dual R2 . Before configuring your device check which revision you have since there are significant differences in how they operate. Serial Flashing ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. Alternative GPIO locations Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed in two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB. You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by carefully scratching it off. Restricted Button Functionality ~ Please be aware, that the button on the Sonoff Dual will initially not have any functionality! The button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. After configuring the device as \"Sonoff Dual (5)\", the button will regain normal functionality. GPIO Locations ~ GPIO4 = red, GPIO14 = orange Solving intermittent relay switch errors ~ Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual uses the serial interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in Tasmota. For the Dual it is mandatory to turn it off withe SerialLog 0 comand. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 . Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Sonoff Dual"},{"location":"devices/Sonoff-Dual/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. Alternative GPIO locations Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed in two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB. You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by carefully scratching it off.","title":"Serial Flashing"},{"location":"devices/Sonoff-Dual/#restricted-button-functionality","text":"Please be aware, that the button on the Sonoff Dual will initially not have any functionality! The button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. After configuring the device as \"Sonoff Dual (5)\", the button will regain normal functionality.","title":"Restricted Button Functionality"},{"location":"devices/Sonoff-Dual/#gpio-locations","text":"GPIO4 = red, GPIO14 = orange","title":"GPIO Locations"},{"location":"devices/Sonoff-Dual/#solving-intermittent-relay-switch-errors","text":"Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual uses the serial interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in Tasmota. For the Dual it is mandatory to turn it off withe SerialLog 0 comand. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 .","title":"Solving intermittent relay switch errors"},{"location":"devices/Sonoff-Dual/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Official Sources"},{"location":"devices/Sonoff-Mini/","text":"The Sonoff Mini is, as the name implies, a very small device, designed to be hidden where there's only supposed to be cables. Since it's not supposed to be visible, it's also designed to easily attach an external button. Tasmota can be flashed on this device via OTA using the Sonoff DIY feature. Several free GPIO are available. The OTA jumper pin is the most accessible and very easy to use on a pin header. GPIO Description 0 Button 1 TX 2 Available 3 RX 4 S2 (external switch input) 12 Relay and red LED 13 Blue LED 16 OTA jumper pin GND S1 (external switch input)","title":"Sonoff Mini"},{"location":"devices/Sonoff-PSA/","text":"itead page","title":"Sonoff PSA"},{"location":"devices/Sonoff-Pow-R2/","text":"\u26a0\ufe0f\ufe0fSpecial Attention \u26a0\ufe0f\ufe0f ~ Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW R2 as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn Serial Flashing ~ Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear/short end of the PCB. To enter flash mode , press down on the button while powering the device. Note - After the module type is changed to \"Sonoff Pow R2\", the serial port is no longer available for entering configuration commands because the serial port is used to communicate to the power measurement chip. Make sure you have set up your network connection before doing this. Serial logging ~ Serial logging is disabled by the Tasmota code for this module. Serial communication is used by the device to transfer the data from the energy monitoring chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on this device. It can cause the device software to crash. Be sure to leave it disabled. Video tutorial by alsolh ~ Power Monitoring Calibration ~ Sonoff Pow R2 might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration Telemetry ~ The Sonoff Pow R2 can provide Energy, Power, Voltage and Current information in different ways. The preffered way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00:00 and 24:00 yesterday Today | kWh | Total Energy usage today from 00:00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt(Power^2 + | | ReactivePower^2) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current Official Sources ~ Itead Product Page Itead Shop (R2) Itead Wiki","title":"Sonoff Pow R2"},{"location":"devices/Sonoff-Pow-R2/#special-attention","text":"Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW R2 as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn","title":"\u26a0\ufe0f\ufe0fSpecial Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/Sonoff-Pow-R2/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear/short end of the PCB. To enter flash mode , press down on the button while powering the device. Note - After the module type is changed to \"Sonoff Pow R2\", the serial port is no longer available for entering configuration commands because the serial port is used to communicate to the power measurement chip. Make sure you have set up your network connection before doing this.","title":"Serial Flashing"},{"location":"devices/Sonoff-Pow-R2/#serial-logging","text":"Serial logging is disabled by the Tasmota code for this module. Serial communication is used by the device to transfer the data from the energy monitoring chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on this device. It can cause the device software to crash. Be sure to leave it disabled.","title":"Serial logging"},{"location":"devices/Sonoff-Pow-R2/#video-tutorial-by-alsolh","text":"","title":"Video tutorial by alsolh"},{"location":"devices/Sonoff-Pow-R2/#power-monitoring-calibration","text":"Sonoff Pow R2 might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration","title":"Power Monitoring Calibration"},{"location":"devices/Sonoff-Pow-R2/#telemetry","text":"The Sonoff Pow R2 can provide Energy, Power, Voltage and Current information in different ways. The preffered way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00:00 and 24:00 yesterday Today | kWh | Total Energy usage today from 00:00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt(Power^2 + | | ReactivePower^2) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current","title":"Telemetry"},{"location":"devices/Sonoff-Pow-R2/#official-sources","text":"Itead Product Page Itead Shop (R2) Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-Pow/","text":"Sonoff Pow has been obsoleted with Sonoff Pow R2 . Before configuring your device check which revision you have. \u26a0\ufe0f\ufe0fSpecial Attention \u26a0\ufe0f\ufe0f ~ Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn Serial Connection ~ Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear end of the PCB. To enter flash mode , press down on the button while powering the device. Power Monitoring Calibration ~ Sonoff Pow might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration Telemetry ~ The Sonoff Pow can provide Energy, Power, Voltage and Current information in different ways. The preferred way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00:00 and 24:00 yesterday Today | kWh | Total Energy usage today from 00:00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt(Power^2 + | | ReactivePower^2) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current Self Protection for Sonoff Pow ~ ITEAD published a recall notice for the Sonoff Pow on March 1st 2017. Some units produced in december 2016 and january 2017 are not well suited for 16A. If you have one of these units you can decide to use them anyway by limiting the maximum current in software. It is, in fact, possible to set a Maximum Power Threshold for the Sonoff Pow. If the power measured by the device exceeds the threshold set by the command MaxPower for a number of seconds set by the command MaxPowerHold the device will remain switched off for MaxPowerWindow seconds (to let it cool down, for example). For all details see issue #218 Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff Pow"},{"location":"devices/Sonoff-Pow/#special-attention","text":"Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn","title":"\u26a0\ufe0f\ufe0fSpecial Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/Sonoff-Pow/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear end of the PCB. To enter flash mode , press down on the button while powering the device.","title":"Serial Connection"},{"location":"devices/Sonoff-Pow/#power-monitoring-calibration","text":"Sonoff Pow might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration","title":"Power Monitoring Calibration"},{"location":"devices/Sonoff-Pow/#telemetry","text":"The Sonoff Pow can provide Energy, Power, Voltage and Current information in different ways. The preferred way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00:00 and 24:00 yesterday Today | kWh | Total Energy usage today from 00:00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt(Power^2 + | | ReactivePower^2) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current","title":"Telemetry"},{"location":"devices/Sonoff-Pow/#self-protection-for-sonoff-pow","text":"ITEAD published a recall notice for the Sonoff Pow on March 1st 2017. Some units produced in december 2016 and january 2017 are not well suited for 16A. If you have one of these units you can decide to use them anyway by limiting the maximum current in software. It is, in fact, possible to set a Maximum Power Threshold for the Sonoff Pow. If the power measured by the device exceeds the threshold set by the command MaxPower for a number of seconds set by the command MaxPowerHold the device will remain switched off for MaxPowerWindow seconds (to let it cool down, for example). For all details see issue #218","title":"Self Protection for Sonoff Pow"},{"location":"devices/Sonoff-Pow/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-RF-Bridge-433/","text":"The Sonoff RF Bridge has two separate chips to handle the Wi-Fi (ESP8285) and RF (EFM8BB1) communications respectively. It is used to send and receive codes with 433.9MHz frequency RF devices. Codes received from RF devices such as remote controls is passed to the onboard ESP8285 via the serial interface. The code data is relayed via MQTT. Similarly, the Bridge receives commands over Wi-Fi and sends the encoded data to the RF chip to control an RF device. Thus, the Sonoff RF Bridge \"bridges\" communications between RF and Wi-Fi. Flash Tasmota ~ Please read the Hardware Preparation article for general flashing instructions. Access the serial interface available on the 5-pin header next to the switch as can be seen in the image. To flash the ESP8285, first move the switch position towards the 5-pin header. Connect the serial-to-USB adapter and press the button on the edge while powering the device in order to put the ESP8285 into programming mode in order to upload the Tasmota firmware. After flashing the ESP8285, be sure to move the switch position away from the 5-pin header to restore the connection to the RF microcontroller. Configure the device as usual and select module Sonoff Bridge (25) . During normal operation the serial interface is used at 19200 baud to communicate with the RF microcontroller. Therefore serial logging ( SerialLog 0 ) must be disabled. IMPORTANT: In the Module configuration GPIO4 and GPIO5 must be left as 00 None On R2 versions of the Sonoff RF Bridge, a hardware modification is required in order to use these GPIOs. Video tutorial by alsolh ~ RF Firmware ~ The RF chip has its own firmware. The device is shipped with Itead firmware which supports a limited set of RF devices limited to mostly just Sonoff devices (a single 24-bit RF protocol). Some later versions of the factory firmware will only relay received RF data once the transmitting device stops. This is fine for remote controls or devices such as door sensors. But for devices such as smoke detectors, this behavior is not acceptable. Custom firmware is available for the RF chip which is commonly referred to as 'Portisch'. By updating the firmware on the RF chip, new types of devices and new features become usable. It also relays the RF data when the data is received rather than waiting until the transmitter stops. Tasmota supports the original Sonoff RF firmware and the Portisch firmware . RF Firmware Upgrade ~ The RF upgrade requires wiring the bridge and then flashing the firmware via the Tasmota web UI. Attention \u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f There are 2 versions of the Sonoff RF Bridge 433 : the R1 and the R2 V1.0 . R1 R2 V1.0 RF firmware flashing: Flashing RF Firmware ~ Make sure you have previously flashed a Tasmota binary built with RF_FLASH . Refer to the builds table for pre-compiled binaries which include this feature. Otherwise the \"Magic byte is not 0xE9\" error will occur. Set the module type to Sonoff Bridge (25) Connect two wires (this will be different depending on the Sonoff RF Bridge 433 hardware version): For R1 : Connect GPIO4 to C2Ck and GPIO5 to C2D . For R2 : Connect GPIO4 to C2D and GPIO5 to C2Ck . ( The text on the R2 PCB silkscreen is switched. Therefore this is the same wiring as on the R1) Switch the ON/OFF switch on the board to 'OFF' (to disconnect RF from ESP). Power up the bridge via the 3.3V & GND pins. (See below if you need to power the device through the USB power port) Obtain the Portisch firmware file: (Clicking on the file link on the GitHub web site does not work since this will download the GitHub preview/content of the file rather than the raw file contents) Download the entire contents of the Tasmota GitHub project project via the green Clone or Download button to ensure that the firmware hex files are downloaded properly. The firmware files are located in the ./tools/fw_SonoffRfBridge_efm8bb1/ folder. Select the newest available hex file. Otherwise you may get error \"Magic byte is not 0xE9\" . As an alternative use wget/curl to download the raw file (https://github.com/arendst/Tasmota/tree/master/tools/fw_SonoffRfBridge_efm8bb1) directly. Select the newest available hex file. Otherwise you may get error \"Magic byte is not 0xE9\" . PowerShell example: wget https://github.com/arendst/Tasmota/raw/master/tools/fw_SonoffRfBridge_efm8bb1/RF-Bridge-EFM8BB1-XXXXXXXX.hex -OutFile .\\RF-Bridge-EFM8BB1-XXXXXXXX.hex Go to the Web UI Firmware Upgrade > Upgrade by File Upload (introduced in v6.0.0a) In the file selection dialog, navigate to the folder on your computer where you saved the hex file from step 6. Click Start Upgrade . The flashing should complete within 60 seconds. Device will restart after upgrade completes. Disconnect wiring and put the ON/OFF switch on the board back to 'ON' to enable the RF again. Hardware Preparation for USB powered flashing ~ This section applies only to the R2 revision of the Sonoff RF Bridge Apply this modification only if you intend to use USB for powering the device during flash process or if you want to use GPIO4 or GPIO5 for other purposes with the RF Bridge. The R2 revision boards connect the GPIO4 and GPIO5 pins to the USB data lines of the power connector. Compliant USB chargers/power supplies are expected to short the two pins together, which is a problem. These lines are not used by the original firmware, nor by Tasmota. The traces toward the USB power connector need to be cut to avoid interference by the USB wiring. Removing these connections does not interfere with the normal Bridge functionality. Operation ~ The Sonoff RF Bridge is able to learn up to 16 different fixed code remote control commands as provided by PT2260, PT2262, PT2264 and EV1527 transmitters. It was not able to recognize the latest Klik Aan Klik Uit (KaKu) remote control signals but some people managed to use the fixed code KaKu devices like PAR-1000 receiver and PAT-103 transmitter. Tasmota provides default remote control commands to all 16 keys so you can start using the bridge with a Sonoff 4Ch Pro or Sonoff RF device without having the bridge have to learn remote control commands. See RF Bridge commands. Portisch Firmware Specific Usage ~ These sections only apply to the custom Portisch firmware. Learning Commands with Portisch Firmware ~ In order to learn Buttons from your remote, go to the Console of your RF Bridge. There, enter rfraw 177 and push the buttons on your remote. Repeat each button 2-3 times, as the signal may be different for each try. This will give you a so called B1 code of your button, which needs to be converted to a B0 code (see below). Sending Commands with Portisch Firmware ~ The commands learned with Portisch Firmware cannot be stored in device memory. Instead, they must be sent as a command. Example using MQTT: cmnd/sonoffRFBridge/Backlog RfRaw AAB0210314016703F924180101011001100110010101100110011001010110010101100255; RfRaw 0 Refer to issue #3973 for further information. B1 to B0 Conversion Tools ~ After learning how bitbucket works from the Portisch wiki , use one of these tools to help convert received B1 sniffing messages to the right 'B0' format to send in the 'RfRaw' command. Online Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press a function (each Button 2-3 times) on your remote control Copy the JSON payload output from the Console and paste it in the online converter and click Convert e.g., {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} The utility will return the resulting B0 string to use in setting up commands in the RF Bridge e.g., AA B0 1A 03 08 07F9 0124 37DC 010101010101101001010101101010100102 55 CLI (rename file from BitBucketConverter.txt to BitBucketConverter.py ) In the command line give the B1 message string and the retries value (in decimal): e.g., BitBucketConverter.py \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Command Line : \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Result: RfRaw AAB01C041407EB015700FD3EBC01010101010110100101010110101010010355 Batch Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press each function (each Button 2-3 times) on your remote control Save everything from the console that happened after rfraw 177 to a text file Run bitbuckedconverter.py -f console.txt Each line of console.txt will be converted into a B0 string and displayed Run bitbuckedconverter.py -f console.txt -e Each line of console.txt will be converted into a B0 string and sent to the Bridge Then: * If the device reacted as expected, you can enter a name of the button (e.g., \"light\") * Else enter nothing to try the next * Repeat this until all lines have been tried * The tool will create a list of buttons and their B0 codes that have worked (i.e. for which you have specified a name) * In the end you can test all of these codes \"Raw sniffing\" As suggested by the Portisch firmware, perform the following: In the web UI Console, send RfRaw AAB155 This will result in two consecutive messages: 1. The first one tells you that you are using one of the new firmware commands 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":\"ON\"} The second one tells that the EFM8BB1 RF chip new firmware accepts the command and enters raw sniffing mode ('A0' means 'ACK') 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} After that keep pushing one of the buttons on the remote. MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 04 07F0 0128 00F2 3822 010101010101101001010101101010100103 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0126 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F5 0127 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F7 0125 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07FC 011E 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0122 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F1 012D 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}}` MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0128 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37D2 010101010101101001010101101010100102 55\"}} Notice that this sequence of messages all start with 'AA' then 'B1' and the last byte '55' The reason for pushing the remote button for several seconds is to get enough 'AA B1 ...... 55' sequences to select the best one to be transmitted back. Then discard the sequences with 'data values' not equal. In the example 'data values' are the 010101010101101001010101101010100102 string. Notice that before that 'data values' string there are several 2 byte values (they are called 'buckets'); they are time values in microseconds. The number of 'buckets' is indicated in a previous byte (in the example a 3 or a 4). In the example, discard the first message (it contains 4 buckets, whereas the rest have only 3 buckets). Examine the values on the buckets in order to choose the message where more buckets are 'similar'. For example messages with ' 37D2 ' in the third bucket are good candidates. Messages with ' 0124 ' in the second bucket are also good candidates. First bucket values are very similar; ' 07F8 ' can be a good one. External Sources ~ Itead Product Page Itead Shop Itead Wiki RF Bridge 433 R2 Information","title":"Sonoff RF Bridge 433"},{"location":"devices/Sonoff-RF-Bridge-433/#flash-tasmota","text":"Please read the Hardware Preparation article for general flashing instructions. Access the serial interface available on the 5-pin header next to the switch as can be seen in the image. To flash the ESP8285, first move the switch position towards the 5-pin header. Connect the serial-to-USB adapter and press the button on the edge while powering the device in order to put the ESP8285 into programming mode in order to upload the Tasmota firmware. After flashing the ESP8285, be sure to move the switch position away from the 5-pin header to restore the connection to the RF microcontroller. Configure the device as usual and select module Sonoff Bridge (25) . During normal operation the serial interface is used at 19200 baud to communicate with the RF microcontroller. Therefore serial logging ( SerialLog 0 ) must be disabled. IMPORTANT: In the Module configuration GPIO4 and GPIO5 must be left as 00 None On R2 versions of the Sonoff RF Bridge, a hardware modification is required in order to use these GPIOs.","title":"Flash Tasmota"},{"location":"devices/Sonoff-RF-Bridge-433/#video-tutorial-by-alsolh","text":"","title":"Video tutorial by alsolh"},{"location":"devices/Sonoff-RF-Bridge-433/#rf-firmware","text":"The RF chip has its own firmware. The device is shipped with Itead firmware which supports a limited set of RF devices limited to mostly just Sonoff devices (a single 24-bit RF protocol). Some later versions of the factory firmware will only relay received RF data once the transmitting device stops. This is fine for remote controls or devices such as door sensors. But for devices such as smoke detectors, this behavior is not acceptable. Custom firmware is available for the RF chip which is commonly referred to as 'Portisch'. By updating the firmware on the RF chip, new types of devices and new features become usable. It also relays the RF data when the data is received rather than waiting until the transmitter stops. Tasmota supports the original Sonoff RF firmware and the Portisch firmware .","title":"RF Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#rf-firmware-upgrade","text":"The RF upgrade requires wiring the bridge and then flashing the firmware via the Tasmota web UI. Attention \u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f There are 2 versions of the Sonoff RF Bridge 433 : the R1 and the R2 V1.0 . R1 R2 V1.0 RF firmware flashing:","title":"RF Firmware Upgrade"},{"location":"devices/Sonoff-RF-Bridge-433/#operation","text":"The Sonoff RF Bridge is able to learn up to 16 different fixed code remote control commands as provided by PT2260, PT2262, PT2264 and EV1527 transmitters. It was not able to recognize the latest Klik Aan Klik Uit (KaKu) remote control signals but some people managed to use the fixed code KaKu devices like PAR-1000 receiver and PAT-103 transmitter. Tasmota provides default remote control commands to all 16 keys so you can start using the bridge with a Sonoff 4Ch Pro or Sonoff RF device without having the bridge have to learn remote control commands. See RF Bridge commands.","title":"Operation"},{"location":"devices/Sonoff-RF-Bridge-433/#portisch-firmware-specific-usage","text":"These sections only apply to the custom Portisch firmware.","title":"Portisch Firmware Specific Usage"},{"location":"devices/Sonoff-RF-Bridge-433/#learning-commands-with-portisch-firmware","text":"In order to learn Buttons from your remote, go to the Console of your RF Bridge. There, enter rfraw 177 and push the buttons on your remote. Repeat each button 2-3 times, as the signal may be different for each try. This will give you a so called B1 code of your button, which needs to be converted to a B0 code (see below).","title":"Learning Commands with Portisch Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#sending-commands-with-portisch-firmware","text":"The commands learned with Portisch Firmware cannot be stored in device memory. Instead, they must be sent as a command. Example using MQTT: cmnd/sonoffRFBridge/Backlog RfRaw AAB0210314016703F924180101011001100110010101100110011001010110010101100255; RfRaw 0 Refer to issue #3973 for further information.","title":"Sending Commands with Portisch Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#b1-to-b0-conversion-tools","text":"After learning how bitbucket works from the Portisch wiki , use one of these tools to help convert received B1 sniffing messages to the right 'B0' format to send in the 'RfRaw' command. Online Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press a function (each Button 2-3 times) on your remote control Copy the JSON payload output from the Console and paste it in the online converter and click Convert e.g., {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} The utility will return the resulting B0 string to use in setting up commands in the RF Bridge e.g., AA B0 1A 03 08 07F9 0124 37DC 010101010101101001010101101010100102 55 CLI (rename file from BitBucketConverter.txt to BitBucketConverter.py ) In the command line give the B1 message string and the retries value (in decimal): e.g., BitBucketConverter.py \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Command Line : \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Result: RfRaw AAB01C041407EB015700FD3EBC01010101010110100101010110101010010355 Batch Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press each function (each Button 2-3 times) on your remote control Save everything from the console that happened after rfraw 177 to a text file Run bitbuckedconverter.py -f console.txt Each line of console.txt will be converted into a B0 string and displayed Run bitbuckedconverter.py -f console.txt -e Each line of console.txt will be converted into a B0 string and sent to the Bridge Then: * If the device reacted as expected, you can enter a name of the button (e.g., \"light\") * Else enter nothing to try the next * Repeat this until all lines have been tried * The tool will create a list of buttons and their B0 codes that have worked (i.e. for which you have specified a name) * In the end you can test all of these codes \"Raw sniffing\" As suggested by the Portisch firmware, perform the following: In the web UI Console, send RfRaw AAB155 This will result in two consecutive messages: 1. The first one tells you that you are using one of the new firmware commands 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":\"ON\"} The second one tells that the EFM8BB1 RF chip new firmware accepts the command and enters raw sniffing mode ('A0' means 'ACK') 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} After that keep pushing one of the buttons on the remote. MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 04 07F0 0128 00F2 3822 010101010101101001010101101010100103 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0126 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F5 0127 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F7 0125 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07FC 011E 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0122 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F1 012D 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}}` MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0128 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37D2 010101010101101001010101101010100102 55\"}} Notice that this sequence of messages all start with 'AA' then 'B1' and the last byte '55' The reason for pushing the remote button for several seconds is to get enough 'AA B1 ...... 55' sequences to select the best one to be transmitted back. Then discard the sequences with 'data values' not equal. In the example 'data values' are the 010101010101101001010101101010100102 string. Notice that before that 'data values' string there are several 2 byte values (they are called 'buckets'); they are time values in microseconds. The number of 'buckets' is indicated in a previous byte (in the example a 3 or a 4). In the example, discard the first message (it contains 4 buckets, whereas the rest have only 3 buckets). Examine the values on the buckets in order to choose the message where more buckets are 'similar'. For example messages with ' 37D2 ' in the third bucket are good candidates. Messages with ' 0124 ' in the second bucket are also good candidates. First bucket values are very similar; ' 07F8 ' can be a good one.","title":"B1 to B0 Conversion Tools"},{"location":"devices/Sonoff-RF-Bridge-433/#external-sources","text":"Itead Product Page Itead Shop Itead Wiki RF Bridge 433 R2 Information","title":"External Sources"},{"location":"devices/Sonoff-RF-R3/","text":"See Sonoff DIY for flashing instructions Convert RF R3 into an RF Bridge ~ Instructions","title":"Sonoff RF R3"},{"location":"devices/Sonoff-RF-R3/#convert-rf-r3-into-an-rf-bridge","text":"Instructions","title":"Convert RF R3 into an RF Bridge"},{"location":"devices/Sonoff-RF/","text":"Serial Flashing ~ The Sonoff RF needs some tweaking as the connection needed during programming between the button and GPIO0 might not be present. This connection must be removed after the conversion to Tasmota or a button press will send the device in an ON/OFF loop. This can be achieved by shorting both solder pads of R21 with a small screwdriver while holding down the button during programming. This can be a bit fiddly, and ideally you should check the bootloader output over serial to see whether you managed to get it into programming mode. Alternatively, Phalox installed a jumper wire (explained in the picture below). Remember to remove it after programming. The R2 V1.0 version of the Sonoff RF uses an ESP8285 which is covered by a horizontally orientated RF expansion board. Entering flash ready mode can be achieved by grounding K_P (which is connected to GPIO0) to the neighbouring GND pin on the RF board during power on. Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine. Pairing a RF remote control ~ During programming a connection for R21 is needed in order to use a button press to ground GPIO0. To pair a RF remote control with the Sonoff RF it is important that there is NO connection made for R21. User gadjet installed a jumper in place of R21 allowing easy programming (jumper in), pairing (jumper out) and normal use (jumper out). The Slampher RF Revision 2.0 can have the same modification applied, but it requires its jumper across R3. Pairing Instructions ~ Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine. Version 2 Pairing Instructions ~ RF units produced after 6/2018 use a different procedure for pairing. Press and hold the button for 3-seconds until the red light flashes once, then press then button on your remote to program. Press and hold for button for 5-seconds until the red light flashes twice to clear remote programming.","title":"Sonoff RF"},{"location":"devices/Sonoff-RF/#serial-flashing","text":"The Sonoff RF needs some tweaking as the connection needed during programming between the button and GPIO0 might not be present. This connection must be removed after the conversion to Tasmota or a button press will send the device in an ON/OFF loop. This can be achieved by shorting both solder pads of R21 with a small screwdriver while holding down the button during programming. This can be a bit fiddly, and ideally you should check the bootloader output over serial to see whether you managed to get it into programming mode. Alternatively, Phalox installed a jumper wire (explained in the picture below). Remember to remove it after programming. The R2 V1.0 version of the Sonoff RF uses an ESP8285 which is covered by a horizontally orientated RF expansion board. Entering flash ready mode can be achieved by grounding K_P (which is connected to GPIO0) to the neighbouring GND pin on the RF board during power on. Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine.","title":"Serial Flashing"},{"location":"devices/Sonoff-RF/#pairing-a-rf-remote-control","text":"During programming a connection for R21 is needed in order to use a button press to ground GPIO0. To pair a RF remote control with the Sonoff RF it is important that there is NO connection made for R21. User gadjet installed a jumper in place of R21 allowing easy programming (jumper in), pairing (jumper out) and normal use (jumper out). The Slampher RF Revision 2.0 can have the same modification applied, but it requires its jumper across R3.","title":"Pairing a RF remote control"},{"location":"devices/Sonoff-RF/#pairing-instructions","text":"Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine.","title":"Pairing Instructions"},{"location":"devices/Sonoff-RF/#version-2-pairing-instructions","text":"RF units produced after 6/2018 use a different procedure for pairing. Press and hold the button for 3-seconds until the red light flashes once, then press then button on your remote to program. Press and hold for button for 5-seconds until the red light flashes twice to clear remote programming.","title":"Version 2 Pairing Instructions"},{"location":"devices/Sonoff-S20/","text":"Sonoff S20 comes in 4 different plug type variations. Flashing process will be the same for each type. Serial Connection ~ Please see the Hardware Preparation page for general instructions. The picture shows how to program the S20 Smart Socket powered by the serial-to-USB converter. With newer US sockets, either use a right-angle header, or remove the header after flashing. Otherwise,the pushbutton may rub against a pin and get stuck. Be sure it is NOT plugged in mains! Remove the \"hidden\" screw. (optional) Remove the board from the plastic shell to have better access to serial pins. There are 2 screws at the red and blue wire. Be careful not to damage the soldered connection! Connect the jumper wires. From top to bottom (see image below): - Vcc (3,3V) - RXD - TXD - GND Connected? Hold the little button pressed while connecting the serial-to-USB adapter to your computer. After about 2 seconds let go of the button. It is now in flashing mode and ready to be flashed with Tasmota. Video tutorial by Don't It Yourself ~ Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/residential/s20-socket Itead Wiki: https://www.itead.cc/wiki/S20_Smart_Socket OpenHab Configuration ~ sonoff.items: Switch S20_1 \"Coffee S20-1 Powerplug\" (LR,gLight) { mqtt=\">[broker:cmnd/sonoff-S20-1/POWER:command:*:default], <[broker:stat/sonoff-S20-1/POWER:state:default], <[broker:stat/sonoff-S20-1/RESULT:state:JSONPATH($.POWER)], <[broker:tele/sonoff-S20-1/STATE:state:JSONPATH($.POWER)] \"} Switch S20_1_Reachable \"S20-1 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-S20-1/LWT:state:MAP(reachable.map)], <[broker:stat/sonoff-S20-1/RESULT:state:ON], <[broker:stat/sonoff-S20-1/POWER:state:ON], <[broker:tele/sonoff-S20-1/STATE:state:ON] \" } default.sitemap: Switch item=S20_1 labelcolor=[S20_1_Reachable == \"ON\" = \"green\",S20_1_Reachable == \"OFF\" = \"red\"] Configuration ~ Once set up and connected, you can set the module type to Sonoff S2X (8) in Configure module .","title":"Sonoff S20"},{"location":"devices/Sonoff-S20/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. The picture shows how to program the S20 Smart Socket powered by the serial-to-USB converter. With newer US sockets, either use a right-angle header, or remove the header after flashing. Otherwise,the pushbutton may rub against a pin and get stuck. Be sure it is NOT plugged in mains! Remove the \"hidden\" screw. (optional) Remove the board from the plastic shell to have better access to serial pins. There are 2 screws at the red and blue wire. Be careful not to damage the soldered connection! Connect the jumper wires. From top to bottom (see image below): - Vcc (3,3V) - RXD - TXD - GND Connected? Hold the little button pressed while connecting the serial-to-USB adapter to your computer. After about 2 seconds let go of the button. It is now in flashing mode and ready to be flashed with Tasmota.","title":"Serial Connection"},{"location":"devices/Sonoff-S20/#video-tutorial-by-dont-it-yourself","text":"","title":"Video tutorial by Don't It Yourself"},{"location":"devices/Sonoff-S20/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/s20-socket Itead Wiki: https://www.itead.cc/wiki/S20_Smart_Socket","title":"Official Sources"},{"location":"devices/Sonoff-S20/#openhab-configuration","text":"sonoff.items: Switch S20_1 \"Coffee S20-1 Powerplug\" (LR,gLight) { mqtt=\">[broker:cmnd/sonoff-S20-1/POWER:command:*:default], <[broker:stat/sonoff-S20-1/POWER:state:default], <[broker:stat/sonoff-S20-1/RESULT:state:JSONPATH($.POWER)], <[broker:tele/sonoff-S20-1/STATE:state:JSONPATH($.POWER)] \"} Switch S20_1_Reachable \"S20-1 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-S20-1/LWT:state:MAP(reachable.map)], <[broker:stat/sonoff-S20-1/RESULT:state:ON], <[broker:stat/sonoff-S20-1/POWER:state:ON], <[broker:tele/sonoff-S20-1/STATE:state:ON] \" } default.sitemap: Switch item=S20_1 labelcolor=[S20_1_Reachable == \"ON\" = \"green\",S20_1_Reachable == \"OFF\" = \"red\"]","title":"OpenHab Configuration"},{"location":"devices/Sonoff-S20/#configuration","text":"Once set up and connected, you can set the module type to Sonoff S2X (8) in Configure module .","title":"Configuration"},{"location":"devices/Sonoff-S26-Smart-Socket/","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-s26-smart-plug Itead Shop: https://www.itead.cc/sonoff-s26-wifi-smart-plug.html Serial Connection ~ Please see the Hardware Preparation page for general instructions. LED State ~ The S26 has a red LED connected to GPIO12 along with the relay so it's not possible to disable the power button LED entirely. Setting LedState 0 disables the blue LED when the relay is turned on and reserves it for Wi-Fi/MQTT state only. Soldering guide ~ Apply rosin to shaved wires. Solder tin to the flats on the module.(First put solder tip to flat and apply tin). Gently solder the wires. Alternative solder points available for 3V3, GND and RX on the underside of the mainboard. Jumper Pin J1 3V3 J2 GND J3 GPIO-12 J4 GPIO-0 J5 GPIO-13 J10 RX No Solder Connection ~ With the help of some adhesive tape it is possible to acheive a flash without soldering. Hook your connecting wires / pins into the locations shown on the T1117A regulator - there is enough space under the SOT-223 package pins for a connection to be made. Use some adhesive tape to hold these pins in place; it only needs to remain there for a few minutes. (Vout = 3v3, Pin 1 = GND) Flip the board on its side to expose the TX and RX pins. Follow steps 1-4 below, ignoring the TX/RX connection. Once in flash mode, hold the TX/RX pin connection in place with one hand and start the flash with the other! It looks messy with the tape in the below photo but means no soldering required. S26 Release 2 ~ If you happen to have an S26R2 (sold since the end of 2021?), which is recognizable by the S26R2 label on the back of the case, you may choose to solder or not: Board release v2.6 has a slightly different layout, and connecting to it may be even easier. In the above picture, serial flasher GND is connected to the capacitor, but you may use the GND pad on the board. Bringing the Module into Flash Mode ~ Disconnect serial programmer and power Press and hold the on-board button - Note: The Button on the main board is not very sensitive and must be pressed firmly. Connect the serial programmer (VCC, RX, TX, GND) Release the on-board button The blue LED should NOT be blinking when in Flash mode. Storage/Memory ~ Running Tasmota 6.1.1 the unit reports: Flash Size 1024kB Program Flash Size 1024kB Program Size 536kB Free Program Space 464kB Free Memory 16kB More information ~ See issue #2808 for user information","title":"Sonoff S26 Smart Socket"},{"location":"devices/Sonoff-S26-Smart-Socket/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/Sonoff-S26-Smart-Socket/#led-state","text":"The S26 has a red LED connected to GPIO12 along with the relay so it's not possible to disable the power button LED entirely. Setting LedState 0 disables the blue LED when the relay is turned on and reserves it for Wi-Fi/MQTT state only.","title":"LED State"},{"location":"devices/Sonoff-S26-Smart-Socket/#soldering-guide","text":"Apply rosin to shaved wires. Solder tin to the flats on the module.(First put solder tip to flat and apply tin). Gently solder the wires. Alternative solder points available for 3V3, GND and RX on the underside of the mainboard. Jumper Pin J1 3V3 J2 GND J3 GPIO-12 J4 GPIO-0 J5 GPIO-13 J10 RX","title":"Soldering guide"},{"location":"devices/Sonoff-S26-Smart-Socket/#no-solder-connection","text":"With the help of some adhesive tape it is possible to acheive a flash without soldering. Hook your connecting wires / pins into the locations shown on the T1117A regulator - there is enough space under the SOT-223 package pins for a connection to be made. Use some adhesive tape to hold these pins in place; it only needs to remain there for a few minutes. (Vout = 3v3, Pin 1 = GND) Flip the board on its side to expose the TX and RX pins. Follow steps 1-4 below, ignoring the TX/RX connection. Once in flash mode, hold the TX/RX pin connection in place with one hand and start the flash with the other! It looks messy with the tape in the below photo but means no soldering required.","title":"No Solder Connection"},{"location":"devices/Sonoff-S26-Smart-Socket/#s26-release-2","text":"If you happen to have an S26R2 (sold since the end of 2021?), which is recognizable by the S26R2 label on the back of the case, you may choose to solder or not: Board release v2.6 has a slightly different layout, and connecting to it may be even easier. In the above picture, serial flasher GND is connected to the capacitor, but you may use the GND pad on the board.","title":"S26 Release 2"},{"location":"devices/Sonoff-S26-Smart-Socket/#bringing-the-module-into-flash-mode","text":"Disconnect serial programmer and power Press and hold the on-board button - Note: The Button on the main board is not very sensitive and must be pressed firmly. Connect the serial programmer (VCC, RX, TX, GND) Release the on-board button The blue LED should NOT be blinking when in Flash mode.","title":"Bringing the Module into Flash Mode"},{"location":"devices/Sonoff-S26-Smart-Socket/#storagememory","text":"Running Tasmota 6.1.1 the unit reports: Flash Size 1024kB Program Flash Size 1024kB Program Size 536kB Free Program Space 464kB Free Memory 16kB","title":"Storage/Memory"},{"location":"devices/Sonoff-S26-Smart-Socket/#more-information","text":"See issue #2808 for user information","title":"More information"},{"location":"devices/Sonoff-S31/","text":"\u26a0\ufe0f\ufe0f\ufe0f Do not connect AC power and the serial connection at the same time \ufe0f\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\ufe0f The GND connection of the S31 is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. The GPIOs on this device are connected to AC power , therefore it is not possible to safely add sensors or displays to it. Serial Flashing ~ The S31 is pretty easy to take apart. 1. Pry off the gray cover on the end. 1. Slide off the two rounded corner pieces to reveal the 3 screws. 1. Unscrew the 3 screws. 1. Lift off the cover. 1. There are no through holes. You can solder a piece of header or you can fabricate something using pogo pins and just hold it for the duration of the flashing process. But, be aware that can get tiring if you need to do it multiple times. 1. The pads are labeled, you need VCC, RX, TX, GND. There are two others that also have RX and TX on them. The ones next to the GND pin are not used for flashing. 1. Connect to your serial converter and 3V3. 1. You need to press the switch (GPIO0) before applying power to put into bootloader mode. For exact energy monitoring you might need to calibrate the device . Tinkerman's review of Sonoff S31 Video tutorial by BK Hobby ~","title":"Sonoff S31"},{"location":"devices/Sonoff-S31/#serial-flashing","text":"The S31 is pretty easy to take apart. 1. Pry off the gray cover on the end. 1. Slide off the two rounded corner pieces to reveal the 3 screws. 1. Unscrew the 3 screws. 1. Lift off the cover. 1. There are no through holes. You can solder a piece of header or you can fabricate something using pogo pins and just hold it for the duration of the flashing process. But, be aware that can get tiring if you need to do it multiple times. 1. The pads are labeled, you need VCC, RX, TX, GND. There are two others that also have RX and TX on them. The ones next to the GND pin are not used for flashing. 1. Connect to your serial converter and 3V3. 1. You need to press the switch (GPIO0) before applying power to put into bootloader mode. For exact energy monitoring you might need to calibrate the device . Tinkerman's review of Sonoff S31","title":"Serial Flashing"},{"location":"devices/Sonoff-S31/#video-tutorial-by-bk-hobby","text":"","title":"Video tutorial by BK Hobby"},{"location":"devices/Sonoff-SC/","text":"Serial Connection / Flashing ~ Please see the Hardware Preparation page for general instructions. Flashing the ESP8266 Remove the 4 screws on the bottom. The button is connected to GPIO0. You will have to remove the TX jumper in the board to avoid the ATMega328P to interfere in the upload process. Press and hold the button while powering the board to set the ESP8266 into flashing mode. Note! After flashing you need to set the baudrate to 19200. Don't forget to reconnect the TX jumper after flashing ;)","title":"Sonoff SC"},{"location":"devices/Sonoff-SC/#serial-connection-flashing","text":"Please see the Hardware Preparation page for general instructions. Flashing the ESP8266 Remove the 4 screws on the bottom. The button is connected to GPIO0. You will have to remove the TX jumper in the board to avoid the ATMega328P to interfere in the upload process. Press and hold the button while powering the board to set the ESP8266 into flashing mode. Note! After flashing you need to set the baudrate to 19200. Don't forget to reconnect the TX jumper after flashing ;)","title":"Serial Connection / Flashing"},{"location":"devices/Sonoff-SV/","text":"Sonoff Safe Voltage is almost the same as Sonoff Basic R1. These are the differences between the two: * It can be powered by DC voltage * It has more usable GPIO pins - GPIO4 - GPIO5 - GPIO14 * It has two LED status lights (RED and GREEN) * The traces on the bottom aren't soldered * The GND, TX, RX and 3v3 pins are labeled \u26a0\ufe0f What can the unit handle \u26a0\ufe0f ~ The trace is 2 mm wide. By assuming the PCB trace thickness is 1 oz/ft^2 you can calculate the current: 2A If you are using more than 2A be sure to put more solder on the solder traces. Using Sonoff SV ~ You can use the Sonoff SV in three different ways: 1. Variable DC voltage between 5-24 V ~ By not having the jumper connected in the far left. the voltage regulator is used for the relay. 2. Solid DC voltage 5 V ~ By bridging the two pins you are connecting the 5 V input directly to the relay so you are bypassing the regulator so the relay still gets 5 V 3. \u26a0\ufe0f With AC voltage \u26a0\ufe0f ~ \u26a0\ufe0f \u26a1\ufe0f WARNING ONLY DO THIS WHEN YOU KNOW WHAT YOU ARE DOING. \u26a1\ufe0f \u26a0\ufe0f By removing the two 0 ohm SMD resistors next to the jumper you are disconnecting the voltage input from the logic. By doing this you can switch AC again like the Sonoff Basic. Than You can use the jumpers labeled 5~12 V as your DC voltage for the ESP and relay. Official Sources ~ Itead Product Page: Itead Shop: https://www.itead.cc/sonoff-sv.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_SV","title":"Sonoff SV"},{"location":"devices/Sonoff-SV/#what-can-the-unit-handle","text":"The trace is 2 mm wide. By assuming the PCB trace thickness is 1 oz/ft^2 you can calculate the current: 2A If you are using more than 2A be sure to put more solder on the solder traces.","title":"\u26a0\ufe0f What can the unit handle \u26a0\ufe0f"},{"location":"devices/Sonoff-SV/#using-sonoff-sv","text":"You can use the Sonoff SV in three different ways:","title":"Using Sonoff SV"},{"location":"devices/Sonoff-SV/#official-sources","text":"Itead Product Page: Itead Shop: https://www.itead.cc/sonoff-sv.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_SV","title":"Official Sources"},{"location":"devices/Sonoff-Slampher/","text":"See this article: Tasmota: Sonoff Slampher WiFi Bulb Holder Local Control (external link) I purchased a Sonoff Slampher V2 in July, 2020. The circuit board didn't match either/any of the tutorial for getting the original or V2 devices into programming mode. Though it's labeled \"V2\", the cluster of resistors/capacitors around the CPU is different; in particular the resistor at the position indicated by many of the tutorials as labelled r9 , is instead labelled r18 . There does seem to be a trace attached to the GPIO0 pin on the CPU but it leads to a dead end (perhaps a via to the other side of the board). After much screwing around, I discovered that simply holding the button while I connected to the four header pins and powered it on put it into programming mode. I flashed it from a mac terminal window like so: esptool.py --port /dev/tty.usbserial-A60226NF write_flash -fs 1MB -fm dout 0x0 ~/Downloads/tasmota.bin The barcode on the box for the device that I received is 6920075757361, it's also labeled with MPN:IM190528001. I purchased the device from Amazon, it was titled SONOFF Slampher R2 433MHz RF&WiFi Smart Lamp Bulb Holder for Smart Home, Compatible with Alexa and Google Assistant and was at this URL: https://www.amazon.com/gp/product/B07TRSYJGB","title":"Sonoff Slampher"},{"location":"devices/Sonoff-T1/","text":"Sonoff-T1 seems to be an evolution of Sonoff Touch and exists in one, two or three button variations and contains a 433MHz receiver. Based on the ESP8285, but using a Silabs EFM8BB1 microcontroller to extend the number of IOs needed to control 3 buttons, with separate relays and LEDs together with the radio. SYN470R is used as 433Mhz Radio. The chip for touch is unlabeled. EFM8BB1 Data Sheet ESP8285 Data Sheet SYN470R Data Sheet Read before flashing ~ Tasmota has functionality to perform special actions on multiple button presses and long press for 40 seconds resets firmware to default. This will cause the T1 board to reset if relay board is not connected, because long press on Button1 will be detected. To avoid this, use command SetOption13 1 immediately after flashing Tasmota. When powered solely with 3.3v from the serial-to-USB adapter long press will be detected by Tasmota on Button1. When powered solely with 3.3v from the serial-to-USB adapter RF functions do not work. If you can't flash succesfully lower the baud rate, most likely to 74880 . Serial Flashing ~ Sonoff T1 UK ~ The front circuit board should be disconnected from the rear relay board to prevent power draw upsetting the flashing process. The unit must be powered up before attempting to enter programming mode. If touch Button1 is held while power is connected, the device will not go enter flash mode. The touch IC does not have time to recognise the key-press before the device boots. Touch Board VER:1 ~ The following board layouts are from the 3 variants of the Sonoff T1 UK variant and are marked Sonoff T1 R2 UK Touch Board, Ver 1.0. Entering Flashing mode varies between the 1, 2 and 3 channel versions. See the above picture for button nomenclature used. (The variations between the 3 versions appear to be managed by the touch IC rather than in the ESP). To enter flashing mode the unit should be powered and connected to the programmer of choice. Touch Button 1 should then be held while the reset button (4) is pressed. When the device reboots, Button 1 can be released. OR Double-press the reset-button Try option 1 OR option 2. This will cause the unit to reboot into flash mode. This is confirmed on a serial console (74880 baud) by the boot mode displaying (1,x) indicating that we are booted to the bootloader and not the flash. You can also confirm booted to flash without a serial console, the main led should be off and the backlight LEDs lit dimly. There is no longer a need to solder anything to GPIO0 or to ground it while powering up for Ver1.0; this step is replaced by the above button sequence. However, GPIO0 to GND is the only way for Ver1.1 boards. Touch Board Ver:1.1 ~ Notes: 1. There is not enough room with this version to solder header pins to the programming port and still close the case. One possibility is to slightly bend the pins of a 4-way header and push it into the holes, removing it after programming. 2. GPIO0 is connected to the helper chip on this version, so the only way to get Ver1.1 of the board into flash mode is to solder a lead onto the resistor R19 from pin 15 on the ESP chip (GPIO0) and connect this lead to GND on power up; the device will set all the touch pads to dim and the WiFi LED D3 will NOT be on at all. 3. The connection marked 'LOG' on the J3 header is GPIO2. WARNING!! Do not attempt to power the device from your serial-to-USB adapter when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and reset all the configured settings. Sonoff T1 EU ~ For most devices, the UK version flashing guide may work. Sonoff T1 EU 1CH (2018-06-04) ~ All the flashing pins are in the front top right corner (sorry about covering them with the wires). From top to bottom: - LOG (GPIO2 not used) - GND - TXD - RXD - VCC To flash simply connect GND, TXD, RXD, and VCC as any regular ESP. Hold the touch button, press reset at once, then it boots into flash mode (no blinking WiFi LED, dimmed touch button). If this does not work, try shorting R19 to GND as shown in \"Touch Board VER:1.1\" * Stock baud rate: 74880 * Relay pin: 0 Sonoff T1 EU 2CH (v1.0) ~ For 2 Channel board version 1.0 , you need to solder (or otherwise permanently connect) GPIO0 (R19) to GND before powering the board and only disconnect them once the flashing is complete. After having connected GPIO0 and GND, power the board - it will boot directly to flashing mode. Flash your firmware and disconnect the board. Sonoff T1 EU 1CH/2CH/3CH (2018-10-03) ~ There are two pin headers (J1 and J3) and no reset button. J3 is used for flashing. GPIO0 is exposed on the back as test point (TP2/GPIO0). Connecting it to any ground such as the ground from J1 when powering up puts the ESP8255 into flash mode. Baud rate for flashing is 74880. Sonoff T1 US ~ It appears that SonOTA may work again with Sonoff firmware v2.0.1 or greater . This needs to be verified for this specific device. To get it working you can simply plug it to mains, once it's powered up, press and hold the button that's closer to the Wi-Fi logo (you'll hear a beep sound). Keep holding it until you hear that beep for the second time. Now let go. The Wi-Fi light should blink in pairs of 3. Now repeat the procedure (Press and hold until you hear the beep 2 times). Now you should be seeing the Wi-Fi logo flashing rapidly. You can proceed to try and flash with SonOTA now. US Model of 3-button T1, received direct from Sonoff China 2018-05-12 ~ Front photo (Google photos) Rear photo (Google photos) (Sorry about the tape smudges). The header labels on J3 are accurate (apparently some boards have TX and RX reversed; this doesn't seem to suffer that). Flashed with SonOTA . Above method of getting into flash mode doesn't seem to work. UPDATE: I did flash it with the FTDI method. To put then in flash mode press 2 times quickly the internal switch S1. UPDATE 2: Confirmed by another user that flashed with SonOTA works as described on \"Preparing\" Sonoff T1 US 3 Gang ~ The jump-wire method to enter the flash mode: * Jump the wire as attached picture * While keeping the wire connected then plug the serial-to-USB adapter to the computer * Wait for 1 to 2 seconds then release the jump-wire * You can start flashing the Sonoff T1 US 3C. Sonoff TX US 2/3 Gang ~ The PCB layout for the TX/T0 model (vertical, black or white face-plate with squared-off, LED-lit buttons) is different again from the original T1. There is no TP2/GPIO0 test point on the back of the PCB and R19 has moved. The basic instructions for flashing the T1 (with a USB adapter) still work. ~ It seems that Sonoff is trying to seal off the ESP using some glue see image: 433MHz remote ~ The Tasmota firmware is compatible with the RF remote feature built in to the T1 modules. Pairing a new remote is the same procedure as a stock Sonoff, i.e., hold the desired button on your sonoff until you are given 1 beep (approx 7 seconds), press the button on your RF remote. The Sonoff will beep to confirm the pairing. To unpair a remote, press until you are given 2 beeps, press the button on your RF remote. The Sonoff will beep to confirm the unpairing. Circuit ~ ESP8285 GPIO0 EFM8BB1 P1,3 Switch 1 input (Goes low when first touch button is pressed) GPIO04 is connected to the small (soft) reset button on the front. GPIO09 EFM8BB1 P1,4 - Switch 3 input (Goes low when third touch button is pressed) GPIO10 EFM8BB1 P1,5 - Switch 2 input GPIO13 is connected to status LED D3. GPIO12 Relay 1 GPIO5 Relay 2 GPIO4 Relay 3 GPIO2 is connected on J3 pin 5 (LOG) On the EFM8BB1 (QFN20 package) P0,0 Relay 1 P0,1 Relay 2 P0,2 Relay 3 P0,3 Button 1 P0,4 Button 2 P0,5 Button 3 P0,6 SYN470R Data Out P0,7 Buzzer P1,0 Led button 1 P1,1 Led button 2 P1,2 Led button 3 P1,3 ESP8285 GPIO0 P1,4 ESP8285 GPIO09 P1,5 ESP8285 GPIO10 P1,6 ESP8285 EXT_RSTB (RESET) Ghost Switching ~ Some of these devices are prone to hardware ghost switching. You may need to experiment with ButtonDebounce and SetOption40 to reduce or eliminate these issues. Also, during the flashing process, you may have soldered a lead to GPIO0 in order to connect it to GND for putting the ESP into programming mode. If there are any random oscillations on GPIO0, this can trigger the relay. The contacts on the PCB are very close together. Check that you don't have any stray solder to another contact. Even if there isn't contact, over time heat and humidity can cause any residual flux to become resistive and allow conductivity. Be sure to clean everything after removing any leads. Known so far ~ When pushing a button, the touch chip lift the power high to the EFM8BB1, and the EFM8BB1 chip ties the signal line for each button low, for the full duration of the keypress. Debouncing is not needed. 433MHz remotes are compatible with the Tasmota firmware DO NOT attempt to power the device from your programmer when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and will reset all the configured settings. The relays state can be set on the GPIO's 12, 5 and 4. The switch status can be read on GPIO's 0, 10 and 9. Push button active low. Unknown so far ~ Where GPIO15 is connected? Over R18 10kOhm pull-down only? Official Sources ~ Sonoff T1 UK ~ Itead Product Page Itead Shop The Sonoff T1 UK with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1. Sonoff T1 EU ~ Itead Product Page Itead Shop The Sonoff T1 EU with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1. Sonoff T1 US ~ Itead Product Page Itead Shop The Sonoff T1 US with 1 to 3 gang was launched March 2018. Sonoff TX US ~ Itead Product Page Itead Shop","title":"Sonoff T1"},{"location":"devices/Sonoff-T1/#read-before-flashing","text":"Tasmota has functionality to perform special actions on multiple button presses and long press for 40 seconds resets firmware to default. This will cause the T1 board to reset if relay board is not connected, because long press on Button1 will be detected. To avoid this, use command SetOption13 1 immediately after flashing Tasmota. When powered solely with 3.3v from the serial-to-USB adapter long press will be detected by Tasmota on Button1. When powered solely with 3.3v from the serial-to-USB adapter RF functions do not work. If you can't flash succesfully lower the baud rate, most likely to 74880 .","title":"Read before flashing"},{"location":"devices/Sonoff-T1/#serial-flashing","text":"","title":"Serial Flashing"},{"location":"devices/Sonoff-T1/#sonoff-t1-uk","text":"The front circuit board should be disconnected from the rear relay board to prevent power draw upsetting the flashing process. The unit must be powered up before attempting to enter programming mode. If touch Button1 is held while power is connected, the device will not go enter flash mode. The touch IC does not have time to recognise the key-press before the device boots.","title":"Sonoff T1 UK"},{"location":"devices/Sonoff-T1/#touch-board-ver1","text":"The following board layouts are from the 3 variants of the Sonoff T1 UK variant and are marked Sonoff T1 R2 UK Touch Board, Ver 1.0. Entering Flashing mode varies between the 1, 2 and 3 channel versions. See the above picture for button nomenclature used. (The variations between the 3 versions appear to be managed by the touch IC rather than in the ESP). To enter flashing mode the unit should be powered and connected to the programmer of choice. Touch Button 1 should then be held while the reset button (4) is pressed. When the device reboots, Button 1 can be released. OR Double-press the reset-button Try option 1 OR option 2. This will cause the unit to reboot into flash mode. This is confirmed on a serial console (74880 baud) by the boot mode displaying (1,x) indicating that we are booted to the bootloader and not the flash. You can also confirm booted to flash without a serial console, the main led should be off and the backlight LEDs lit dimly. There is no longer a need to solder anything to GPIO0 or to ground it while powering up for Ver1.0; this step is replaced by the above button sequence. However, GPIO0 to GND is the only way for Ver1.1 boards.","title":"Touch Board VER:1"},{"location":"devices/Sonoff-T1/#touch-board-ver11","text":"Notes: 1. There is not enough room with this version to solder header pins to the programming port and still close the case. One possibility is to slightly bend the pins of a 4-way header and push it into the holes, removing it after programming. 2. GPIO0 is connected to the helper chip on this version, so the only way to get Ver1.1 of the board into flash mode is to solder a lead onto the resistor R19 from pin 15 on the ESP chip (GPIO0) and connect this lead to GND on power up; the device will set all the touch pads to dim and the WiFi LED D3 will NOT be on at all. 3. The connection marked 'LOG' on the J3 header is GPIO2. WARNING!! Do not attempt to power the device from your serial-to-USB adapter when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and reset all the configured settings.","title":"Touch Board Ver:1.1"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu","text":"For most devices, the UK version flashing guide may work.","title":"Sonoff T1 EU"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-1ch-2018-06-04","text":"All the flashing pins are in the front top right corner (sorry about covering them with the wires). From top to bottom: - LOG (GPIO2 not used) - GND - TXD - RXD - VCC To flash simply connect GND, TXD, RXD, and VCC as any regular ESP. Hold the touch button, press reset at once, then it boots into flash mode (no blinking WiFi LED, dimmed touch button). If this does not work, try shorting R19 to GND as shown in \"Touch Board VER:1.1\" * Stock baud rate: 74880 * Relay pin: 0","title":"Sonoff T1 EU 1CH (2018-06-04)"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-2ch-v10","text":"For 2 Channel board version 1.0 , you need to solder (or otherwise permanently connect) GPIO0 (R19) to GND before powering the board and only disconnect them once the flashing is complete. After having connected GPIO0 and GND, power the board - it will boot directly to flashing mode. Flash your firmware and disconnect the board.","title":"Sonoff T1 EU 2CH (v1.0)"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-1ch2ch3ch-2018-10-03","text":"There are two pin headers (J1 and J3) and no reset button. J3 is used for flashing. GPIO0 is exposed on the back as test point (TP2/GPIO0). Connecting it to any ground such as the ground from J1 when powering up puts the ESP8255 into flash mode. Baud rate for flashing is 74880.","title":"Sonoff T1 EU 1CH/2CH/3CH (2018-10-03)"},{"location":"devices/Sonoff-T1/#sonoff-t1-us","text":"It appears that SonOTA may work again with Sonoff firmware v2.0.1 or greater . This needs to be verified for this specific device. To get it working you can simply plug it to mains, once it's powered up, press and hold the button that's closer to the Wi-Fi logo (you'll hear a beep sound). Keep holding it until you hear that beep for the second time. Now let go. The Wi-Fi light should blink in pairs of 3. Now repeat the procedure (Press and hold until you hear the beep 2 times). Now you should be seeing the Wi-Fi logo flashing rapidly. You can proceed to try and flash with SonOTA now.","title":"Sonoff T1 US"},{"location":"devices/Sonoff-T1/#us-model-of-3-button-t1-received-direct-from-sonoff-china-2018-05-12","text":"Front photo (Google photos) Rear photo (Google photos) (Sorry about the tape smudges). The header labels on J3 are accurate (apparently some boards have TX and RX reversed; this doesn't seem to suffer that). Flashed with SonOTA . Above method of getting into flash mode doesn't seem to work. UPDATE: I did flash it with the FTDI method. To put then in flash mode press 2 times quickly the internal switch S1. UPDATE 2: Confirmed by another user that flashed with SonOTA works as described on \"Preparing\"","title":"US Model of 3-button T1, received direct from Sonoff China 2018-05-12"},{"location":"devices/Sonoff-T1/#sonoff-t1-us-3-gang","text":"The jump-wire method to enter the flash mode: * Jump the wire as attached picture * While keeping the wire connected then plug the serial-to-USB adapter to the computer * Wait for 1 to 2 seconds then release the jump-wire * You can start flashing the Sonoff T1 US 3C.","title":"Sonoff T1 US 3 Gang"},{"location":"devices/Sonoff-T1/#sonoff-tx-us-23-gang","text":"The PCB layout for the TX/T0 model (vertical, black or white face-plate with squared-off, LED-lit buttons) is different again from the original T1. There is no TP2/GPIO0 test point on the back of the PCB and R19 has moved. The basic instructions for flashing the T1 (with a USB adapter) still work.","title":"Sonoff TX US 2/3 Gang"},{"location":"devices/Sonoff-T1/#_1","text":"It seems that Sonoff is trying to seal off the ESP using some glue see image:","title":""},{"location":"devices/Sonoff-T1/#433mhz-remote","text":"The Tasmota firmware is compatible with the RF remote feature built in to the T1 modules. Pairing a new remote is the same procedure as a stock Sonoff, i.e., hold the desired button on your sonoff until you are given 1 beep (approx 7 seconds), press the button on your RF remote. The Sonoff will beep to confirm the pairing. To unpair a remote, press until you are given 2 beeps, press the button on your RF remote. The Sonoff will beep to confirm the unpairing.","title":"433MHz remote"},{"location":"devices/Sonoff-T1/#circuit","text":"ESP8285 GPIO0 EFM8BB1 P1,3 Switch 1 input (Goes low when first touch button is pressed) GPIO04 is connected to the small (soft) reset button on the front. GPIO09 EFM8BB1 P1,4 - Switch 3 input (Goes low when third touch button is pressed) GPIO10 EFM8BB1 P1,5 - Switch 2 input GPIO13 is connected to status LED D3. GPIO12 Relay 1 GPIO5 Relay 2 GPIO4 Relay 3 GPIO2 is connected on J3 pin 5 (LOG) On the EFM8BB1 (QFN20 package) P0,0 Relay 1 P0,1 Relay 2 P0,2 Relay 3 P0,3 Button 1 P0,4 Button 2 P0,5 Button 3 P0,6 SYN470R Data Out P0,7 Buzzer P1,0 Led button 1 P1,1 Led button 2 P1,2 Led button 3 P1,3 ESP8285 GPIO0 P1,4 ESP8285 GPIO09 P1,5 ESP8285 GPIO10 P1,6 ESP8285 EXT_RSTB (RESET)","title":"Circuit"},{"location":"devices/Sonoff-T1/#ghost-switching","text":"Some of these devices are prone to hardware ghost switching. You may need to experiment with ButtonDebounce and SetOption40 to reduce or eliminate these issues. Also, during the flashing process, you may have soldered a lead to GPIO0 in order to connect it to GND for putting the ESP into programming mode. If there are any random oscillations on GPIO0, this can trigger the relay. The contacts on the PCB are very close together. Check that you don't have any stray solder to another contact. Even if there isn't contact, over time heat and humidity can cause any residual flux to become resistive and allow conductivity. Be sure to clean everything after removing any leads.","title":"Ghost Switching"},{"location":"devices/Sonoff-T1/#known-so-far","text":"When pushing a button, the touch chip lift the power high to the EFM8BB1, and the EFM8BB1 chip ties the signal line for each button low, for the full duration of the keypress. Debouncing is not needed. 433MHz remotes are compatible with the Tasmota firmware DO NOT attempt to power the device from your programmer when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and will reset all the configured settings. The relays state can be set on the GPIO's 12, 5 and 4. The switch status can be read on GPIO's 0, 10 and 9. Push button active low.","title":"Known so far"},{"location":"devices/Sonoff-T1/#unknown-so-far","text":"Where GPIO15 is connected? Over R18 10kOhm pull-down only?","title":"Unknown so far"},{"location":"devices/Sonoff-T1/#official-sources","text":"","title":"Official Sources"},{"location":"devices/Sonoff-T1/#sonoff-t1-uk_1","text":"Itead Product Page Itead Shop The Sonoff T1 UK with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1.","title":"Sonoff T1 UK"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu_1","text":"Itead Product Page Itead Shop The Sonoff T1 EU with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1.","title":"Sonoff T1 EU"},{"location":"devices/Sonoff-T1/#sonoff-t1-us_1","text":"Itead Product Page Itead Shop The Sonoff T1 US with 1 to 3 gang was launched March 2018.","title":"Sonoff T1 US"},{"location":"devices/Sonoff-T1/#sonoff-tx-us","text":"Itead Product Page Itead Shop","title":"Sonoff TX US"},{"location":"devices/Sonoff-TH/","text":"Sonoff TH10 or TH16 / Ver 2.0 (year 2017/2018/2019) based on ESP8266. TH10 has a relay rated to 10 amps and TH16 to 16 amps (Input voltage: 90~ 250V AC). Serial Flashing ~ The 2.5mm jack socket connects to GPIO14. In PCB Ver 2.1 you can find a fifth pin next to the serial pins, labeled EXP-LOG . You can use this as GPIO2 to any generic purpose. Currently should make a custom template for it. Sonoff sensors with 2.5mm jack ~ Sonoff sells 3 sensors with 2.5mm jack to use with the Sonoff TH. 1. Sonoff TH Sensor Si7021 2. Sonoff TH Sensor AM2301 3. Sonoff Temp Sensor DS18B20 Length of the wire is approximately 47cm apart from DS18b20 sensor that comes with approximately 1m long wire. Can be extended with a Sonoff 5m sensor extension cable. NOTE!!! Normally a Si7021 sensor is an I 2 C device. The Sonoff labelled Si7021 sensor is BASED on an Si7021, but, to make this sensor plug'n'play on a Sonoff TH an 8-bit MCU is added on the board. This changes the I 2 C communication of an Si7021 sensor to one-wire communication! That is why a \"Sonoff SI7021 sensor\" doesn't work in combination with a I 2 C library. Tasmota supports Sonoff TH with all three Sonoff sensors. Just select module Sonoff TH (4) and under GPIO14 configure the sensor you have connected. NOT SUPPORTED ~ Si7021 sensor contains an integrated resistive heating element that may be used to drive off condensation. It's recommended enabling the heater when the humidity readings are above 80%. Humidity readings above 80% become very unreliable. If the \"Sonoff Si7021 sensor\" is used at the dew point and condensation occurs on the sensor, the on-chip heater could be activated to dry the sensor and restore operation once the sensor is above the dew point. Turning on the heater will also reduce the tendency of the humidity sensor to accumulate an offset due to \"memory\" of sustained high humidity conditions. Six different power levels are available. The maximum source current of a GPIO pin on an ESP8266 is about 12mA. So the first power level of 3.09mA and second power level of 9.18mA would be theoretically usable. Keep that in mind if you use this \"Sonoff Si7021 sensor\" outdoors! Si7021 Datasheet Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff TH"},{"location":"devices/Sonoff-TH/#serial-flashing","text":"The 2.5mm jack socket connects to GPIO14. In PCB Ver 2.1 you can find a fifth pin next to the serial pins, labeled EXP-LOG . You can use this as GPIO2 to any generic purpose. Currently should make a custom template for it.","title":"Serial Flashing"},{"location":"devices/Sonoff-TH/#sonoff-sensors-with-25mm-jack","text":"Sonoff sells 3 sensors with 2.5mm jack to use with the Sonoff TH. 1. Sonoff TH Sensor Si7021 2. Sonoff TH Sensor AM2301 3. Sonoff Temp Sensor DS18B20 Length of the wire is approximately 47cm apart from DS18b20 sensor that comes with approximately 1m long wire. Can be extended with a Sonoff 5m sensor extension cable. NOTE!!! Normally a Si7021 sensor is an I 2 C device. The Sonoff labelled Si7021 sensor is BASED on an Si7021, but, to make this sensor plug'n'play on a Sonoff TH an 8-bit MCU is added on the board. This changes the I 2 C communication of an Si7021 sensor to one-wire communication! That is why a \"Sonoff SI7021 sensor\" doesn't work in combination with a I 2 C library. Tasmota supports Sonoff TH with all three Sonoff sensors. Just select module Sonoff TH (4) and under GPIO14 configure the sensor you have connected.","title":"Sonoff sensors with 2.5mm jack"},{"location":"devices/Sonoff-TH/#not-supported","text":"Si7021 sensor contains an integrated resistive heating element that may be used to drive off condensation. It's recommended enabling the heater when the humidity readings are above 80%. Humidity readings above 80% become very unreliable. If the \"Sonoff Si7021 sensor\" is used at the dew point and condensation occurs on the sensor, the on-chip heater could be activated to dry the sensor and restore operation once the sensor is above the dew point. Turning on the heater will also reduce the tendency of the humidity sensor to accumulate an offset due to \"memory\" of sustained high humidity conditions. Six different power levels are available. The maximum source current of a GPIO pin on an ESP8266 is about 12mA. So the first power level of 3.09mA and second power level of 9.18mA would be theoretically usable. Keep that in mind if you use this \"Sonoff Si7021 sensor\" outdoors! Si7021 Datasheet","title":"NOT SUPPORTED"},{"location":"devices/Sonoff-TH/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-TX-Series/","text":"The sonoff TX Series comes with 4 versions T0, T1, T2, T3 The boards are the same for all the series with only a difference in the T0 which has no RF chip Flashing ~ The flashing steps are the same than for the older T1 switch but holding switch 1 does not put the board into flashing mode and there is no reset button on the board So to put a T1 Touch v1.0 board into flash mode you need to ground GPIO 0 which is exposed on the back of the board and plug the board to USB Here is an image of the wiring Legend: * Yellow => 3.3v * Purple => GND * Green => TX FTDI to RX sonoff * Blue => RX FTDI to TX sonoff If the manipulation is done correctly the Wifi led will not blink when the device is powered, this means you are in flash mode and you can follow the other guide","title":"Sonoff TX Series"},{"location":"devices/Sonoff-TX-Series/#flashing","text":"The flashing steps are the same than for the older T1 switch but holding switch 1 does not put the board into flashing mode and there is no reset button on the board So to put a T1 Touch v1.0 board into flash mode you need to ground GPIO 0 which is exposed on the back of the board and plug the board to USB Here is an image of the wiring Legend: * Yellow => 3.3v * Purple => GND * Green => TX FTDI to RX sonoff * Blue => RX FTDI to TX sonoff If the manipulation is done correctly the Wifi led will not blink when the device is powered, this means you are in flash mode and you can follow the other guide","title":"Flashing"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/","text":"June 2019 - Devices delivered with Sonoff v3.3.0 stock firmware. Product page Banggood Serial flashing works for this device. You may wish to check whether the Sonoff DIY flashing method works if this device is upgraded to v3.3.1. Board label: T0US TOUCH v1.0 2008.11.15 TX T0 US, 1-3CH boards are physically the same. Only need the \"top board\" to flash (not the bottom relay part) -- don't power with mains (you can't if you only use top anyway) R19 is tied to GPIO 0 to enter flash mode, just like on T1 but in a different spot for t0 (or US?). Find the C2 (j1) pins and look directly up about half inch for r19 Ensure that you select 3.3v and not 5v! to flash the board. ESP8285 - 1M - DOUT - erase flash - 115200 baud Like the T1, this does not have enough room to solder a header on. Use a piece of thick cardboard to lay your top board on. Firmly press some jumpers through the serial holes into the cardboard. If you push these through at an angle will be good enough to make contact to connect to your serial adaptor, trial and error but is not hard. See photo below. Regular flashing steps apply: connect Ground, Vcc TX, RX to your serial adaptor. Pay attention to TX/RX! For flash mode, use another jumper through the ground hole on the C2 pins (left of the serial and label J1). Same as above, push the jumper through cardboard to secure it. While powered off hold the other end of jumper to R19 and then power up (plug in your USB serial adaptor). Hold it for 3-5 seconds after it powers up before removing it. You should not see the network status led flash anymore, then you know you're in flash mode. If its flashing power off and try again. Using the TX T1 1-3 device template will work. A new T0 template is forthcoming. Start-to-Finish Flashing Guide ~ Flashing ~ Connect the device's serial interface pins to the Serial-to-USB adapter . Be sure that your adapter is set to supply 3.3v . Place a jumper wire from GND to the side of R19 nearest the screw hole cutout - this is connected to GPIO0. Download tasmota.bin from http://ota.tasmota.com/tasmota Have Flashing tool running with the correct settings. Be sure to select DOUT and Erase flash - yes . Select the right COM port for your serial-to-USB adapter and select tasmota.bin from the folder where you downloaded the file. Plug the serial adapter into the USB port and click the Flash button on Tasmota PyFlasher . When you get the flash complete, remove the GND jumper wire from GPIO0. Cycle power on your device by disconnecting the serial adapter from the USB port for a couple of seconds and plugging it back in. IP Configuration ~ Using a mobile device, scan for Wi-Fi networks and connect to the sonoff-xxxx access point. When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Open the browser on your mobile device and navigate to http://192.168.4.1. In the Tasmota web UI, scan wifi networks and select the network for your home. Then enter the network's password ( click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered ). When you save the settings, the device will restart and connect to your home network. The sonoff-xxxx network will not longer be present. Therefore your mobile device will automatically be disconnected and should connect back to its data network. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Make not of the IP address assigned to your device. MQTT Configuration ~ Go to new IP address (http:// IP ) in a browser. Click Configuration->Configure MQTT-> MQTT Host: Enter the address (192.168.xx.yy or Hostname) of your MQTT broker. If you use the Home Assistant embedded broker, this will be your HA server. User: Enter the username for your MQTT broker Password: Enter the password for your MQTT broker Topic: Enter the unique MQTT topic for your device Save your settings. The device will restart Device Configuration ~ Click Configuration->Configure Module->Module Type->Sonoff T1 3CH (30) (the appropriate module for your device model) and save. The device will restart. Test the operation of the switches from the web UI. You should hear the relays click. Click Console If you use Home Assistant, enter SetOption19 1 to enable device auto-discovery. Check the log for any errors. Reassemble the switch and connect it to mains power. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Also use the Tasmota web UI to ensure the switch is operating as expected. Home Assistant Configuration ~ Open TasmoAdmin via Hassio and Autoscan In Name1->Name3 enter switch position names again (note: understand orientation of switch) Go to \u2018Devices List\u2019 and check/test buttons click Click Cog configuration and enter names again and save Click Cog configuration, go to MQTT and change Group Topic to swtheatre and save Go to Devices List again and the circle arrows to restart the device Go to Integrations->MQTT and find the new switch and rename/locate items accordingly","title":"Sonoff TX T0 Touch 1CH 2CH 3CH    US"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#start-to-finish-flashing-guide","text":"","title":"Start-to-Finish Flashing Guide"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#flashing","text":"Connect the device's serial interface pins to the Serial-to-USB adapter . Be sure that your adapter is set to supply 3.3v . Place a jumper wire from GND to the side of R19 nearest the screw hole cutout - this is connected to GPIO0. Download tasmota.bin from http://ota.tasmota.com/tasmota Have Flashing tool running with the correct settings. Be sure to select DOUT and Erase flash - yes . Select the right COM port for your serial-to-USB adapter and select tasmota.bin from the folder where you downloaded the file. Plug the serial adapter into the USB port and click the Flash button on Tasmota PyFlasher . When you get the flash complete, remove the GND jumper wire from GPIO0. Cycle power on your device by disconnecting the serial adapter from the USB port for a couple of seconds and plugging it back in.","title":"Flashing"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#ip-configuration","text":"Using a mobile device, scan for Wi-Fi networks and connect to the sonoff-xxxx access point. When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Open the browser on your mobile device and navigate to http://192.168.4.1. In the Tasmota web UI, scan wifi networks and select the network for your home. Then enter the network's password ( click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered ). When you save the settings, the device will restart and connect to your home network. The sonoff-xxxx network will not longer be present. Therefore your mobile device will automatically be disconnected and should connect back to its data network. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Make not of the IP address assigned to your device.","title":"IP Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#mqtt-configuration","text":"Go to new IP address (http:// IP ) in a browser. Click Configuration->Configure MQTT-> MQTT Host: Enter the address (192.168.xx.yy or Hostname) of your MQTT broker. If you use the Home Assistant embedded broker, this will be your HA server. User: Enter the username for your MQTT broker Password: Enter the password for your MQTT broker Topic: Enter the unique MQTT topic for your device Save your settings. The device will restart","title":"MQTT Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#device-configuration","text":"Click Configuration->Configure Module->Module Type->Sonoff T1 3CH (30) (the appropriate module for your device model) and save. The device will restart. Test the operation of the switches from the web UI. You should hear the relays click. Click Console If you use Home Assistant, enter SetOption19 1 to enable device auto-discovery. Check the log for any errors. Reassemble the switch and connect it to mains power. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Also use the Tasmota web UI to ensure the switch is operating as expected.","title":"Device Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#home-assistant-configuration","text":"Open TasmoAdmin via Hassio and Autoscan In Name1->Name3 enter switch position names again (note: understand orientation of switch) Go to \u2018Devices List\u2019 and check/test buttons click Click Cog configuration and enter names again and save Click Cog configuration, go to MQTT and change Group Topic to swtheatre and save Go to Devices List again and the circle arrows to restart the device Go to Integrations->MQTT and find the new switch and rename/locate items accordingly","title":"Home Assistant Configuration"},{"location":"devices/Sonoff-Touch/","text":"Itead Product Page Itead Shop Itead Wiki: (n/a) Unlike most Sonoff modules, the Sonoff Touch is based on the ESP8285 rather than the ESP8266. The actual chip inside may be a PSF-A85 . Serial Connection ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. Carefully remove the top PCB from the assembly. The hidden underside of the PCB contains the ESP8285 as shown in the pictures. The four serial pins (3V3, Rx, Tx, GND) can be seen in the pictures for the US version (left) and the EU version (right) of the module PCB. Be careful while removing and reassembling the top PCB. The touch sensor should be back in its intended place. Be sure to not touch it directly during the modifications. The Sonoff Touch button is not connected to GPIO0 and hence cannot be used to bring the module into Programming Mode . A connection between GPIO0 and GND needs to be made manually. GPIO0 can be found on the right side of the ESP8285 and is the second pin from the bottom, as can be seen on the pictures. Note: Even if you have the PSF-A85 chip inside instead of a default ESP8285, the GPIO0 pin is in the same location. Pay attention to the corner of the chip with three unused solder contacts. That is where the external antenna connector is located in the images above. The PSF-A85 in the Sonoff Touch does not have the external antenna connector soldered on. Control ON/OFF Leds on Sonoff Touch solution ~ Solder the switch LED where the Wi-Fi LED is and then you can control the LED by using the command LedPower ON . The Switch LED is on all the time, even when the switch is off so you can easily find the switch in the dark. Alternatively, you can solder the switch LED on 3.3v and ground but then you can't control the LED, it is always on and very bright.","title":"Sonoff Touch"},{"location":"devices/Sonoff-Touch/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. Carefully remove the top PCB from the assembly. The hidden underside of the PCB contains the ESP8285 as shown in the pictures. The four serial pins (3V3, Rx, Tx, GND) can be seen in the pictures for the US version (left) and the EU version (right) of the module PCB. Be careful while removing and reassembling the top PCB. The touch sensor should be back in its intended place. Be sure to not touch it directly during the modifications. The Sonoff Touch button is not connected to GPIO0 and hence cannot be used to bring the module into Programming Mode . A connection between GPIO0 and GND needs to be made manually. GPIO0 can be found on the right side of the ESP8285 and is the second pin from the bottom, as can be seen on the pictures. Note: Even if you have the PSF-A85 chip inside instead of a default ESP8285, the GPIO0 pin is in the same location. Pay attention to the corner of the chip with three unused solder contacts. That is where the external antenna connector is located in the images above. The PSF-A85 in the Sonoff Touch does not have the external antenna connector soldered on.","title":"Serial Connection"},{"location":"devices/Sonoff-Touch/#control-onoff-leds-on-sonoff-touch-solution","text":"Solder the switch LED where the Wi-Fi LED is and then you can control the LED by using the command LedPower ON . The Switch LED is on all the time, even when the switch is off so you can easily find the switch in the dark. Alternatively, you can solder the switch LED on 3.3v and ground but then you can't control the LED, it is always on and very bright.","title":"Control ON/OFF Leds on Sonoff Touch solution"},{"location":"devices/Sonoff-iFan02/","text":"The Sonoff iFan02 is supported in Tasmota from version 6.0.0b Itead Product Page Itead Shop Itead iFan02 Schematics Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Flashing using only a USB to serial converter will not work as the unit draws too much current as can be observed by a flashing blue led on the PCA and a lot of serial gibberish. As AC is not connected to Gnd I used the available power supply of the unit and connecting the USB to serial converter to J3 pins Gnd, Tx and Rx. The button is not connected to GPIO0 so flashing the unit requires some extra work. I managed to flash the iFan02 by soldering a wire to TP16 (GPIO00) on the bottom of the PCA. Keep this wire connected to Gnd during the power-on or reset process (pressing the button) and the unit will be in firmware upgrade mode. If you've soldered the gpio0 connection don't forget to unsolder before booting normally. Connect RX -> TX | 3.3 -> 3.3 | TX -> RX | GND -> GND and connect TP16 to GND (as used in the TTL). Press and hold the button while connecting to power. If you have an Arduino you may be able to flash without providing an additional power source. I have successfully flashed using an Arduino Duemilanove with the atmel chip pulled out (basically using it for FTDI and 3.3v power regulation). Rx on Arduino goes to Rx on iFan02, Tx to Tx (no crossover like with FTDI). I did not have to press the button, only to ground TP16 while initiating the flash in Arduino IDE. The Arduino provides enough power to flash, however it will not boot into Tasmota unless you plug in to external power (it boot loops after flashing is complete). Additonal information ~ See issue #2839 for user information See issue #3412 light on after restore power Functioning iFan02 in Tasmota WebUI iFan02 PCA with TP16 Two users report the TP16 pad lifting after soldering a wire to ground as shown in picture. This renders it useless. It may be better to use a pogo pin contact, bare wire or solder and then epoxy/glue the wire in place, leaving it permanently. Board Top Showing ESP8285 ESP8285 Pinout Using hard wired push button switch attached to iFan02 GPIO to cycle speeds ~ If anyone wants to setup a single push button switch attached to the GPIO3 Serial + ground In that will cycle through the speeds and turn off - after setting it in the configuration (GPIO3 to 11 Switch3) the console code is: rule1 on switch3#state do FanSpeed + endon Alternate Power Supply Schematic ~","title":"Sonoff iFan02"},{"location":"devices/Sonoff-iFan02/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Flashing using only a USB to serial converter will not work as the unit draws too much current as can be observed by a flashing blue led on the PCA and a lot of serial gibberish. As AC is not connected to Gnd I used the available power supply of the unit and connecting the USB to serial converter to J3 pins Gnd, Tx and Rx. The button is not connected to GPIO0 so flashing the unit requires some extra work. I managed to flash the iFan02 by soldering a wire to TP16 (GPIO00) on the bottom of the PCA. Keep this wire connected to Gnd during the power-on or reset process (pressing the button) and the unit will be in firmware upgrade mode. If you've soldered the gpio0 connection don't forget to unsolder before booting normally. Connect RX -> TX | 3.3 -> 3.3 | TX -> RX | GND -> GND and connect TP16 to GND (as used in the TTL). Press and hold the button while connecting to power. If you have an Arduino you may be able to flash without providing an additional power source. I have successfully flashed using an Arduino Duemilanove with the atmel chip pulled out (basically using it for FTDI and 3.3v power regulation). Rx on Arduino goes to Rx on iFan02, Tx to Tx (no crossover like with FTDI). I did not have to press the button, only to ground TP16 while initiating the flash in Arduino IDE. The Arduino provides enough power to flash, however it will not boot into Tasmota unless you plug in to external power (it boot loops after flashing is complete).","title":"Serial Flashing"},{"location":"devices/Sonoff-iFan02/#additonal-information","text":"See issue #2839 for user information See issue #3412 light on after restore power Functioning iFan02 in Tasmota WebUI iFan02 PCA with TP16 Two users report the TP16 pad lifting after soldering a wire to ground as shown in picture. This renders it useless. It may be better to use a pogo pin contact, bare wire or solder and then epoxy/glue the wire in place, leaving it permanently. Board Top Showing ESP8285 ESP8285 Pinout","title":"Additonal information"},{"location":"devices/Sonoff-iFan02/#using-hard-wired-push-button-switch-attached-to-ifan02-gpio-to-cycle-speeds","text":"If anyone wants to setup a single push button switch attached to the GPIO3 Serial + ground In that will cycle through the speeds and turn off - after setting it in the configuration (GPIO3 to 11 Switch3) the console code is: rule1 on switch3#state do FanSpeed + endon","title":"Using hard wired push button switch attached to iFan02 GPIO to cycle speeds"},{"location":"devices/Sonoff-iFan02/#alternate-power-supply-schematic","text":"","title":"Alternate Power Supply Schematic"},{"location":"devices/Sonoff-iFan03/","text":"(For information on the iFan02 please see here - iFan02 ) Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Next, please see the Flashing page for general information on the flashing process. Flash the latest version of tasmota.bin : Connect your serial flashing device pins to the iFan03 (for connection locations see the pin out on the left hand side of the picture below). When you are ready to flash your device, hold down the large white tipped button on the iFan03 while connecting the serial adapter to your computer. This will power the serial adapter as well as the iFan03. Usually, you can release the button on the iFan03 once it has fully booted - after 3-5 seconds once the lights have flashed. If the device does not enter programming mode successfully, cycle power but this time continue to hold the button during the entire firmware upload process (i.e., step 4 below). Using Tasmota PyFlasher (recommended): Select the firmware file that you want to flash Set the COM port for your serial programming adapter Ensure that flash mode Dual Output (DOUT) , and baud rate of 115200 is selected If you are flashing Tasmota for the first time, also select yes, wipes all data . Click on the \"Flash NodeMCU\" button and wait until the flashing process is completed. Cycle power on the serial adapter by unplugging and plugging it back in from the USB port. Do not hold down the iFan03 button. Wait for the iFan03 to reboot. If this is the first time you have flashed Tasmota on the device, connect to the iFan03 sonoff-xxxx Wi-Fi access point and configure your Wi-Fi credentials by opening 192.168.4.1 in a browser. Wait for the iFan03 to reboot. Find the IP address of the iFan03 and navigate to that IP address in any browser. Select \"Configure Module\" from the \"Configuration\" menu and select Sonoff iFan03 (71) from the drop down list. Wait for the iFan03 to restart and then continue any other required or desired configuration. US Ceiling Fans ~ The capacitors in the iFan03 do not set the speed of US fans correctly. To correct the speeds for US ceiling fans, you need to remove the existing capacitors from the iFan03 and replace them with equivalently electrically rated 5uF (microfarad) capacitors. Do NOT do this if you are not comfortable using a soldering iron as improperly performing this action could increase the risk of bodily injury or property damage. RF Remote Control Pairing ~ To pair the remote control after the device has been flashed with the new firmware, the device needs to be powered from mains voltage (not from the USB serial flashing device). Be careful dealing with mains voltages. Ensure that all connections are correctly made and that the iFan03 covers are properly re-assembled. To pair the remote control, hold down any button on the remote control and apply power to the iFan03. Once the device boots up you should hear a series of clicks as the internal relays operate. Once completed you can test the remote and it should all be operational.","title":"Sonoff iFan03"},{"location":"devices/Sonoff-iFan03/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Next, please see the Flashing page for general information on the flashing process. Flash the latest version of tasmota.bin : Connect your serial flashing device pins to the iFan03 (for connection locations see the pin out on the left hand side of the picture below). When you are ready to flash your device, hold down the large white tipped button on the iFan03 while connecting the serial adapter to your computer. This will power the serial adapter as well as the iFan03. Usually, you can release the button on the iFan03 once it has fully booted - after 3-5 seconds once the lights have flashed. If the device does not enter programming mode successfully, cycle power but this time continue to hold the button during the entire firmware upload process (i.e., step 4 below). Using Tasmota PyFlasher (recommended): Select the firmware file that you want to flash Set the COM port for your serial programming adapter Ensure that flash mode Dual Output (DOUT) , and baud rate of 115200 is selected If you are flashing Tasmota for the first time, also select yes, wipes all data . Click on the \"Flash NodeMCU\" button and wait until the flashing process is completed. Cycle power on the serial adapter by unplugging and plugging it back in from the USB port. Do not hold down the iFan03 button. Wait for the iFan03 to reboot. If this is the first time you have flashed Tasmota on the device, connect to the iFan03 sonoff-xxxx Wi-Fi access point and configure your Wi-Fi credentials by opening 192.168.4.1 in a browser. Wait for the iFan03 to reboot. Find the IP address of the iFan03 and navigate to that IP address in any browser. Select \"Configure Module\" from the \"Configuration\" menu and select Sonoff iFan03 (71) from the drop down list. Wait for the iFan03 to restart and then continue any other required or desired configuration.","title":"Serial Flashing"},{"location":"devices/Sonoff-iFan03/#us-ceiling-fans","text":"The capacitors in the iFan03 do not set the speed of US fans correctly. To correct the speeds for US ceiling fans, you need to remove the existing capacitors from the iFan03 and replace them with equivalently electrically rated 5uF (microfarad) capacitors. Do NOT do this if you are not comfortable using a soldering iron as improperly performing this action could increase the risk of bodily injury or property damage.","title":"US Ceiling Fans"},{"location":"devices/Sonoff-iFan03/#rf-remote-control-pairing","text":"To pair the remote control after the device has been flashed with the new firmware, the device needs to be powered from mains voltage (not from the USB serial flashing device). Be careful dealing with mains voltages. Ensure that all connections are correctly made and that the iFan03 covers are properly re-assembled. To pair the remote control, hold down any button on the remote control and apply power to the iFan03. Once the device boots up you should hear a series of clicks as the internal relays operate. Once completed you can test the remote and it should all be operational.","title":"RF Remote Control Pairing"},{"location":"devices/Supernight-dual-wifi-plug/","text":"Received these in a 2 pack. flashing with OTA was no issue. I quickly figured out most of the IO. GPIO1 = Left Socket Button GPIO3 = Left Socket Relay GPIO12 = Right Socket Relay GPIO14 = Red LED for both buttons The \"night light\" seems to be tied to the light sensor only and cannot be turned off. This makes the plug a no-go for me. Also, I could not figure out the right socket button. I ended up destroying one of the two plugs to see what was inside. There are 2 circuit boards. One with the Wifi and esp module and another with the buttons and the night lights. On the button board, the trace for the right button is purposely notched for that button so that it doesn't connect to the header leading to the second circuit board with the esp chip. I'm really wishing I verified that button before flashing as I don't intend to buy more to test it. Found this on the issues tracker Just a quick update. I've still not figured out the second button, but I do have energy monitoring working now. My current pinout is... * GPIO1 = Left Socket Button * GPIO3 = Left Socket Relay * GPIO4 = HLW8012/Voltage (HLWBL CF1) * GPIO5 = HLW8012 CF Power (HLW8012 CF) * GPIO12 = Right Socket Relay * GPIO13 = HLW8012 Output (HLWBL SEL) * GPIO14 = Red LED for both buttons Pins 6,7,8 and 11 cause hard resets when I try to set them to switches or buttons. If you have tasmota >= 6.4.1.14 then here is a template based on the above. {\"NAME\":\"SuperNight Dua\",\"GPIO\":[255,17,255,21,132,133,255,255,22,130,58,255,255],\"FLAG\":1,\"BASE\":18}","title":"Supernight dual wifi plug"},{"location":"devices/TYWE3S/","text":"Pinout for flashing TYWE3S devices. Module has a nearly identical pinout to ESP-12 module series. TYWE3S Wiring for Flashing ~ Vcc - 3.3V EN - 3.3V TX - RX RX - TX GND - GND Make sure to ground GPIO0 during boot. TYWE3S - Flashing Jig Additional Information ~ Pin Number Symbol IO type Function 1 TXD0 O UART0_TXD 2 RXD0 I/O UART0_RXD 3 GPIO5 I/O GPIO5_05 4 GPIO4 I/O GPIO5_04 5 GPIO0 I/O GPIO5_0 (Participate in the module power-on initialization process,use with caution) 6 GPIO2 O UART0_TXD (Used to print module internal information) 7 GPIO15 O GPIO_15 (Participate in the module power-on initialization process,use with caution) 8 GND P Power Reference Ground 9 VCC P Module Power Pin (3.3V) 10 GPIO13 I/O GPIO_13 11 GPIO12 I/O GPIO_12 12 GPIO14 I/O GPIO_14 13 GPIO16 I/O GPIO_16 (Use 10K pull-up resistor for use) 14 EN I Module enable pin,normal use needs to receive 3.3V 15 ADC AI ADC port, 10-bit precision SAR ADC 16 RST I/O Hardware reset pin (low level effective, internal pull-up resistance) For Switches and dimmers with additional MCU check guide here","title":"TYWE3S"},{"location":"devices/TYWE3S/#tywe3s-wiring-for-flashing","text":"Vcc - 3.3V EN - 3.3V TX - RX RX - TX GND - GND Make sure to ground GPIO0 during boot. TYWE3S - Flashing Jig","title":"TYWE3S Wiring for Flashing"},{"location":"devices/TYWE3S/#additional-information","text":"Pin Number Symbol IO type Function 1 TXD0 O UART0_TXD 2 RXD0 I/O UART0_RXD 3 GPIO5 I/O GPIO5_05 4 GPIO4 I/O GPIO5_04 5 GPIO0 I/O GPIO5_0 (Participate in the module power-on initialization process,use with caution) 6 GPIO2 O UART0_TXD (Used to print module internal information) 7 GPIO15 O GPIO_15 (Participate in the module power-on initialization process,use with caution) 8 GND P Power Reference Ground 9 VCC P Module Power Pin (3.3V) 10 GPIO13 I/O GPIO_13 11 GPIO12 I/O GPIO_12 12 GPIO14 I/O GPIO_14 13 GPIO16 I/O GPIO_16 (Use 10K pull-up resistor for use) 14 EN I Module enable pin,normal use needs to receive 3.3V 15 ADC AI ADC port, 10-bit precision SAR ADC 16 RST I/O Hardware reset pin (low level effective, internal pull-up resistance) For Switches and dimmers with additional MCU check guide here","title":"Additional Information"},{"location":"devices/Teckin-SP22/","text":"The BlitzWolf BW-SHP2 , HomeCube SP1, and Teckin SP22 are basically the same device barring the branding. Warning ~ There are at least two Versions of the SP22 out. An old one with a TYWE2S WiFi module and ESP... chip. This version is compatible with Tasmota. A new one with a WR2 WiFi module and RTL8710BN chip. This one is not compatible with Tasmota.","title":"Teckin SP22"},{"location":"devices/Teckin-SP22/#warning","text":"There are at least two Versions of the SP22 out. An old one with a TYWE2S WiFi module and ESP... chip. This version is compatible with Tasmota. A new one with a WR2 WiFi module and RTL8710BN chip. This one is not compatible with Tasmota.","title":"Warning"},{"location":"devices/Teckin-SP23/","text":"The Teckin SP23 is wifi enabled smart plug with the ability to remotely monitor power consumption and turn devices on and off. Details: ~ The Teckin SP23 appears to be a clone of the BlitzWolf SHP2 hardware with Tuya firmware. It uses an ESP8266EX and is capable of switching up to 16 amps at 250 VAC. Two Teckin SP23s (marked V1.2) purchased from Amazon UK (January 2019) have been flashed successfully and use BlitzWolf SHP2 Sonoff configuration. Voltage calibration may be required for accurate power monitoring. Two additional Teckin SP23s were purchased from Amazon UK (July 2019) and successfully flashed using Tuya-Convert. Upgrading to Tasmota 6.6 and using BlitzWolf SHP configuration was problematic - LED's did not show power status - but downgrading to 6.3 and using BlitzWolf SHP2 as above gave perfect performance. The units were not disassembled so there was no way of determining board version. A set of 4 Teckin SP23s were purchased from Amazon UK (Sept 2019) and they flashed without issues using Tuya-Convert. This device functions properly with tasmota.bin 6.6.0 (LED flashing blue when ON) with the template in the repository . Two devices purchased on Amazon ES were already patched, but have been successfully flashed with the new-sdk branch of kueblc's tuya-convert fork . How to flash ~ OTA Flashing ~ No hardware preparation is required to flash if you are confident about having the same version and can easily be flashed using Tuya-Convert methods. This results in a fully functional device when using the BlitzWolf SHP2 template. The ability to OTA flash the device may not work in the future . Tuya has patched their firmware to block the OTA flashing tools. If the manufacturer updates the firmware shipped with the device to the latest Tuya version, OTA flashing will cease to be an option. As of August 2019, devices purchased from Amazon (link above) were still able to be OTA flashed (via Tuya-Convert). Flashing via serial ~ Video Tutorial by Marcus Bennett Configuration ~ After flashing and configuring the Wi-Fi parameters, use the Tasmota web UI Configure Template. Set Based on to BlitzWolf SHP (45) and then change GPIO2 from Led1i (56) to Led2i (57) for the LED to operate properly. How to disassemble if desired ~ If you wish to confirm you have the same hardware the Teckin SP23 can be opened by hitting each side of the plug at the lip with a rubber mallet or similar. This will leave a visually unblemished enclosure which can be resecured with superglue or similar. Full album Home Automation Hub Integration ~ openHAB ~ sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=iPower_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\" Home Assistant ~ switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Teckin SP23"},{"location":"devices/Teckin-SP23/#details","text":"The Teckin SP23 appears to be a clone of the BlitzWolf SHP2 hardware with Tuya firmware. It uses an ESP8266EX and is capable of switching up to 16 amps at 250 VAC. Two Teckin SP23s (marked V1.2) purchased from Amazon UK (January 2019) have been flashed successfully and use BlitzWolf SHP2 Sonoff configuration. Voltage calibration may be required for accurate power monitoring. Two additional Teckin SP23s were purchased from Amazon UK (July 2019) and successfully flashed using Tuya-Convert. Upgrading to Tasmota 6.6 and using BlitzWolf SHP configuration was problematic - LED's did not show power status - but downgrading to 6.3 and using BlitzWolf SHP2 as above gave perfect performance. The units were not disassembled so there was no way of determining board version. A set of 4 Teckin SP23s were purchased from Amazon UK (Sept 2019) and they flashed without issues using Tuya-Convert. This device functions properly with tasmota.bin 6.6.0 (LED flashing blue when ON) with the template in the repository . Two devices purchased on Amazon ES were already patched, but have been successfully flashed with the new-sdk branch of kueblc's tuya-convert fork .","title":"Details:"},{"location":"devices/Teckin-SP23/#how-to-flash","text":"","title":"How to flash"},{"location":"devices/Teckin-SP23/#ota-flashing","text":"No hardware preparation is required to flash if you are confident about having the same version and can easily be flashed using Tuya-Convert methods. This results in a fully functional device when using the BlitzWolf SHP2 template. The ability to OTA flash the device may not work in the future . Tuya has patched their firmware to block the OTA flashing tools. If the manufacturer updates the firmware shipped with the device to the latest Tuya version, OTA flashing will cease to be an option. As of August 2019, devices purchased from Amazon (link above) were still able to be OTA flashed (via Tuya-Convert).","title":"OTA Flashing"},{"location":"devices/Teckin-SP23/#flashing-via-serial","text":"Video Tutorial by Marcus Bennett","title":"Flashing via serial"},{"location":"devices/Teckin-SP23/#configuration","text":"After flashing and configuring the Wi-Fi parameters, use the Tasmota web UI Configure Template. Set Based on to BlitzWolf SHP (45) and then change GPIO2 from Led1i (56) to Led2i (57) for the LED to operate properly.","title":"Configuration"},{"location":"devices/Teckin-SP23/#how-to-disassemble-if-desired","text":"If you wish to confirm you have the same hardware the Teckin SP23 can be opened by hitting each side of the plug at the lip with a rubber mallet or similar. This will leave a visually unblemished enclosure which can be resecured with superglue or similar. Full album","title":"How to disassemble if desired"},{"location":"devices/Teckin-SP23/#home-automation-hub-integration","text":"","title":"Home Automation Hub Integration"},{"location":"devices/Teckin-SP23/#openhab","text":"sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=iPower_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\"","title":"openHAB"},{"location":"devices/Teckin-SP23/#home-assistant","text":"switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Home Assistant"},{"location":"devices/Teckin-sp10/","text":"so I got a couple of these guys given to me teckin sp10 on amazon.ca follow some great info here I found the esp8266 as expected in here I was able to identify the module at a esp8266-s3 spec sheet @znanev did most of the work already the uk version of this plug as noted by Znanev it took a great deal of time to confirm that I did indeed have the same pin outs as this UK plug I stumbled apon what I think is the original manufacturer of these but we will probably never know plug maker I am going to now shamelessly steal from @znanev as he wrote this much better than I could have WiFi module pins ~ Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14 Serial Connection ~ For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 ( Rx , Tx , Vdd and GND ). Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. Configuration ~ Once Tasmota 's WebUI configuration interface is loaded in the browser, you can change many settings using the menu options. Console window is where you can change almost all configuration parameters. Head straight to the Configure Module menu, selected 'Generic' for 'Module type' . Here are the settings that I selected on that screen: Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). end quote if you care led 2 is blue and led 1 is red I flashed the standard tasmota.bin file to it with out any problems with both the esptools and with arduino the one benefit to using arduino is that I was able to configure my wifi in advance I hope to update this and clean it up but I thought I should get it up here as I found nothing about this plug before I forget to post and I can't remember any details. Note: I have a newer version of this, labelled C7 HYS-X5-SOCKET_V1.2. The connectors for the ESP8266 board seem different. Still mapping them, but beware of following these instructions unless you know you have the same version. Update: looks like I actually destroyed the ESP8266 board somehow, using the software-only tuya-convert technique. After failing to get it to update, I opened up the case by putting it between two dowels in my vise, and tightening until it cracked open. There was zero resistance between pins 13 and 14. I fed it power at 3.3 volts to 1 amp, before giving up. An identical second plug updated without incident.","title":"Teckin sp10"},{"location":"devices/Teckin-sp10/#wifi-module-pins","text":"Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14","title":"WiFi module pins"},{"location":"devices/Teckin-sp10/#serial-connection","text":"For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 ( Rx , Tx , Vdd and GND ). Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode.","title":"Serial Connection"},{"location":"devices/Teckin-sp10/#configuration","text":"Once Tasmota 's WebUI configuration interface is loaded in the browser, you can change many settings using the menu options. Console window is where you can change almost all configuration parameters. Head straight to the Configure Module menu, selected 'Generic' for 'Module type' . Here are the settings that I selected on that screen: Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). end quote if you care led 2 is blue and led 1 is red I flashed the standard tasmota.bin file to it with out any problems with both the esptools and with arduino the one benefit to using arduino is that I was able to configure my wifi in advance I hope to update this and clean it up but I thought I should get it up here as I found nothing about this plug before I forget to post and I can't remember any details. Note: I have a newer version of this, labelled C7 HYS-X5-SOCKET_V1.2. The connectors for the ESP8266 board seem different. Still mapping them, but beware of following these instructions unless you know you have the same version. Update: looks like I actually destroyed the ESP8266 board somehow, using the software-only tuya-convert technique. After failing to get it to update, I opened up the case by putting it between two dowels in my vise, and tightening until it cracked open. There was zero resistance between pins 13 and 14. I fed it power at 3.3 volts to 1 amp, before giving up. An identical second plug updated without incident.","title":"Configuration"},{"location":"devices/Tuya-Smart-Plug-Models-ESP8266MOD-by-AI-THINKER-and-ESP-12F-by-TUYA-LN-0026/","text":"WARNING! The current version of these plugs does not come with an ESP8266, but with a custom TUYA chip, which can't be flashed with Tasmota. These are simple, No-Name smart plugs (I bought these at AliExpress). One of them has ESP8266MOD chip (by AI-THINKER), other one has ESP-12F chip (by TUYA L/N 0026). Both are actually same chips and are flashed the same way. You need to solder 5 wires: 1. VCC (3.3V) 2. GND (GROUND) 3. Rx 4. Tx 5. GPIO0 To put this chips into flash mode, we need to jump wire GPIO0 and GROUND, before you plug your USB adapter into computer. Release jump wire after couple of seconds. Red LED (bottom one) should slightly lit up. Now you can start flashing process. When flashing process is complete, you can unplug USB adapter. Your TUYA smart plug is TASMOTIZED. THIS IS OPTIONAL!!! You can now use Termite app, to load your router WiFi SSID and password using below commands: (just copy and paste all of it, but put your details in). In Termite settings, check your COM number, where adapter is plugged in and select 115200. Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17 After that, Termite should tell you, what IP address was assigned to your smart plug. Put that IP address in your browser and you should see Tasmota GUI. Go into Configuration > Configure Module > Change to Generic (and click Save). After restart, go into Configuration > Configure Module and change GPIO's as on screen below. You can change between D4 GPIO2 56 LED1i and D4 GPIO2 52 LED1 (Blue led on when device is on, or blue led on when device is off) That's it, now your smart plug will flash both red and blue leds and smart plug button should respond to presses. Special thanks to Travis Griggs for his help with flashing process (I based this tutorial on his own: LINK )","title":"Tuya Smart Plug Models ESP8266MOD by AI THINKER and ESP 12F by TUYA LN 0026"},{"location":"devices/WL-SW01_10-WiFi-Smart-Switch/","text":"Manufactured by Blue50 as WL-SW01_10 and also sold as TISHRIC . Sonoff Basic in a different form factor with the same features. It contains an ESP8285 chip on a vertical breakout board with all the needed GPIOs broken out and labeled. There are also a couple pads on the board to solder VCC and G. Use template {\"NAME\":\"WL-SW01_10\",\"GPIO\":[17,149,0,148,0,0,0,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":1} If your Tasmota version doesn't support templates select module Sonoff Basic (1) .","title":"WL SW01 10 WiFi Smart Switch"},{"location":"devices/WS03-WS01-WS05/","text":"WS03-Led Controller (from Aliexpress) ~ The WS01 LED-Controller uses an ESP8266-S1 Module (16MBit Flash) Alle required Pins for programming are available, as well as additional GPIO4 and GPIO2. Outside Images PCB Image with pinout GPIO2 & GPIO4 are working for I 2 C (2=SDA 4=SCL). (Tested with DS3231 Module ) The device uses an additional CD4050 at the pins used for PWM.","title":"WS03-Led Controller (from Aliexpress)"},{"location":"devices/WS03-WS01-WS05/#ws03-led-controller-from-aliexpress","text":"The WS01 LED-Controller uses an ESP8266-S1 Module (16MBit Flash) Alle required Pins for programming are available, as well as additional GPIO4 and GPIO2. Outside Images PCB Image with pinout GPIO2 & GPIO4 are working for I 2 C (2=SDA 4=SCL). (Tested with DS3231 Module ) The device uses an additional CD4050 at the pins used for PWM.","title":"WS03-Led Controller (from Aliexpress)"},{"location":"devices/Wemos-D1-Mini/","text":"Flashing Wemos with Tasmota ~ Flashing a Wemos D1 Mini with Tasmota firmware is nearly the same as for every other device. Just connect Wemos D1 mini via USB. No action required to enter Flashmode! Configure Tasmota for Wemos ~ Generic Module ~ In the Configuration -> Configure Module page, select Module Type: \"18 Generic\" . After Saving the settings, the WEMOS reboots with the Generic configuration. The first time you switch to \"18 Generic\" you will NOT see all the options as seen in the picture below YET. You have to save \"18 Generic\" first and when you go there again after the reboot you get the long table where you can change all the pin's parameters. These steps are confirmed to also work with the Wemos D1 mini PRO v2.0.0. Link to Wemos hardware & documentation ~ DOCS dot WEMOS dot CC","title":"Wemos D1 Mini"},{"location":"devices/Wemos-D1-Mini/#flashing-wemos-with-tasmota","text":"Flashing a Wemos D1 Mini with Tasmota firmware is nearly the same as for every other device. Just connect Wemos D1 mini via USB. No action required to enter Flashmode!","title":"Flashing Wemos with Tasmota"},{"location":"devices/Wemos-D1-Mini/#configure-tasmota-for-wemos","text":"","title":"Configure Tasmota for Wemos"},{"location":"devices/Wemos-D1-Mini/#generic-module","text":"In the Configuration -> Configure Module page, select Module Type: \"18 Generic\" . After Saving the settings, the WEMOS reboots with the Generic configuration. The first time you switch to \"18 Generic\" you will NOT see all the options as seen in the picture below YET. You have to save \"18 Generic\" first and when you go there again after the reboot you get the long table where you can change all the pin's parameters. These steps are confirmed to also work with the Wemos D1 mini PRO v2.0.0.","title":"Generic Module"},{"location":"devices/Wemos-D1-Mini/#link-to-wemos-hardware-documentation","text":"DOCS dot WEMOS dot CC","title":"Link to Wemos hardware &amp; documentation"},{"location":"devices/Wemos-D1-R1-%26-R2/","text":"Wemos D1 Release 1 (R1) and Release 2 (R2) ~ Here you can find information for the big brother of the Wemos D1 mini which can be found here . R1 vs. R2 - The Difference ~ When you take a look at the figure 1 you will see it with one blink of the eye thet the old Wemos is different against the new verion R2. The old version has an ESP8266 12B or 12E model. The new one has a ESP8266 12F model on the pcb board. You see this in the defference of the Wifi antenna. Here is a Wiki link to the different ESP8266 modules. The next part for R2 are the 2x4 solder pins for the serial and I2C interface which is not on the old model R1. The techncal data/specifiactions are the same. SO as you see they look like an Arduino UNO inculding the stacks to mount different shields. Later i will give more information over shields which i have tested and there are a lot of them. Figure: WeMos D1 R1 vs. WeMos D1 R2","title":"Wemos D1 R1 & R2"},{"location":"devices/Wemos-D1-R1-%26-R2/#wemos-d1-release-1-r1-and-release-2-r2","text":"Here you can find information for the big brother of the Wemos D1 mini which can be found here .","title":"Wemos D1 Release 1 (R1) and Release 2 (R2)"},{"location":"devices/Wemos-D1-R1-%26-R2/#r1-vs-r2-the-difference","text":"When you take a look at the figure 1 you will see it with one blink of the eye thet the old Wemos is different against the new verion R2. The old version has an ESP8266 12B or 12E model. The new one has a ESP8266 12F model on the pcb board. You see this in the defference of the Wifi antenna. Here is a Wiki link to the different ESP8266 modules. The next part for R2 are the 2x4 solder pins for the serial and I2C interface which is not on the old model R1. The techncal data/specifiactions are the same. SO as you see they look like an Arduino UNO inculding the stacks to mount different shields. Later i will give more information over shields which i have tested and there are a lot of them. Figure: WeMos D1 R1 vs. WeMos D1 R2","title":"R1 vs. R2 - The Difference"},{"location":"devices/Xenon-SM-SW102-2-two-relay-light-switch/","text":"Amazon Link: https://www.amazon.com/Tempered-Controlled-Separately-Standard-Compatible/dp/B0719Q5G5B/ref=sr_1_3?ie=UTF8&qid=1540511385&sr=8-3&keywords=xenon+light+switch&dpID=21PWx5MUrEL&preST= SY300_QL70 &dpSrc=srch Also sold as the Mojocraft Wireless Smart Wall Switch 2 Gang: https://www.amazon.com/Mojocraft-Wireless-Sensitive-Compatible-Required/dp/B072JCWH23/ref=sr_1_3?ie=UTF8&qid=1540858092&sr=8-3&keywords=Mojocraft I didn't spot any headers, but device has a sub-board with an ESP-12 module on it. Solder right to the 3.3V, Ground, TX, RX, and GPIO pins and flash away. I set the device up as a generic device with the following assignments. GPIO 3 is button 2 GPIO 4 is relay 2 GPIO 12 is button 1 GPIO 13 is relay 1","title":"Xenon SM SW102 2 two relay light switch"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/","text":"Mi Desk Lamp is a cold+warm white led lamp, which has a rotary knob that also acts as a push-button: - pushing it turns the lamp on/off - rotating it controls the brightness - rotating it while pushed controls the color temperature At the bottom of the lamp stand there is also a 'Reset' button, which can be pressed by a hairpin/toothpick/etc only. Manufacturer Link Configuration ~ Tasmota supports it directly as Module \"Mi Desk Lamp\" . This module is deactivated by default. You must add #define ROTARY_V1 in your user_config_override.h and compile the firmware for this module to be available as a selection option. To configure it as Generic , here is the GPIO assignment: - GPIO02: Button ( GPIO_KEY1 ) - GPIO04: Cold White ( GPIO_PWM1 ) - GPIO05: Warm White ( GPIO_PWM2 ) - GPIO12: Rotary switch A pin ( GPIO_ROT_A ) - GPIO13: Rotary switch B pin ( GPIO_ROT_B ) NOTE: The operation of the rotary switch depends on the module type being MI_DESK_LAMP , so full functionality cannot be achieved with the Generic config. Flashing ~ This lamp is based on a YeeLight LXU 1.7 module, that contains: - an ESP8266 - 2 MB flash Disassembly ~ First of all, remove the knob by pushing some soft and flat tool underneath it and gently pry away from the stand. Then remove the bottom of the stand, held by 3 screws underneath the rubber strips: Underneath you find a small board for the power input and the reset button, and the controller board: The test points (8 vertical, 2 horizontal) are connected to the module pins 7..14 and 17..18 (see below). As GPIO0 is not among them, they aren't enough for flashing, so the board must be removed anyway. NOTE: You need to remove the knob before you can remove this controller board. The controller board contains - a 3.3V converter on the side of the white power wires - two LED drivers on the side of the red/blue/black LED wires - the rotary button - the Yeelight module Pinout ~ Left side: - Pin 1: ADC (N.C.) - Pin 2: GPIO15 (N.C.) - Pin 3: GND - Pin 4: GPIO0 - Pin 5: GND - Pin 6: GND Bottom: - Pin 7: GND - Pin 8: Vcc (3.3V) - Pin 9: GPIO14 (Reset button) - Pin 10: GPIO2 (Rotary button) - Pin 11: GPIO13 (Rotary B) - Pin 12: GPIO12 (Rotary A) - Pin 13: GPIO4 (Cold white) - Pin 14: GPIO5 (Warm white) Right side: - Pin 15: GND - Pin 16: GND - Pin 17: RxD (N.C.) - Pin 18: TxD (N.C.) - Pin 19: GND (N.C.) - Pin 20: GND (N.C.) Three pins (ADC, GPIO0 and GPIO15) are not used by the lamp, they are available for hacking :). Procedure ~ For serial flashing we need 2 power wires (GND, Vcc), 2 serial wires (RxD, TxD) and the boot mode button (GPIO0): As there is plenty of free space in the lamp stand, I left the wires long enough to reach some empty area and soldered solo pin head sockets on them. This way they will be available if/when I decide to add something on those 3 extra pins :). The rest of the serial flashing process is as usual , but if you want to make a backup of the original firmware, keep in mind that the flash size is 2 MBs . If you are re-flashing the original firmware, the flash size must be explicitly set to '2MB-c1', the auto-detected '2MB' doesn't work , so: esptool.py write_flash --flash_size 2MB-c1 0x00000 xiaomi_desk_lamp.orig.bin Serial logging ~ A bonus feature for debugging/logging: The lamp has an external DC12V power supply, so there is no shock hazard. Nonetheless, accidental 12V can still cause damage to a 3.3V serial converter, so be cautious if you do serial logging on a live lamp. The original firmware sets the USART to the same 74880 baud as the ESP boot loader, and it dumps some details as well: ets Jan 8 2013,rst cause:1, boot mode:(3,7) load 0x60000020, len 4, room 16 phy ver: 1055_1, pp ver: 10.7 rf cal sector: 507 tcpip_task_hdl : 3fff2958, prio:10,stack:512 idle_task_hdl : 3fff29f8,prio:0, stack:384 tim_task_hdl : 3fff5188, prio:2,stack:512 pwm version:1.0.2 mcu version: 1.3.0_0055 prod: yeelink.light.lamp1 data : 0x3ffe8000 ~ 0x3ffe91f4, len: 4596 rodata: 0x3ffe9310 ~ 0x3ffeaa7c, len: 5996 bss : 0x3ffeaa80 ~ 0x3fff27d8, len: 32088 heap : 0x3fff27d8 ~ 0x40000000, len: 55336 BUILD TIME: May 25 2018,07:01:12 ESP SDK VER: 1.5.0-dev(c6beda8) did is 65282142 mac addr 7811dc06cfd9 reset reason: 0 current flash flag is 0, current user bin addr 0x101000 mode : softAP(7a:11:dc:06:cf:d9) dhcp server start:(ip:192.168.4.1,mask:255.255.255.0,gw:192.168.4.1) add if1 bcn 100 Hacking ~ The lamp has 3 pins that aren't used in normal operation: ADC, GPIO0 and GPIO15. GPIO15 is and must be pulled up for boot selection, so its usability is somewhat limited. On the other hand, if you already soldered wires to VCC, GND and GPIO0 for serial flashing, they are perfect for a DHT11 or DHT22 temperature+humidity sensor! As the lamp has external power supply, and the LEDs are in the upper part of the lamp, the temperature of the base is the same as of the ambient, and by its nature the lamp is situated on your desk, so it's a perfect place for temp+humidity measurements. If you want to place the sensor inside the lamp base, then you may need to remove some material from one of the weight panels, and if you choose to place it on the outside (e.g., near the base), then a convenient and relatively hidden path for the 3 wires is above the power jack, just enlarge the hole by 2 mm-s with a file.","title":"Xiaomi Mi Desk Lamp"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#configuration","text":"Tasmota supports it directly as Module \"Mi Desk Lamp\" . This module is deactivated by default. You must add #define ROTARY_V1 in your user_config_override.h and compile the firmware for this module to be available as a selection option. To configure it as Generic , here is the GPIO assignment: - GPIO02: Button ( GPIO_KEY1 ) - GPIO04: Cold White ( GPIO_PWM1 ) - GPIO05: Warm White ( GPIO_PWM2 ) - GPIO12: Rotary switch A pin ( GPIO_ROT_A ) - GPIO13: Rotary switch B pin ( GPIO_ROT_B ) NOTE: The operation of the rotary switch depends on the module type being MI_DESK_LAMP , so full functionality cannot be achieved with the Generic config.","title":"Configuration"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#flashing","text":"This lamp is based on a YeeLight LXU 1.7 module, that contains: - an ESP8266 - 2 MB flash","title":"Flashing"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#disassembly","text":"First of all, remove the knob by pushing some soft and flat tool underneath it and gently pry away from the stand. Then remove the bottom of the stand, held by 3 screws underneath the rubber strips: Underneath you find a small board for the power input and the reset button, and the controller board: The test points (8 vertical, 2 horizontal) are connected to the module pins 7..14 and 17..18 (see below). As GPIO0 is not among them, they aren't enough for flashing, so the board must be removed anyway. NOTE: You need to remove the knob before you can remove this controller board. The controller board contains - a 3.3V converter on the side of the white power wires - two LED drivers on the side of the red/blue/black LED wires - the rotary button - the Yeelight module","title":"Disassembly"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#pinout","text":"Left side: - Pin 1: ADC (N.C.) - Pin 2: GPIO15 (N.C.) - Pin 3: GND - Pin 4: GPIO0 - Pin 5: GND - Pin 6: GND Bottom: - Pin 7: GND - Pin 8: Vcc (3.3V) - Pin 9: GPIO14 (Reset button) - Pin 10: GPIO2 (Rotary button) - Pin 11: GPIO13 (Rotary B) - Pin 12: GPIO12 (Rotary A) - Pin 13: GPIO4 (Cold white) - Pin 14: GPIO5 (Warm white) Right side: - Pin 15: GND - Pin 16: GND - Pin 17: RxD (N.C.) - Pin 18: TxD (N.C.) - Pin 19: GND (N.C.) - Pin 20: GND (N.C.) Three pins (ADC, GPIO0 and GPIO15) are not used by the lamp, they are available for hacking :).","title":"Pinout"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#procedure","text":"For serial flashing we need 2 power wires (GND, Vcc), 2 serial wires (RxD, TxD) and the boot mode button (GPIO0): As there is plenty of free space in the lamp stand, I left the wires long enough to reach some empty area and soldered solo pin head sockets on them. This way they will be available if/when I decide to add something on those 3 extra pins :). The rest of the serial flashing process is as usual , but if you want to make a backup of the original firmware, keep in mind that the flash size is 2 MBs . If you are re-flashing the original firmware, the flash size must be explicitly set to '2MB-c1', the auto-detected '2MB' doesn't work , so: esptool.py write_flash --flash_size 2MB-c1 0x00000 xiaomi_desk_lamp.orig.bin","title":"Procedure"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#serial-logging","text":"A bonus feature for debugging/logging: The lamp has an external DC12V power supply, so there is no shock hazard. Nonetheless, accidental 12V can still cause damage to a 3.3V serial converter, so be cautious if you do serial logging on a live lamp. The original firmware sets the USART to the same 74880 baud as the ESP boot loader, and it dumps some details as well: ets Jan 8 2013,rst cause:1, boot mode:(3,7) load 0x60000020, len 4, room 16 phy ver: 1055_1, pp ver: 10.7 rf cal sector: 507 tcpip_task_hdl : 3fff2958, prio:10,stack:512 idle_task_hdl : 3fff29f8,prio:0, stack:384 tim_task_hdl : 3fff5188, prio:2,stack:512 pwm version:1.0.2 mcu version: 1.3.0_0055 prod: yeelink.light.lamp1 data : 0x3ffe8000 ~ 0x3ffe91f4, len: 4596 rodata: 0x3ffe9310 ~ 0x3ffeaa7c, len: 5996 bss : 0x3ffeaa80 ~ 0x3fff27d8, len: 32088 heap : 0x3fff27d8 ~ 0x40000000, len: 55336 BUILD TIME: May 25 2018,07:01:12 ESP SDK VER: 1.5.0-dev(c6beda8) did is 65282142 mac addr 7811dc06cfd9 reset reason: 0 current flash flag is 0, current user bin addr 0x101000 mode : softAP(7a:11:dc:06:cf:d9) dhcp server start:(ip:192.168.4.1,mask:255.255.255.0,gw:192.168.4.1) add if1 bcn 100","title":"Serial logging"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#hacking","text":"The lamp has 3 pins that aren't used in normal operation: ADC, GPIO0 and GPIO15. GPIO15 is and must be pulled up for boot selection, so its usability is somewhat limited. On the other hand, if you already soldered wires to VCC, GND and GPIO0 for serial flashing, they are perfect for a DHT11 or DHT22 temperature+humidity sensor! As the lamp has external power supply, and the LEDs are in the upper part of the lamp, the temperature of the base is the same as of the ambient, and by its nature the lamp is situated on your desk, so it's a perfect place for temp+humidity measurements. If you want to place the sensor inside the lamp base, then you may need to remove some material from one of the weight panels, and if you choose to place it on the outside (e.g., near the base), then a convenient and relatively hidden path for the 3 wires is above the power jack, just enlarge the hole by 2 mm-s with a file.","title":"Hacking"},{"location":"devices/YTF-IR-Bridge/","text":"YTF BaKEN - Identical to the YTF Tuya Flashing ~ OTA flashing ~ This device is based on a Tuya Wi-Fi module and may still be flashable with Tuya-Convert . Serial flashing ~ Like most devices, GPIO0 has to be held low during power up to get into flash mode. In the picture below, notice the red jumper wire between IO0 and GND. I soldered it in such a way I could hold it during power on, but release later (basically acts as a button), since it can not be held low if you want normal operation. Configuration ~ Introduced in version 6.4.1.8 as YTF IR Bridge (62) GPIO Component Description 04 LED1i (52) Blue LED - Link status 05 IRrecv (51) IR Receiver 13 Button1 (17) Button 14 IRsend (8) IR Transmitter IR Codes ~ IR Code List","title":"YTF IR Bridge"},{"location":"devices/YTF-IR-Bridge/#flashing","text":"","title":"Flashing"},{"location":"devices/YTF-IR-Bridge/#ota-flashing","text":"This device is based on a Tuya Wi-Fi module and may still be flashable with Tuya-Convert .","title":"OTA flashing"},{"location":"devices/YTF-IR-Bridge/#serial-flashing","text":"Like most devices, GPIO0 has to be held low during power up to get into flash mode. In the picture below, notice the red jumper wire between IO0 and GND. I soldered it in such a way I could hold it during power on, but release later (basically acts as a button), since it can not be held low if you want normal operation.","title":"Serial flashing"},{"location":"devices/YTF-IR-Bridge/#configuration","text":"Introduced in version 6.4.1.8 as YTF IR Bridge (62) GPIO Component Description 04 LED1i (52) Blue LED - Link status 05 IRrecv (51) IR Receiver 13 Button1 (17) Button 14 IRsend (8) IR Transmitter","title":"Configuration"},{"location":"devices/YTF-IR-Bridge/#ir-codes","text":"IR Code List","title":"IR Codes"},{"location":"devices/YUNTONG-Smart/","text":"Sonoff Basic Clone can be flashed to Tasmota PIN assignment: PCB Antenna End: * TOP Layer - Bottom Layer * EN - TOUT * IO14 - IO12 * IO13 - IO15 * IO0 - IO2 * IO4 - IO5 * RX - TX * VCC - GND The clone are based on the ESP-03S - User manual","title":"YUNTONG Smart"},{"location":"devices/ZEOOTA-Wifi-Smart-Power-Strip-4-EU-outlets-with-4-USB-ports/","text":"This power strip has Tuya TYWE2S module (ESP8285 chip). Successfully flashed Tasmota on it. 4 power outlets are individually controlled. USB ports have just one relay to switch all ports on/off. Model purchased: https://www.aliexpress.com/item/Wifi-Smart-Power-Strip-4-EU-Outlets-Plug-Socket-with-USB-4-Charging-Port-App-Voice/32864686078.html Used this connection for flashing (just connect GPIO0 on the back side of the module to GND before USB connection to enter flash mode): Module configuration:","title":"ZEOOTA Wifi Smart Power Strip 4 EU outlets with 4 USB ports"},{"location":"devices/leegoal-plug/","text":"Description ~ Very nice and cheap plug :) https://www.amazon.de/gp/product/B07FD971T9/ Features: ~ 3800 W switchi ng USB port 5V 2.1A for charging Power monitor Tuya compatible Model description ~ FLHS ZN04 Configuration ~ Tasmota template based on BlitzWolf (45) {\"NAME\":\"Plug\",\"GPIO\":[57,0,56,0,0,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} Flashing ~ It is possible to flash over OTA. But, it seems flashing via OTA may leave remains of old firmware because it wasn't fully erased before flashing Tasmota. So the device can fail after feature updates. (I have 3 devices originally flashed via OTA bricked after update later). So if you flashed via OTA it better to not update FW anymore. Unfortunately I bricked one of my plugs (probably by typing wrong Wifi name), so I needed to flash manually. Manual flash should be done exactly as shown here: * https://github.com/arendst/Tasmota/issues/3950#issuecomment-436074625 * devices/Hyleton-313-Smart-Plug Access to the internals is easy. Casing is held by 3 torx screws (no glue anywhere). Chip info ~ Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: Manufacturer: a1 Device: 4014 Detected flash size: 1MB","title":"Description"},{"location":"devices/leegoal-plug/#description","text":"Very nice and cheap plug :) https://www.amazon.de/gp/product/B07FD971T9/","title":"Description"},{"location":"devices/leegoal-plug/#features","text":"3800 W switchi ng USB port 5V 2.1A for charging Power monitor Tuya compatible","title":"Features:"},{"location":"devices/leegoal-plug/#model-description","text":"FLHS ZN04","title":"Model description"},{"location":"devices/leegoal-plug/#configuration","text":"Tasmota template based on BlitzWolf (45) {\"NAME\":\"Plug\",\"GPIO\":[57,0,56,0,0,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45}","title":"Configuration"},{"location":"devices/leegoal-plug/#flashing","text":"It is possible to flash over OTA. But, it seems flashing via OTA may leave remains of old firmware because it wasn't fully erased before flashing Tasmota. So the device can fail after feature updates. (I have 3 devices originally flashed via OTA bricked after update later). So if you flashed via OTA it better to not update FW anymore. Unfortunately I bricked one of my plugs (probably by typing wrong Wifi name), so I needed to flash manually. Manual flash should be done exactly as shown here: * https://github.com/arendst/Tasmota/issues/3950#issuecomment-436074625 * devices/Hyleton-313-Smart-Plug Access to the internals is easy. Casing is held by 3 torx screws (no glue anywhere).","title":"Flashing"},{"location":"devices/leegoal-plug/#chip-info","text":"Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: Manufacturer: a1 Device: 4014 Detected flash size: 1MB","title":"Chip info"},{"location":"devices/meross-MSS425/","text":"Be Aware ~ There are different versions of this power strip. An MSS425EEU-R purchased in August 2019 was based on the Mediatek Wi-Fi chip and not on an ESP82xx! Tasmota is only suitable for ESP82xx based devices. meross Power Strip ~ This power strip was selling on Amazon for about $17 when I bought it. The ESP module is mounted on the side vertically on board. It's another Tuya TYWE3S, 1MB. For more information on the Tuya TYWE3S, see this page . I soldered pins on and bent them down to get everything back in the case. To open, 4 screws are under the soft foot pads. They take a size 2.0 triangle bit; make sure you have a large collection of small screwdriver bits around. The programming header is directly on the Tuya module and is silkscreened with the labels for the pins. Solder onto those and program just like any other Tuya. There's unfortunately no button to get into firmware mode that I could find, so you have to ground the pin yourself. If you're using an external power source for the board and another power source for your TXD/RXD, make sure to tie the grounds together or else it won't talk. I burned on the generic tasmota release and set it up like so: Relays 1-3 are the AC plugs Relays 4,5 are the USBs The button only turns off the first AC by default, but you could write rules to do whatever you want.","title":"Be Aware"},{"location":"devices/meross-MSS425/#be-aware","text":"There are different versions of this power strip. An MSS425EEU-R purchased in August 2019 was based on the Mediatek Wi-Fi chip and not on an ESP82xx! Tasmota is only suitable for ESP82xx based devices.","title":"Be Aware"},{"location":"devices/meross-MSS425/#meross-power-strip","text":"This power strip was selling on Amazon for about $17 when I bought it. The ESP module is mounted on the side vertically on board. It's another Tuya TYWE3S, 1MB. For more information on the Tuya TYWE3S, see this page . I soldered pins on and bent them down to get everything back in the case. To open, 4 screws are under the soft foot pads. They take a size 2.0 triangle bit; make sure you have a large collection of small screwdriver bits around. The programming header is directly on the Tuya module and is silkscreened with the labels for the pins. Solder onto those and program just like any other Tuya. There's unfortunately no button to get into firmware mode that I could find, so you have to ground the pin yourself. If you're using an external power source for the board and another power source for your TXD/RXD, make sure to tie the grounds together or else it won't talk. I burned on the generic tasmota release and set it up like so: Relays 1-3 are the AC plugs Relays 4,5 are the USBs The button only turns off the first AC by default, but you could write rules to do whatever you want.","title":"meross Power Strip"},{"location":"devices/minitiger-Touch-Light-Switch/","text":"minitiger Touch Light Switch ~ This is a cheap Sonoff T1 clone. Available with 1/2/3 channels. The board has the ID 2PH89174A Device ~ ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Aliexpress link: Click Aliexpress link for no neutral version (single live wire) version: Click Images ~ Front and soldering: Fullsize Front and identification number: Fullsize Back and GND: Fullsize Soldering layout: Fullsize Flashing ~ This board can be flashed with vanilla sonoff-tasmota. I used esptool on linux to upload the firmware. Programming mode: ~ Short GPIO0 to GND, as with all boards. If you have successfully put the micro into programming mode the LED does not light up! Config: ~ Single Channel: ~ Works out of the box, configured as Sonoff Basic. The LED does not light up when the switch is turned off. Configure as Sonoff T1 to enable the LED. Dual Channel: ~ {\"NAME\":\"Wall Switch 2C\",\"GPIO\":[17,255,255,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":28} Dual Channel - No Neutral (Single Live Wire): ~ {\"NAME\":\"Wall Switch 2C\",\"GPIO\":[53,52,255,17,18,0,0,0,0,21,22,0,0],\"FLAG\":0,\"BASE\":28} Triple Channel: ~ Since I don't own such a board, you are on your own... Button 3 should be GPIO10 and Relay 3 should be GPIO4. Use at your own risk!","title":"minitiger Touch Light Switch"},{"location":"devices/minitiger-Touch-Light-Switch/#minitiger-touch-light-switch","text":"This is a cheap Sonoff T1 clone. Available with 1/2/3 channels. The board has the ID 2PH89174A","title":"minitiger Touch Light Switch"},{"location":"devices/minitiger-Touch-Light-Switch/#device","text":"ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Aliexpress link: Click Aliexpress link for no neutral version (single live wire) version: Click","title":"Device"},{"location":"devices/minitiger-Touch-Light-Switch/#images","text":"Front and soldering: Fullsize Front and identification number: Fullsize Back and GND: Fullsize Soldering layout: Fullsize","title":"Images"},{"location":"devices/minitiger-Touch-Light-Switch/#flashing","text":"This board can be flashed with vanilla sonoff-tasmota. I used esptool on linux to upload the firmware.","title":"Flashing"},{"location":"devices/minitiger-Touch-Light-Switch/#programming-mode","text":"Short GPIO0 to GND, as with all boards. If you have successfully put the micro into programming mode the LED does not light up!","title":"Programming mode:"},{"location":"devices/minitiger-Touch-Light-Switch/#config","text":"","title":"Config:"},{"location":"devices/minitiger-Touch-Light-Switch/#single-channel","text":"Works out of the box, configured as Sonoff Basic. The LED does not light up when the switch is turned off. Configure as Sonoff T1 to enable the LED.","title":"Single Channel:"},{"location":"devices/minitiger-Touch-Light-Switch/#dual-channel","text":"{\"NAME\":\"Wall Switch 2C\",\"GPIO\":[17,255,255,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":28}","title":"Dual Channel:"},{"location":"devices/minitiger-Touch-Light-Switch/#dual-channel-no-neutral-single-live-wire","text":"{\"NAME\":\"Wall Switch 2C\",\"GPIO\":[53,52,255,17,18,0,0,0,0,21,22,0,0],\"FLAG\":0,\"BASE\":28}","title":"Dual Channel - No Neutral (Single Live Wire):"},{"location":"devices/minitiger-Touch-Light-Switch/#triple-channel","text":"Since I don't own such a board, you are on your own... Button 3 should be GPIO10 and Relay 3 should be GPIO4. Use at your own risk!","title":"Triple Channel:"},{"location":"devices/others/","text":"Motor Clockwise/Anticlockwise ~ (Now retired, see https://www.itead.cc/motor-reversing-wifi-wireless-switch.html) This USB powered or external powered board provides one GPIO controlling two alternating relays with Normally Open (NO) and Normally Closed (NC) contacts. It can be used for changing directions of a connected motor. Programming the on-board 3.3V PSA-B is possible when Rx (Pin 7), Tx (Pin 8) and GND (Pin 9) are connected to the FTDI interface, the button is pressed and (USB) power is provided.","title":"Others"},{"location":"devices/others/#motor-clockwiseanticlockwise","text":"(Now retired, see https://www.itead.cc/motor-reversing-wifi-wireless-switch.html) This USB powered or external powered board provides one GPIO controlling two alternating relays with Normally Open (NO) and Normally Closed (NC) contacts. It can be used for changing directions of a connected motor. Programming the on-board 3.3V PSA-B is possible when Rx (Pin 7), Tx (Pin 8) and GND (Pin 9) are connected to the FTDI interface, the button is pressed and (USB) power is provided.","title":"Motor Clockwise/Anticlockwise"},{"location":"devices/wk30/","text":"Connection ~ Vcc - 3.3V TX - RX RX - TX GND - GND GPIO0 - GND Additional Information ~ This device is available on Amazon as \"Smart WiFi Plug Outlet Mini with Energy Monitoring.\" The product number, WK30 appears nowhere on the page on Amazon, so here's its ASIN: B07C326VKR It remains to be seen if this device actually features energy monitoring as in the title on Amazon. Nicely labeled holes for a header exist. The pictures below are with a header soldered on. All that was needed was to jumper GPIO0 to ground in addition to the usual connections. Once tasmota is up, configure the device as generic. Device Images ~ GPIO Config ~ This has the LEDs, GPIO4 and GPIO5 separated out as different relays so they can be controlled independently of the switch.","title":"Wk30"},{"location":"devices/wk30/#connection","text":"Vcc - 3.3V TX - RX RX - TX GND - GND GPIO0 - GND","title":"Connection"},{"location":"devices/wk30/#additional-information","text":"This device is available on Amazon as \"Smart WiFi Plug Outlet Mini with Energy Monitoring.\" The product number, WK30 appears nowhere on the page on Amazon, so here's its ASIN: B07C326VKR It remains to be seen if this device actually features energy monitoring as in the title on Amazon. Nicely labeled holes for a header exist. The pictures below are with a header soldered on. All that was needed was to jumper GPIO0 to ground in addition to the usual connections. Once tasmota is up, configure the device as generic.","title":"Additional Information"},{"location":"devices/wk30/#device-images","text":"","title":"Device Images"},{"location":"devices/wk30/#gpio-config","text":"This has the LEDs, GPIO4 and GPIO5 separated out as different relays so they can be controlled independently of the switch.","title":"GPIO Config"},{"location":"installation/","text":"","title":"Index"},{"location":"installation/Flashing/","text":"","title":"Flashing"},{"location":"installation/Hardware-Preparation/","text":"","title":"Hardware Preparation"},{"location":"installation/Initial-Configuration/","text":"","title":"Initial Configuration"},{"location":"installation/Prerequisites/","text":"","title":"Prerequisites"}]}